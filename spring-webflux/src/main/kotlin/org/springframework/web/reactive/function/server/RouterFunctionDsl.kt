/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.reactive.function.server

import org.springframework.core.io.Resource
import org.springframework.http.HttpMethod
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import reactor.core.publisher.Mono
import java.net.URI
import java.util.function.Supplier

/**
 * Allow to create easily a WebFlux.fn [RouterFunction] with a [Reactive router Kotlin DSL][RouterFunctionDsl].
 *
 * Example:
 *
 * ```
 * @Configuration
 * class RouterConfiguration {
 *
 * 	@Bean
 * 	fun mainRouter(userHandler: UserHandler) = router {
 * 		accept(TEXT_HTML).nest {
 * 			(GET("/user/") or GET("/users/")).invoke(userHandler::findAllView)
 * 			GET("/users/{login}", userHandler::findViewById)
 * 		}
 * 		accept(APPLICATION_JSON).nest {
 * 			(GET("/api/user/") or GET("/api/users/")).invoke(userHandler::findAll)
 * 			POST("/api/users/", userHandler::create)
 * 		}
 * 	}
 *
 * }
 * ```
 * @author Sebastien Deleuze
 * @see coRouter
 * @since 5.0
 */
/**
 * 允许使用[反应式路由器Kotlin DSL] [RouterFunctionDsl]轻松创建WebFlux.fn [RouterFunction]。 
 * 示例：```@Configuration类RouterConfiguration {@Bean fun mainRouter（userHandler：UserHandler）= router {accept（TEXT_HTML）.nest {（GET（"/ user /"）或GET（"/ users /"））。 
 * invoke （userHandler :: findAllView）GET（"/ users / {login}"，userHandler :: findViewById）} accept（APPLICATION_JSON）.nest {（GET（"/ api / user /"）或GET（"/ api / users / "））。 
 * invoke（userHandler :: findAll）POST（"/ api / users /"，userHandler :: create）}}}```@author  Sebastien Deleuze 
 * @see  coRouter @since 5.0
 */
fun router(routes: RouterFunctionDsl.() -> Unit) = RouterFunctionDsl(routes).build()

/**
 * Provide a WebFlux.fn [RouterFunction] Reactive Kotlin DSL created by [`router { }`][router] in order to be able to write idiomatic Kotlin code.
 *
 * @author Sebastien Deleuze
 * @author Yevhenii Melnyk
 * @since 5.0
 */
/**
 * 提供一个WebFlux.fn [RouterFunction]由[`router {}] [router]创建的可响应Kotlin DSL，以便能够编写惯用的Kotlin代码。 
 *  @author 塞巴斯蒂安·德勒兹（Sebastien Deleuze）@author  Yevhenii Melnyk @从5.0开始
 */
class RouterFunctionDsl internal constructor (private val init: RouterFunctionDsl.() -> Unit) {

	@PublishedApi
	internal val builder = RouterFunctions.route()

	/**
	 * Return a composed request predicate that tests against both this predicate AND
	 * the [other] predicate (String processed as a path predicate). When evaluating the
	 * composed predicate, if this predicate is `false`, then the [other] predicate is not
	 * evaluated.
	 * @see RequestPredicate.and
	 * @see RequestPredicates.path
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词将同时对此谓词和[other]谓词（字符串作为路径谓词进行处理）进行测试。 
	 * 在评估组合谓词时，如果该谓词为"false"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.and 
	 * @see  RequestPredicates.path
	 */
	infix fun RequestPredicate.and(other: String): RequestPredicate = this.and(path(other))

	/**
	 * Return a composed request predicate that tests against both this predicate OR
	 * the [other] predicate (String processed as a path predicate). When evaluating the
	 * composed predicate, if this predicate is `true`, then the [other] predicate is not
	 * evaluated.
	 * @see RequestPredicate.or
	 * @see RequestPredicates.path
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词将同时对此谓词或[other]谓词（字符串作为路径谓词进行处理）进行测试。 
	 * 在评估组合谓词时，如果该谓词为"true"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.or 
	 * @see  RequestPredicates.path
	 */
	infix fun RequestPredicate.or(other: String): RequestPredicate = this.or(path(other))

	/**
	 * Return a composed request predicate that tests against both this predicate (String
	 * processed as a path predicate) AND the [other] predicate. When evaluating the
	 * composed predicate, if this predicate is `false`, then the [other] predicate is not
	 * evaluated.
	 * @see RequestPredicate.and
	 * @see RequestPredicates.path
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词同时针对此谓词（作为路径谓词处理的String）和[other]谓词进行测试。 
	 * 在评估组合谓词时，如果该谓词为"false"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.and 
	 * @see  RequestPredicates.path
	 */
	infix fun String.and(other: RequestPredicate): RequestPredicate = path(this).and(other)

	/**
	 * Return a composed request predicate that tests against both this predicate (String
	 * processed as a path predicate) OR the [other] predicate. When evaluating the
	 * composed predicate, if this predicate is `true`, then the [other] predicate is not
	 * evaluated.
	 * @see RequestPredicate.or
	 * @see RequestPredicates.path
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词将同时对此谓词（作为路径谓词处理的字符串）或[other]谓词进行测试。 
	 * 在评估组合谓词时，如果该谓词为"true"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.or 
	 * @see  RequestPredicates.path
	 */
	infix fun String.or(other: RequestPredicate): RequestPredicate = path(this).or(other)

	/**
	 * Return a composed request predicate that tests against both this predicate AND
	 * the [other] predicate. When evaluating the composed predicate, if this
	 * predicate is `false`, then the [other] predicate is not evaluated.
	 * @see RequestPredicate.and
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词同时针对此谓词和[other]谓词进行测试。 
	 * 在评估组合谓词时，如果该谓词为"false"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.and
	 */
	infix fun RequestPredicate.and(other: RequestPredicate): RequestPredicate = this.and(other)

	/**
	 * Return a composed request predicate that tests against both this predicate OR
	 * the [other] predicate. When evaluating the composed predicate, if this
	 * predicate is `true`, then the [other] predicate is not evaluated.
	 * @see RequestPredicate.or
	 */
	/**
	 * 返回对这个谓词或[other]谓词进行测试的组合请求谓词。 
	 * 在评估组合谓词时，如果该谓词为"true"，则不会评估[other]谓词。 
	 *  
	 * @see  RequestPredicate.or
	 */
	infix fun RequestPredicate.or(other: RequestPredicate): RequestPredicate = this.or(other)

	/**
	 * Return a predicate that represents the logical negation of this predicate.
	 */
	/**
	 * 返回表示该谓词逻辑否定的谓词。 
	 * 
	 */
	operator fun RequestPredicate.not(): RequestPredicate = this.negate()

	/**
	 * Route to the given router function if the given request predicate applies. This
	 * method can be used to create *nested routes*, where a group of routes share a
	 * common path (prefix), header, or other request predicate.
	 * @see RouterFunctions.nest
	 */
	/**
	 * 如果给定的请求谓词适用，则路由到给定的路由器功能。 
	 * 此方法可用于创建嵌套的路由，其中​​一组路由共享一个公共路径（前缀），标头或其他请求谓词。 
	 *  
	 * @see  RouterFunctions.nest
	 */
	fun RequestPredicate.nest(init: RouterFunctionDsl.() -> Unit) {
		builder.nest(this, Supplier { RouterFunctionDsl(init).build() })
	}

	/**
	 * Route to the given router function if the given request predicate (String
	 * processed as a path predicate) applies. This method can be used to create
	 * *nested routes*, where a group of routes share a common path
	 * (prefix), header, or other request predicate.
	 * @see RouterFunctions.nest
	 * @see RequestPredicates.path
	*/
	/**
	 * 如果给定的请求谓词（作为路径谓词处理的字符串）适用，则路由到给定的路由器功能。 
	 * 此方法可用于创建嵌套的路由，其中​​一组路由共享一个公共路径（前缀），标头或其他请求谓词。 
	 *  
	 * @see  RouterFunctions.nest 
	 * @see  RequestPredicates.path
	 */
	fun String.nest(init: RouterFunctionDsl.() -> Unit) {
		builder.path(this, Supplier { RouterFunctionDsl(init).build() })
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `GET` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 将路由添加到给定的处理函数，以处理与给定模式匹配的所有HTTP`GET`请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun GET(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.GET(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `GET` requests
	 * that match the given pattern and predicate.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 将路由添加到给定的处理函数，该路由处理与给定的模式和谓词匹配的所有HTTP"GET"请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun GET(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.GET(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `GET`
	 * and the given [pattern] matches against the request path.
	 * @see RequestPredicates.GET
	 */
	/**
	 * 如果请求的HTTP方法为GET且给定的[pattern]与请求路径匹配，则返回一个[RequestPredicate]匹配。 
	 *  
	 * @see  RequestPredicates.GET
	 */
	fun GET(pattern: String): RequestPredicate = RequestPredicates.GET(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `HEAD` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`HEAD`请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun HEAD(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.HEAD(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `HEAD` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`HEAD`请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun HEAD(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.HEAD(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `HEAD`
	 * and the given `pattern` matches against the request path.
	 * @see RequestPredicates.HEAD
	 */
	/**
	 * 如果请求的HTTP方法为HEAD且给定的pattern与请求路径匹配，则返回一个[RequestPredicate]匹配。 
	 *  
	 * @see  RequestPredicates.HEAD
	 */
	fun HEAD(pattern: String): RequestPredicate = RequestPredicates.HEAD(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `POST` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`POST`请求​​。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun POST(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.POST(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `POST` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`POST`请求​​。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun POST(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.POST(pattern, predicate, HandlerFunction<ServerResponse>  { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `POST`
	 * and the given `pattern` matches against the request path.
	 * @see RequestPredicates.POST
	 */
	/**
	 * 如果请求的HTTP方法为POST且给定的pattern与请求路径匹配，则返回匹配的[RequestPredicate]。 
	 *  
	 * @see  RequestPredicates.POST
	 */
	fun POST(pattern: String): RequestPredicate = RequestPredicates.POST(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `PUT` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 向给定的处理函数添加一条路由，该路由处理与给定模式匹配的所有HTTP`PUT`请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun PUT(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.PUT(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `PUT` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 向给定的处理函数添加一条路由，该路由处理与给定模式匹配的所有HTTP`PUT`请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun PUT(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.PUT(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `PUT`
	 * and the given `pattern` matches against the request path.
	 * @see RequestPredicates.PUT
	 */
	/**
	 * 返回一个[RequestPredicate]，如果请求的HTTP方法为`PUT`，并且给定的'pattern'与请求路径匹配，则返回一个匹配的[RequestPredicate]。 
	 *  
	 * @see  RequestPredicates.PUT
	 */
	fun PUT(pattern: String): RequestPredicate = RequestPredicates.PUT(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `PATCH` requests
	 * that match the given pattern and predicate.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 将路由添加到给定的处理函数，以处理与给定的模式和谓词匹配的所有HTTP"PATCH"请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun PATCH(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.PATCH(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `PATCH` requests
	 * that match the given pattern and predicate.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 将路由添加到给定的处理函数，以处理与给定的模式和谓词匹配的所有HTTP"PATCH"请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun PATCH(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.PATCH(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `PATCH`
	 * and the given `pattern` matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is PATCH and if the given pattern
	 * matches against the request path
	 */
	/**
	 * 返回一个[RequestPredicate]，如果请求的HTTP方法为`PATCH`，并且给定的'pattern'与请求路径匹配，则返回一个匹配的[RequestPredicate]。 
	 *  
	 * @param 模式将路径模式与
	 * @return 匹配的谓词进行匹配，如果请求方法是PATCH，并且给定模式与请求路径匹配，则谓词将匹配
	 */
	fun PATCH(pattern: String): RequestPredicate = RequestPredicates.PATCH(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `DELETE` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`DELETE`请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun DELETE(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.DELETE(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `DELETE` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 向给定的处理函数添加路由，该路由处理与给定模式匹配的所有HTTP`DELETE`请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun DELETE(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.DELETE(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `DELETE`
	 * and the given `pattern` matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is DELETE and if the given pattern
	 * matches against the request path
	 */
	/**
	 * 返回一个[RequestPredicate]，如果请求的HTTP方法为`DELETE'且给定的`pattern`与请求路径匹配，则该匹配。 
	 *  
	 * @param 模式将路径模式与
	 * @return 匹配的谓词进行匹配，如果请求方法为DELETE并且给定模式与请求路径匹配，则谓词将匹配
	 */
	fun DELETE(pattern: String): RequestPredicate = RequestPredicates.DELETE(pattern)

	/**
	 * Adds a route to the given handler function that handles all HTTP `OPTIONS` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 */
	/**
	 * 向给定的处理函数添加一条路由，该路由处理与给定模式匹配的所有HTTP`OPTIONS`请求。 
	 *  
	 * @param 图案化要匹配的图案
	 */
	fun OPTIONS(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.OPTIONS(pattern) { f(it).cast(ServerResponse::class.java) }
	}

	/**
	 * Adds a route to the given handler function that handles all HTTP `OPTIONS` requests
	 * that match the given pattern.
	 * @param pattern the pattern to match to
	 * @param predicate additional predicate to match
	 * @since 5.2
	 */
	/**
	 * 向给定的处理函数添加一条路由，该路由处理与给定模式匹配的所有HTTP`OPTIONS`请求。 
	 *  
	 * @param 模式化模式以匹配
	 * @param 谓词以匹配其他谓词，从5.2开始
	 */
	fun OPTIONS(pattern: String, predicate: RequestPredicate, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.OPTIONS(pattern, predicate, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) })
	}

	/**
	 * Return a [RequestPredicate] that matches if request's HTTP method is `OPTIONS`
	 * and the given `pattern` matches against the request path.
	 * @param pattern the path pattern to match against
	 * @return a predicate that matches if the request method is OPTIONS and if the given pattern
	 * matches against the request path
	 */
	/**
	 * 如果请求的HTTP方法为OPTIONS且给定的pattern与请求路径匹配，则返回匹配的[RequestPredicate]。 
	 *  
	 * @param 模式将路径模式与
	 * @return 匹配的谓词进行匹配，如果请求方法为OPTIONS且给定模式与请求路径匹配，则谓词将匹配
	 */
	fun OPTIONS(pattern: String): RequestPredicate = RequestPredicates.OPTIONS(pattern)

	/**
	 * Route to the given handler function if the given accept predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的接受谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun accept(mediaType: MediaType, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.accept(mediaType), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	* Return a [RequestPredicate] that tests if the request's
	* [accept][ServerRequest.Headers.accept] header is
	* [compatible][MediaType.isCompatibleWith] with any of the given media types.
	* @param mediaTypes the media types to match the request's accept header against
	* @return a predicate that tests the request's accept header against the given media types
	*/
	/**
	 * 返回一个[RequestPredicate]，该请求测试请求的[accept] [ServerRequest.Headers.accept]标头是否与任何给定的媒体类型兼容[MediaType.isCompatibleWith]。 
	 *  
	 * @param  mediaType设置媒体类型以将请求的接受标头与
	 * @return 进行匹配，谓词针对给定的媒体类型测试请求的接受标头
	 */
	fun accept(vararg mediaTypes: MediaType): RequestPredicate = RequestPredicates.accept(*mediaTypes)

	/**
	 * Route to the given handler function if the given contentType predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的contentType谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun contentType(mediaTypes: MediaType, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.contentType(mediaTypes), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that tests if the request's
	 * [content type][ServerRequest.Headers.contentType] is
	 * [included][MediaType.includes] by any of the given media types.
	 * @param mediaTypes the media types to match the request's content type against
	 * @return a predicate that tests the request's content type against the given media types
	 */
	/**
	 * 返回一个[RequestPredicate]，用于测试请求的[内容类型] [ServerRequest.Headers.contentType]是否由任何给定的媒体类型[included] [MediaType.includes]。 
	 *  
	 * @param  mediaType将媒体类型与
	 * @return 相匹配，以将请求的内容类型与给定的媒体类型相比较，以测试请求的内容类型
	 */
	fun contentType(vararg mediaTypes: MediaType): RequestPredicate = RequestPredicates.contentType(*mediaTypes)

	/**
	 * Route to the given handler function if the given headers predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的标头谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun headers(headersPredicate: (ServerRequest.Headers) -> Boolean, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.headers(headersPredicate), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that tests the request's headers against the given headers predicate.
	 * @param headersPredicate a predicate that tests against the request headers
	 * @return a predicate that tests against the given header predicate
	 */
	/**
	 * 返回一个[RequestPredicate]，它根据给定的标头谓词测试请求的标头。 
	 *  
	 * @param  headersPredicate对请求标头进行测试的谓词
	 * @return 对给定标头谓词进行测试的谓词
	 */
	fun headers(headersPredicate: (ServerRequest.Headers) -> Boolean): RequestPredicate =
			RequestPredicates.headers(headersPredicate)

	/**
	 * Route to the given handler function if the given method predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的方法谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun method(httpMethod: HttpMethod, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.method(httpMethod), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that tests against the given HTTP method.
	 * @param httpMethod the HTTP method to match to
	 * @return a predicate that tests against the given HTTP method
	 */
	/**
	 * 返回一个针对给定HTTP方法进行测试的[RequestPredicate]。 
	 *  
	 * @param  httpMethod匹配
	 * @return 的HTTP方法，该谓词针对给定的HTTP方法进行测试
	 */
	fun method(httpMethod: HttpMethod): RequestPredicate = RequestPredicates.method(httpMethod)

	/**
	 * Route to the given handler function if the given path predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的路径谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun path(pattern: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.path(pattern), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that tests the request path against the given path pattern.
	 * @see RequestPredicates.path
	 */
	/**
	 * 返回一个[RequestPredicate]，它根据给定的路径模式测试请求路径。 
	 *  
	 * @see  RequestPredicates.path
	 */
	fun path(pattern: String): RequestPredicate = RequestPredicates.path(pattern)

	/**
	 * Route to the given handler function if the given pathExtension predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的pathExtension谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun pathExtension(extension: String, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.pathExtension(extension), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that matches if the request's path has the given extension.
	 * @param extension the path extension to match against, ignoring case
	 * @return a predicate that matches if the request's path has the given file extension
	 */
	/**
	 * 如果请求的路径具有给定的扩展名，则返回一个匹配的[RequestPredicate]。 
	 *  
	 * @param 扩展名要匹配的路径扩展名，忽略大小写
	 * @return 如果请求的路径具有给定的文件扩展名，则谓词匹配
	 */
	fun pathExtension(extension: String): RequestPredicate = RequestPredicates.pathExtension(extension)

	/**
	 * Route to the given handler function if the given pathExtension predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的pathExtension谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun pathExtension(predicate: (String) -> Boolean, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.pathExtension(predicate), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that matches if the request's path matches the given
	 * predicate.
	 * @see RequestPredicates.pathExtension
	 */
	/**
	 * 如果请求的路径与给定的谓词匹配，则返回一个与之匹配的[RequestPredicate]。 
	 *  
	 * @see  RequestPredicates.pathExtension
	 */
	fun pathExtension(predicate: (String) -> Boolean): RequestPredicate =
			RequestPredicates.pathExtension(predicate)

	/**
	 * Route to the given handler function if the given queryParam predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的queryParam谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	fun queryParam(name: String, predicate: (String) -> Boolean, f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.queryParam(name, predicate), HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Return a [RequestPredicate] that tests the request's query parameter of the given name
	 * against the given predicate.
	 * @param name the name of the query parameter to test against
	 * @param predicate predicate to test against the query parameter value
	 * @return a predicate that matches the given predicate against the query parameter of the given name
	 * @see ServerRequest#queryParam(String)
	 */
	/**
	 * 返回一个[RequestPredicate]，它根据给定的谓词测试给定名称的请求的查询参数。 
	 *  
	 * @param 命名要针对查询的查询参数的名称
	 * @param 谓词要针对查询参数值的测试
	 * @return 谓词，该谓词与给定谓词与给定名称的查询参数匹配ServerRequest＃queryParam（String）
	 */
	fun queryParam(name: String, predicate: (String) -> Boolean): RequestPredicate =
			RequestPredicates.queryParam(name, predicate)

	/**
	 * Route to the given handler function if the given request predicate applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定的请求谓词适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	operator fun RequestPredicate.invoke(f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(this, HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Route to the given handler function if the given predicate (String
	 * processed as a path predicate) applies.
	 * @see RouterFunctions.route
	 */
	/**
	 * 如果给定谓词（作为路径谓词处理的字符串）适用，则路由到给定的处理函数。 
	 *  
	 * @see  RouterFunctions.route
	 */
	operator fun String.invoke(f: (ServerRequest) -> Mono<out ServerResponse>) {
		builder.add(RouterFunctions.route(RequestPredicates.path(this),  HandlerFunction<ServerResponse> { f(it).cast(ServerResponse::class.java) }))
	}

	/**
	 * Route requests that match the given pattern to resources relative to the given root location.
	 * @see RouterFunctions.resources
	 */
	/**
	 * 将与给定模式匹配的请求路由到相对于给定根位置的资源。 
	 *  
	 * @see  RouterFunctions.resources
	 */
	fun resources(path: String, location: Resource) {
		builder.resources(path, location)
	}

	/**
	 * Route to resources using the provided lookup function. If the lookup function provides a
	 * [Resource] for the given request, it will be it will be exposed using a
	 * [HandlerFunction] that handles GET, HEAD, and OPTIONS requests.
	 */
	/**
	 * 使用提供的查找功能路由到资源。 
	 * 如果查找功能为给定请求提供了[资源]，它将使用处理GET，HEAD和OPTIONS请求的[HandlerFunction]公开。 
	 * 
	 */
	fun resources(lookupFunction: (ServerRequest) -> Mono<Resource>) {
		builder.resources(lookupFunction)
	}

	/**
	 * Merge externally defined router functions into this one.
	 * @param routerFunction the router function to be added
	 * @since 5.2
	 */
	/**
	 * 将外部定义的路由器功能合并到这一功能中。 
	 *  
	 * @param  routerFunction自5.2起开始添加的路由器功能
	 */
	fun add(routerFunction: RouterFunction<ServerResponse>) {
		builder.add(routerFunction)
	}

	/**
	 * Filters all routes created by this router with the given filter function. Filter
	 * functions are typically used to address cross-cutting concerns, such as logging,
	 * security, etc.
	 * @param filterFunction the function to filter all routes built by this router
	 * @since 5.2
	 */
	/**
	 * 使用给定的过滤功能过滤由该路由器创建的所有路由。 
	 * 过滤器功能通常用于解决跨领域的问题，例如日志记录，安全性等。 
	 * 
	 * @param  filterFunction过滤从此路由器建立的所有路由（自5.2版本开始）的功能。 
	 * 
	 */
	fun filter(filterFunction: (ServerRequest, (ServerRequest) -> Mono<ServerResponse>) -> Mono<ServerResponse>) {
		builder.filter { request, next ->
			filterFunction(request) {
				next.handle(request)
			}
		}
	}

	/**
	 * Filter the request object for all routes created by this builder with the given request
	 * processing function. Filters are typically used to address cross-cutting concerns, such
	 * as logging, security, etc.
	 * @param requestProcessor a function that transforms the request
	 * @since 5.2
	 */
	/**
	 * 使用给定的请求处理功能，过滤此构建器创建的所有路由的请求对象。 
	 * 过滤器通常用于解决跨领域的问题，例如日志记录，安全性等。 
	 * 
	 * @param  requestProcessor一个用于转换请求的函数，自5.2起
	 */
	fun before(requestProcessor: (ServerRequest) -> ServerRequest) {
		builder.before(requestProcessor)
	}

	/**
	 * Filter the response object for all routes created by this builder with the given response
	 * processing function. Filters are typically used to address cross-cutting concerns, such
	 * as logging, security, etc.
	 * @param responseProcessor a function that transforms the response
	 * @since 5.2
	 */
	/**
	 * 使用给定的响应处理功能过滤此构建器创建的所有路由的响应对象。 
	 * 过滤器通常用于解决跨领域的问题，例如日志记录，安全性等。 
	 * 
	 * @param  responseProcessor一个自5.2起转换响应的函数
	 */
	fun after(responseProcessor: (ServerRequest, ServerResponse) -> ServerResponse) {
		builder.after(responseProcessor)
	}

	/**
	 * Filters all exceptions that match the predicate by applying the given response provider
	 * function.
	 * @param predicate the type of exception to filter
	 * @param responseProvider a function that creates a response
	 * @since 5.2
	 */
	/**
	 * 通过应用给定的响应提供程序功能，筛选与谓词匹配的所有异常。 
	 *  
	 * @param 声明要过滤的异常类型
	 * @param  responseProvider一个自5.2起创建响应的函数
	 */
	fun onError(predicate: (Throwable) -> Boolean, responseProvider: (Throwable, ServerRequest) -> Mono<ServerResponse>) {
		builder.onError(predicate, responseProvider)
	}

	/**
	 * Filters all exceptions that match the predicate by applying the given response provider
	 * function.
	 * @param E the type of exception to filter
	 * @param responseProvider a function that creates a response
	 * @since 5.2
	 */
	/**
	 * 通过应用给定的响应提供程序功能，筛选与谓词匹配的所有异常。 
	 *  
	 * @param  E要过滤的异常类型
	 * @param  responseProvider一个自5.2起创建响应的函数
	 */
	inline fun <reified E : Throwable> onError(noinline responseProvider: (Throwable, ServerRequest) -> Mono<ServerResponse>) {
		builder.onError({it is E}, responseProvider)
	}

	/**
	 * Return a composed routing function created from all the registered routes.
	 * @since 5.1
	 */
	/**
	 * 返回从所有已注册路由创建的组合路由功能。 
	 *  @5.1起
	 */
	internal fun build(): RouterFunction<ServerResponse> {
		init()
		return builder.build()
	}

	/**
	 * Create a builder with the status code and headers of the given response.
	 * @param other the response to copy the status and headers from
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 使用状态代码和给定响应的标题创建一个构建器。 
	 *  
	 * @param 其他响应，以从
	 * @return 创建的生成器@since 5.1复制状态和标题
	 */
	fun from(other: ServerResponse): ServerResponse.BodyBuilder =
			ServerResponse.from(other)

	/**
	 * Create a builder with the given HTTP status.
	 * @param status the response status
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建具有给定HTTP状态的构建器。 
	 *  
	 * @param 表示响应状态
	 * @return 创建的生成器自5.1起
	 */
	fun status(status: HttpStatus): ServerResponse.BodyBuilder =
			ServerResponse.status(status)

	/**
	 * Create a builder with the given HTTP status.
	 * @param status the response status
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建具有给定HTTP状态的构建器。 
	 *  
	 * @param 表示响应状态
	 * @return 创建的生成器自5.1起
	 */
	fun status(status: Int): ServerResponse.BodyBuilder =
			ServerResponse.status(status)

	/**
	 * Create a builder with the status set to [200 OK][HttpStatus.OK].
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建状态设置为[200 OK] [HttpStatus.OK]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun ok(): ServerResponse.BodyBuilder =
			ServerResponse.ok()

	/**
	 * Create a new builder with a [201 Created][HttpStatus.CREATED] status
	 * and a location header set to the given URI.
	 * @param location the location URI
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[201 Created] [HttpStatus.CREATED]的新构建器，并将位置标头设置为给定的URI。 
	 *  
	 * @param  location位置URI 
	 * @return 创建的生成器@since 5.1
	 */
	fun created(location: URI): ServerResponse.BodyBuilder =
			ServerResponse.created(location)

	/**
	 * Create a builder with an [202 Accepted][HttpStatus.ACCEPTED] status.
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[202 Accepted] [HttpStatus.ACCEPTED]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun accepted(): ServerResponse.BodyBuilder =
			ServerResponse.accepted()

	/**
	 * Create a builder with a [204 No Content][HttpStatus.NO_CONTENT] status.
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建状态为[204 No Content] [HttpStatus.NO_CONTENT]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun noContent(): ServerResponse.HeadersBuilder<*> =
			ServerResponse.noContent()

	/**
	 * Create a builder with a [303 See Other][HttpStatus.SEE_OTHER]
	 * status and a location header set to the given URI.
	 * @param location the location URI
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建状态为[303请参见其他] [HttpStatus.SEE_OTHER]且位置标头设置为给定URI的构建器。 
	 *  
	 * @param  location位置URI 
	 * @return 创建的生成器@since 5.1
	 */
	fun seeOther(location: URI): ServerResponse.BodyBuilder =
			ServerResponse.seeOther(location)

	/**
	 * Create a builder with a [307 Temporary Redirect][HttpStatus.TEMPORARY_REDIRECT]
	 * status and a location header set to the given URI.
	 * @param location the location URI
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[307临时重定向] [HttpStatus.TEMPORARY_REDIRECT]的构建器，并将位置标头设置为给定的URI。 
	 *  
	 * @param  location位置URI 
	 * @return 创建的生成器@since 5.1
	 */
	fun temporaryRedirect(location: URI): ServerResponse.BodyBuilder =
			ServerResponse.temporaryRedirect(location)

	/**
	 * Create a builder with a [308 Permanent Redirect][HttpStatus.PERMANENT_REDIRECT]
	 * status and a location header set to the given URI.
	 * @param location the location URI
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[308永久重定向] [HttpStatus.PERMANENT_REDIRECT]的构建器，并将位置标头设置为给定的URI。 
	 *  
	 * @param  location位置URI 
	 * @return 创建的生成器@since 5.1
	 */
	fun permanentRedirect(location: URI): ServerResponse.BodyBuilder =
			ServerResponse.permanentRedirect(location)

	/**
	 * Create a builder with a [400 Bad Request][HttpStatus.BAD_REQUEST] status.
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[400错误的请求] [HttpStatus.BAD_REQUEST]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun badRequest(): ServerResponse.BodyBuilder =
			ServerResponse.badRequest()

	/**
	 * Create a builder with a [404 Not Found][HttpStatus.NOT_FOUND] status.
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建状态为[404找不到] [HttpStatus.NOT_FOUND]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun notFound(): ServerResponse.HeadersBuilder<*> =
			ServerResponse.notFound()

	/**
	 * Create a builder with an
	 * [422 Unprocessable Entity][HttpStatus.UNPROCESSABLE_ENTITY] status.
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建一个状态为[422不可处理的实体] [HttpStatus.UNPROCESSABLE_ENTITY]的构建器。 
	 *  
	 * @return 创建的生成器@since 5.1
	 */
	fun unprocessableEntity(): ServerResponse.BodyBuilder =
			ServerResponse.unprocessableEntity()

}
