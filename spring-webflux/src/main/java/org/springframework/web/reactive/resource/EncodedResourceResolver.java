/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.reactive.resource;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import reactor.core.publisher.Mono;

import org.springframework.core.io.AbstractResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.web.server.ServerWebExchange;

/**
 * Resolver that delegates to the chain, and if a resource is found, it then
 * attempts to find an encoded (e.g. gzip, brotli) variant that is acceptable
 * based on the "Accept-Encoding" request header.
 *
 * <p>The list of supported {@link #setContentCodings(List) contentCodings} can
 * be configured, in order of preference, and each coding must be associated
 * with {@link #setExtensions(Map) extensions}.
 *
 * <p>Note that this resolver must be ordered ahead of a
 * {@link VersionResourceResolver} with a content-based, version strategy to
 * ensure the version calculation is not impacted by the encoding.
 *
 * @author Rossen Stoyanchev
 * @since 5.1
 */
/**
 * 委托给链的解析器，如果找到资源，则它会尝试根据"接受编码"请求标头找到可接受的编码（例如gzip，brotli）变体。 
 *  <p>可以按照优先顺序配置受支持的{@link  #setContentCodings（List）contentCodings}的列表，并且每个编码必须与{@link  #setExtensions（Map）扩展名）相关联。 
 *  <p>请注意，必须使用基于内容的版本策略在{@link  VersionResourceResolver}之前订购此解析器，以确保版本计算不受编码的影响。 
 *  @author  Rossen Stoyanchev @从5.1开始
 */
public class EncodedResourceResolver extends AbstractResourceResolver {

	/**
	 * The default content codings.
	 */
	/**
	 * 默认的内容编码。 
	 * 
	 */
	public static final List<String> DEFAULT_CODINGS = Arrays.asList("br", "gzip");


	private final List<String> contentCodings = new ArrayList<>(DEFAULT_CODINGS);

	private final Map<String, String> extensions = new LinkedHashMap<>();


	public EncodedResourceResolver() {
		this.extensions.put("gzip", ".gz");
		this.extensions.put("br", ".br");
	}


	/**
	 * Configure the supported content codings in order of preference. The first
	 * coding that is present in the {@literal "Accept-Encoding"} header for a
	 * given request, and that has a file present with the associated extension,
	 * is used.
	 * <p><strong>Note:</strong> Each coding must be associated with a file
	 * extension via {@link #registerExtension} or {@link #setExtensions}. Also
	 * customizations to the list of codings here should be matched by
	 * customizations to the same list in {@link CachingResourceResolver} to
	 * ensure encoded variants of a resource are cached under separate keys.
	 * <p>By default this property is set to {@literal ["br", "gzip"]}.
	 * @param codings one or more supported content codings
	 */
	/**
	 * 按首选项顺序配置支持的内容编码。 
	 * 使用第一个编码，该编码出现在{@literal"Accept-Encoding"}头中，用于给定请求，并且具有与相关扩展名一起存在的文件。 
	 *  <p> <strong>注意</ strong>：每个编码都必须通过{@link  #registerExtension}或{@link  #setExtensions}与文件扩展名关联。 
	 * 同样，此处的编码列表的自定义项应与{@link  CachingResourceResolver}中的相同列表的自定义项进行匹配，以确保资源的编码变体被缓存在单独的键下。 
	 *  <p>默认情况下，此属性设置为{@literal ["br"，"gzip"]}。 
	 *  
	 * @param 编码一种或多种受支持的内容编码
	 */
	public void setContentCodings(List<String> codings) {
		Assert.notEmpty(codings, "At least one content coding expected");
		this.contentCodings.clear();
		this.contentCodings.addAll(codings);
	}

	/**
	 * Return a read-only list with the supported content codings.
	 */
	/**
	 * 返回带有支持的内容编码的只读列表。 
	 * 
	 */
	public List<String> getContentCodings() {
		return Collections.unmodifiableList(this.contentCodings);
	}

	/**
	 * Configure mappings from content codings to file extensions. A dot "."
	 * will be prepended in front of the extension value if not present.
	 * <p>By default this is configured with {@literal ["br" -> ".br"]} and
	 * {@literal ["gzip" -> ".gz"]}.
	 * @param extensions the extensions to use.
	 * @see #registerExtension(String, String)
	 */
	/**
	 * 配置从内容编码到文件扩展名的映射。 
	 * 点"。 
	 * "如果不存在，则将在扩展值之前。 
	 *  <p>默认情况下，此配置为{@literal ["br"->".br"]}和{@literal ["gzip"->".gz"]}。 
	 *  
	 * @param 扩展名要使用的扩展名。 
	 *  
	 * @see  #registerExtension（字符串，字符串）
	 */
	public void setExtensions(Map<String, String> extensions) {
		extensions.forEach(this::registerExtension);
	}

	/**
	 * Return a read-only map with coding-to-extension mappings.
	 */
	/**
	 * 返回带有编码到扩展映射的只读映射。 
	 * 
	 */
	public Map<String, String> getExtensions() {
		return Collections.unmodifiableMap(this.extensions);
	}

	/**
	 * Java config friendly alternative to {@link #setExtensions(Map)}.
	 * @param coding the content coding
	 * @param extension the associated file extension
	 */
	/**
	 * Java配置友好替代{@link  #setExtensions（Map）}。 
	 *  
	 * @param 编码内容编码
	 * @param 扩展相关的文件扩展名
	 */
	public void registerExtension(String coding, String extension) {
		this.extensions.put(coding, (extension.startsWith(".") ? extension : "." + extension));
	}


	@Override
	protected Mono<Resource> resolveResourceInternal(@Nullable ServerWebExchange exchange,
			String requestPath, List<? extends Resource> locations, ResourceResolverChain chain) {

		return chain.resolveResource(exchange, requestPath, locations).map(resource -> {

			if (exchange == null) {
				return resource;
			}

			String acceptEncoding = getAcceptEncoding(exchange);
			if (acceptEncoding == null) {
				return resource;
			}

			for (String coding : this.contentCodings) {
				if (acceptEncoding.contains(coding)) {
					try {
						String extension = getExtension(coding);
						Resource encoded = new EncodedResource(resource, coding, extension);
						if (encoded.exists()) {
							return encoded;
						}
					}
					catch (IOException ex) {
						logger.trace(exchange.getLogPrefix() +
								"No " + coding + " resource for [" + resource.getFilename() + "]", ex);
					}
				}
			}

			return resource;
		});
	}

	@Nullable
	private String getAcceptEncoding(ServerWebExchange exchange) {
		ServerHttpRequest request = exchange.getRequest();
		String header = request.getHeaders().getFirst(HttpHeaders.ACCEPT_ENCODING);
		return (header != null ? header.toLowerCase() : null);
	}

	private String getExtension(String coding) {
		String extension = this.extensions.get(coding);
		if (extension == null) {
			throw new IllegalStateException("No file extension associated with content coding " + coding);
		}
		return extension;
	}

	@Override
	protected Mono<String> resolveUrlPathInternal(String resourceUrlPath,
			List<? extends Resource> locations, ResourceResolverChain chain) {

		return chain.resolveUrlPath(resourceUrlPath, locations);
	}


	/**
	 * An encoded {@link HttpResource}.
	 */
	/**
	 * 编码的{@link  HttpResource}。 
	 * 
	 */
	static final class EncodedResource extends AbstractResource implements HttpResource {

		private final Resource original;

		private final String coding;

		private final Resource encoded;

		EncodedResource(Resource original, String coding, String extension) throws IOException {
			this.original = original;
			this.coding = coding;
			this.encoded = original.createRelative(original.getFilename() + extension);
		}

		@Override
		public InputStream getInputStream() throws IOException {
			return this.encoded.getInputStream();
		}

		@Override
		public boolean exists() {
			return this.encoded.exists();
		}

		@Override
		public boolean isReadable() {
			return this.encoded.isReadable();
		}

		@Override
		public boolean isOpen() {
			return this.encoded.isOpen();
		}

		@Override
		public boolean isFile() {
			return this.encoded.isFile();
		}

		@Override
		public URL getURL() throws IOException {
			return this.encoded.getURL();
		}

		@Override
		public URI getURI() throws IOException {
			return this.encoded.getURI();
		}

		@Override
		public File getFile() throws IOException {
			return this.encoded.getFile();
		}

		@Override
		public long contentLength() throws IOException {
			return this.encoded.contentLength();
		}

		@Override
		public long lastModified() throws IOException {
			return this.encoded.lastModified();
		}

		@Override
		public Resource createRelative(String relativePath) throws IOException {
			return this.encoded.createRelative(relativePath);
		}

		@Override
		@Nullable
		public String getFilename() {
			return this.original.getFilename();
		}

		@Override
		public String getDescription() {
			return this.encoded.getDescription();
		}

		@Override
		public HttpHeaders getResponseHeaders() {
			HttpHeaders headers;
			if (this.original instanceof HttpResource) {
				headers = ((HttpResource) this.original).getResponseHeaders();
			}
			else {
				headers = new HttpHeaders();
			}
			headers.add(HttpHeaders.CONTENT_ENCODING, this.coding);
			headers.add(HttpHeaders.VARY, HttpHeaders.ACCEPT_ENCODING);
			return headers;
		}
	}

}
