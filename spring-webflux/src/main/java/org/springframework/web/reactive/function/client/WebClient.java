/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.reactive.function.client;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntPredicate;
import java.util.function.Predicate;

import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.reactive.ClientHttpConnector;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.http.codec.ClientCodecConfigurer;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Non-blocking, reactive client to perform HTTP requests, exposing a fluent,
 * reactive API over underlying HTTP client libraries such as Reactor Netty.
 *
 * <p>Use static factory methods {@link #create()} or {@link #create(String)},
 * or {@link WebClient#builder()} to prepare an instance.
 *
 * <p>For examples with a response body see:
 * <ul>
 * <li>{@link RequestHeadersSpec#retrieve() retrieve()}
 * <li>{@link RequestHeadersSpec#exchange() exchange()}
 * </ul>
 * <p>For examples with a request body see:
 * <ul>
 * <li>{@link RequestBodySpec#bodyValue(Object) bodyValue(Object)}
 * <li>{@link RequestBodySpec#body(Publisher, Class) body(Publisher,Class)}
 * </ul>
 *
 * @author Rossen Stoyanchev
 * @author Arjen Poutsma
 * @author Sebastien Deleuze
 * @author Brian Clozel
 * @since 5.0
 */
/**
 * 非阻塞，反应式客户端执行HTTP请求，通过底层HTTP客户端库（如Reactor Netty）公开流利的，反应式API。 
 *  <p>使用静态工厂方法{@link  #create（）}或{@link  #create（String）}或{@link  WebClient＃builder（）}来准备实例。 
 *  <p>有关带有响应正文的示例，请参见：<ul> <li> {<@link> RequestHeadersSpec＃retrieve（）restore（）} <li> {<@link> RequestHeadersSpec＃exchange（）exchange（）} </ ul> <p>有关请求正文的示例，请参见：<ul> <li> {<@link> RequestBodySpec＃bodyValue（Object）bodyValue（Object）} <li> {<@link> RequestBodySpec＃body（Publisher，Class ）body（Publisher，Class）} </ ul> @author  Rossen Stoyanchev @author  Arjen Poutsma @author  Sebastien Deleuze @author  Brian Clozel @5.0起
 */
public interface WebClient {

	/**
	 * Start building an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP GET请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Start building an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP HEAD请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Start building an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP POST请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec post();

	/**
	 * Start building an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP PUT请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec put();

	/**
	 * Start building an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP PATCH请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec patch();

	/**
	 * Start building an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP DELETE请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Start building an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始构建HTTP OPTIONS请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Start building a request for the given {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 开始为给定的{@code  HttpMethod}建立一个请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to create a new {@code WebClient} whose settings are
	 * replicated from the current {@code WebClient}.
	 */
	/**
	 * 返回一个生成器以创建一个新的{@code  WebClient}，其设置将从当前的{@code  WebClient}复制。 
	 * 
	 */
	Builder mutate();


	// Static, factory methods

	/**
	 * Create a new {@code WebClient} with Reactor Netty by default.
	 * @see #create(String)
	 * @see #builder()
	 */
	/**
	 * 默认情况下，使用Reactor Netty创建一个新的{@code  WebClient}。 
	 *  
	 * @see  #create（字符串）
	 * @see  #builder（）
	 */
	static WebClient create() {
		return new DefaultWebClientBuilder().build();
	}

	/**
	 * Variant of {@link #create()} that accepts a default base URL. For more
	 * details see {@link Builder#baseUrl(String) Builder.baseUrl(String)}.
	 * @param baseUrl the base URI for all requests
	 * @see #builder()
	 */
	/**
	 * {@link  #create（）}的变体，它接受默认的基本URL。 
	 * 有关更多详细信息，请参见{@link  Builder＃baseUrl（String）Builder.baseUrl（String）}。 
	 *  
	 * @param  baseUrl所有请求的基本URI 
	 * @see  #builder（）
	 */
	static WebClient create(String baseUrl) {
		return new DefaultWebClientBuilder().baseUrl(baseUrl).build();
	}

	/**
	 * Obtain a {@code WebClient} builder.
	 */
	/**
	 * 获取一个{@code  WebClient}构建器。 
	 * 
	 */
	static WebClient.Builder builder() {
		return new DefaultWebClientBuilder();
	}


	/**
	 * A mutable builder for creating a {@link WebClient}.
	 */
	/**
	 * 用于创建{@link  WebClient}的可变构建器。 
	 * 
	 */
	interface Builder {

		/**
		 * Configure a base URL for requests performed through the client.
		 *
		 * <p>For example given base URL "https://abc.go.com/v1":
		 * <p><pre class="code">
		 * Mono&#060;Account&#062; result = client.get().uri("/accounts/{id}", 43)
		 *         .retrieve()
		 *         .bodyToMono(Account.class);
		 *
		 * // Result: https://abc.go.com/v1/accounts/43
		 *
		 * Flux&#060;Account&#062; result = client.get()
		 *         .uri(builder -> builder.path("/accounts").queryParam("q", "12").build())
		 *         .retrieve()
		 *         .bodyToFlux(Account.class);
		 *
		 * // Result: https://abc.go.com/v1/accounts?q=12
		 * </pre>
		 *
		 * <p>The base URL can be overridden with an absolute URI:
		 * <pre class="code">
		 * Mono&#060;Account&#062; result = client.get().uri("https://xyz.com/path")
		 *         .retrieve()
		 *         .bodyToMono(Account.class);
		 *
		 * // Result: https://xyz.com/path
		 * </pre>
		 *
		 * <p>Or partially overridden with a {@code UriBuilder}:
		 * <pre class="code">
		 * Flux&#060;Account&#062; result = client.get()
		 *         .uri(builder -> builder.replacePath("/v2/accounts").queryParam("q", "12").build())
		 *         .retrieve()
		 *         .bodyToFlux(Account.class);
		 *
		 * // Result: https://abc.com/v2/accounts?q=12
		 * </pre>
		 *
		 * @see #defaultUriVariables(Map)
		 * @see #uriBuilderFactory(UriBuilderFactory)
		 */
		/**
		 * 为通过客户端执行的请求配置基本URL。 
		 *  <p>例如，给定的基本URL"https://abc.go.com/v1"：<p> <pre class ="code"> Mono <Account> result = client.get（）。 
		 * uri（"/ accounts / {id}"，43）.retrieve（）.bodyToMono（Account.class）; //结果：https：//abc.go.com/v1/accounts/43 Flux <Account> result = client.get（）.uri（builder-> builder.path（"/ accounts"）。 
		 * queryParam（"q "，"12"）。 
		 * build（））.retrieve（）.bodyToFlux（Account.class）; //结果：https://abc.go.com/v1/accounts?q=12 </ pre> <p>基本URL可以用绝对URI覆盖：<pre class ="code"> Mono <Account >结果= client.get（）。 
		 * uri（"https://xyz.com/path"）.retrieve（）.bodyToMono（Account.class）; //结果：https：//xyz.com/path </ pre> <p>或用{@code  UriBuilder}部分覆盖：<pre class ="code"> Flux <Account> result = client.get （）.uri（builder-> builder.replacePath（"/ v2 / accounts"）。 
		 * queryParam（"q"，"12"）。 
		 * build（））.retrieve（）.bodyToFlux（Account.class）; //结果：https://abc.com/v2/accounts?q=12 </ pre> 
		 * @see  #defaultUriVariables（Map）
		 * @see  #uriBuilderFactory（UriBuilderFactory）
		 */
		Builder baseUrl(String baseUrl);

		/**
		 * Configure default URI variable values that will be used when expanding
		 * URI templates using a {@link Map}.
		 * @param defaultUriVariables the default values to use
		 * @see #baseUrl(String)
		 * @see #uriBuilderFactory(UriBuilderFactory)
		 */
		/**
		 * 配置使用{@link  Map}扩展URI模板时将使用的默认URI变量值。 
		 *  
		 * @param  defaultUriVariable设置要使用的默认值
		 * @see  #baseUrl（String）
		 * @see  #uriBuilderFactory（UriBuilderFactory）
		 */
		Builder defaultUriVariables(Map<String, ?> defaultUriVariables);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance. This is
		 * an alternative to and effectively overrides the following:
		 * <ul>
		 * <li>{@link #baseUrl(String)}
		 * <li>{@link #defaultUriVariables(Map)}.
		 * </ul>
		 * @param uriBuilderFactory the URI builder factory to use
		 * @see #baseUrl(String)
		 * @see #defaultUriVariables(Map)
		 */
		/**
		 * 提供一个预先配置的{@link  UriBuilderFactory}实例。 
		 * 这是一种替代方法，可以有效地覆盖以下内容：<ul> <li> {<@link> #baseUrl（String）} <li> {<@link> #defaultUriVariables（Map）}。 
		 *  </ ul> 
		 * @param  uriBuilderFactory URI构建器工厂以使用
		 * @see  #baseUrl（String）
		 * @see  #defaultUriVariables（Map）
		 */
		Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Global option to specify a header to be added to every request,
		 * if the request does not already contain such a header.
		 * @param header the header name
		 * @param values the header values
		 */
		/**
		 * 全局选项，用于指定要添加到每个请求的标头（如果请求尚未包含此类标头）。 
		 *  
		 * @param 标头标头名称
		 * @param 值标头值
		 */
		Builder defaultHeader(String header, String... values);

		/**
		 * Provides access to every {@link #defaultHeader(String, String...)}
		 * declared so far with the possibility to add, replace, or remove.
		 * @param headersConsumer the consumer
		 */
		/**
		 * 提供对到目前为止声明的每个{@link  #defaultHeader（String，String ...）}的访问，并可以添加，替换或删除。 
		 *  
		 * @param 标头消费消费者
		 */
		Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Global option to specify a cookie to be added to every request,
		 * if the request does not already contain such a cookie.
		 * @param cookie the cookie name
		 * @param values the cookie values
		 */
		/**
		 * 全局选项，用于指定要添加到每个请求的cookie（如果该请求尚未包含该cookie）。 
		 *  
		 * @param  cookie cookie名称
		 * @param 对cookie值进行赋值
		 */
		Builder defaultCookie(String cookie, String... values);

		/**
		 * Provides access to every {@link #defaultCookie(String, String...)}
		 * declared so far with the possibility to add, replace, or remove.
		 * @param cookiesConsumer a function that consumes the cookies map
		 */
		/**
		 * 提供对到目前为止声明的每个{@link  #defaultCookie（String，String ...）}的访问，并可以添加，替换或删除。 
		 *  
		 * @param  cookiesConsumer消费使用Cookies映射的函数
		 */
		Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Provide a consumer to modify every request being built just before the
		 * call to {@link RequestHeadersSpec#exchange() exchange()}.
		 * @param defaultRequest the consumer to use for modifying requests
		 * @since 5.1
		 */
		/**
		 * 提供使用者以在调用{@link  RequestHeadersSpec＃exchange（）exchange（）}之前修改正在构建的每个请求。 
		 *  
		 * @param  default请求使用者自5.1起使用
		 */
		Builder defaultRequest(Consumer<RequestHeadersSpec<?>> defaultRequest);

		/**
		 * Add the given filter to the end of the filter chain.
		 * @param filter the filter to be added to the chain
		 */
		/**
		 * 将给定的过滤器添加到过滤器链的末尾。 
		 *  
		 * @param 过滤器要添加到链中的过滤器
		 */
		Builder filter(ExchangeFilterFunction filter);

		/**
		 * Manipulate the filters with the given consumer. The list provided to
		 * the consumer is "live", so that the consumer can be used to remove
		 * filters, change ordering, etc.
		 * @param filtersConsumer a function that consumes the filter list
		 * @return this builder
		 */
		/**
		 * 与给定的使用者一起操作过滤器。 
		 * 提供给使用者的列表是"活动的"，因此可以使用使用者删除过滤器，更改顺序等。 
		 * 
		 * @param  filtersConsumer使用此过滤器的函数，该列表使用@
		 * @return>
		 */
		Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer);

		/**
		 * Configure the {@link ClientHttpConnector} to use. This is useful for
		 * plugging in and/or customizing options of the underlying HTTP client
		 * library (e.g. SSL).
		 * <p>By default this is set to
		 * {@link org.springframework.http.client.reactive.ReactorClientHttpConnector
		 * ReactorClientHttpConnector}.
		 * @param connector the connector to use
		 */
		/**
		 * 配置{@link  ClientHttpConnector}以使用。 
		 * 这对于插入和/或自定义基础HTTP客户端库（例如SSL）的选项很有用。 
		 *  <p>默认情况下，它设置为{@link  org.springframework.http.client.reactive.ReactorClientHttpConnector ReactorClientHttpConnector}。 
		 *  
		 * @param 连接器要使用的连接器
		 */
		Builder clientConnector(ClientHttpConnector connector);

		/**
		 * Configure the codecs for the {@code WebClient} in the
		 * {@link #exchangeStrategies(ExchangeStrategies) underlying}
		 * {@code ExchangeStrategies}.
		 * @param configurer the configurer to apply
		 * @since 5.1.13
		 */
		/**
		 * 在{@link  #exchangeStrategies（ExchangeStrategies）基础} {@code  ExchangeStrategies}中为{@code  WebClient}配置编解码器。 
		 *  
		 * @param 配置器配置器从5.1.13开始应用
		 */
		Builder codecs(Consumer<ClientCodecConfigurer> configurer);

		/**
		 * Configure the {@link ExchangeStrategies} to use.
		 * <p>For most cases, prefer using {@link #codecs(Consumer)} which allows
		 * customizing the codecs in the {@code ExchangeStrategies} rather than
		 * replace them. That ensures multiple parties can contribute to codecs
		 * configuration.
		 * <p>By default this is set to {@link ExchangeStrategies#withDefaults()}.
		 * @param strategies the strategies to use
		 */
		/**
		 * 配置{@link  ExchangeStrategies}以供使用。 
		 *  <p>在大多数情况下，更喜欢使用{@link  #codecs（Consumer）}，它允许在{@code  ExchangeStrategies}中自定义编解码器，而不是替换它们。 
		 * 这样可以确保多方可以为编解码器配置做出贡献。 
		 *  <p>默认情况下，它设置为{@link  ExchangeStrategies＃withDefaults（）}。 
		 *  
		 * @param 策略使用的策略
		 */
		Builder exchangeStrategies(ExchangeStrategies strategies);

		/**
		 * Customize the strategies configured via
		 * {@link #exchangeStrategies(ExchangeStrategies)}. This method is
		 * designed for use in scenarios where multiple parties wish to update
		 * the {@code ExchangeStrategies}.
		 * @deprecated as of 5.1.13 in favor of {@link #codecs(Consumer)}
		 */
		/**
		 * 自定义通过{@link  #exchangeStrategies（ExchangeStrategies）}配置的策略。 
		 * 此方法设计用于多方希望更新{@code  ExchangeStrategies}的方案。 
		 *  @自5.1.13起不推荐使用{@link  #codecs（Consumer）}
		 */
		@Deprecated
		Builder exchangeStrategies(Consumer<ExchangeStrategies.Builder> configurer);

		/**
		 * Provide an {@link ExchangeFunction} pre-configured with
		 * {@link ClientHttpConnector} and {@link ExchangeStrategies}.
		 * <p>This is an alternative to, and effectively overrides
		 * {@link #clientConnector}, and
		 * {@link #exchangeStrategies(ExchangeStrategies)}.
		 * @param exchangeFunction the exchange function to use
		 */
		/**
		 * 提供一个预先配置有{@link  ClientHttpConnector}和{@link  ExchangeStrategies}的{@link  ExchangeFunction}。 
		 *  <p>这是一种替代方法，可以有效地覆盖{@link  #clientConnector}和{@link  #exchangeStrategies（ExchangeStrategies）}。 
		 *  
		 * @param  exchangeFunction要使用的交换功能
		 */
		Builder exchangeFunction(ExchangeFunction exchangeFunction);

		/**
		 * Apply the given {@code Consumer} to this builder instance.
		 * <p>This can be useful for applying pre-packaged customizations.
		 * @param builderConsumer the consumer to apply
		 */
		/**
		 * 将给定的{@code  Consumer}应用于此构建器实例。 
		 *  <p>这对于应用预打包的自定义项很有用。 
		 *  
		 * @param  builder消费者可以申请
		 */
		Builder apply(Consumer<Builder> builderConsumer);

		/**
		 * Clone this {@code WebClient.Builder}.
		 */
		/**
		 * 克隆此{@code  WebClient.Builder}。 
		 * 
		 */
		Builder clone();

		/**
		 * Builder the {@link WebClient} instance.
		 */
		/**
		 * 生成{@link  WebClient}实例。 
		 * 
		 */
		WebClient build();
	}


	/**
	 * Contract for specifying the URI for a request.
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 用于指定请求URI的合同。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link URI}.
		 */
		/**
		 * 使用绝对的，完全构造的{@link  URI}指定URI。 
		 * 
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * If a {@link UriBuilderFactory} was configured for the client (e.g.
		 * with a base URI) it will be used to expand the URI template.
		 */
		/**
		 * 使用URI模板和URI变量指定请求的URI。 
		 * 如果为客户端配置了{@link  UriBuilderFactory}（例如，使用基本URI），它将用于扩展URI模板。 
		 * 
		 */
		S uri(String uri, Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * If a {@link UriBuilderFactory} was configured for the client (e.g.
		 * with a base URI) it will be used to expand the URI template.
		 */
		/**
		 * 使用URI模板和URI变量指定请求的URI。 
		 * 如果为客户端配置了{@link  UriBuilderFactory}（例如，使用基本URI），它将用于扩展URI模板。 
		 * 
		 */
		S uri(String uri, Map<String, ?> uriVariables);

		/**
		 * Specify the URI starting with a URI template and finishing off with a
		 * {@link UriBuilder} created from the template.
		 * @since 5.2
		 */
		/**
		 * 以URI模板开头并以从模板创建的{@link  UriBuilder}结尾，指定URI。 
		 *  @5.2起
		 */
		S uri(String uri, Function<UriBuilder, URI> uriFunction);

		/**
		 * Specify the URI by through a {@link UriBuilder}.
		 * @see #uri(String, Function)
		 */
		/**
		 * 通过{@link  UriBuilder}指定URI。 
		 *  
		 * @see  #uri（字符串，函数）
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Contract for specifying request headers leading up to the exchange.
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 用于指定导致交换的请求标头的合同。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return this builder
		 */
		/**
		 * 设置可接受的{@link  plain MediaType媒体类型}列表，如{@code  Accept}标头所指定。 
		 *  
		 * @param  acceptableMediaTypes可接受的媒体类型
		 * @return 此构建器
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return this builder
		 */
		/**
		 * 按照{@code  Accept-Charset}标头指定的设置可接受的{@link  plain Charset字符集}的列表。 
		 *  
		 * @param  acceptableCharsets可接受的字符集
		 * @return 此构建器
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return this builder
		 */
		/**
		 * 添加具有给定名称和值的cookie。 
		 *  
		 * @param 命名cookie名称
		 * @param 值cookie值
		 * @return 此构建器
		 */
		S cookie(String name, String value);

		/**
		 * Provides access to every cookie declared so far with the possibility
		 * to add, replace, or remove values.
		 * @param cookiesConsumer the consumer to provide access to
		 * @return this builder
		 */
		/**
		 * 提供对到目前为止已声明的每个cookie的访问，并可以添加，替换或删除值。 
		 *  
		 * @param  cookies消费者可以使用它来访问此构建器的
		 * @return 
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return this builder
		 */
		/**
		 * 设置{@code  If-Modified-Since}标头的值。 
		 *  <p>日期应指定为格林尼治标准时间1970年1月1日以来的毫秒数。 
		 *  
		 * @param  ifModifiedSince标头的新值
		 * @return 此构建器
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return this builder
		 */
		/**
		 * 设置{@code  If-None-Match}标头的值。 
		 *  
		 * @param  ifNoneMatch头文件的新值
		 * @return 此构建器
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return this builder
		 */
		/**
		 * 在给定名称下添加给定的单个标头值。 
		 *  
		 * @param  headerName标头名称
		 * @param  headerValues标头值
		 * @return 此构建器
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Provides access to every header declared so far with the possibility
		 * to add, replace, or remove values.
		 * @param headersConsumer the consumer to provide access to
		 * @return this builder
		 */
		/**
		 * 提供对到目前为止声明的每个标头的访问，并可以添加，替换或删除值。 
		 *  
		 * @param 标头让消费者使用以提供对
		 * @return 此构建器的访问
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this builder
		 */
		/**
		 * 将具有给定名称的属性设置为给定值。 
		 *  
		 * @param 名称要添加的属性的名称
		 * @param 值要添加的属性的值
		 * @return 此构建器
		 */
		S attribute(String name, Object value);

		/**
		 * Provides access to every attribute declared so far with the
		 * possibility to add, replace, or remove values.
		 * @param attributesConsumer the consumer to provide access to
		 * @return this builder
		 */
		/**
		 * 提供对到目前为止声明的每个属性的访问，并可以添加，替换或删除值。 
		 *  
		 * @param 属性消费方可以提供对此<Builder的
		 * @return 的访问权限
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the HTTP request and retrieve the response body:
		 * <p><pre>
		 * Mono&lt;Person&gt; bodyMono = client.get()
		 *     .uri("/persons/1")
		 *     .accept(MediaType.APPLICATION_JSON)
		 *     .retrieve()
		 *     .bodyToMono(Person.class);
		 * </pre>
		 * <p>This method is a shortcut to using {@link #exchange()} and
		 * decoding the response body through {@link ClientResponse}.
		 * @return {@code ResponseSpec} to specify how to decode the body
		 * @see #exchange()
		 */
		/**
		 * 执行HTTP请求并检索响应正文：<p> <pre> Mono <Person> bodyMono = client.get（）.uri（"/ persons / 1"）.accept（MediaType.APPLICATION_JSON）.retrieve（）.bodyToMono （Person.class）; </ pre> <p>此方法是使用{@link  #exchange（）}并通过{@link  ClientResponse}解码响应正文的快捷方式。 
		 *  
		 * @return  {@code  ResponseSpec}指定如何解码正文
		 * @see  #exchange（）
		 */
		ResponseSpec retrieve();

		/**
		 * Perform the HTTP request and return a {@link ClientResponse} with the
		 * response status and headers. You can then use methods of the response
		 * to consume the body:
		 * <p><pre>
		 * Mono&lt;Person&gt; mono = client.get()
		 *     .uri("/persons/1")
		 *     .accept(MediaType.APPLICATION_JSON)
		 *     .exchange()
		 *     .flatMap(response -&gt; response.bodyToMono(Person.class));
		 *
		 * Flux&lt;Person&gt; flux = client.get()
		 *     .uri("/persons")
		 *     .accept(MediaType.APPLICATION_STREAM_JSON)
		 *     .exchange()
		 *     .flatMapMany(response -&gt; response.bodyToFlux(Person.class));
		 * </pre>
		 * <p><strong>NOTE:</strong> Unlike {@link #retrieve()}, when using
		 * {@code exchange()}, it is the responsibility of the application to
		 * consume any response content regardless of the scenario (success,
		 * error, unexpected data, etc). Not doing so can cause a memory leak.
		 * See {@link ClientResponse} for a list of all the available options
		 * for consuming the body. Generally prefer using {@link #retrieve()}
		 * unless you have a good reason to use {@code exchange()} which does
		 * allow to check the response status and headers before deciding how or
		 * if to consume the response.
		 * @return a {@code Mono} for the response
		 * @see #retrieve()
		 */
		/**
		 * 执行HTTP请求并返回带有响应状态和标头的{@link  ClientResponse}。 
		 * 然后，您可以使用响应方法来消耗主体：<p> <pre> Mono <Person> mono = client.get（）.uri（"/ persons / 1"）.accept（MediaType.APPLICATION_JSON）.exchange（ ）.flatMap（response-> response.bodyToMono（Person.class））; Flux <Person> flux = client.get（）.uri（"/ persons"）.accept（MediaType.APPLICATION_STREAM_JSON）.exchange（）.flatMapMany（response-> response.bodyToFlux（Person.class））; </ pre> <p> <strong>注意：</ strong>：与{@link  #retrieve（）}不同，使用{@code  exchange（）}时，应用程序有责任消耗任何响应内容，与方案无关（成功，错误，意外数据等）。 
		 * 否则会导致内存泄漏。 
		 * 有关消耗身体的所有可用选项的列表，请参见{@link  ClientResponse}。 
		 * 通常最好使用{@link  #retrieve（）}，除非您有充分的理由使用{@code  exchange（）}，它确实允许在确定如何或是否使用响应之前检查响应状态和标头。 
		 *  
		 * @return 一个{@code  Mono}用于响应
		 * @see  #retrieve（）
		 */
		Mono<ClientResponse> exchange();
	}


	/**
	 * Contract for specifying request headers and body leading up to the exchange.
	 */
	/**
	 * 用于指定导致交换的请求标头和正文的合同。 
	 * 
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return this builder
		 * @see HttpHeaders#setContentLength(long)
		 */
		/**
		 * 按照{@code  Content-Length}标头指定的内容，以字节为单位设置正文的长度。 
		 *  
		 * @param  contentLength内容长度
		 * @return 此构建器
		 * @see  HttpHeaders＃setContentLength（long）
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return this builder
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		/**
		 * 设置主体的{@link  plain MediaType媒体类型}，如{@code  Content-Type}标头所指定。 
		 *  
		 * @param  contentType内容类型
		 * @return 此构建器
		 * @see  HttpHeaders＃setContentType（MediaType）
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Shortcut for {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromValue value inserter}.
		 * For example:
		 * <p><pre class="code">
		 * Person person = ... ;
		 *
		 * Mono&lt;Void&gt; result = client.post()
		 *     .uri("/persons/{id}", id)
		 *     .contentType(MediaType.APPLICATION_JSON)
		 *     .bodyValue(person)
		 *     .retrieve()
		 *     .bodyToMono(Void.class);
		 * </pre>
		 * <p>For multipart requests consider providing
		 * {@link org.springframework.util.MultiValueMap MultiValueMap} prepared
		 * with {@link org.springframework.http.client.MultipartBodyBuilder
		 * MultipartBodyBuilder}.
		 * @param body the value to write to the request body
		 * @return this builder
		 * @throws IllegalArgumentException if {@code body} is a
		 * {@link Publisher} or producer known to {@link ReactiveAdapterRegistry}
		 * @since 5.2
		 */
		/**
		 * {@link  #body（BodyInserter）}与{@link  plain BodyInserters＃fromValue值插入器}的快捷方式。 
		 * 例如：<p> <pre class ="code"> Person person = ...; Mono <Void>结果= client.post（）.uri（"/ persons / {id}"，id）.contentType（MediaType.APPLICATION_JSON）.bodyValue（person）.retrieve（）.bodyToMono（Void.class）; </ pre> <p>对于多部分请求，请考虑提供使用{@link  org.springframework.http.client.MultipartBodyBuilder MultipartBodyBuilder}编写的{@link  org.springframework.util.MultiValueMap MultiValueMap}。 
		 *  
		 * @param 正文要写入请求正文的值
		 * @return 此构建器
		 * @throws  IllegalArgumentException如果{@code  body}是{@link  Publisher}或{@link 已知的生产者ReactiveAdapterRegistry} @从5.2开始
		 */
		RequestHeadersSpec<?> bodyValue(Object body);

		/**
		 * Shortcut for {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromPublisher Publisher inserter}.
		 * For example:
		 * <p><pre>
		 * Mono&lt;Person&gt; personMono = ... ;
		 *
		 * Mono&lt;Void&gt; result = client.post()
		 *     .uri("/persons/{id}", id)
		 *     .contentType(MediaType.APPLICATION_JSON)
		 *     .body(personMono, Person.class)
		 *     .retrieve()
		 *     .bodyToMono(Void.class);
		 * </pre>
		 * @param publisher the {@code Publisher} to write to the request
		 * @param elementClass the type of elements published
		 * @param <T> the type of the elements contained in the publisher
		 * @param <P> the type of the {@code Publisher}
		 * @return this builder
		 */
		/**
		 * {@link  #body（BodyInserter）}的快捷方式，带有{@link  plain BodyInserters＃fromPublisher Publisher插入程序}。 
		 * 例如：<p> <pre> Mono <Person> personMono = ...; Mono <Void>结果= client.post（）.uri（"/ persons / {id}"，id）.contentType（MediaType.APPLICATION_JSON）.body（personMono，Person.class）.retrieve（）.bodyToMono（Void。 
		 * 类）; </ pre> 
		 * @param 发布者{{@@code> Publisher}向请求
		 * @param  elementClass写入发布的元素类型
		 * @param  <T>发布者中包含的元素类型<
		 * @param> <P> {@code  Publisher}的类型
		 * @return 此构建器
		 */
		<T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher, Class<T> elementClass);

		/**
		 * Variant of {@link #body(Publisher, Class)} that allows providing
		 * element type information with generics.
		 * @param publisher the {@code Publisher} to write to the request
		 * @param elementTypeRef the type of elements published
		 * @param <T> the type of the elements contained in the publisher
		 * @param <P> the type of the {@code Publisher}
		 * @return this builder
		 */
		/**
		 * {@link  #body（Publisher，Class）}的变体，它允许提供具有泛型的元素类型信息。 
		 *  
		 * @param 发布者{{@@code> Publisher}写入请求
		 * @param  elementTypeRef发布的元素类型
		 * @param  <T>发布者中包含的元素类型
		 * @param  <P > {@code  Publisher}的类型
		 * @return 此构建器
		 */
		<T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher,
				ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Variant of {@link #body(Publisher, Class)} that allows using any
		 * producer that can be resolved to {@link Publisher} via
		 * {@link ReactiveAdapterRegistry}.
		 * @param producer the producer to write to the request
		 * @param elementClass the type of elements produced
		 * @return this builder
		 * @since 5.2
		 */
		/**
		 * {@link  #body（Publisher，Class）}的变体，它允许使用可以通过{@link  ReactiveAdapterRegistry}解析为{@link  Publisher}的任何生产者。 
		 *  
		 * @param 生产者生产者向请求中写入
		 * @param  elementClass产生的元素类型
		 * @return 此生成器@5.2起
		 */
		RequestHeadersSpec<?> body(Object producer, Class<?> elementClass);

		/**
		 * Variant of {@link #body(Publisher, ParameterizedTypeReference)} that
		 * allows using any producer that can be resolved to {@link Publisher}
		 * via {@link ReactiveAdapterRegistry}.
		 * @param producer the producer to write to the request
		 * @param elementTypeRef the type of elements produced
		 * @return this builder
		 * @since 5.2
		 */
		/**
		 * {@link  #body（Publisher，ParameterizedTypeReference）}的变体，它允许使用可以通过{@link  ReactiveAdapterRegistry}解析为{@link  Publisher}的任何生产者。 
		 *  
		 * @param 生产者生产者写入请求
		 * @param  elementTypeRef产生的元素类型
		 * @return 此构建器@5.2起
		 */
		RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef);

		/**
		 * Set the body of the request using the given body inserter.
		 * See {@link BodyInserters} for built-in {@link BodyInserter} implementations.
		 * @param inserter the body inserter to use for the request body
		 * @return this builder
		 * @see org.springframework.web.reactive.function.BodyInserters
		 */
		/**
		 * 使用给定的正文插入器设置请求的正文。 
		 * 有关内置{@link  BodyInserter}实现的信息，请参见{@link  BodyInserters}。 
		 *  
		 * @param 插入程序用于请求正文的正文插入程序
		 * @return 此构建器
		 * @see  org.springframework.web.reactive.function.BodyInserters
		 */
		RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter);

		/**
		 * Shortcut for {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromValue value inserter}.
		 * As of 5.2 this method delegates to {@link #bodyValue(Object)}.
		 * @deprecated as of Spring Framework 5.2 in favor of {@link #bodyValue(Object)}
		 */
		/**
		 * {@link  #body（BodyInserter）}与{@link  plain BodyInserters＃fromValue值插入器}的快捷方式。 
		 * 从5.2开始，此方法委托给{@link  #bodyValue（Object）}。 
		 * 自Spring Framework 5.2起已弃用@，推荐使用{@link  #bodyValue（Object）}
		 */
		@Deprecated
		RequestHeadersSpec<?> syncBody(Object body);
	}


	/**
	 * Contract for specifying response operations following the exchange.
	 */
	/**
	 * 交换后指定响应操作的合同。 
	 * 
	 */
	interface ResponseSpec {

		/**
		 * Register a custom error function that gets invoked when the given {@link HttpStatus}
		 * predicate applies. Whatever exception is returned from the function (possibly using
		 * {@link ClientResponse#createException()}) will also be returned as error signal
		 * from {@link #bodyToMono(Class)} and {@link #bodyToFlux(Class)}.
		 * <p>By default, an error handler is registered that returns a
		 * {@link WebClientResponseException} when the response status code is 4xx or 5xx.
		 * To override this default (and return a non-error response from {@code bodyOn*}), register
		 * an exception function that returns an {@linkplain Mono#empty() empty} mono.
		 * <p><strong>NOTE:</strong> if the response is expected to have content,
		 * the exceptionFunction should consume it. If not, the content will be
		 * automatically drained to ensure resources are released.
		 * @param statusPredicate a predicate that indicates whether {@code exceptionFunction}
		 * applies
		 * @param exceptionFunction the function that returns the exception
		 * @return this builder
		 * @see ClientResponse#createException()
		 */
		/**
		 * 注册一个自定义错误函数，该函数将在给定的{@link  HttpStatus}谓词适用时被调用。 
		 * 从函数返回的任何异常（可能使用{@link  ClientResponse＃createException（）}）也将作为错误信号从{@link  #bodyToMono（Class）}和{@link  #bodyToFlux（类）}。 
		 *  <p>默认情况下，注册一个错误处理程序，当响应状态代码为4xx或5xx时，该错误处理程序返回{@link  WebClientResponseException}。 
		 * 要覆盖此默认值（并从{@code  bodyOn}返回非错误响应），请注册一个异常函数，该函数返回一个{@link  plain Mono＃empty（）empty} mono。 
		 *  <p> <strong>注意：</ strong>：如果期望响应包含内容，exceptionFunction应该使用它。 
		 * 否则，内容将自动耗尽以确保释放资源。 
		 *  
		 * @param  statusPredicate谓词，指示{{@@code> exceptionFunction}是否应用
		 * @param  exceptionFunction返回异常的函数
		 * @return 此构建器
		 * @see  ClientResponse＃createException（）
		 */
		ResponseSpec onStatus(Predicate<HttpStatus> statusPredicate,
				Function<ClientResponse, Mono<? extends Throwable>> exceptionFunction);

		/**
		 * Register a custom error function that gets invoked when the given raw status code
		 * predicate applies. The exception returned from the function will be returned from
		 * {@link #bodyToMono(Class)} and {@link #bodyToFlux(Class)}.
		 * <p>By default, an error handler is registered that throws a
		 * {@link WebClientResponseException} when the response status code is 4xx or 5xx.
		 * @param statusCodePredicate a predicate of the raw status code that indicates
		 * whether {@code exceptionFunction} applies.
		 * <p><strong>NOTE:</strong> if the response is expected to have content,
		 * the exceptionFunction should consume it. If not, the content will be
		 * automatically drained to ensure resources are released.
		 * @param exceptionFunction the function that returns the exception
		 * @return this builder
		 * @since 5.1.9
		 */
		/**
		 * 注册一个自定义错误函数，该错误函数将在给定原始状态代码谓词适用时被调用。 
		 * 从函数返回的异常将从{@link  #bodyToMono（Class）}和{@link  #bodyToFlux（Class）}返回。 
		 *  <p>默认情况下，注册一个错误处理程序，该错误处理程序在响应状态代码为4xx或5xx时抛出{@link  WebClientResponseException}。 
		 *  
		 * @param  statusCodePredicate原始状态代码的谓词，该谓词指示{@code  exceptionFunction}是否适用。 
		 *  <p> <strong>注意：</ strong>：如果期望响应包含内容，exceptionFunction应该使用它。 
		 * 否则，内容将自动耗尽以确保释放资源。 
		 *  
		 * @param  exceptionFunction返回异常的函数
		 * @return 此构建器@since 5.1.9
		 */
		ResponseSpec onRawStatus(IntPredicate statusCodePredicate,
				Function<ClientResponse, Mono<? extends Throwable>> exceptionFunction);

		/**
		 * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or
		 * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden
		 * with {@link #onStatus(Predicate, Function)}.
		 * @param elementClass the expected response body element class
		 * @param <T> response body type
		 * @return a mono containing the body, or a {@link WebClientResponseException} if the
		 * status code is 4xx or 5xx
		 */
		/**
		 * 将主体提取到{@code  Mono}。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementClass期望的响应主体元素类
		 * @param  <T>响应主体类型
		 * @return 包含主体的单声道； 
		 * 如果状态代码是4xx或5xx，则返回{@link  WebClientResponseException}
		 */
		<T> Mono<T> bodyToMono(Class<T> elementClass);

		/**
		 * Extract the body to a {@code Mono}. By default, if the response has status code 4xx or
		 * 5xx, the {@code Mono} will contain a {@link WebClientException}. This can be overridden
		 * with {@link #onStatus(Predicate, Function)}.
		 * @param elementTypeRef a type reference describing the expected response body element type
		 * @param <T> response body type
		 * @return a mono containing the body, or a {@link WebClientResponseException} if the
		 * status code is 4xx or 5xx
		 */
		/**
		 * 将主体提取到{@code  Mono}。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementTypeRef类型引用，描述了预期的响应主体元素类型
		 * @param  <T>响应主体类型
		 * @return 包含主体的单声道； 
		 * 如果状态代码为4xx，则为{@link  WebClientResponseException}或5xx
		 */
		<T> Mono<T> bodyToMono(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or
		 * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden
         * with {@link #onStatus(Predicate, Function)}.
		 * @param elementClass the class of elements in the response
		 * @param <T> the type of elements in the response
		 * @return a flux containing the body, or a {@link WebClientResponseException} if the
		 * status code is 4xx or 5xx
		 */
		/**
		 * 将主体提取到{@code  Flux}。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Flux}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementClass响应中元素的类
		 * @param  <T>响应中元素的类型
		 * @return 包含正文的通量，或者如果状态代码为{@link  WebClientResponseException} 4xx或5xx
		 */
		<T> Flux<T> bodyToFlux(Class<T> elementClass);

		/**
		 * Extract the body to a {@code Flux}. By default, if the response has status code 4xx or
		 * 5xx, the {@code Flux} will contain a {@link WebClientException}. This can be overridden
         * with {@link #onStatus(Predicate, Function)}.
		 * @param elementTypeRef a type reference describing the expected response body element type
		 * @param <T> the type of elements in the response
		 * @return a flux containing the body, or a {@link WebClientResponseException} if the
		 * status code is 4xx or 5xx
		 */
		/**
		 * 将主体提取到{@code  Flux}。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Flux}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementTypeRef一个类型引用，描述了预期的响应主体元素类型
		 * @param  <T>响应中元素的类型
		 * @return 包含主体的通量，或者{{@link> WebClientResponseException}状态码是4xx或5xx
		 */
		<T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Return the response as a delayed {@code ResponseEntity}. By default, if the response has
		 * status code 4xx or 5xx, the {@code Mono} will contain a {@link WebClientException}. This
		 * can be overridden with {@link #onStatus(Predicate, Function)}.
		 * @param bodyClass the expected response body type
		 * @param <T> response body type
		 * @return {@code Mono} with the {@code ResponseEntity}
		 * @since 5.2
		 */
		/**
		 * 作为延迟的{@code  ResponseEntity}返回响应。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  bodyClass预期的响应主体类型
		 * @param  <T>响应主体类型
		 * @return  {@code  Mono}与{@code  ResponseEntity} @5.2起
		 */
		<T> Mono<ResponseEntity<T>> toEntity(Class<T> bodyClass);

		/**
		 * Return the response as a delayed {@code ResponseEntity}. By default, if the response has
		 * status code 4xx or 5xx, the {@code Mono} will contain a {@link WebClientException}. This
		 * can be overridden with {@link #onStatus(Predicate, Function)}.
		 * @param bodyTypeReference a type reference describing the expected response body type
		 * @param <T> response body type
		 * @return {@code Mono} with the {@code ResponseEntity}
		 * @since 5.2
		 */
		/**
		 * 作为延迟的{@code  ResponseEntity}返回响应。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  bodyTypeReference类型参考，描述了预期的响应主体类型
		 * @param  <T>响应主体类型
		 * @return  {@code  Mono}与{@code  ResponseEntity} @since 5.2
		 */
		<T> Mono<ResponseEntity<T>> toEntity(ParameterizedTypeReference<T> bodyTypeReference);

		/**
		 * Return the response as a delayed list of {@code ResponseEntity}s. By default, if the
		 * response has status code 4xx or 5xx, the {@code Mono} will contain a
		 * {@link WebClientException}. This can be overridden with
		 * {@link #onStatus(Predicate, Function)}.
		 * @param elementClass the expected response body list element class
		 * @param <T> the type of elements in the list
		 * @return {@code Mono} with the list of {@code ResponseEntity}s
		 * @since 5.2
		 */
		/**
		 * 以{@code  ResponseEntity}的延迟列表形式返回响应。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementClass期望的响应主体列表元素类
		 * @param  <T>列表中元素的类型
		 * @return  {@code  Mono}和列表中的{@code  ResponseEntity} s @从5.2开始
		 */
		<T> Mono<ResponseEntity<List<T>>> toEntityList(Class<T> elementClass);

		/**
		 * Return the response as a delayed list of {@code ResponseEntity}s. By default, if the
		 * response has status code 4xx or 5xx, the {@code Mono} will contain a
		 * {@link WebClientException}. This can be overridden with
		 * {@link #onStatus(Predicate, Function)}.
		 * @param elementTypeRef the expected response body list element reference type
		 * @param <T> the type of elements in the list
		 * @return {@code Mono} with the list of {@code ResponseEntity}s
		 * @since 5.2
		 */
		/**
		 * 以{@code  ResponseEntity}的延迟列表形式返回响应。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 *  
		 * @param  elementTypeRef期望的响应主体列表元素引用类型
		 * @param  <T>列表中的元素类型
		 * @return  {@code  Mono}和列表中的{@code  ResponseEntity} s @5.2起
		 */
		<T> Mono<ResponseEntity<List<T>>> toEntityList(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Return the response as a delayed {@code ResponseEntity} containing status and headers,
		 * but no body.  By default, if the response has status code 4xx or 5xx, the {@code Mono}
		 * will contain a {@link WebClientException}. This can be overridden with
		 * {@link #onStatus(Predicate, Function)}.
		 * Calling this method will {@linkplain ClientResponse#releaseBody() release} the body of
		 * the response.
		 * @return {@code Mono} with the bodiless {@code ResponseEntity}
		 * @since 5.2
		 */
		/**
		 * 以延迟的{@code  ResponseEntity}形式返回响应，其中包含状态和标头，但没有正文。 
		 * 默认情况下，如果响应的状态码为4xx或5xx，则{@code  Mono}将包含一个{@link  WebClientException}。 
		 * 可以使用{@link  #onStatus（Predicate，Function）}覆盖它。 
		 * 调用此方法将{@link  plain ClientResponse＃releaseBody（）release}响应的正文。 
		 *  
		 * @return  {@code  Mono}与无身体的{@code  ResponseEntity} @从5.2开始
		 */
		Mono<ResponseEntity<Void>> toBodilessEntity();
	}


	/**
	 * Contract for specifying request headers and URI for a request.
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 用于指定请求标头和请求URI的合同。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>>
			extends UriSpec<S>, RequestHeadersSpec<S> {
	}


	/**
	 * Contract for specifying request headers, body and URI for a request.
	 */
	/**
	 * 用于指定请求标头，正文和URI的合同。 
	 * 
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


}
