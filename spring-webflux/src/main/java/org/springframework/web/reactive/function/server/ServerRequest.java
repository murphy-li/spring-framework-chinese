/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.reactive.function.server;

import java.net.InetSocketAddress;
import java.net.URI;
import java.nio.charset.Charset;
import java.security.Principal;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.function.Consumer;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRange;
import org.springframework.http.MediaType;
import org.springframework.http.codec.HttpMessageReader;
import org.springframework.http.codec.json.Jackson2CodecSupport;
import org.springframework.http.codec.multipart.Part;
import org.springframework.http.server.PathContainer;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyExtractor;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebSession;
import org.springframework.web.util.UriBuilder;

/**
 * Represents a server-side HTTP request, as handled by a {@code HandlerFunction}.
 *
 * <p>Access to headers and body is offered by {@link Headers} and
 * {@link #body(BodyExtractor)}, respectively.
 *
 * @author Arjen Poutsma
 * @author Sebastien Deleuze
 * @since 5.0
 */
/**
 * 表示由{@code  HandlerFunction}处理的服务器端HTTP请求。 
 *  <p>分别由{@link 标头}和{@link  #body（BodyExtractor）}提供对标头和正文的访问。 
 *  @author  Arjen Poutsma @author 塞巴斯蒂安·德勒兹@5.0起
 */
public interface ServerRequest {

	/**
	 * Get the HTTP method.
	 * @return the HTTP method as an HttpMethod enum value, or {@code null}
	 * if not resolvable (e.g. in case of a non-standard HTTP method)
	 */
	/**
	 * 获取HTTP方法。 
	 *  
	 * @return  HTTP方法作为HttpMethod枚举值； 
	 * 如果无法解析，则返回{@code  null}（例如，在使用非标准HTTP方法的情况下）
	 */
	@Nullable
	default HttpMethod method() {
		return HttpMethod.resolve(methodName());
	}

	/**
	 * Get the name of the HTTP method.
	 * @return the HTTP method as a String
	 */
	/**
	 * 获取HTTP方法的名称。 
	 *  
	 * @return  HTTP方法作为字符串
	 */
	String methodName();

	/**
	 * Get the request URI.
	 */
	/**
	 * 获取请求URI。 
	 * 
	 */
	URI uri();

	/**
	 * Get a {@code UriBuilderComponents} from the URI associated with this
	 * {@code ServerRequest}.
	 * <p><strong>Note:</strong> as of 5.1 this method ignores {@code "Forwarded"}
	 * and {@code "X-Forwarded-*"} headers that specify the
	 * client-originated address. Consider using the {@code ForwardedHeaderFilter}
	 * to extract and use, or to discard such headers.
	 * @return a URI builder
	 */
	/**
	 * 从与此{@code  ServerRequest}关联的URI中获取一个{@code  UriBuilderComponents}。 
	 *  <p> <strong>注意</ strong>：从5.1版本开始，此方法将忽略{@code "Forwarded"}和{@code "X-Forwarded-"}标头，这些标头指定了客户端起源的地址。 
	 * 考虑使用{@code  ForwardedHeaderFilter}提取和使用或丢弃此类标头。 
	 *  
	 * @return  URI构建器
	 */
	UriBuilder uriBuilder();

	/**
	 * Get the request path.
	 */
	/**
	 * 获取请求路径。 
	 * 
	 */
	default String path() {
		return uri().getRawPath();
	}

	/**
	 * Get the request path as a {@code PathContainer}.
	 */
	/**
	 * 以{@code  PathContainer}的形式获取请求路径。 
	 * 
	 */
	default PathContainer pathContainer() {
		return PathContainer.parsePath(path());
	}

	/**
	 * Get the headers of this request.
	 */
	/**
	 * 获取此请求的标头。 
	 * 
	 */
	Headers headers();

	/**
	 * Get the cookies of this request.
	 */
	/**
	 * 获取此请求的cookie。 
	 * 
	 */
	MultiValueMap<String, HttpCookie> cookies();

	/**
	 * Get the remote address to which this request is connected, if available.
	 * @since 5.1
	 */
	/**
	 * 获取此请求连接到的远程地址（如果有）。 
	 *  @5.1起
	 */
	Optional<InetSocketAddress> remoteAddress();

	/**
	 * Get the remote address to which this request is connected, if available.
	 * @since 5.2.3
	 */
	/**
	 * 获取此请求连接到的远程地址（如果有）。 
	 *  @从5.2.3开始
	 */
	Optional<InetSocketAddress> localAddress();

	/**
	 * Get the readers used to convert the body of this request.
	 * @since 5.1
	 */
	/**
	 * 获取用于转换此请求正文的读者。 
	 *  @5.1起
	 */
	List<HttpMessageReader<?>> messageReaders();

	/**
	 * Extract the body with the given {@code BodyExtractor}.
	 * @param extractor the {@code BodyExtractor} that reads from the request
	 * @param <T> the type of the body returned
	 * @return the extracted body
	 * @see #body(BodyExtractor, Map)
	 */
	/**
	 * 使用给定的{@code  BodyExtractor}提取主体。 
	 *  
	 * @param 提取器{@code  BodyExtractor}从请求中读取
	 * @param  <T>返回的主体类型
	 * @return 提取的主体
	 * @see  #body（BodyExtractor，Map）
	 */
	<T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor);

	/**
	 * Extract the body with the given {@code BodyExtractor} and hints.
	 * @param extractor the {@code BodyExtractor} that reads from the request
	 * @param hints the map of hints like {@link Jackson2CodecSupport#JSON_VIEW_HINT}
	 * to use to customize body extraction
	 * @param <T> the type of the body returned
	 * @return the extracted body
	 */
	/**
	 * 使用给定的{@code  BodyExtractor}和提示提取主体。 
	 *  
	 * @param 提取器从请求
	 * @param 读取的{@code  BodyExtractor}提示的映射图，如{@link  Jackson2CodecSupport＃JSON_VIEW_HINT}，用于自定义主体提取
	 * @param  <T>返回的主体类型
	 * @return 提取的主体
	 */
	<T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints);

	/**
	 * Extract the body to a {@code Mono}.
	 * @param elementClass the class of element in the {@code Mono}
	 * @param <T> the element type
	 * @return the body as a mono
	 */
	/**
	 * 将主体提取到{@code  Mono}。 
	 *  
	 * @param  elementClass {@code  Mono}中元素的类
	 * @param  <T>元素类型
	 * @return 作为mono的主体
	 */
	<T> Mono<T> bodyToMono(Class<? extends T> elementClass);

	/**
	 * Extract the body to a {@code Mono}.
	 * @param typeReference a type reference describing the expected response request type
	 * @param <T> the element type
	 * @return a mono containing the body of the given type {@code T}
	 */
	/**
	 * 将主体提取到{@code  Mono}。 
	 *  
	 * @param  typeReference类型描述，描述了预期的响应请求类型
	 * @param  <T>元素类型
	 * @return 包含给定类型{{@code> T}的主体的单声道
	 */
	<T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference);

	/**
	 * Extract the body to a {@code Flux}.
	 * @param elementClass the class of element in the {@code Flux}
	 * @param <T> the element type
	 * @return the body as a flux
	 */
	/**
	 * 将主体提取到{@code  Flux}。 
	 *  
	 * @param  elementClass {{@code> Flux}中元素的类
	 * @param  <T>元素类型
	 * @return 体作为通量
	 */
	<T> Flux<T> bodyToFlux(Class<? extends T> elementClass);

	/**
	 * Extract the body to a {@code Flux}.
	 * @param typeReference a type reference describing the expected request body type
	 * @param <T> the element type
	 * @return a flux containing the body of the given type {@code T}
	 */
	/**
	 * 将主体提取到{@code  Flux}。 
	 *  
	 * @param  typeReference类型参考，描述了预期的请求主体类型
	 * @param  <T>元素类型
	 * @return 包含给定类型主体的通量{@code  T}
	 */
	<T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference);

	/**
	 * Get the request attribute value if present.
	 * @param name the attribute name
	 * @return the attribute value
	 */
	/**
	 * 获取请求属性值（如果存在）。 
	 *  
	 * @param 命名属性名称
	 * @return 属性值
	 */
	default Optional<Object> attribute(String name) {
		return Optional.ofNullable(attributes().get(name));
	}

	/**
	 * Get a mutable map of request attributes.
	 * @return the request attributes
	 */
	/**
	 * 获取请求属性的可变映射。 
	 *  
	 * @return 请求属性
	 */
	Map<String, Object> attributes();

	/**
	 * Get the first query parameter with the given name, if present.
	 * @param name the parameter name
	 * @return the parameter value
	 */
	/**
	 * 获取具有给定名称的第一个查询参数（如果存在）。 
	 *  
	 * @param 命名参数名称
	 * @return 参数值
	 */
	default Optional<String> queryParam(String name) {
		List<String> queryParamValues = queryParams().get(name);
		if (CollectionUtils.isEmpty(queryParamValues)) {
			return Optional.empty();
		}
		else {
			String value = queryParamValues.get(0);
			if (value == null) {
				value = "";
			}
			return Optional.of(value);
		}
	}

	/**
	 * Get all query parameters for this request.
	 */
	/**
	 * 获取此请求的所有查询参数。 
	 * 
	 */
	MultiValueMap<String, String> queryParams();

	/**
	 * Get the path variable with the given name, if present.
	 * @param name the variable name
	 * @return the variable value
	 * @throws IllegalArgumentException if there is no path variable with the given name
	 */
	/**
	 * 获取具有给定名称的路径变量（如果存在）。 
	 *  
	 * @param 命名变量名称
	 * @return 变量值
	 * @throws  IllegalArgumentException如果没有具有给定名称的路径变量
	 */
	default String pathVariable(String name) {
		Map<String, String> pathVariables = pathVariables();
		if (pathVariables.containsKey(name)) {
			return pathVariables().get(name);
		}
		else {
			throw new IllegalArgumentException("No path variable with name \"" + name + "\" available");
		}
	}

	/**
	 * Get all path variables for this request.
	 */
	/**
	 * 获取此请求的所有路径变量。 
	 * 
	 */
	Map<String, String> pathVariables();

	/**
	 * Get the web session for this request.
	 * <p>Always guaranteed to return an instance either matching the session id
	 * requested by the client, or with a new session id either because the client
	 * did not specify one or because the underlying session had expired.
	 * <p>Use of this method does not automatically create a session.
	 */
	/**
	 * 获取此请求的网络会话。 
	 *  <p>总是保证返回一个实例，该实例要么与客户端请求的会话ID匹配，要么与新的会话ID匹配，这是因为客户端未指定一个实例，或者由于基础会话已过期。 
	 *  <p>使用此方法不会自动创建会话。 
	 * 
	 */
	Mono<WebSession> session();

	/**
	 * Get the authenticated user for the request, if any.
	 */
	/**
	 * 获取请求的经过身份验证的用户（如果有）。 
	 * 
	 */
	Mono<? extends Principal> principal();

	/**
	 * Get the form data from the body of the request if the Content-Type is
	 * {@code "application/x-www-form-urlencoded"} or an empty map otherwise.
	 * <p><strong>Note:</strong> calling this method causes the request body to
	 * be read and parsed in full, and the resulting {@code MultiValueMap} is
	 * cached so that this method is safe to call more than once.
	 */
	/**
	 * 如果Content-Type为{@code "application / x-www-form-urlencoded"}，则从请求的正文中获取表单数据； 
	 * 否则为空映射。 
	 *  <p> <strong>注意</ strong>：调用此方法将导致读取请求主体并对其进行完全解析，并缓存生成的{@code  MultiValueMap}，以便可以安全地多次调用此方法。 
	 *  。 
	 * 
	 */
	Mono<MultiValueMap<String, String>> formData();

	/**
	 * Get the parts of a multipart request if the Content-Type is
	 * {@code "multipart/form-data"} or an empty map otherwise.
	 * <p><strong>Note:</strong> calling this method causes the request body to
	 * be read and parsed in full, and the resulting {@code MultiValueMap} is
	 * cached so that this method is safe to call more than once.
	 */
	/**
	 * 如果Content-Type为{@code "multipart / form-data"}或为空映射，则获取多部分请求的部分。 
	 *  <p> <strong>注意</ strong>：调用此方法将导致读取请求主体并对其进行完全解析，并缓存生成的{@code  MultiValueMap}，以便可以安全地多次调用此方法。 
	 *  。 
	 * 
	 */
	Mono<MultiValueMap<String, Part>> multipartData();

	/**
	 * Get the web exchange that this request is based on.
	 * <p>Note: Manipulating the exchange directly (instead of using the methods provided on
	 * {@code ServerRequest} and {@code ServerResponse}) can lead to irregular results.
	 * @since 5.1
	 */
	/**
	 * 获取此请求所基于的Web交换。 
	 *  <p>注意：直接操纵交换（而不使用{@code  ServerRequest}和{@code  ServerResponse}上提供的方法）会导致异常结果。 
	 *  @5.1起
	 */
	ServerWebExchange exchange();


	// Static builder methods

	/**
	 * Create a new {@code ServerRequest} based on the given {@code ServerWebExchange} and
	 * message readers.
	 * @param exchange the exchange
	 * @param messageReaders the message readers
	 * @return the created {@code ServerRequest}
	 */
	/**
	 * 根据给定的{@code  ServerWebExchange}和消息阅读器创建一个新的{@code  ServerRequest}。 
	 *  
	 * @param 交换交换
	 * @param  messageReaders消息阅读器
	 * @return 创建的{@code  ServerRequest}
	 */
	static ServerRequest create(ServerWebExchange exchange, List<HttpMessageReader<?>> messageReaders) {
		return new DefaultServerRequest(exchange, messageReaders);
	}

	/**
	 * Create a builder with the status, headers, and cookies of the given request.
	 * @param other the response to copy the status, headers, and cookies from
	 * @return the created builder
	 * @since 5.1
	 */
	/**
	 * 创建具有给定请求的状态，标题和cookie的构建器。 
	 *  
	 * @param 其他响应，以从
	 * @return 创建的生成器@since 5.1复制状态，标题和cookie
	 */
	static Builder from(ServerRequest other) {
		return new DefaultServerRequestBuilder(other);
	}


	/**
	 * Represents the headers of the HTTP request.
	 * @see ServerRequest#headers()
	 */
	/**
	 * 表示HTTP请求的标头。 
	 *  
	 * @see  ServerRequest＃headers（）
	 */
	interface Headers {

		/**
		 * Get the list of acceptable media types, as specified by the {@code Accept}
		 * header.
		 * <p>Returns an empty list if the acceptable media types are unspecified.
		 */
		/**
		 * 获取由{@code  Accept}标头指定的可接受的媒体类型列表。 
		 *  <p>如果未指定可接受的媒体类型，则返回一个空列表。 
		 * 
		 */
		List<MediaType> accept();

		/**
		 * Get the list of acceptable charsets, as specified by the
		 * {@code Accept-Charset} header.
		 */
		/**
		 * 获取{{@@code> Accept-Charset}标头指定的可接受字符集列表。 
		 * 
		 */
		List<Charset> acceptCharset();

		/**
		 * Get the list of acceptable languages, as specified by the
		 * {@code Accept-Language} header.
		 */
		/**
		 * 获取{{@@code> Accept-Language}标头指定的可接受语言的列表。 
		 * 
		 */
		List<Locale.LanguageRange> acceptLanguage();

		/**
		 * Get the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 */
		/**
		 * 获取{{@@code> Content-Length}标头指定的主体长度（以字节为单位）。 
		 * 
		 */
		OptionalLong contentLength();

		/**
		 * Get the media type of the body, as specified by the
		 * {@code Content-Type} header.
		 */
		/**
		 * 获取主体的媒体类型，如{@code  Content-Type}标头所指定。 
		 * 
		 */
		Optional<MediaType> contentType();

		/**
		 * Get the value of the {@code Host} header, if available.
		 * <p>If the header value does not contain a port, the
		 * {@linkplain InetSocketAddress#getPort() port} in the returned address will
		 * be {@code 0}.
		 */
		/**
		 * 获取{@code  Host}标头的值（如果有）。 
		 *  <p>如果标头值不包含端口，则返回地址中的{@link  plain InetSocketAddress＃getPort（）端口}将为{@code  0}。 
		 * 
		 */
		@Nullable
		InetSocketAddress host();

		/**
		 * Get the value of the {@code Range} header.
		 * <p>Returns an empty list when the range is unknown.
		 */
		/**
		 * 获取{@code  Range}标头的值。 
		 *  <p>当范围未知时，返回一个空列表。 
		 * 
		 */
		List<HttpRange> range();

		/**
		 * Get the header value(s), if any, for the header of the given name.
		 * <p>Returns an empty list if no header values are found.
		 * @param headerName the header name
		 */
		/**
		 * 获取给定名称的标头的标头值（如果有）。 
		 *  <p>如果未找到标头值，则返回一个空列表。 
		 *  
		 * @param  headerName标题名称
		 */
		List<String> header(String headerName);

		/**
		 * Get the headers as an instance of {@link HttpHeaders}.
		 */
		/**
		 * 获取标头作为{@link  HttpHeaders}的实例。 
		 * 
		 */
		HttpHeaders asHttpHeaders();
	}


	/**
	 * Defines a builder for a request.
	 * @since 5.1
	 */
	/**
	 * 定义请求的构建器。 
	 *  @5.1起
	 */
	interface Builder {

		/**
		 * Set the method of the request.
		 * @param method the new method
		 * @return this builder
		 */
		/**
		 * 设置请求的方法。 
		 *  
		 * @param 方法新方法
		 * @return 此构建器
		 */
		Builder method(HttpMethod method);

		/**
		 * Set the URI of the request.
		 * @param uri the new URI
		 * @return this builder
		 */
		/**
		 * 设置请求的URI。 
		 *  
		 * @param  uri新的URI 
		 * @return 此构建器
		 */
		Builder uri(URI uri);

		/**
		 * Add the given header value(s) under the given name.
		 * @param headerName the header name
		 * @param headerValues the header value(s)
		 * @return this builder
		 * @see HttpHeaders#add(String, String)
		 */
		/**
		 * 在给定名称下添加给定标头值。 
		 *  
		 * @param  headerName标头名称
		 * @param  headerValues标头值
		 * @return 此构建器
		 * @see  HttpHeaders＃add（String，String）
		 */
		Builder header(String headerName, String... headerValues);

		/**
		 * Manipulate this request's headers with the given consumer.
		 * <p>The headers provided to the consumer are "live", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		/**
		 * 使用给定的使用者处理此请求的标头。 
		 *  <p>提供给使用者的标头是"活动的"，因此使用者可以用来{@link  plain HttpHeaders＃set（String，String）overwrite}现有标头值，{<@link> plain HttpHeaders＃ remove（Object）remove}值，或使用其他任何{@link  HttpHeaders}方法。 
		 *  
		 * @param  headers消费一个使用{@code  HttpHeaders} 
		 * @return 此构建器的函数
		 */
		Builder headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add a cookie with the given name and value(s).
		 * @param name the cookie name
		 * @param values the cookie value(s)
		 * @return this builder
		 */
		/**
		 * 添加具有给定名称和值的Cookie。 
		 *  
		 * @param 命名cookie名称
		 * @param 评估cookie值
		 * @return 此构建器
		 */
		Builder cookie(String name, String... values);

		/**
		 * Manipulate this request's cookies with the given consumer.
		 * <p>The map provided to the consumer is "live", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing cookies,
		 * {@linkplain MultiValueMap#remove(Object) remove} cookies, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		/**
		 * 与给定的使用者操作此请求的cookie。 
		 *  <p>提供给使用者的地图是"实时的"，因此使用者可以用来{@link  plain MultiValueMap＃set（Object，Object）overwrite}现有的cookie，{<@link> plain MultiValueMap＃remove （对象）删除} cookie，或使用任何其他{@link  MultiValueMap}方法。 
		 *  
		 * @param  cookies消费一个使用Cookies映射的函数
		 * @return 此构建器
		 */
		Builder cookies(Consumer<MultiValueMap<String, HttpCookie>> cookiesConsumer);

		/**
		 * Set the body of the request.
		 * <p>Calling this methods will
		 * {@linkplain org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer) release}
		 * the existing body of the builder.
		 * @param body the new body
		 * @return this builder
		 */
		/**
		 * 设置请求的主体。 
		 *  <p>调用此方法将{@link  plain org.springframework.core.io.buffer.DataBufferUtils＃release（DataBuffer）release}生成器的现有主体。 
		 *  
		 * @param 新建主体
		 * @return 此生成器
		 */
		Builder body(Flux<DataBuffer> body);

		/**
		 * Set the body of the request to the UTF-8 encoded bytes of the given string.
		 * <p>Calling this methods will
		 * {@linkplain org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer) release}
		 * the existing body of the builder.
		 * @param body the new body
		 * @return this builder
		 */
		/**
		 * 将请求的主体设置为给定字符串的UTF-8编码字节。 
		 *  <p>调用此方法将{@link  plain org.springframework.core.io.buffer.DataBufferUtils＃release（DataBuffer）release}生成器的现有主体。 
		 *  
		 * @param 新建主体
		 * @return 此生成器
		 */
		Builder body(String body);

		/**
		 * Add an attribute with the given name and value.
		 * @param name the attribute name
		 * @param value the attribute value
		 * @return this builder
		 */
		/**
		 * 添加具有给定名称和值的属性。 
		 *  
		 * @param 命名属性名称
		 * @param 值属性值
		 * @return 此构建器
		 */
		Builder attribute(String name, Object value);

		/**
		 * Manipulate this request's attributes with the given consumer.
		 * <p>The map provided to the consumer is "live", so that the consumer can be used
		 * to {@linkplain Map#put(Object, Object) overwrite} existing attributes,
		 * {@linkplain Map#remove(Object) remove} attributes, or use any of the other
		 * {@link Map} methods.
		 * @param attributesConsumer a function that consumes the attributes map
		 * @return this builder
		 */
		/**
		 * 使用给定的使用者处理此请求的属性。 
		 *  <p>提供给使用者的地图是"实时"的，因此可以使用使用者{@link  plain Map＃put（Object，Object）overwrite}现有属性，{<@link> plain Map＃remove （对象）remove}属性，或使用任何其他{@link  Map}方法。 
		 *  
		 * @param  attributesConsumer消费使用属性映射的函数
		 * @return 此构建器
		 */
		Builder attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Build the request.
		 * @return the built request
		 */
		/**
		 * 建立请求。 
		 *  
		 * @return 构建的请求
		 */
		ServerRequest build();
	}

}
