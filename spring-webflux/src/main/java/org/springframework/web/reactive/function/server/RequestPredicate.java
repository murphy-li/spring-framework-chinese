/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.reactive.function.server;

import java.util.Optional;

/**
 * Represents a function that evaluates on a given {@link ServerRequest}.
 * Instances of this function that evaluate on common request properties
 * can be found in {@link RequestPredicates}.
 *
 * @author Arjen Poutsma
 * @since 5.0
 * @see RequestPredicates
 * @see RouterFunctions#route(RequestPredicate, HandlerFunction)
 * @see RouterFunctions#nest(RequestPredicate, RouterFunction)
 */
/**
 * 表示在给定的{@link  ServerRequest}上求值的函数。 
 * 可以在{@link  RequestPredicates}中找到此函数的实例，这些实例可以评估常见的请求属性。 
 *  @author  Arjen Poutsma @从5.0开始
 * @see  RequestPredicates 
 * @see  RouterFunctions＃route（RequestPredicate，HandlerFunction）
 * @see  RouterFunctions＃nest（RequestPredicate，RouterFunction）
 */
@FunctionalInterface
public interface RequestPredicate {

	/**
	 * Evaluate this predicate on the given request.
	 * @param request the request to match against
	 * @return {@code true} if the request matches the predicate; {@code false} otherwise
	 */
	/**
	 * 根据给定的请求评估该谓词。 
	 *  
	 * @param 如果请求与谓词匹配，则请求将请求与
	 * @return  {@code  true}进行匹配； 
	 *  {@code  false}否则
	 */
	boolean test(ServerRequest request);

	/**
	 * Return a composed request predicate that tests against both this predicate AND
	 * the {@code other} predicate. When evaluating the composed predicate, if this
	 * predicate is {@code false}, then the {@code other} predicate is not evaluated.
	 * @param other a predicate that will be logically-ANDed with this predicate
	 * @return a predicate composed of this predicate AND the {@code other} predicate
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词同时针对此谓词和{@code  other}谓词进行测试。 
	 * 在评估组合谓词时，如果该谓词为{@code  false}，则不会评估{@code  other}谓词。 
	 *  
	 * @param 其他将与该谓词进行逻辑与的谓词
	 * @return 由该谓词和{@code  other}谓词组成的谓词
	 */
	default RequestPredicate and(RequestPredicate other) {
		return new RequestPredicates.AndRequestPredicate(this, other);
	}

	/**
	 * Return a predicate that represents the logical negation of this predicate.
	 * @return a predicate that represents the logical negation of this predicate
	 */
	/**
	 * 返回表示该谓词逻辑否定的谓词。 
	 *  
	 * @return 表示此谓词逻辑否定的谓词
	 */
	default RequestPredicate negate() {
		return new RequestPredicates.NegateRequestPredicate(this);
	}

	/**
	 * Return a composed request predicate that tests against both this predicate OR
	 * the {@code other} predicate. When evaluating the composed predicate, if this
	 * predicate is {@code true}, then the {@code other} predicate is not evaluated.
	 * @param other a predicate that will be logically-ORed with this predicate
	 * @return a predicate composed of this predicate OR the {@code other} predicate
	 */
	/**
	 * 返回一个组合的请求谓词，该谓词可同时针对此谓词或{@code  other}谓词进行测试。 
	 * 在评估组合谓词时，如果此谓词为{@code  true}，则不会评估{@code  other}谓词。 
	 *  
	 * @param 另一个与该谓词进行逻辑或运算的谓词
	 * @return 由该谓词或{@code  other}谓词组成的谓词
	 */
	default RequestPredicate or(RequestPredicate other) {
		return new RequestPredicates.OrRequestPredicate(this, other);
	}

	/**
	 * Transform the given request into a request used for a nested route. For instance,
	 * a path-based predicate can return a {@code ServerRequest} with a the path remaining
	 * after a match.
	 * <p>The default implementation returns an {@code Optional} wrapping the given request if
	 * {@link #test(ServerRequest)} evaluates to {@code true}; or {@link Optional#empty()}
	 * if it evaluates to {@code false}.
	 * @param request the request to be nested
	 * @return the nested request
	 * @see RouterFunctions#nest(RequestPredicate, RouterFunction)
	 */
	/**
	 * 将给定的请求转换为用于嵌套路由的请求。 
	 * 例如，基于路径的谓词可以返回{@code  ServerRequest}，其路径在匹配后仍保留。 
	 *  <p>如果{@link  #test（ServerRequest）}评估为{@code  true}，则默认实现返回一个包装给定请求的{@code 可选}； 
	 * 或{@link 可选#empty（）}（如果评估为{@code  false}）。 
	 *  
	 * @param 请求嵌套请求
	 * @return 嵌套请求
	 * @see  RouterFunctions＃nest（RequestPredicate，RouterFunction）
	 */
	default Optional<ServerRequest> nest(ServerRequest request) {
		return (test(request) ? Optional.of(request) : Optional.empty());
	}

	/**
	 * Accept the given visitor. Default implementation calls
	 * {@link RequestPredicates.Visitor#unknown(RequestPredicate)}; composed {@code RequestPredicate}
	 * implementations are expected to call {@code accept} for all components that make up this
	 * request predicate.
	 * @param visitor the visitor to accept
	 */
	/**
	 * 接受给定的访客。 
	 * 默认实现调用{@link  RequestPredicates.Visitor＃unknown（RequestPredicate）}； 
	 * 组成{@code  RequestPredicate}的实现，应该对组成该请求谓词的所有组件调用{@code  accept}。 
	 *  
	 * @param 访客访客接受
	 */
	default void accept(RequestPredicates.Visitor visitor) {
		visitor.unknown(this);
	}

}
