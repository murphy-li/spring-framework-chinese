/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.simp.config;

import java.util.Arrays;
import java.util.Collection;

import org.springframework.context.event.SmartApplicationListener;
import org.springframework.lang.Nullable;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler;
import org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler;
import org.springframework.util.Assert;
import org.springframework.util.PathMatcher;

/**
 * A registry for configuring message broker options.
 *
 * @author Rossen Stoyanchev
 * @author Sebastien Deleuze
 * @since 4.0
 */
/**
 * 用于配置消息代理选项的注册表。 
 *  @author  Rossen Stoyanchev @author 塞巴斯蒂安·德勒兹@始于4.0
 */
public class MessageBrokerRegistry {

	private final SubscribableChannel clientInboundChannel;

	private final MessageChannel clientOutboundChannel;

	@Nullable
	private SimpleBrokerRegistration simpleBrokerRegistration;

	@Nullable
	private StompBrokerRelayRegistration brokerRelayRegistration;

	private final ChannelRegistration brokerChannelRegistration = new ChannelRegistration();

	@Nullable
	private String[] applicationDestinationPrefixes;

	@Nullable
	private String userDestinationPrefix;

	@Nullable
	private Integer userRegistryOrder;

	@Nullable
	private PathMatcher pathMatcher;

	@Nullable
	private Integer cacheLimit;

	private boolean preservePublishOrder;


	public MessageBrokerRegistry(SubscribableChannel clientInboundChannel, MessageChannel clientOutboundChannel) {
		Assert.notNull(clientInboundChannel, "Inbound channel must not be null");
		Assert.notNull(clientOutboundChannel, "Outbound channel must not be null");
		this.clientInboundChannel = clientInboundChannel;
		this.clientOutboundChannel = clientOutboundChannel;
	}


	/**
	 * Enable a simple message broker and configure one or more prefixes to filter
	 * destinations targeting the broker (e.g. destinations prefixed with "/topic").
	 */
	/**
	 * 启用一个简单的消息代理，并配置一个或多个前缀以过滤以代理为目标的目标（例如，以"/ topic"为前缀的目标）。 
	 * 
	 */
	public SimpleBrokerRegistration enableSimpleBroker(String... destinationPrefixes) {
		this.simpleBrokerRegistration = new SimpleBrokerRegistration(
				this.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);
		return this.simpleBrokerRegistration;
	}

	/**
	 * Enable a STOMP broker relay and configure the destination prefixes supported by the
	 * message broker. Check the STOMP documentation of the message broker for supported
	 * destinations.
	 */
	/**
	 * 启用S​​TOMP代理中继，并配置消息代理支持的目标前缀。 
	 * 检查消息代理的STOMP文档以获取受支持的目标。 
	 * 
	 */
	public StompBrokerRelayRegistration enableStompBrokerRelay(String... destinationPrefixes) {
		this.brokerRelayRegistration = new StompBrokerRelayRegistration(
				this.clientInboundChannel, this.clientOutboundChannel, destinationPrefixes);
		return this.brokerRelayRegistration;
	}

	/**
	 * Customize the channel used to send messages from the application to the message
	 * broker. By default, messages from the application to the message broker are sent
	 * synchronously, which means application code sending a message will find out
	 * if the message cannot be sent through an exception. However, this can be changed
	 * if the broker channel is configured here with task executor properties.
	 */
	/**
	 * 自定义用于将消息从应用程序发送到消息代理的通道。 
	 * 默认情况下，从应用程序到消息代理的消息是同步发送的，这意味着发送消息的应用程序代码将确定是否无法通过异常发送消息。 
	 * 但是，如果在此处使用任务执行程序属性配置了代理通道，则可以更改此设置。 
	 * 
	 */
	public ChannelRegistration configureBrokerChannel() {
		return this.brokerChannelRegistration;
	}

	protected ChannelRegistration getBrokerChannelRegistration() {
		return this.brokerChannelRegistration;
	}

	@Nullable
	protected String getUserDestinationBroadcast() {
		return (this.brokerRelayRegistration != null ?
				this.brokerRelayRegistration.getUserDestinationBroadcast() : null);
	}

	@Nullable
	protected String getUserRegistryBroadcast() {
		return (this.brokerRelayRegistration != null ?
				this.brokerRelayRegistration.getUserRegistryBroadcast() : null);
	}

	/**
	 * Configure one or more prefixes to filter destinations targeting application
	 * annotated methods. For example destinations prefixed with "/app" may be
	 * processed by annotated methods while other destinations may target the
	 * message broker (e.g. "/topic", "/queue").
	 * <p>When messages are processed, the matching prefix is removed from the destination
	 * in order to form the lookup path. This means annotations should not contain the
	 * destination prefix.
	 * <p>Prefixes that do not have a trailing slash will have one automatically appended.
	 */
	/**
	 * 配置一个或多个前缀以筛选针对应用程序注释方法的目标。 
	 * 例如，以"/ app"为前缀的目的地可以通过注释方法处理，而其他目的地可以以消息代理为目标（例如"/ topic"，"/ queue"）。 
	 *  <p>处理消息时，将从目标中删除匹配的前缀，以形成查找路径。 
	 * 这意味着注释不应包含目标前缀。 
	 *  <p>不带斜杠的前缀将自动附加一个。 
	 * 
	 */
	public MessageBrokerRegistry setApplicationDestinationPrefixes(String... prefixes) {
		this.applicationDestinationPrefixes = prefixes;
		return this;
	}

	@Nullable
	protected Collection<String> getApplicationDestinationPrefixes() {
		return (this.applicationDestinationPrefixes != null ?
				Arrays.asList(this.applicationDestinationPrefixes) : null);
	}

	/**
	 * Configure the prefix used to identify user destinations. User destinations
	 * provide the ability for a user to subscribe to queue names unique to their
	 * session as well as for others to send messages to those unique,
	 * user-specific queues.
	 * <p>For example when a user attempts to subscribe to "/user/queue/position-updates",
	 * the destination may be translated to "/queue/position-updatesi9oqdfzo" yielding a
	 * unique queue name that does not collide with any other user attempting to do the same.
	 * Subsequently when messages are sent to "/user/{username}/queue/position-updates",
	 * the destination is translated to "/queue/position-updatesi9oqdfzo".
	 * <p>The default prefix used to identify such destinations is "/user/".
	 */
	/**
	 * 配置用于标识用户目的地的前缀。 
	 * 用户目的地为用户提供了为其会话预订唯一的队列名称的功能，并为其他用户提供了向这些唯一的，特定于用户的队列发送消息的功能。 
	 *  <p>例如，当用户尝试订阅"/ user / queue / position-updates"时，目标可以转换为"/ queue / position-updatesi9oqdfzo"，从而产生一个唯一的队列名称，该名称不会与任何其他用户冲突试图做同样的事情。 
	 * 随后，当消息发送到"/ user / {用户名} / queue / position-updates"时，目的地将转换为"/ queue / position-updatesi9oqdfzo"。 
	 *  <p>用于标识此类目的地的默认前缀为"/ user /"。 
	 * 
	 */
	public MessageBrokerRegistry setUserDestinationPrefix(String destinationPrefix) {
		this.userDestinationPrefix = destinationPrefix;
		return this;
	}

	@Nullable
	protected String getUserDestinationPrefix() {
		return this.userDestinationPrefix;
	}

	/**
	 * Set the order for the
	 * {@link org.springframework.messaging.simp.user.SimpUserRegistry
	 * SimpUserRegistry} to use as a {@link SmartApplicationListener}.
	 * @param order the order value
	 * @since 5.0.8
	 */
	/**
	 * 设置{@link  org.springframework.messaging.simp.user.SimpUserRegistry SimpUserRegistry}用作{@link  SmartApplicationListener}的顺序。 
	 *  
	 * @param 从5.0.8开始订购订单值
	 */
	public void setUserRegistryOrder(int order) {
		this.userRegistryOrder = order;
	}

	@Nullable
	protected Integer getUserRegistryOrder() {
		return this.userRegistryOrder;
	}

	/**
	 * Configure the PathMatcher to use to match the destinations of incoming
	 * messages to {@code @MessageMapping} and {@code @SubscribeMapping} methods.
	 * <p>By default {@link org.springframework.util.AntPathMatcher} is configured.
	 * However applications may provide an {@code AntPathMatcher} instance
	 * customized to use "." (commonly used in messaging) instead of "/" as path
	 * separator or provide a completely different PathMatcher implementation.
	 * <p>Note that the configured PathMatcher is only used for matching the
	 * portion of the destination after the configured prefix. For example given
	 * application destination prefix "/app" and destination "/app/price.stock.**",
	 * the message might be mapped to a controller with "price" and "stock.**"
	 * as its type and method-level mappings respectively.
	 * <p>When the simple broker is enabled, the PathMatcher configured here is
	 * also used to match message destinations when brokering messages.
	 * @since 4.1
	 * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setPathMatcher
	 */
	/**
	 * 配置PathMatcher以将传入消息的目的地与{@code  @MessageMapping}和{@code  @SubscribeMapping}方法进行匹配。 
	 *  <p>默认情况下，已配置{@link  org.springframework.util.AntPathMatcher}。 
	 * 但是，应用程序可以提供一个自定义为使用"{"的{@code  AntPathMatcher}实例。 
	 *  （通常在消息传递中使用）代替"/"作为路径分隔符，或提供完全不同的PathMatcher实现。 
	 *  <p>请注意，配置的PathMatcher仅用于匹配配置的前缀之后的目标部分。 
	 * 例如，在给定应用程序目标前缀"/ app"和目标"/app/price.stock。 
	 * "的情况下，该消息可能分别使用"price"和"stock。 
	 * "作为其类型和方法级别的映射映射到控制器。 
	 *  <p>启用简单代理后，在代理消息时，此处配置的PathMatcher也用于匹配消息目标。 
	 *  @since 4.1 
	 * @see  org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry＃setPathMatcher
	 */
	public MessageBrokerRegistry setPathMatcher(PathMatcher pathMatcher) {
		this.pathMatcher = pathMatcher;
		return this;
	}

	@Nullable
	protected PathMatcher getPathMatcher() {
		return this.pathMatcher;
	}

	/**
	 * Configure the cache limit to apply for registrations with the broker.
	 * <p>This is currently only applied for the destination cache in the
	 * subscription registry. The default cache limit there is 1024.
	 * @since 4.3.2
	 * @see org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#setCacheLimit
	 */
	/**
	 * 配置缓存限制以申请向代理注册。 
	 *  <p>这当前仅适用于订阅注册表中的目标缓存。 
	 * 默认的缓存限制为1024。 
	 * @since 4.3.2 
	 * @see  org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry＃setCacheLimit
	 */
	public MessageBrokerRegistry setCacheLimit(int cacheLimit) {
		this.cacheLimit = cacheLimit;
		return this;
	}

	/**
	 * Whether the client must receive messages in the order of publication.
	 * <p>By default messages sent to the {@code "clientOutboundChannel"} may
	 * not be processed in the same order because the channel is backed by a
	 * ThreadPoolExecutor that in turn does not guarantee processing in order.
	 * <p>When this flag is set to {@code true} messages within the same session
	 * will be sent to the {@code "clientOutboundChannel"} one at a time in
	 * order to preserve the order of publication. Enable this only if needed
	 * since there is some performance overhead to keep messages in order.
	 * @since 5.1
	 */
	/**
	 * 客户端是否必须按照发布顺序接收消息。 
	 *  <p>默认情况下，发送到{@code "clientOutboundChannel"}的默认消息可能无法按相同的顺序处理，因为该通道由ThreadPoolExecutor支持，而ThreadPoolExecutor不能保证按顺序进行处理。 
	 *  <p>当此标志设置为{@code  true}时，同一会话中的消息将一次发送到{@code "clientOutboundChannel"}，以保留发布顺序。 
	 * 仅在需要时才启用此选项，因为要保持消息顺序有一些性能开销。 
	 *  @5.1起
	 */
	public MessageBrokerRegistry setPreservePublishOrder(boolean preservePublishOrder) {
		this.preservePublishOrder = preservePublishOrder;
		return this;
	}

	@Nullable
	protected SimpleBrokerMessageHandler getSimpleBroker(SubscribableChannel brokerChannel) {
		if (this.simpleBrokerRegistration == null && this.brokerRelayRegistration == null) {
			enableSimpleBroker();
		}
		if (this.simpleBrokerRegistration != null) {
			SimpleBrokerMessageHandler handler = this.simpleBrokerRegistration.getMessageHandler(brokerChannel);
			handler.setPathMatcher(this.pathMatcher);
			handler.setCacheLimit(this.cacheLimit);
			handler.setPreservePublishOrder(this.preservePublishOrder);
			return handler;
		}
		return null;
	}

	@Nullable
	protected StompBrokerRelayMessageHandler getStompBrokerRelay(SubscribableChannel brokerChannel) {
		if (this.brokerRelayRegistration != null) {
			StompBrokerRelayMessageHandler relay = this.brokerRelayRegistration.getMessageHandler(brokerChannel);
			relay.setPreservePublishOrder(this.preservePublishOrder);
			return relay;
		}
		return null;
	}

}
