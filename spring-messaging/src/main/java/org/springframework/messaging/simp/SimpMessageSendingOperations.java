/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.simp;

import java.util.Map;

import org.springframework.lang.Nullable;
import org.springframework.messaging.MessagingException;
import org.springframework.messaging.core.MessagePostProcessor;
import org.springframework.messaging.core.MessageSendingOperations;

/**
 * A specialization of {@link MessageSendingOperations} with methods for use with
 * the Spring Framework support for Simple Messaging Protocols (like STOMP).
 *
 * <p>For more on user destinations see
 * {@link org.springframework.messaging.simp.user.UserDestinationResolver
 * UserDestinationResolver}.
 *
 * <p>Generally it is expected the user is the one authenticated with the
 * WebSocket session (or by extension the user authenticated with the
 * handshake request that started the session). However if the session is
 * not authenticated, it is also possible to pass the session id (if known)
 * in place of the user name. Keep in mind though that in that scenario,
 * you must use one of the overloaded methods that accept headers making sure the
 * {@link org.springframework.messaging.simp.SimpMessageHeaderAccessor#setSessionId
 * sessionId} header has been set accordingly.
 *
 * @author Rossen Stoyanchev
 * @since 4.0
 */
/**
 * {@link  MessageSendingOperations}的一种特殊化，其方法与Spring Framework支持的简单消息协议（如STOMP）一起使用。 
 *  <p>有关用户目标的更多信息，请参见{@link  org.springframework.messaging.simp.user.UserDestinationResolver UserDestinationResolver}。 
 *  <p>通常，期望用户是通过WebSocket会话进行身份验证的用户（或者扩展为使用已启动会话的握手请求进行身份验证的用户）。 
 * 但是，如果会话未通过身份验证，也可以传递会话ID（如果知道）代替用户名。 
 * 请记住，尽管在这种情况下，您必须使用接受标头的重载方法之一，以确保已相应设置{@link  org.springframework.messaging.simp.SimpMessageHeaderAccessor＃setSessionId sessionId}标头。 
 *  @author  Rossen Stoyanchev @从4.0开始
 */
public interface SimpMessageSendingOperations extends MessageSendingOperations<String> {

	/**
	 * Send a message to the given user.
	 * @param user the user that should receive the message.
	 * @param destination the destination to send the message to.
	 * @param payload the payload to send
	 */
	/**
	 * 向给定的用户发送消息。 
	 *  
	 * @param  user应该接收消息的用户。 
	 *  
	 * @param 目的地将消息发送到的目的地。 
	 *  
	 * @param 有效负载要发送的有效负载
	 */
	void convertAndSendToUser(String user, String destination, Object payload) throws MessagingException;

	/**
	 * Send a message to the given user.
	 * <p>By default headers are interpreted as native headers (e.g. STOMP) and
	 * are saved under a special key in the resulting Spring
	 * {@link org.springframework.messaging.Message Message}. In effect when the
	 * message leaves the application, the provided headers are included with it
	 * and delivered to the destination (e.g. the STOMP client or broker).
	 * <p>If the map already contains the key
	 * {@link org.springframework.messaging.support.NativeMessageHeaderAccessor#NATIVE_HEADERS "nativeHeaders"}
	 * or was prepared with
	 * {@link org.springframework.messaging.simp.SimpMessageHeaderAccessor SimpMessageHeaderAccessor}
	 * then the headers are used directly. A common expected case is providing a
	 * content type (to influence the message conversion) and native headers.
	 * This may be done as follows:
	 * <pre class="code">
	 * SimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create();
	 * accessor.setContentType(MimeTypeUtils.TEXT_PLAIN);
	 * accessor.setNativeHeader("foo", "bar");
	 * accessor.setLeaveMutable(true);
	 * MessageHeaders headers = accessor.getMessageHeaders();
	 * messagingTemplate.convertAndSendToUser(user, destination, payload, headers);
	 * </pre>
	 * <p><strong>Note:</strong> if the {@code MessageHeaders} are mutable as in
	 * the above example, implementations of this interface should take notice and
	 * update the headers in the same instance (rather than copy or re-create it)
	 * and then set it immutable before sending the final message.
	 * @param user the user that should receive the message (must not be {@code null})
	 * @param destination the destination to send the message to (must not be {@code null})
	 * @param payload the payload to send (may be {@code null})
	 * @param headers the message headers (may be {@code null})
	 */
	/**
	 * 向给定的用户发送消息。 
	 *  <p>默认情况下，标头被解释为本地标头（例如STOMP），并保存在生成​​的Spring {@link  org.springframework.messaging.Message Message}中的特殊键下。 
	 * 实际上，当消息离开应用程序时，提供的标头将包含在消息中并传递到目的地（例如STOMP客户端或代理）。 
	 *  <p>如果地图已经包含键{@link  org.springframework.messaging.support.NativeMessageHeaderAccessor＃NATIVE_HEADERS"nativeHeaders"}或已使用{@link  org.springframework.messaging.simp.SimpMessageHeaderAccessor SimpMessageHeaderAccessor}进行了准备然后直接使用标头。 
	 * 常见的预期情况是提供内容类型（以影响消息转换）和本机头。 
	 * 这可以如下进行：<pre class ="code"> SimpMessageHeaderAccessor accessor = SimpMessageHeaderAccessor.create（）; accessor.setContentType（MimeTypeUtils.TEXT_PLAIN）; accessor.setNativeHeader（"foo"，"bar"）; accessor.setLeaveMutable（true）; MessageHeaders标头= accessor.getMessageHeaders（）; messagesTemplate.convertAndSendToUser（用户，目的地，有效载荷，标题）; </ pre> <p> <strong>注意：</ strong>：如果{@code  MessageHeaders}像上面的示例一样是可变的，则此接口的实现应引起注意并在同一实例中更新标头（而是然后复制或重新创建它），然后在发送最终消息之前将其设置为不可变。 
	 *  
	 * @param 用户应该接收消息的用户（不得为{@code  null}）
	 * @param 目的地将消息发送至的目的地（不得为{@code  null}）<
	 * @param>有效负载要发送的有效负载（可能为{@code  null}）
	 * @param 标头消息头（可能为{@code  null}）
	 */
	void convertAndSendToUser(String user, String destination, Object payload, Map<String, Object> headers)
			throws MessagingException;

	/**
	 * Send a message to the given user.
	 * @param user the user that should receive the message (must not be {@code null})
	 * @param destination the destination to send the message to (must not be {@code null})
	 * @param payload the payload to send (may be {@code null})
	 * @param postProcessor a postProcessor to post-process or modify the created message
	 */
	/**
	 * 向给定的用户发送消息。 
	 *  
	 * @param 用户应该接收消息的用户（不得为{@code  null}）
	 * @param 目的地将消息发送至的目的地（不得为{@code  null}）<
	 * @param>有效负载要发送的有效负载（可能为{@code  null}）
	 * @param  postProcessor一个postProcessor以对后处理或修改创建的消息进行后处理
	 */
	void convertAndSendToUser(String user, String destination, Object payload, MessagePostProcessor postProcessor)
			throws MessagingException;

	/**
	 * Send a message to the given user.
	 * <p>See {@link #convertAndSend(Object, Object, java.util.Map)} for important
	 * notes regarding the input headers.
	 * @param user the user that should receive the message
	 * @param destination the destination to send the message to
	 * @param payload the payload to send
	 * @param headers the message headers
	 * @param postProcessor a postProcessor to post-process or modify the created message
	 */
	/**
	 * 向给定的用户发送消息。 
	 *  <p>有关输入标头的重要说明，请参见{@link  #convertAndSend（Object，Object，java.util.Map）}。 
	 *  
	 * @param 用户应该接收消息的用户
	 * @param 目标将消息发送到
	 * @param 的目标有效负载有效载荷以将
	 * @param 标头发送给消息标头
	 * @param  postProcessor后发布的postProcessor -处理或修改创建的消息
	 */
	void convertAndSendToUser(String user, String destination, Object payload, @Nullable Map<String, Object> headers,
			@Nullable MessagePostProcessor postProcessor) throws MessagingException;

}
