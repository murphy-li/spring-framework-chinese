/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.simp.config;

import org.springframework.lang.Nullable;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.util.Assert;

/**
 * A registration class for customizing the properties of {@link ThreadPoolTaskExecutor}.
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @since 4.0
 */
/**
 * 用于自定义{@link  ThreadPoolTask​​Executor}的属性的注册类。 
 *  @author  Rossen Stoyanchev @author  Juergen Hoeller @始于4.0
 */
public class TaskExecutorRegistration {

	private final ThreadPoolTaskExecutor taskExecutor;

	@Nullable
	private Integer corePoolSize;

	@Nullable
	private Integer maxPoolSize;

	@Nullable
	private Integer keepAliveSeconds;

	@Nullable
	private Integer queueCapacity;


	/**
	 * Create a new {@code TaskExecutorRegistration} for a default
	 * {@link ThreadPoolTaskExecutor}.
	 */
	/**
	 * 为默认的{@link  ThreadPoolTask​​Executor}创建一个新的{@code  TaskExecutorRegistration}。 
	 * 
	 */
	public TaskExecutorRegistration() {
		this.taskExecutor = new ThreadPoolTaskExecutor();
		this.taskExecutor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 2);
		this.taskExecutor.setAllowCoreThreadTimeOut(true);
	}

	/**
	 * Create a new {@code TaskExecutorRegistration} for a given
	 * {@link ThreadPoolTaskExecutor}.
	 * @param taskExecutor the executor to use
	 */
	/**
	 * 为给定的{@link  ThreadPoolTask​​Executor}创建一个新的{@code  TaskExecutorRegistration}。 
	 *  
	 * @param  taskExecutor执行者使用
	 */
	public TaskExecutorRegistration(ThreadPoolTaskExecutor taskExecutor) {
		Assert.notNull(taskExecutor, "ThreadPoolTaskExecutor must not be null");
		this.taskExecutor = taskExecutor;
	}


	/**
	 * Set the core pool size of the ThreadPoolExecutor.
	 * <p><strong>NOTE:</strong> The core pool size is effectively the max pool size
	 * when an unbounded {@link #queueCapacity(int) queueCapacity} is configured
	 * (the default). This is essentially the "Unbounded queues" strategy as explained
	 * in {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}. When
	 * this strategy is used, the {@link #maxPoolSize(int) maxPoolSize} is ignored.
	 * <p>By default this is set to twice the value of
	 * {@link Runtime#availableProcessors()}. In an application where tasks do not
	 * block frequently, the number should be closer to or equal to the number of
	 * available CPUs/cores.
	 */
	/**
	 * 设置ThreadPoolExecutor的核心池大小。 
	 *  <p> <strong>注意：</ strong>：配置了无限制的{@link  #queueCapacity（int）queueCapacity}（默认值）时，核心池大小实际上是最大池大小。 
	 * 本质上，这是{{@link> java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}中解释的"无界队列"策略。 
	 * 使用此策略时，将忽略{@link  #maxPoolSize（int）maxPoolSize}。 
	 *  <p>默认情况下，此值设置为{@link  Runtime＃availableProcessors（）}的两倍。 
	 * 在任务不经常阻塞的应用程序中，该数量应接近或等于可用CPU /内核的数量。 
	 * 
	 */
	public TaskExecutorRegistration corePoolSize(int corePoolSize) {
		this.corePoolSize = corePoolSize;
		return this;
	}

	/**
	 * Set the max pool size of the ThreadPoolExecutor.
	 * <p><strong>NOTE:</strong> When an unbounded
	 * {@link #queueCapacity(int) queueCapacity} is configured (the default), the
	 * max pool size is effectively ignored. See the "Unbounded queues" strategy
	 * in {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor} for
	 * more details.
	 * <p>By default this is set to {@code Integer.MAX_VALUE}.
	 */
	/**
	 * 设置ThreadPoolExecutor的最大池大小。 
	 *  <p> <strong>注意：</ strong>：配置了无限制的{@link  #queueCapacity（int）queueCapacity}（默认值）时，最大池大小实际上将被忽略。 
	 * 有关更多详细信息，请参见{@link  java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}中的"无限制队列"策略。 
	 *  <p>默认情况下，它设置为{@code  Integer.MAX_VALUE}。 
	 * 
	 */
	public TaskExecutorRegistration maxPoolSize(int maxPoolSize) {
		this.maxPoolSize = maxPoolSize;
		return this;
	}

	/**
	 * Set the time limit for which threads may remain idle before being terminated.
	 * If there are more than the core number of threads currently in the pool,
	 * after waiting this amount of time without processing a task, excess threads
	 * will be terminated. This overrides any value set in the constructor.
	 * <p>By default this is set to 60.
	 */
	/**
	 * 设置线程在终止之前可能保持空闲的时间限制。 
	 * 如果当前池中的线程数超过核心数，则在等待此时间而不处理任务之后，多余的线程将被终止。 
	 * 这将覆盖构造函数中设置的任何值。 
	 *  <p>默认情况下设置为60。 
	 * 
	 */
	public TaskExecutorRegistration keepAliveSeconds(int keepAliveSeconds) {
		this.keepAliveSeconds = keepAliveSeconds;
		return this;
	}

	/**
	 * Set the queue capacity for the ThreadPoolExecutor.
	 * <p><strong>NOTE:</strong> when an unbounded {@code queueCapacity} is configured
	 * (the default), the core pool size is effectively the max pool size. This is
	 * essentially the "Unbounded queues" strategy as explained in
	 * {@link java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}. When
	 * this strategy is used, the {@link #maxPoolSize(int) maxPoolSize} is ignored.
	 * <p>By default this is set to {@code Integer.MAX_VALUE}.
	 */
	/**
	 * 设置ThreadPoolExecutor的队列容量。 
	 *  <p> <strong>注意：</ strong>：配置无限制的{@code  queueCapacity}（默认值）时，核心池大小实际上是最大池大小。 
	 * 本质上，这是{{@link> java.util.concurrent.ThreadPoolExecutor ThreadPoolExecutor}中解释的"无界队列"策略。 
	 * 使用此策略时，将忽略{@link  #maxPoolSize（int）maxPoolSize}。 
	 *  <p>默认情况下，它设置为{@code  Integer.MAX_VALUE}。 
	 * 
	 */
	public TaskExecutorRegistration queueCapacity(int queueCapacity) {
		this.queueCapacity = queueCapacity;
		return this;
	}


	protected ThreadPoolTaskExecutor getTaskExecutor() {
		if (this.corePoolSize != null) {
			this.taskExecutor.setCorePoolSize(this.corePoolSize);
		}
		if (this.maxPoolSize != null) {
			this.taskExecutor.setMaxPoolSize(this.maxPoolSize);
		}
		if (this.keepAliveSeconds != null) {
			this.taskExecutor.setKeepAliveSeconds(this.keepAliveSeconds);
		}
		if (this.queueCapacity != null) {
			this.taskExecutor.setQueueCapacity(this.queueCapacity);
		}
		return this.taskExecutor;
	}

}
