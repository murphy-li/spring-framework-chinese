/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.simp.user;

import java.security.Principal;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.logging.Log;

import org.springframework.lang.Nullable;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.simp.SimpLogging;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.util.Assert;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;

/**
 * A default implementation of {@code UserDestinationResolver} that relies
 * on a {@link SimpUserRegistry} to find active sessions for a user.
 *
 * <p>When a user attempts to subscribe, e.g. to "/user/queue/position-updates",
 * the "/user" prefix is removed and a unique suffix added based on the session
 * id, e.g. "/queue/position-updates-useri9oqdfzo" to ensure different users can
 * subscribe to the same logical destination without colliding.
 *
 * <p>When sending to a user, e.g. "/user/{username}/queue/position-updates", the
 * "/user/{username}" prefix is removed and a suffix based on active session id's
 * is added, e.g. "/queue/position-updates-useri9oqdfzo".
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @since 4.0
 */
/**
 * {@code  UserDestinationResolver}的默认实现依赖于{@link  SimpUserRegistry}来查找用户的活动会话。 
 *  <p>当用户尝试订阅时，例如到"/ user / queue / position-updates"，则删除"/ user"前缀，并根据会话ID添加唯一后缀，例如"/ queue / position-updates-useri9oqdfzo"以确保不同的用户可以订阅相同的逻辑目的地而不会发生冲突。 
 *  <p>发送给用户时，例如"/ user / {用户名} / queue / position-updates"，删除"/ user / {用户名}"前缀，并添加基于活动会话ID的后缀，例如"/ queue / position-updates-useri9oqdfzo"。 
 *  @author 罗森·斯托扬切夫（Rossen Stoyanchev）@author 布莱恩·克洛泽（Brian Clozel）@从4.0开始
 */
public class DefaultUserDestinationResolver implements UserDestinationResolver {

	private static final Log logger = SimpLogging.forLogName(DefaultUserDestinationResolver.class);


	private final SimpUserRegistry userRegistry;

	private String prefix = "/user/";

	private boolean removeLeadingSlash = false;


	/**
	 * Create an instance that will access user session id information through
	 * the provided registry.
	 * @param userRegistry the registry, never {@code null}
	 */
	/**
	 * 创建一个实例，该实例将通过提供的注册表访问用户会话ID信息。 
	 *  
	 * @param  userRegistry注册表，永不{@code  null}
	 */
	public DefaultUserDestinationResolver(SimpUserRegistry userRegistry) {
		Assert.notNull(userRegistry, "SimpUserRegistry must not be null");
		this.userRegistry = userRegistry;
	}


	/**
	 * Return the configured {@link SimpUserRegistry}.
	 */
	/**
	 * 返回配置的{@link  SimpUserRegistry}。 
	 * 
	 */
	public SimpUserRegistry getSimpUserRegistry() {
		return this.userRegistry;
	}

	/**
	 * The prefix used to identify user destinations. Any destinations that do not
	 * start with the given prefix are not be resolved.
	 * <p>The default prefix is "/user/".
	 * @param prefix the prefix to use
	 */
	/**
	 * 用于标识用户目的地的前缀。 
	 * 不以给定前缀开头的所有目标均无法解析。 
	 *  <p>默认前缀为"/ user /"。 
	 *  
	 * @param 前缀要使用的前缀
	 */
	public void setUserDestinationPrefix(String prefix) {
		Assert.hasText(prefix, "Prefix must not be empty");
		this.prefix = (prefix.endsWith("/") ? prefix : prefix + "/");
	}

	/**
	 * Return the configured prefix for user destinations.
	 */
	/**
	 * 返回用户目标的已配置前缀。 
	 * 
	 */
	public String getDestinationPrefix() {
		return this.prefix;
	}

	/**
	 * Use this property to indicate whether the leading slash from translated
	 * user destinations should be removed or not. This depends on the
	 * destination prefixes the message broker is configured with.
	 * <p>By default this is set to {@code false}, i.e.
	 * "do not change the target destination", although
	 * {@link org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration
	 * AbstractMessageBrokerConfiguration} may change that to {@code true}
	 * if the configured destinations do not have a leading slash.
	 * @param remove whether to remove the leading slash
	 * @since 4.3.14
	 */
	/**
	 * 使用此属性指示是否应删除翻译后的用户目标中的前导斜线。 
	 * 这取决于配置消息代理的目标前缀。 
	 *  <p>默认情况下，它设置为{@code  false}，即"不更改目标目的地"，尽管{@link  org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration AbstractMessageBrokerConfiguration}可能会将其更改为{@code  true}，如果配置的目标没有斜杠。 
	 *  
	 * @param 删除是否删除前导斜线@自4.3.14起
	 */
	public void setRemoveLeadingSlash(boolean remove) {
		this.removeLeadingSlash = remove;
	}

	/**
	 * Whether to remove the leading slash from target destinations.
	 * @since 4.3.14
	 */
	/**
	 * 是否从目标位置删除前导斜线。 
	 *  @自4.3.14起
	 */
	public boolean isRemoveLeadingSlash() {
		return this.removeLeadingSlash;
	}

	/**
	 * Provide the {@code PathMatcher} in use for working with destinations
	 * which in turn helps to determine whether the leading slash should be
	 * kept in actual destinations after removing the
	 * {@link #setUserDestinationPrefix userDestinationPrefix}.
	 * <p>By default actual destinations have a leading slash, e.g.
	 * {@code /queue/position-updates} which makes sense with brokers that
	 * support destinations with slash as separator. When a {@code PathMatcher}
	 * is provided that supports an alternative separator, then resulting
	 * destinations won't have a leading slash, e.g. {@code
	 * jms.queue.position-updates}.
	 * @param pathMatcher the PathMatcher used to work with destinations
	 * @since 4.3
	 * @deprecated as of 4.3.14 this property is no longer used and is replaced
	 * by {@link #setRemoveLeadingSlash(boolean)} that indicates more explicitly
	 * whether to keep the leading slash which may or may not be the case
	 * regardless of how the {@code PathMatcher} is configured.
	 */
	/**
	 * 提供{@code  PathMatcher}用于与目标一起使用，这反过来又有助于确定在删除{@link  #setUserDestinationPrefix userDestinationPrefix}后是否在实际目标中保留前导斜线。 
	 *  <p>默认情况下，实际目的地的前导斜线例如是{@code  / queue / position-updates}这对于支持使用斜杠作为分隔符的目标的代理是有意义的。 
	 * 当提供支持替代分隔符的{@code  PathMatcher}时，结果目的地将不会有斜杠，例如{@code  jms.queue.position-updates}。 
	 *  
	 * @param  pathMatcher自4.3起从4.3开始不推荐使用的PathMatcher，自4.3.14起已弃用此属性，并由{@link  #setRemoveLeadingSlash（boolean）}取代，该属性更明确地指示是否保留无论如何配置{@code  PathMatcher}，都可能出现或可能不会出现前导斜杠。 
	 * 
	 */
	@Deprecated
	public void setPathMatcher(@Nullable PathMatcher pathMatcher) {
		// Do nothing
	}


	@Override
	@Nullable
	public UserDestinationResult resolveDestination(Message<?> message) {
		ParseResult parseResult = parse(message);
		if (parseResult == null) {
			return null;
		}
		String user = parseResult.getUser();
		String sourceDestination = parseResult.getSourceDestination();
		Set<String> targetSet = new HashSet<>();
		for (String sessionId : parseResult.getSessionIds()) {
			String actualDestination = parseResult.getActualDestination();
			String targetDestination = getTargetDestination(
					sourceDestination, actualDestination, sessionId, user);
			if (targetDestination != null) {
				targetSet.add(targetDestination);
			}
		}
		String subscribeDestination = parseResult.getSubscribeDestination();
		return new UserDestinationResult(sourceDestination, targetSet, subscribeDestination, user);
	}

	@Nullable
	private ParseResult parse(Message<?> message) {
		MessageHeaders headers = message.getHeaders();
		String sourceDestination = SimpMessageHeaderAccessor.getDestination(headers);
		if (sourceDestination == null || !checkDestination(sourceDestination, this.prefix)) {
			return null;
		}
		SimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(headers);
		if (messageType != null) {
			switch (messageType) {
				case SUBSCRIBE:
				case UNSUBSCRIBE:
					return parseSubscriptionMessage(message, sourceDestination);
				case MESSAGE:
					return parseMessage(headers, sourceDestination);
			}
		}
		return null;
	}

	@Nullable
	private ParseResult parseSubscriptionMessage(Message<?> message, String sourceDestination) {
		MessageHeaders headers = message.getHeaders();
		String sessionId = SimpMessageHeaderAccessor.getSessionId(headers);
		if (sessionId == null) {
			logger.error("No session id. Ignoring " + message);
			return null;
		}
		int prefixEnd = this.prefix.length() - 1;
		String actualDestination = sourceDestination.substring(prefixEnd);
		if (isRemoveLeadingSlash()) {
			actualDestination = actualDestination.substring(1);
		}
		Principal principal = SimpMessageHeaderAccessor.getUser(headers);
		String user = (principal != null ? principal.getName() : null);
		Assert.isTrue(user == null || !user.contains("%2F"), "Invalid sequence \"%2F\" in user name: " + user);
		Set<String> sessionIds = Collections.singleton(sessionId);
		return new ParseResult(sourceDestination, actualDestination, sourceDestination, sessionIds, user);
	}

	private ParseResult parseMessage(MessageHeaders headers, String sourceDest) {
		int prefixEnd = this.prefix.length();
		int userEnd = sourceDest.indexOf('/', prefixEnd);
		Assert.isTrue(userEnd > 0, "Expected destination pattern \"/user/{userId}/**\"");
		String actualDest = sourceDest.substring(userEnd);
		String subscribeDest = this.prefix.substring(0, prefixEnd - 1) + actualDest;
		String userName = sourceDest.substring(prefixEnd, userEnd);
		userName = StringUtils.replace(userName, "%2F", "/");

		String sessionId = SimpMessageHeaderAccessor.getSessionId(headers);
		Set<String> sessionIds;
		if (userName.equals(sessionId)) {
			userName = null;
			sessionIds = Collections.singleton(sessionId);
		}
		else {
			sessionIds = getSessionIdsByUser(userName, sessionId);
		}

		if (isRemoveLeadingSlash()) {
			actualDest = actualDest.substring(1);
		}
		return new ParseResult(sourceDest, actualDest, subscribeDest, sessionIds, userName);
	}

	private Set<String> getSessionIdsByUser(String userName, @Nullable String sessionId) {
		Set<String> sessionIds;
		SimpUser user = this.userRegistry.getUser(userName);
		if (user != null) {
			if (sessionId != null && user.getSession(sessionId) != null) {
				sessionIds = Collections.singleton(sessionId);
			}
			else {
				Set<SimpSession> sessions = user.getSessions();
				sessionIds = new HashSet<>(sessions.size());
				for (SimpSession session : sessions) {
					sessionIds.add(session.getId());
				}
			}
		}
		else {
			sessionIds = Collections.emptySet();
		}
		return sessionIds;
	}

	protected boolean checkDestination(String destination, String requiredPrefix) {
		return destination.startsWith(requiredPrefix);
	}

	/**
	 * This method determines how to translate the source "user" destination to an
	 * actual target destination for the given active user session.
	 * @param sourceDestination the source destination from the input message.
	 * @param actualDestination a subset of the destination without any user prefix.
	 * @param sessionId the id of an active user session, never {@code null}.
	 * @param user the target user, possibly {@code null}, e.g if not authenticated.
	 * @return a target destination, or {@code null} if none
	 */
/**
 * \""）;字符串actualDest = sourceDest.substring（userEnd）;字符串subscriptionDest = this.prefix.substring（0，prefixEnd-1）+ actualDest;字符串userName = sourceDest.substring（prefixEnd，userEnd）; userName = StringUtils.replace（userName，"％2F"，"/"）;字符串sessionId = SimpMessageHeaderAccessor.getSessionId（headers）; Set <String> sessionIds;如果（userName.equals（sessionId））{userName = null; sessionIds = Collections.singleton（sessionId）; } else {sessionIds = getSessionIdsByUser（userName，sessionId）; }如果（isRemoveLeadingSlash（））{ActualDest = actualDest.substring（1）; }返回新的ParseResult（sourceDest，actualDest，subscribeDest，sessionIds，userName）； 
 *  }私人Set <String> getSessionIdsByUser（String userName，@Nullable String sessionId）{Set <String> sessionIds; SimpUser用户= this.userRegistry.getUser（userName）; if（user！ 
 * = null）{if（sessionId！ 
 * = null && user.getSession（sessionId）！ 
 * = null）{sessionIds = Collections.singleton（sessionId）; } else {Set <SimpSession>会话= user.getSessions（）; sessionIds = new HashSet <>（sessions.size（））;对于（SimpSession会话：会话）{sessionIds.add（session.getId（））; }}}其他{sessionIds = Collections.emptySet（）; } return sessionIds; } protected boolean checkDestination（String destination，String requiredPrefix）{return destination.startsWith（requiredPrefix）; }此方法确定如何将给定活动用户会话的源"用户"目的地转换为实际目标目的地。 
 *  
 * @param  sourceDestination输入消息中的源目标。 
 *  
 * @param  ActualDestination是目标的子集，没有任何用户前缀。 
 *  
 * @param  sessionId活动用户会话的ID，从不{@code  null}。 
 *  
 * @param 用户为目标用户，可能为{@code  null}，例如，如果未通过身份验证。 
 *  
 * @return 目标目的地，如果没有，则为{<@@code> null}
 */
	@SuppressWarnings("unused")
	@Nullable
	protected String getTargetDestination(String sourceDestination, String actualDestination,
			String sessionId, @Nullable String user) {

		return actualDestination + "-user" + sessionId;
	}

	@Override
	public String toString() {
		return "DefaultUserDestinationResolver[prefix=" + this.prefix + "]";
	}


	/**
	 * A temporary placeholder for a parsed source "user" destination.
	 */
	/**
	 * 解析的源"用户"目标的临时占位符。 
	 * 
	 */
	private static class ParseResult {

		private final String sourceDestination;

		private final String actualDestination;

		private final String subscribeDestination;

		private final Set<String> sessionIds;

		@Nullable
		private final String user;

		public ParseResult(String sourceDest, String actualDest, String subscribeDest,
				Set<String> sessionIds, @Nullable String user) {

			this.sourceDestination = sourceDest;
			this.actualDestination = actualDest;
			this.subscribeDestination = subscribeDest;
			this.sessionIds = sessionIds;
			this.user = user;
		}

		public String getSourceDestination() {
			return this.sourceDestination;
		}

		public String getActualDestination() {
			return this.actualDestination;
		}

		public String getSubscribeDestination() {
			return this.subscribeDestination;
		}

		public Set<String> getSessionIds() {
			return this.sessionIds;
		}

		@Nullable
		public String getUser() {
			return this.user;
		}
	}

}
