/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.support;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.lang.Nullable;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHeaders;
import org.springframework.util.Assert;
import org.springframework.util.IdGenerator;
import org.springframework.util.MimeType;
import org.springframework.util.MimeTypeUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.PatternMatchUtils;
import org.springframework.util.StringUtils;

/**
 * A base for classes providing strongly typed getters and setters as well as
 * behavior around specific categories of headers (e.g. STOMP headers).
 * Supports creating new headers, modifying existing headers (when still mutable),
 * or copying and modifying existing headers.
 *
 * <p>The method {@link #getMessageHeaders()} provides access to the underlying,
 * fully-prepared {@link MessageHeaders} that can then be used as-is (i.e.
 * without copying) to create a single message as follows:
 *
 * <pre class="code">
 * MessageHeaderAccessor accessor = new MessageHeaderAccessor();
 * accessor.setHeader("foo", "bar");
 * Message message = MessageBuilder.createMessage("payload", accessor.getMessageHeaders());
 * </pre>
 *
 * <p>After the above, by default the {@code MessageHeaderAccessor} becomes
 * immutable. However it is possible to leave it mutable for further initialization
 * in the same thread, for example:
 *
 * <pre class="code">
 * MessageHeaderAccessor accessor = new MessageHeaderAccessor();
 * accessor.setHeader("foo", "bar");
 * accessor.setLeaveMutable(true);
 * Message message = MessageBuilder.createMessage("payload", accessor.getMessageHeaders());
 *
 * // later on in the same thread...
 *
 * MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message);
 * accessor.setHeader("bar", "baz");
 * accessor.setImmutable();
 * </pre>
 *
 * <p>The method {@link #toMap()} returns a copy of the underlying headers. It can
 * be used to prepare multiple messages from the same {@code MessageHeaderAccessor}
 * instance:
 * <pre class="code">
 * MessageHeaderAccessor accessor = new MessageHeaderAccessor();
 * MessageBuilder builder = MessageBuilder.withPayload("payload").setHeaders(accessor);
 *
 * accessor.setHeader("foo", "bar1");
 * Message message1 = builder.build();
 *
 * accessor.setHeader("foo", "bar2");
 * Message message2 = builder.build();
 *
 * accessor.setHeader("foo", "bar3");
 * Message  message3 = builder.build();
 * </pre>
 *
 * <p>However note that with the above style, the header accessor is shared and
 * cannot be re-obtained later on. Alternatively it is also possible to create
 * one {@code MessageHeaderAccessor} per message:
 *
 * <pre class="code">
 * MessageHeaderAccessor accessor1 = new MessageHeaderAccessor();
 * accessor.set("foo", "bar1");
 * Message message1 = MessageBuilder.createMessage("payload", accessor1.getMessageHeaders());
 *
 * MessageHeaderAccessor accessor2 = new MessageHeaderAccessor();
 * accessor.set("foo", "bar2");
 * Message message2 = MessageBuilder.createMessage("payload", accessor2.getMessageHeaders());
 *
 * MessageHeaderAccessor accessor3 = new MessageHeaderAccessor();
 * accessor.set("foo", "bar3");
 * Message message3 = MessageBuilder.createMessage("payload", accessor3.getMessageHeaders());
 * </pre>
 *
 * <p>Note that the above examples aim to demonstrate the general idea of using
 * header accessors. The most likely usage however is through subclasses.
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @since 4.0
 */
/**
 * 类的基础，该类提供强类型的获取器和设置器，以及围绕特定类别的标头（例如STOMP标头）的行为。 
 * 支持创建新的标头，修改现有的标头（当仍可变时）或复制和修改现有的标头。 
 *  <p>方法{@link  #getMessageHeaders（）}提供对完全准备好的基础{@link  MessageHeaders}的访问，然后可以按原样使用（即，无需复制）以创建单个消息，如下所示：遵循：<pre class ="code"> MessageHeaderAccessor accessor = new MessageHeaderAccessor（）; accessor.setHeader（"foo"，"bar"）;消息消息= MessageBuilder.createMessage（"payload"，accessor.getMessageHeaders（））; </ pre> <p>完成上述操作后，默认情况下{@code  MessageHeaderAccessor}变为不可变。 
 * 但是，可以将其保持可变以便在同一线程中进一步初始化，例如：<pre class ="code"> MessageHeaderAccessor accessor = new MessageHeaderAccessor（）;。 
 *  accessor.setHeader（"foo"，"bar"）; accessor.setLeaveMutable（true）;消息消息= MessageBuilder.createMessage（"payload"，accessor.getMessageHeaders（））; //稍后在同一线程中... MessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor（message）; accessor.setHeader（"bar"，"baz"）; accessor.setImmutable（）; </ pre> <p>方法{@link  #toMap（）}返回基础标头的副本。 
 * 它可用于从同一{@code  MessageHeaderAccessor}实例准备多条消息：<pre class ="code"> MessageHeaderAccessor accessor = new MessageHeaderAccessor（）; MessageBuilder builder = MessageBuilder.withPayload（"payload"）。 
 * setHeaders（accessor）; accessor.setHeader（"foo"，"bar1"）;消息message1 = builder.build（）; accessor.setHeader（"foo"，"bar2"）;消息message2 = builder.build（）; accessor.setHeader（"foo"，"bar3"）;消息message3 = builder.build（）; </ pre> <p>但是请注意，使用上述样式，标头访问器是共享的，以后无法重新获得。 
 * 或者，也可以为每条消息创建一个{@code  MessageHeaderAccessor}：<pre class ="code"> MessageHeaderAccessor accessor1 = new MessageHeaderAccessor（）; accessor.set（"foo"，"bar1"）;消息message1 = MessageBuilder.createMessage（"payload"，accessor1.getMessageHeaders（））; MessageHeaderAccessor accessor2 =新的MessageHeaderAccessor（）; accessor.set（"foo"，"bar2"）;消息message2 = MessageBuilder.createMessage（"payload"，accessor2.getMessageHeaders（））; MessageHeaderAccessor accessor3 =新的MessageHeaderAccessor（）; accessor.set（"foo"，"bar3"）;消息message3 = MessageBuilder.createMessage（"payload"，accessor3.getMessageHeaders（））; </ pre> <p>请注意，以上示例旨在说明使用标头访问器的一般思想。 
 * 但是，最可能的用法是通过子类。 
 *  @author  Rossen Stoyanchev @author  Juergen Hoeller @始于4.0
 */
public class MessageHeaderAccessor {

	/**
	 * The default charset used for headers.
	 */
	/**
	 * 标头使用的默认字符集。 
	 * 
	 */
	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;

	private static final MimeType[] READABLE_MIME_TYPES = new MimeType[] {
			MimeTypeUtils.APPLICATION_JSON, MimeTypeUtils.APPLICATION_XML,
			new MimeType("text", "*"), new MimeType("application", "*+json"), new MimeType("application", "*+xml")
	};


	private final MutableMessageHeaders headers;

	private boolean leaveMutable = false;

	private boolean modified = false;

	private boolean enableTimestamp = false;

	@Nullable
	private IdGenerator idGenerator;


	/**
	 * A constructor to create new headers.
	 */
	/**
	 * 用于创建新标题的构造函数。 
	 * 
	 */
	public MessageHeaderAccessor() {
		this(null);
	}

	/**
	 * A constructor accepting the headers of an existing message to copy.
	 * @param message a message to copy the headers from, or {@code null} if none
	 */
	/**
	 * 接受要复制的现有消息的标头的构造函数。 
	 *  
	 * @param 消息一条消息，用于复制标题，如果没有，则返回{@code  null}
	 */
	public MessageHeaderAccessor(@Nullable Message<?> message) {
		this.headers = new MutableMessageHeaders(message != null ? message.getHeaders() : null);
	}


	/**
	 * Build a 'nested' accessor for the given message.
	 * @param message the message to build a new accessor for
	 * @return the nested accessor (typically a specific subclass)
	 */
	/**
	 * 为给定消息构建一个"嵌套"访问器。 
	 *  
	 * @param 发出消息，以为
	 * @return 嵌套访问器（通常是特定的子类）建立新的访问器
	 */
	protected MessageHeaderAccessor createAccessor(Message<?> message) {
		return new MessageHeaderAccessor(message);
	}


	// Configuration properties

	/**
	 * By default when {@link #getMessageHeaders()} is called, {@code "this"}
	 * {@code MessageHeaderAccessor} instance can no longer be used to modify the
	 * underlying message headers and the returned {@code MessageHeaders} is immutable.
	 * <p>However when this is set to {@code true}, the returned (underlying)
	 * {@code MessageHeaders} instance remains mutable. To make further modifications
	 * continue to use the same accessor instance or re-obtain it via:<br>
	 * {@link MessageHeaderAccessor#getAccessor(Message, Class)
	 * MessageHeaderAccessor.getAccessor(Message, Class)}
	 * <p>When modifications are complete use {@link #setImmutable()} to prevent
	 * further changes. The intended use case for this mechanism is initialization
	 * of a Message within a single thread.
	 * <p>By default this is set to {@code false}.
	 * @since 4.1
	 */
	/**
	 * 默认情况下，调用{@link  #getMessageHeaders（）}时，{<@code>"this"} {@code  MessageHeaderAccessor}实例将不再可用于修改基础消息头和返回的{<@代码> MessageHeaders}是不可变的。 
	 *  <p>但是，如果将其设置为{@code  true}，则返回的（基础）{<@code> MessageHeaders}实例仍然可变。 
	 * 要进行进一步的修改，请继续使用相同的访问器实例，或通过以下方式重新获取它：<br> {@link  MessageHeaderAccessor＃getAccessor（Message，Class）MessageHeaderAccessor.getAccessor（Message，Class）} <p>完成修改后使用{@link  #setImmutable（）}来防止进一步的更改。 
	 * 该机制的预期用例是在单个线程中初始化Message。 
	 *  <p>默认情况下，此设置为{@code  false}。 
	 *  @始于4.1
	 */
	public void setLeaveMutable(boolean leaveMutable) {
		Assert.state(this.headers.isMutable(), "Already immutable");
		this.leaveMutable = leaveMutable;
	}

	/**
	 * By default when {@link #getMessageHeaders()} is called, {@code "this"}
	 * {@code MessageHeaderAccessor} instance can no longer be used to modify the
	 * underlying message headers. However if {@link #setLeaveMutable(boolean)}
	 * is used, this method is necessary to indicate explicitly when the
	 * {@code MessageHeaders} instance should no longer be modified.
	 * @since 4.1
	 */
	/**
	 * 默认情况下，调用{@link  #getMessageHeaders（）}时，{<@code>"this"} {@code  MessageHeaderAccessor}实例将不能再用于修改基础消息头。 
	 * 但是，如果使用{@link  #setLeaveMutable（boolean）}，则必须使用此方法来明确指示何时不应再修改{@code  MessageHeaders}实例。 
	 *  @始于4.1
	 */
	public void setImmutable() {
		this.headers.setImmutable();
	}

	/**
	 * Whether the underlying headers can still be modified.
	 * @since 4.1
	 */
	/**
	 * 基础头是否仍然可以被修改。 
	 *  @始于4.1
	 */
	public boolean isMutable() {
		return this.headers.isMutable();
	}

	/**
	 * Mark the underlying message headers as modified.
	 * @param modified typically {@code true}, or {@code false} to reset the flag
	 * @since 4.1
	 */
	/**
	 * 将基础消息标头标记为已修改。 
	 *  
	 * @param 通常修改为{@code  true}或{@code  false}以重置标志@since 4.1
	 */
	protected void setModified(boolean modified) {
		this.modified = modified;
	}

	/**
	 * Check whether the underlying message headers have been marked as modified.
	 * @return {@code true} if the flag has been set, {@code false} otherwise
	 */
	/**
	 * 检查基础消息头是否已标记为已修改。 
	 *  
	 * @return  {@code  true}（如果已设置标志），否则为{@code  false}
	 */
	public boolean isModified() {
		return this.modified;
	}

	/**
	 * A package private mechanism to enables the automatic addition of the
	 * {@link org.springframework.messaging.MessageHeaders#TIMESTAMP} header.
	 * <p>By default, this property is set to {@code false}.
	 * @see IdTimestampMessageHeaderInitializer
	 */
	/**
	 * 一个包专用机制，用于自动添加{@link  org.springframework.messaging.MessageHeaders＃TIMESTAMP}标头。 
	 *  <p>默认情况下，此属性设置为{@code  false}。 
	 *  
	 * @see  IdTimestampMessageHeaderInitializer
	 */
	void setEnableTimestamp(boolean enableTimestamp) {
		this.enableTimestamp = enableTimestamp;
	}

	/**
	 * A package-private mechanism to configure the IdGenerator strategy to use.
	 * <p>By default this property is not set in which case the default IdGenerator
	 * in {@link org.springframework.messaging.MessageHeaders} is used.
	 * @see IdTimestampMessageHeaderInitializer
	 */
	/**
	 * 一种包专用机制，用于配置要使用的IdGenerator策略。 
	 *  <p>默认情况下未设置此属性，在这种情况下，将使用{@link  org.springframework.messaging.MessageHeaders}中的默认IdGenerator。 
	 *  
	 * @see  IdTimestampMessageHeaderInitializer
	 */
	void setIdGenerator(IdGenerator idGenerator) {
		this.idGenerator = idGenerator;
	}


	// Accessors for the resulting MessageHeaders

	/**
	 * Return the underlying {@code MessageHeaders} instance.
	 * <p>Unless {@link #setLeaveMutable(boolean)} was set to {@code true}, after
	 * this call, the headers are immutable and this accessor can no longer
	 * modify them.
	 * <p>This method always returns the same {@code MessageHeaders} instance if
	 * invoked multiples times. To obtain a copy of the underlying headers, use
	 * {@link #toMessageHeaders()} or {@link #toMap()} instead.
	 * @since 4.1
	 */
	/**
	 * 返回基础的{@code  MessageHeaders}实例。 
	 *  <p>除非将{@link  #setLeaveMutable（boolean）}设置为{@code  true}，否则在此调用之后，标头是不可变的，并且此访问器无法再对其进行修改。 
	 *  <p>如果多次调用此方法，则始终返回相同的{@code  MessageHeaders}实例。 
	 * 要获取基础标头的副本，请改用{@link  #toMessageHeaders（）}或{@link  #toMap（）}。 
	 *  @始于4.1
	 */
	public MessageHeaders getMessageHeaders() {
		if (!this.leaveMutable) {
			setImmutable();
		}
		return this.headers;
	}

	/**
	 * Return a copy of the underlying header values as a {@link MessageHeaders} object.
	 * <p>This method can be invoked many times, with modifications in between
	 * where each new call returns a fresh copy of the current header values.
	 * @since 4.1
	 */
	/**
	 * 返回基础标头值的副本作为{@link  MessageHeaders}对象。 
	 *  <p>可以多次调用此方法，并在每次新调用返回当前标头值的新副本之间进行修改。 
	 *  @始于4.1
	 */
	public MessageHeaders toMessageHeaders() {
		return new MessageHeaders(this.headers);
	}

	/**
	 * Return a copy of the underlying header values as a plain {@link Map} object.
	 * <p>This method can be invoked many times, with modifications in between
	 * where each new call returns a fresh copy of the current header values.
	 */
	/**
	 * 返回基础标头值的副本作为普通的{@link  Map}对象。 
	 *  <p>可以多次调用此方法，并在每次新调用返回当前标头值的新副本之间进行修改。 
	 * 
	 */
	public Map<String, Object> toMap() {
		return new HashMap<>(this.headers);
	}


	// Generic header accessors

	/**
	 * Retrieve the value for the header with the given name.
	 * @param headerName the name of the header
	 * @return the associated value, or {@code null} if none found
	 */
	/**
	 * 检索具有给定名称的标头的值。 
	 *  
	 * @param  headerName标题的名称
	 * @return 关联的值； 
	 * 如果找不到，则为{@code  null}
	 */
	@Nullable
	public Object getHeader(String headerName) {
		return this.headers.get(headerName);
	}

	/**
	 * Set the value for the given header name.
	 * <p>If the provided value is {@code null}, the header will be removed.
	 */
	/**
	 * 设置给定标题名称的值。 
	 *  <p>如果提供的值为{@code  null}，则标题将被删除。 
	 * 
	 */
	public void setHeader(String name, @Nullable Object value) {
		if (isReadOnly(name)) {
			throw new IllegalArgumentException("'" + name + "' header is read-only");
		}
		verifyType(name, value);
		if (value != null) {
			// Modify header if necessary
			if (!ObjectUtils.nullSafeEquals(value, getHeader(name))) {
				this.modified = true;
				this.headers.getRawHeaders().put(name, value);
			}
		}
		else {
			// Remove header if available
			if (this.headers.containsKey(name)) {
				this.modified = true;
				this.headers.getRawHeaders().remove(name);
			}
		}
	}

	protected void verifyType(@Nullable String headerName, @Nullable Object headerValue) {
		if (headerName != null && headerValue != null) {
			if (MessageHeaders.ERROR_CHANNEL.equals(headerName) ||
					MessageHeaders.REPLY_CHANNEL.endsWith(headerName)) {
				if (!(headerValue instanceof MessageChannel || headerValue instanceof String)) {
					throw new IllegalArgumentException(
							"'" + headerName + "' header value must be a MessageChannel or String");
				}
			}
		}
	}

	/**
	 * Set the value for the given header name only if the header name is not
	 * already associated with a value.
	 */
	/**
	 * 仅当标题名称尚未与值关联时，才设置给定标题名称的值。 
	 * 
	 */
	public void setHeaderIfAbsent(String name, Object value) {
		if (getHeader(name) == null) {
			setHeader(name, value);
		}
	}

	/**
	 * Remove the value for the given header name.
	 */
	/**
	 * 删除给定标题名称的值。 
	 * 
	 */
	public void removeHeader(String headerName) {
		if (StringUtils.hasLength(headerName) && !isReadOnly(headerName)) {
			setHeader(headerName, null);
		}
	}

	/**
	 * Removes all headers provided via array of 'headerPatterns'.
	 * <p>As the name suggests, array may contain simple matching patterns for header
	 * names. Supported pattern styles are: "xxx*", "*xxx", "*xxx*" and "xxx*yyy".
	 */
	/**
	 * 删除通过"headerPatterns"数组提供的所有标题。 
	 *  <p>顾名思义，数组可以包含用于标头名称的简单匹配模式。 
	 * 支持的样式样式为："xxx"，"xxx"，"xxx"和"xxx yyy"。 
	 * 
	 */
	public void removeHeaders(String... headerPatterns) {
		List<String> headersToRemove = new ArrayList<>();
		for (String pattern : headerPatterns) {
			if (StringUtils.hasLength(pattern)){
				if (pattern.contains("*")){
					headersToRemove.addAll(getMatchingHeaderNames(pattern, this.headers));
				}
				else {
					headersToRemove.add(pattern);
				}
			}
		}
		for (String headerToRemove : headersToRemove) {
			removeHeader(headerToRemove);
		}
	}

	private List<String> getMatchingHeaderNames(String pattern, @Nullable Map<String, Object> headers) {
		if (headers == null) {
			return Collections.emptyList();
		}
		List<String> matchingHeaderNames = new ArrayList<>();
		for (String key : headers.keySet()) {
			if (PatternMatchUtils.simpleMatch(pattern, key)) {
				matchingHeaderNames.add(key);
			}
		}
		return matchingHeaderNames;
	}

	/**
	 * Copy the name-value pairs from the provided Map.
	 * <p>This operation will overwrite any existing values. Use
	 * {@link #copyHeadersIfAbsent(Map)} to avoid overwriting values.
	 */
	/**
	 * 从提供的地图中复制名称/值对。 
	 *  <p>此操作将覆盖所有现有值。 
	 * 使用{@link  #copyHeadersIfAbsent（Map）}避免覆盖值。 
	 * 
	 */
	public void copyHeaders(@Nullable Map<String, ?> headersToCopy) {
		if (headersToCopy != null) {
			headersToCopy.forEach((key, value) -> {
				if (!isReadOnly(key)) {
					setHeader(key, value);
				}
			});
		}
	}

	/**
	 * Copy the name-value pairs from the provided Map.
	 * <p>This operation will <em>not</em> overwrite any existing values.
	 */
	/**
	 * 从提供的地图中复制名称/值对。 
	 *  <p>此操作将<em>不</ em>覆盖所有现有值。 
	 * 
	 */
	public void copyHeadersIfAbsent(@Nullable Map<String, ?> headersToCopy) {
		if (headersToCopy != null) {
			headersToCopy.forEach((key, value) -> {
				if (!isReadOnly(key)) {
					setHeaderIfAbsent(key, value);
				}
			});
		}
	}

	protected boolean isReadOnly(String headerName) {
		return (MessageHeaders.ID.equals(headerName) || MessageHeaders.TIMESTAMP.equals(headerName));
	}


	// Specific header accessors

	@Nullable
	public UUID getId() {
		Object value = getHeader(MessageHeaders.ID);
		if (value == null) {
			return null;
		}
		return (value instanceof UUID ? (UUID) value : UUID.fromString(value.toString()));
	}

	@Nullable
	public Long getTimestamp() {
		Object value = getHeader(MessageHeaders.TIMESTAMP);
		if (value == null) {
			return null;
		}
		return (value instanceof Long ? (Long) value : Long.parseLong(value.toString()));
	}

	public void setContentType(MimeType contentType) {
		setHeader(MessageHeaders.CONTENT_TYPE, contentType);
	}

	@Nullable
	public MimeType getContentType() {
		Object value = getHeader(MessageHeaders.CONTENT_TYPE);
		if (value == null) {
			return null;
		}
		return (value instanceof MimeType ? (MimeType) value : MimeType.valueOf(value.toString()));
	}

	private Charset getCharset() {
		MimeType contentType = getContentType();
		Charset charset = (contentType != null ? contentType.getCharset() : null);
		return (charset != null ? charset : DEFAULT_CHARSET);
	}

	public void setReplyChannelName(String replyChannelName) {
		setHeader(MessageHeaders.REPLY_CHANNEL, replyChannelName);
	}

	public void setReplyChannel(MessageChannel replyChannel) {
		setHeader(MessageHeaders.REPLY_CHANNEL, replyChannel);
	}

	@Nullable
	public Object getReplyChannel() {
		return getHeader(MessageHeaders.REPLY_CHANNEL);
	}

	public void setErrorChannelName(String errorChannelName) {
		setHeader(MessageHeaders.ERROR_CHANNEL, errorChannelName);
	}

	public void setErrorChannel(MessageChannel errorChannel) {
		setHeader(MessageHeaders.ERROR_CHANNEL, errorChannel);
	}

	@Nullable
	public Object getErrorChannel() {
		return getHeader(MessageHeaders.ERROR_CHANNEL);
	}


	// Log message stuff

	/**
	 * Return a concise message for logging purposes.
	 * @param payload the payload that corresponds to the headers.
	 * @return the message
	 */
	/**
	 * 返回简明的消息以进行记录。 
	 *  
	 * @param 有效负载对应于标头的有效负载。 
	 *  
	 * @return 消息
	 */
	public String getShortLogMessage(Object payload) {
		return "headers=" + this.headers.toString() + getShortPayloadLogMessage(payload);
	}

	/**
	 * Return a more detailed message for logging purposes.
	 * @param payload the payload that corresponds to the headers.
	 * @return the message
	 */
	/**
	 * 返回更详细的消息以进行记录。 
	 *  
	 * @param 有效负载对应于标头的有效负载。 
	 *  
	 * @return 消息
	 */
	public String getDetailedLogMessage(@Nullable Object payload) {
		return "headers=" + this.headers.toString() + getDetailedPayloadLogMessage(payload);
	}

	protected String getShortPayloadLogMessage(Object payload) {
		if (payload instanceof String) {
			String payloadText = (String) payload;
			return (payloadText.length() < 80) ?
				" payload=" + payloadText :
				" payload=" + payloadText.substring(0, 80) + "...(truncated)";
		}
		else if (payload instanceof byte[]) {
			byte[] bytes = (byte[]) payload;
			if (isReadableContentType()) {
				return (bytes.length < 80) ?
						" payload=" + new String(bytes, getCharset()) :
						" payload=" + new String(Arrays.copyOf(bytes, 80), getCharset()) + "...(truncated)";
			}
			else {
				return " payload=byte[" + bytes.length + "]";
			}
		}
		else {
			String payloadText = payload.toString();
			return (payloadText.length() < 80) ?
					" payload=" + payloadText :
					" payload=" + ObjectUtils.identityToString(payload);
		}
	}

	protected String getDetailedPayloadLogMessage(@Nullable Object payload) {
		if (payload instanceof String) {
			return " payload=" + payload;
		}
		else if (payload instanceof byte[]) {
			byte[] bytes = (byte[]) payload;
			if (isReadableContentType()) {
				return " payload=" + new String(bytes, getCharset());
			}
			else {
				return " payload=byte[" + bytes.length + "]";
			}
		}
		else {
			return " payload=" + payload;
		}
	}

	protected boolean isReadableContentType() {
		MimeType contentType = getContentType();
		for (MimeType mimeType : READABLE_MIME_TYPES) {
			if (mimeType.includes(contentType)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public String toString() {
		return getClass().getSimpleName() + " [headers=" + this.headers + "]";
	}


	// Static factory methods

	/**
	 * Return the original {@code MessageHeaderAccessor} used to create the headers
	 * of the given {@code Message}, or {@code null} if that's not available or if
	 * its type does not match the required type.
	 * <p>This is for cases where the existence of an accessor is strongly expected
	 * (followed up with an assertion) or where an accessor will be created otherwise.
	 * @param message the message to get an accessor for
	 * @param requiredType the required accessor type (or {@code null} for any)
	 * @return an accessor instance of the specified type, or {@code null} if none
	 * @since 4.1
	 */
	/**
	 * 返回用于创建给定{@code  Message}的标头的原始{@code  MessageHeaderAccessor}，如果不可用或者其类型与所需类型不匹配，则返回{@code  null}。 
	 *  <p>这是针对强烈期望访问者存在（紧随其后的是断言）或否则将创建访问者的情况。 
	 *  
	 * @param 消息，该消息为获取
	 * @param 的访问器而必需。 
	 * 键入所需的访问器类型（对于任何类型，为{<@@code> null}）
	 * @return 指定类型的访问器实例，或{<@code > null}，如果没有，则自4.1起
	 */
	@Nullable
	public static <T extends MessageHeaderAccessor> T getAccessor(Message<?> message, @Nullable Class<T> requiredType) {
		return getAccessor(message.getHeaders(), requiredType);
	}

	/**
	 * A variation of {@link #getAccessor(org.springframework.messaging.Message, Class)}
	 * with a {@code MessageHeaders} instance instead of a {@code Message}.
	 * <p>This is for cases when a full message may not have been created yet.
	 * @param messageHeaders the message headers to get an accessor for
	 * @param requiredType the required accessor type (or {@code null} for any)
	 * @return an accessor instance of the specified type, or {@code null} if none
	 * @since 4.1
	 */
	/**
	 * 带有{@code  MessageHeaders}实例而不是{@code  Message}的{@link  #getAccessor（org.springframework.messaging.Message，Class）}的变体。 
	 *  <p>这是针对尚未创建完整消息的情况。 
	 *  
	 * @param  messageHeader消息标头以获取
	 * @param 必需的访问者。 
	 * 键入所需的访问者类型（对于任何访问者，则为{<@@code> null}）
	 * @return 指定类型的访问者实例，或{<@代码> null}，如果没有@4.1起
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <T extends MessageHeaderAccessor> T getAccessor(
			MessageHeaders messageHeaders, @Nullable Class<T> requiredType) {

		if (messageHeaders instanceof MutableMessageHeaders) {
			MutableMessageHeaders mutableHeaders = (MutableMessageHeaders) messageHeaders;
			MessageHeaderAccessor headerAccessor = mutableHeaders.getAccessor();
			if (requiredType == null || requiredType.isInstance(headerAccessor))  {
				return (T) headerAccessor;
			}
		}
		return null;
	}

	/**
	 * Return a mutable {@code MessageHeaderAccessor} for the given message attempting
	 * to match the type of accessor used to create the message headers, or otherwise
	 * wrapping the message with a {@code MessageHeaderAccessor} instance.
	 * <p>This is for cases where a header needs to be updated in generic code
	 * while preserving the accessor type for downstream processing.
	 * @return an accessor of the required type (never {@code null})
	 * @since 4.1
	 */
	/**
	 * 为给定的消息返回一个可变的{@code  MessageHeaderAccessor}，以尝试匹配用于创建消息头的访问器的类型，或者使用{@code  MessageHeaderAccessor}实例包装该消息。 
	 *  <p>这是在需要在保留访问器类型以进行下游处理的同时，以通用代码更新标头的情况。 
	 *  
	 * @return 所需类型的访问器（从不{<@@code> null}）@4.1起
	 */
	public static MessageHeaderAccessor getMutableAccessor(Message<?> message) {
		if (message.getHeaders() instanceof MutableMessageHeaders) {
			MutableMessageHeaders mutableHeaders = (MutableMessageHeaders) message.getHeaders();
			MessageHeaderAccessor accessor = mutableHeaders.getAccessor();
			return (accessor.isMutable() ? accessor : accessor.createAccessor(message));
		}
		return new MessageHeaderAccessor(message);
	}


	@SuppressWarnings("serial")
	private class MutableMessageHeaders extends MessageHeaders {

		private boolean mutable = true;

		public MutableMessageHeaders(@Nullable Map<String, Object> headers) {
			super(headers, MessageHeaders.ID_VALUE_NONE, -1L);
		}

		@Override
		public Map<String, Object> getRawHeaders() {
			Assert.state(this.mutable, "Already immutable");
			return super.getRawHeaders();
		}

		public void setImmutable() {
			if (!this.mutable) {
				return;
			}

			if (getId() == null) {
				IdGenerator idGenerator = (MessageHeaderAccessor.this.idGenerator != null ?
						MessageHeaderAccessor.this.idGenerator : MessageHeaders.getIdGenerator());
				UUID id = idGenerator.generateId();
				if (id != MessageHeaders.ID_VALUE_NONE) {
					getRawHeaders().put(ID, id);
				}
			}

			if (getTimestamp() == null) {
				if (MessageHeaderAccessor.this.enableTimestamp) {
					getRawHeaders().put(TIMESTAMP, System.currentTimeMillis());
				}
			}

			this.mutable = false;
		}

		public boolean isMutable() {
			return this.mutable;
		}

		public MessageHeaderAccessor getAccessor() {
			return MessageHeaderAccessor.this;
		}

		protected Object writeReplace() {
			// Serialize as regular MessageHeaders (without MessageHeaderAccessor reference)
			return new MessageHeaders(this);
		}
	}

}
