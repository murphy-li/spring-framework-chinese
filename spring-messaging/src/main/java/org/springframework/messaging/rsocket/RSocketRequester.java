/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.rsocket;

import java.net.URI;
import java.util.function.Consumer;

import io.rsocket.ConnectionSetupPayload;
import io.rsocket.Payload;
import io.rsocket.RSocket;
import io.rsocket.transport.ClientTransport;
import io.rsocket.transport.netty.client.TcpClientTransport;
import io.rsocket.transport.netty.client.WebsocketClientTransport;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.core.codec.Decoder;
import org.springframework.lang.Nullable;
import org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler;
import org.springframework.util.MimeType;

/**
 * A thin wrapper around a sending {@link RSocket} with a fluent API accepting
 * and returning higher level Objects for input and for output, along with
 * methods to prepare routing and other metadata.
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @since 5.2
 */
/**
 * 发送方{@link  RSocket}周围的薄包装，带有流畅的API，用于接受和返回用于输入和输出的更高级别的对象，以及用于准备路由和其他元数据的方法。 
 *  @author 罗森·斯托扬切夫（Rossen Stoyanchev）@author 布莱恩·克洛泽尔​​（Brian Clozel）@5.2起
 */
public interface RSocketRequester {

	/**
	 * Return the underlying sending RSocket.
	 */
	/**
	 * 返回基础发送RSocket。 
	 * 
	 */
	RSocket rsocket();

	/**
	 * Return the data {@code MimeType} selected for the underlying RSocket
	 * at connection time. On the client side this is configured via
	 * {@link RSocketRequester.Builder#dataMimeType(MimeType)} while on the
	 * server side it's obtained from the {@link ConnectionSetupPayload}.
	 */
	/**
	 * 返回在连接时为基础RSocket选择的数据{@code  MimeType}。 
	 * 在客户端，这是通过{@link  RSocketRequester.Builder＃dataMimeType（MimeType）}配置的，而在服务器端，它是从{@link  ConnectionSetupPayload}获取的。 
	 * 
	 */
	MimeType dataMimeType();

	/**
	 * Return the metadata {@code MimeType} selected for the underlying RSocket
	 * at connection time. On the client side this is configured via
	 * {@link RSocketRequester.Builder#metadataMimeType(MimeType)} while on the
	 * server side it's obtained from the {@link ConnectionSetupPayload}.
	 */
	/**
	 * 返回在连接时为基础RSocket选择的元数据{@code  MimeType}。 
	 * 在客户端，这是通过{@link  RSocketRequester.Builder＃metadataMimeType（MimeType）}配置的，而在服务器端，它是从{@link  ConnectionSetupPayload}获取的。 
	 * 
	 */
	MimeType metadataMimeType();

	/**
	 * Begin to specify a new request with the given route to a remote handler.
	 * <p>The route can be a template with placeholders, e.g.
	 * {@code "flight.{code}"} in which case the supplied route variables are
	 * formatted via {@code toString()} and expanded into the template.
	 * If a formatted variable contains a "." it is replaced with the escape
	 * sequence "%2E" to avoid treating it as separator by the responder .
	 * <p>If the connection is set to use composite metadata, the route is
	 * encoded as {@code "message/x.rsocket.routing.v0"}. Otherwise the route
	 * is encoded according to the mime type for the connection.
	 * @param route the route expressing a remote handler mapping
	 * @param routeVars variables to be expanded into the route template
	 * @return a spec for further defining and executing the request
	 */
	/**
	 * 开始使用到远程处理程序的给定路由指定一个新请求。 
	 *  <p>路线可以是带有占位符的模板，例如{@code "flight。 
	 * {code}"}，在这种情况下，提供的路径变量通过{@code  toString（）}进行格式化，并扩展到模板中。 
	 * 如果格式化的变量包含"。 
	 * "将其替换为转义序列"％2E"，以避免响应者将其视为分隔符。 
	 *  <p>如果连接设置为使用复合元数据，则路由将编码为{@code "message / x.rsocket.routing.v0"}。 
	 * 否则，将根据连接的mime类型对路由进行编码。 
	 *  
	 * @param 路由表示远程处理程序映射的路由
	 * @param  routeVars变量将扩展为路由模板
	 * @return 规范，用于进一步定义和执行请求
	 */
	RequestSpec route(String route, Object... routeVars);

	/**
	 * Begin to specify a new request with the given metadata value, which can
	 * be a concrete value or any producer of a single value that can be adapted
	 * to a {@link Publisher} via {@link ReactiveAdapterRegistry}.
	 * @param metadata the metadata value to encode
	 * @param mimeType the mime type that describes the metadata;
	 * This is required for connection using composite metadata. Otherwise the
	 * value is encoded according to the mime type for the connection and this
	 * argument may be left as {@code null}.
	 */
	/**
	 * 开始使用给定的元数据值指定一个新请求，该元数据可以是具体值，也可以是可以通过{@link  ReactiveAdapterRegistry}适应{@link  Publisher}的单个值的任何生产者。 
	 *  
	 * @param 元数据要编码的元数据值
	 * @param  mimeType描述元数据的mime类型； 
	 * 这是使用复合元数据进行连接所必需的。 
	 * 否则，将根据连接的mime类型对该值进行编码，并且该参数可以保留为{@code  null}。 
	 * 
	 */
	RequestSpec metadata(Object metadata, @Nullable MimeType mimeType);


	/**
	 * Obtain a builder to create a client {@link RSocketRequester} by connecting
	 * to an RSocket server.
	 */
	/**
	 * 通过连接到RSocket服务器，获取生成器以创建客户端{@link  RSocketRequester}。 
	 * 
	 */
	static RSocketRequester.Builder builder() {
		return new DefaultRSocketRequesterBuilder();
	}

	/**
	 * Wrap an existing {@link RSocket}. Typically used in client or server
	 * responders to wrap the {@code RSocket} for the remote side.
	 */
	/**
	 * 包装现有的{@link  RSocket}。 
	 * 通常用于客户端或服务器响应程序中，以包装{@code  RSocket}到远程端。 
	 * 
	 */
	static RSocketRequester wrap(
			RSocket rsocket, MimeType dataMimeType, MimeType metadataMimeType,
			RSocketStrategies strategies) {

		return new DefaultRSocketRequester(rsocket, dataMimeType, metadataMimeType, strategies);
	}


	/**
	 * Builder to create a requester by connecting to a server.
	 */
	/**
	 * 通过连接到服务器来创建请求者的生成器。 
	 * 
	 */
	interface Builder {

		/**
		 * Configure the payload data MimeType to specify on the {@code SETUP}
		 * frame that applies to the whole connection.
		 * <p>If not set, this will be initialized to the MimeType of the first
		 * {@link RSocketStrategies.Builder#decoder(Decoder[])  non-default}
		 * {@code Decoder}, or otherwise the MimeType of the first decoder.
		 */
		/**
		 * 配置有效负载数据MimeType，以在{@code  SETUP}帧上指定适用于整个连接的数据。 
		 *  <p>如果未设置，则将其初始化为第一个{@link  RSocketStrategies.Builder＃decoder（Decoder []）非默认} {@code  Decoder}的MimeType，否则初始化为第一解码器。 
		 * 
		 */
		RSocketRequester.Builder dataMimeType(@Nullable MimeType mimeType);

		/**
		 * Configure the payload metadata MimeType to specify on the {@code SETUP}
		 * frame that applies to the whole connection.
		 * <p>By default this is set to
		 * {@code "message/x.rsocket.composite-metadata.v0"} in which case the
		 * route, if provided, is encoded as a {@code "message/x.rsocket.routing.v0"}
		 * composite metadata entry. If this is set to any other MimeType, it is
		 * assumed that's the MimeType for the route, if provided.
		 */
		/**
		 * 配置有效负载元数据MimeType以在{@code  SETUP}框架上指定以应用于整个连接。 
		 *  <p>默认情况下，此设置为{@code "message / x.rsocket.composite-metadata.v0"}，在这种情况下，如果提供了路由，则将其编码为{@code "message / x .rsocket.routing.v0"}复合元数据条目。 
		 * 如果将其设置为任何其他MimeType，则假定该路由为MimeType（如果提供）。 
		 * 
		 */
		RSocketRequester.Builder metadataMimeType(MimeType mimeType);

		/**
		 * Set the data for the setup payload. The data will be encoded
		 * according to the configured {@link #dataMimeType(MimeType)}.
		 * The data be a concrete value or any producer of a single value that
		 * can be adapted to a {@link Publisher} via {@link ReactiveAdapterRegistry}.
		 * <p>By default this is not set.
		 */
		/**
		 * 设置设置有效负载的数据。 
		 * 数据将根据配置的{@link  #dataMimeType（MimeType）}进行编码。 
		 * 数据可以是具体值，也可以是可以通过{@link  ReactiveAdapterRegistry}适应{@link  Publisher}的单个值的任何生产者。 
		 *  <p>默认情况下未设置。 
		 * 
		 */
		RSocketRequester.Builder setupData(Object data);

		/**
		 * Set the route for the setup payload. The rules for formatting and
		 * encoding the route are the same as those for a request route as
		 * described in {@link #route(String, Object...)}.
		 * <p>By default this is not set.
		 */
		/**
		 * 设置设置有效负载的路由。 
		 * 路由的格式化和编码规则与{@link  #route（String，Object ...）}中描述的请求路由的规则相同。 
		 *  <p>默认情况下未设置。 
		 * 
		 */
		RSocketRequester.Builder setupRoute(String route, Object... routeVars);

		/**
		 * Add metadata entry to the setup payload. Composite metadata must be
		 * in use if this is called more than once or in addition to
		 * {@link #setupRoute(String, Object...)}. The metadata value be a
		 * concrete value or any producer of a single value that can be adapted
		 * to a {@link Publisher} via {@link ReactiveAdapterRegistry}.
		 */
		/**
		 * 将元数据条目添加到设置有效内容。 
		 * 如果多次调用复合元数据，或者除了{@link  #setupRoute（String，Object ...）}之外，还必须使用复合元数据。 
		 * 元数据值可以是具体值，也可以是可以通过{@link  ReactiveAdapterRegistry}适应{@link  Publisher}的单个值的任何生产者。 
		 * 
		 */
		RSocketRequester.Builder setupMetadata(Object value, @Nullable MimeType mimeType);

		/**
		 * Provide the {@link RSocketStrategies} to use.
		 * <p>This is useful for changing the default settings, yet still allowing
		 * further customizations via {@link #rsocketStrategies(Consumer)}.
		 * If not set, defaults are obtained from {@link RSocketStrategies#builder()}.
		 * @param strategies the strategies to use
		 */
		/**
		 * 提供{@link  RSocketStrategies}以供使用。 
		 *  <p>这对于更改默认设置很有用，但仍允许通过{@link  #rsocketStrategies（Consumer）}进行进一步的自定义。 
		 * 如果未设置，则从{@link  RSocketStrategies＃builder（）}获取默认值。 
		 *  
		 * @param 策略使用的策略
		 */
		RSocketRequester.Builder rsocketStrategies(@Nullable RSocketStrategies strategies);

		/**
		 * Customize the {@link RSocketStrategies}.
		 * <p>Allows further customization on {@link RSocketStrategies},
		 * mutating them if they were {@link #rsocketStrategies(RSocketStrategies) set},
		 * or starting from {@link RSocketStrategies#builder()} defaults}.
		 */
		/**
		 * 自定义{@link  RSocketStrategies}。 
		 *  <p>允许在{@link  RSocketStrategies}上进行进一步的自定义，如果{{@link> #rsocketStrategies（RSocketStrategies）set}设置了它们，或者从{@link  RSocketStrategies＃builder（）}默认值}对其进行了更改，则可以对其进行更改。 
		 * 
		 */
		RSocketRequester.Builder rsocketStrategies(Consumer<RSocketStrategies.Builder> configurer);

		/**
		 * Callback to configure the {@code ClientRSocketFactory} directly.
		 * <ul>
		 * <li>The data and metadata mime types cannot be set directly
		 * on the {@code ClientRSocketFactory} and will be overridden. Use the
		 * shortcuts {@link #dataMimeType(MimeType)} and
		 * {@link #metadataMimeType(MimeType)} on this builder instead.
		 * <li>The frame decoder also cannot be set directly and instead is set
		 * to match the configured {@code DataBufferFactory}.
		 * <li>For the
		 * {@link io.rsocket.RSocketFactory.ClientRSocketFactory#setupPayload(Payload)
		 * setupPayload}, consider using methods on this builder to specify the
		 * route, other metadata, and data as Object values to be encoded.
		 * <li>To configure client side responding, see
		 * {@link RSocketMessageHandler#clientResponder(RSocketStrategies, Object...)}.
		 * </ul>
		 */
		/**
		 * 回调以直接配置{@code  ClientRSocketFactory}。 
		 *  <ul> <li>数据和元数据哑剧类型不能直接在{@code  ClientRSocketFactory}上设置，并将被覆盖。 
		 * 请在此构建器上使用快捷方式{@link  #dataMimeType（MimeType）}和{@link  #metadataMimeType（MimeType）}。 
		 *  <li>也不能直接设置帧解码器，而是将其设置为与已配置的{@code  DataBufferFactory}匹配。 
		 *  <li>对于{@link  io.rsocket.RSocketFactory.ClientRSocketFactory＃setupPayload（Payload）setupPayload}，请考虑使用此构建器上的方法来指定路由，其他元数据和数据作为要编码的Object值。 
		 *  <li>要配置客户端响应，请参见{@link  RSocketMessageHandler＃clientResponder（RSocketStrategies，Object ...）}。 
		 *  </ ul>
		 */
		RSocketRequester.Builder rsocketFactory(ClientRSocketFactoryConfigurer configurer);

		/**
		 * Configure this builder through a {@code Consumer}. This enables
		 * libraries such as Spring Security to provide shortcuts for applying
		 * a set of related customizations.
		 * @param configurer the configurer to apply
		 */
		/**
		 * 通过{@code 使用者}配置此构建器。 
		 * 这使诸如Spring Security之类的库能够提供用于应用一组相关自定义项的快捷方式。 
		 *  
		 * @param  configurer配置器要应用
		 */
		RSocketRequester.Builder apply(Consumer<RSocketRequester.Builder> configurer);

		/**
		 * Connect to the server over TCP.
		 * @param host the server host
		 * @param port the server port
		 * @return an {@code RSocketRequester} for the connection
		 * @see TcpClientTransport
		 */
		/**
		 * 通过TCP连接到服务器。 
		 *  
		 * @param 托管服务器主机
		 * @param 端口服务器端口
		 * @return 用于连接的{@code  RSocketRequester} 
		 * @see  TcpClientTransport
		 */
		Mono<RSocketRequester> connectTcp(String host, int port);

		/**
		 * Connect to the server over WebSocket.
		 * @param uri the RSocket server endpoint URI
		 * @return an {@code RSocketRequester} for the connection
		 * @see WebsocketClientTransport
		 */
		/**
		 * 通过WebSocket连接到服务器。 
		 *  
		 * @param  uri RSocket服务器端点URI 
		 * @return 和{@code  RSocketRequester}用于连接
		 * @see  WebsocketClientTransport
		 */
		Mono<RSocketRequester> connectWebSocket(URI uri);

		/**
		 * Connect to the server with the given {@code ClientTransport}.
		 * @param transport the client transport to use
		 * @return an {@code RSocketRequester} for the connection
		 */
		/**
		 * 使用给定的{@code  ClientTransport}连接到服务器。 
		 *  
		 * @param 传输客户端传输以使用
		 * @return  {{@code> RSocketRequester}进行连接
		 */
		Mono<RSocketRequester> connect(ClientTransport transport);

	}

	/**
	 * Spec to declare the input for an RSocket request.
	 */
	/**
	 * 规范，用于声明RSocket请求的输入。 
	 * 
	 */
	interface RequestSpec extends MetadataSpec<RequestSpec>, RetrieveSpec {

		/**
		 * Append additional metadata entries through a {@code Consumer}.
		 * This enables libraries such as Spring Security to provide shortcuts
		 * for applying a set of customizations.
		 * @param configurer the configurer to apply
		 * @throws IllegalArgumentException if not using composite metadata.
		 */
		/**
		 * 通过{@code 使用者}附加其他元数据条目。 
		 * 这使诸如Spring Security之类的库能够提供应用一组定制的快捷方式。 
		 *  
		 * @param  configurer如果不使用复合元数据，则配置程序将应用
		 * @throws  IllegalArgumentException。 
		 * 
		 */
		RequestSpec metadata(Consumer<MetadataSpec<?>> configurer);

		/**
		 * Provide payload data for the request. This can be one of:
		 * <ul>
		 * <li>Concrete value
		 * <li>{@link Publisher} of value(s)
		 * <li>Any other producer of value(s) that can be adapted to a
		 * {@link Publisher} via {@link ReactiveAdapterRegistry}
		 * </ul>
		 * @param data the Object value for the payload data
		 * @return spec to declare the expected response
		 */
		/**
		 * 提供请求的有效负载数据。 
		 * 它可以是以下值之一：<ul> <li>具体值<li> {<@link>发布者}的值<li>可以与{<@link进行匹配的）其他任何值的生产者> Publisher}通过{@link  ReactiveAdapterRegistry} </ ul> 
		 * @param  data有效负载数据
		 * @return 规范的Object值来声明预期的响应
		 */
		RetrieveSpec data(Object data);

		/**
		 * Variant of {@link #data(Object)} that also accepts a hint for the
		 * types of values that will be produced. The class hint is used to
		 * find a compatible {@code Encoder} once, up front vs per value.
		 * @param producer the source of payload data value(s). This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementClass the type of values to be produced
		 * @return spec to declare the expected response
		 */
		/**
		 * {@link  #data（Object）}的变体，它也接受将要生成的值类型的提示。 
		 * 类提示用于一次查找兼容的{@code 编码器}，首先是根据值进行查找。 
		 *  
		 * @param 生产者有效载荷数据值的来源。 
		 * 它必须是{@link 发布者}或通过{@link  ReactiveAdapterRegistry} 
		 * @param  elementClass适应{{@code> Publisher}的其他生产者<Class>要生成的值的类型
		 * @return 规范声明预期的回应
		 */
		RetrieveSpec data(Object producer, Class<?> elementClass);

		/**
		 * Variant of {@link #data(Object, Class)} for when the type hint has
		 * to have a generic type. See {@link ParameterizedTypeReference}.
		 * @param producer the source of payload data value(s). This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementTypeRef the type of values to be produced
		 * @return spec to declare the expected response
		 */
		/**
		 * {@link  #data（Object，Class）}的变体，用于类型提示必须具有通用类型的情况。 
		 * 请参见{@link  ParameterizedTypeReference}。 
		 *  
		 * @param 生产者有效载荷数据值的来源。 
		 * 它必须是{@link 发布者}或通过{@link  ReactiveAdapterRegistry}适应{{@code>发布者}的其他生产者。 
		 * 
		 * @param  elementTypeRef要生成的值的类型
		 * @return 规范声明预期的回应
		 */
		RetrieveSpec data(Object producer, ParameterizedTypeReference<?> elementTypeRef);
	}


	/**
	 * Spec for providing additional composite metadata entries.
	 *
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 提供其他复合元数据条目的规范。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface MetadataSpec<S extends MetadataSpec<S>> {

		/**
		 * Use this to append additional metadata entries when using composite
		 * metadata. An {@link IllegalArgumentException} is raised if this
		 * method is used when not using composite metadata.
		 * The metadata value be a concrete value or any producer of a single
		 * value that can be adapted to a {@link Publisher} via
		 * {@link ReactiveAdapterRegistry}.
		 * @param metadata an Object to be encoded with a suitable
		 * {@link org.springframework.core.codec.Encoder Encoder}, or a
		 * {@link org.springframework.core.io.buffer.DataBuffer DataBuffer}
		 * @param mimeType the mime type that describes the metadata
		 */
		/**
		 * 使用复合元数据时，可使用此选项附加其他元数据条目。 
		 * 如果不使用复合元数据时使用此方法，则会引发{@link  IllegalArgumentException}。 
		 * 元数据值可以是具体值，也可以是可以通过{@link  ReactiveAdapterRegistry}适应{@link  Publisher}的单个值的任何生产者。 
		 *  
		 * @param 元数据使用合适的{@link  org.springframework.core.codec.Encoder编码器}或{@link  org.springframework.core.io.buffer.DataBuffer DataBuffer}进行编码的对象
		 * @param  mimeType描述元数据的mime类型
		 */
		S metadata(Object metadata, MimeType mimeType);
	}


	/**
	 * Spec to declare the expected output for an RSocket request.
	 * @since 5.2.2
	 */
	/**
	 * 用于声明RSocket请求的预期输出的规范。 
	 *  @从5.2.2开始
	 */
	interface RetrieveSpec {

		/**
		 * Perform a {@link RSocket#fireAndForget fireAndForget}.
		 */
		/**
		 * 执行一个{@link  RSocket＃fireAndForget fireAndForget}。 
		 * 
		 */
		Mono<Void> send();

		/**
		 * Perform a {@link RSocket#requestResponse requestResponse} exchange.
		 * <p>If the return type is {@code Mono<Void>}, the {@code Mono} will
		 * complete after all data is consumed.
		 * <p><strong>Note:</strong> This method will raise an error if
		 * the request payload is a multi-valued {@link Publisher} as there is
		 * no many-to-one RSocket interaction.
		 * @param dataType the expected data type for the response
		 * @param <T> parameter for the expected data type
		 * @return the decoded response
		 */
		/**
		 * 执行{@link  RSocket＃requestResponse requestResponse}交换。 
		 *  <p>如果返回类型为{@code  Mono <Void>}，则在使用完所有数据后将完成{@code  Mono}。 
		 *  <p> <strong>注意</ strong>：如果请求有效负载是多值{@link  Publisher}，则由于没有多对一的RSocket交互，因此此方法将引发错误。 
		 *  
		 * @param  dataType响应的预期数据类型
		 * @param  <T>预期数据类型的参数
		 * @return 解码后的响应
		 */
		<T> Mono<T> retrieveMono(Class<T> dataType);

		/**
		 * Variant of {@link #retrieveMono(Class)} for when the dataType has
		 * to have a generic type. See {@link ParameterizedTypeReference}.
		 */
		/**
		 * {@link  #retrieveMono（Class）}的变体，用于dataType必须具有通用类型的情况。 
		 * 请参见{@link  ParameterizedTypeReference}。 
		 * 
		 */
		<T> Mono<T> retrieveMono(ParameterizedTypeReference<T> dataTypeRef);

		/**
		 * Perform an {@link RSocket#requestStream requestStream} or a
		 * {@link RSocket#requestChannel requestChannel} exchange depending on
		 * whether the request input is single or multi-payload.
		 * <p>If the return type is {@code Flux<Void>}, the {@code Flux} will
		 * complete after all data is consumed.
		 * @param dataType the expected type for values in the response
		 * @param <T> parameterize the expected type of values
		 * @return the decoded response
		 */
		/**
		 * 根据请求输入是单有效负载还是多有效负载，执行{@link  RSocket＃requestStream requestStream}或{@link  RSocket＃requestChannel requestChannel}交换。 
		 *  <p>如果返回类型为{@code  Flux <Void>}，则在使用完所有数据后，{<@code> Flux}将完成。 
		 *  
		 * @param  data键入响应中值的期望类型
		 * @param  <T>参数化期望值的类型
		 * @return 解码后的响应
		 */
		<T> Flux<T> retrieveFlux(Class<T> dataType);

		/**
		 * Variant of {@link #retrieveFlux(Class)} for when the dataType has
		 * to have a generic type. See {@link ParameterizedTypeReference}.
		 */
		/**
		 * {@link  #retrieveFlux（Class）}的变体，用于dataType必须具有通用类型的情况。 
		 * 请参见{@link  ParameterizedTypeReference}。 
		 * 
		 */
		<T> Flux<T> retrieveFlux(ParameterizedTypeReference<T> dataTypeRef);
	}

}
