/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.rsocket.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import io.rsocket.ConnectionSetupPayload;

/**
 * Annotation to map the initial {@link ConnectionSetupPayload} and subsequent
 * metadata pushes onto a handler method.
 *
 * <p>This is a method-level annotation that can be combined with a type-level
 * {@link org.springframework.messaging.handler.annotation.MessageMapping @MessageMapping}
 * for a combined route pattern. It supports the same arguments as
 * {@code @MessageMapping} but the return value must be {@code void}. On a
 * server, handling can be asynchronous (e.g. {@code Mono<Void>}), in which
 * case the connection is accepted if and when the {@code Mono<Void>} completes.
 * On the client side this method is only a callback and does not affect the
 * establishment of the connection.
 *
 * <p><strong>Note:</strong> an {@code @ConnectMapping} method may start
 * requests to the remote through an
 * {@link org.springframework.messaging.rsocket.RSocketRequester RSocketRequester}
 * method argument, but it must do so independent of the handling thread (e.g.
 * via subscribing on a different thread).
 *
 * @author Rossen Stoyanchev
 * @since 5.2
 */
/**
 * 映射初始{@link  ConnectionSetupPayload}和后续元数据的注释将推入处理程序方法。 
 *  <p>这是方法级别的注释，可以与类型级别的{@link  org.springframework.messaging.handler.annotation.MessageMapping @MessageMapping}结合使用以实现组合的路由模式。 
 * 它支持与{@code  @MessageMapping}相同的参数，但返回值必须为{@code  void}。 
 * 在服务器上，处理可以是异步的（例如{@code  Mono <Void>}），在这种情况下，如果{@code  Mono <Void>}完成，则接受连接。 
 * 在客户端，此方法仅是回调，并且不会影响连接的建立。 
 *  <p> <strong>注意：</ strong>：{@code  @ConnectMapping}方法可以通过{@link  org.springframework.messaging.rsocket.RSocketRequester RSocketRequester}方法参数启动对远程的请求，但是它必须独立于处理线程来这样做（例如，通过预订不同的线程）。 
 *  @author  Rossen Stoyanchev @从5.2开始
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ConnectMapping {

	/**
	 * Mappings expressed by this annotation to match to the route from the
	 * metadata of the initial {@link ConnectionSetupPayload} or in
	 * subsequent metadata pushes.
	 * <p>Depending on the configured
	 * {@link org.springframework.util.RouteMatcher RouteMatcher}, the pattern may be
	 * {@link org.springframework.util.AntPathMatcher AntPathMatcher} or
	 * {@link org.springframework.web.util.pattern.PathPattern PathPattern} based.
	 * <p>By default this is an empty array in which case it matches all
	 * {@link ConnectionSetupPayload} and metadata pushes.
	 */
	/**
	 * 此注释表示的映射要与来自初始{@link  ConnectionSetupPayload}的元数据或后续元数据推送中的路由相匹配。 
	 *  <p>取决于配置的{@link  org.springframework.util.RouteMatcher RouteMatcher}，该模式可以是{@link  org.springframework.util.AntPathMatcher AntPathMatcher}或{@link  org.springframework。 
	 *  web.util.pattern.PathPattern基于PathPattern}。 
	 *  <p>默认情况下，这是一个空数组，在这种情况下，它与所有{@link  ConnectionSetupPayload}和元数据推送匹配。 
	 * 
	 */
	String[] value() default {};

}
