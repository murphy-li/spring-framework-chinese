/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.messaging.handler.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.messaging.Message;

/**
 * Annotation for mapping a {@link Message} onto a message-handling method by
 * matching the declared {@link #value() patterns} to a destination extracted
 * from the message. The annotation is supported at the type-level too, as a
 * way of declaring a pattern prefix (or prefixes) across all class methods.
 *
 * <p>{@code @MessageMapping} methods support the following arguments:
 * <ul>
 * <li>{@link Payload @Payload} method argument to extract the payload of a
 * message and have it de-serialized to the declared target type.
 * {@code @Payload} arguments may also be annotated with Validation annotations
 * such as {@link org.springframework.validation.annotation.Validated @Validated}
 * and will then have JSR-303 validation applied. Keep in mind the annotation
 * is not required to be present as it is assumed by default for arguments not
 * handled otherwise. </li>
 * <li>{@link DestinationVariable @DestinationVariable} method argument for
 * access to template variable values extracted from the message destination,
 * e.g. {@code /hotels/{hotel}}. Variable values may also be converted from
 * String to the declared method argument type, if needed.</li>
 * <li>{@link Header @Header} method argument to extract a specific message
 * header value and have a
 * {@link org.springframework.core.convert.converter.Converter Converter}
 * applied to it to convert the value to the declared target type.</li>
 * <li>{@link Headers @Headers} method argument that is also assignable to
 * {@link java.util.Map} for access to all headers.</li>
 * <li>{@link org.springframework.messaging.MessageHeaders MessageHeaders}
 * method argument for access to all headers.</li>
 * <li>{@link org.springframework.messaging.support.MessageHeaderAccessor
 * MessageHeaderAccessor} method argument for access to all headers.
 * In some processing scenarios, like STOMP over WebSocket, this may also be
 * a specialization such as
 * {@link org.springframework.messaging.simp.SimpMessageHeaderAccessor
 * SimpMessageHeaderAccessor}.</li>
 * <li>{@link Message Message&lt;T&gt;} for access to body and headers with the body
 * de-serialized if necessary to match the declared type.</li>
 * <li>{@link java.security.Principal} method arguments are supported in
 * some processing scenarios such as STOMP over WebSocket. It reflects the
 * authenticated user.</li>
 * </ul>
 *
 * <p>Return value handling depends on the processing scenario:
 * <ul>
 * <li>STOMP over WebSocket -- the value is turned into a message and sent to a
 * default response destination or to a custom destination specified with an
 * {@link SendTo @SendTo} or
 * {@link org.springframework.messaging.simp.annotation.SendToUser @SendToUser}
 * annotation.
 * <li>RSocket -- the response is used to reply to the stream request.
 * </ul>
 *
 * <p>Specializations of this annotation include
 * {@link org.springframework.messaging.simp.annotation.SubscribeMapping @SubscribeMapping}
 * (e.g. STOMP subscriptions) and
 * {@link org.springframework.messaging.rsocket.annotation.ConnectMapping @ConnectMapping}
 * (e.g. RSocket connections). Both narrow the primary mapping further and also match
 * against the message type. Both can be combined with a type-level
 * {@code @MessageMapping} that declares a common pattern prefix (or prefixes).
 *
 * <p>For further details on the use of this annotation in different contexts,
 * see the following sections of the Spring Framework reference:
 * <ul>
 * <li>STOMP over WebSocket
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#websocket-stomp-handle-annotations">
 * "Annotated Controllers"</a>.
 * <li>RSocket
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#rsocket-annot-responders">
 * "Annotated Responders"</a>.
 * </ul>
 *
 * <p><b>NOTE:</b> When using controller interfaces (e.g. for AOP proxying),
 * make sure to consistently put <i>all</i> your mapping annotations - such as
 * {@code @MessageMapping} and {@code @SubscribeMapping} - on
 * the controller <i>interface</i> rather than on the implementation class.
 *
 * @author Rossen Stoyanchev
 * @since 4.0
 * @see org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler
 * @see org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler
 */
/**
 * 通过将声明的{@link  #value（）模式}与从消息中提取的目标进行匹配，来将{@link  Message}映射到消息处理方法的注释。 
 * 类型级别也支持注释，这是一种在所有类方法中声明模式前缀的方法。 
 *  <p> {<@code> @MessageMapping}方法支持以下参数：<ul> <li> {<@link> Payload @Payload}方法参数可提取消息的有效负载并将其反序列化为声明的目标类型。 
 *  {@code  @Payload}参数也可以使用Validation注释进行注释，例如{@link  org.springframework.validation.annotation.Validated @Validated}，然后将应用JSR-303验证。 
 * 请记住，由于默认情况下未对未处理的参数采用默认注释，因此不需要显示注释。 
 *  </ li> <li> {<@link> DestinationVariable @DestinationVariable}方法参数，用于访问从消息目标中提取的模板变量值，例如{@code  / hotels / {hotel}}。 
 * 如果需要，也可以将变量值从String转换为声明的方法参数类型。 
 * </ li> <li> {<@link> Header @Header}方法参数以提取特定的消息标头值并具有{<@link > org.springframework.core.convert.converter.Converter Converter}应用于将值转换为声明的目标类型。 
 * </ li> <li> {<@link> Headers @Headers}方法参数也可分配给{@link  java.util.Map}用于访问所有标头。 
 * </ li> <li> {<@link> org.springframework.messaging.MessageHeaders MessageHeaders}方法参数用于访问所有标头。 
 * </ li> <li> {<@link> org.springframework.messaging.support.MessageHeaderAccessor MessageHeaderAccessor}方法参数，用于访问所有标头。 
 * 在某些处理方案中，例如通过WebSocket的STOMP，这也可能是一种特殊化，例如{@link  org.springframework.messaging.simp.SimpMessageHeaderAccessor SimpMessageHeaderAccessor}。 
 * </ li> <li> {<@link>消息消息< T>}用于访问正文和标头已反序列化的标题（如果需要，以匹配声明的类型）。 
 * </ li> <li> {<@link> java.security.Principal}方法参数在某些处理方案中受支持作为通过WebSocket的STOMP。 
 * 它反映了经过身份验证的用户。 
 * </ li> </ ul> <p>返回值处理取决于处理方案：<ul> <li> WebSocket上的STOMP －将值转换为消息并发送到默认响应目标或使用{@link  SendTo @SendTo}或{@link  org.springframework.messaging.simp.annotation.SendToUser @SendToUser}注释指定的自定义目标。 
 *  <li> RSocket-响应用于答复流请求。 
 *  </ ul> <p>此注解的专业包括{@link  org.springframework.messaging.simp.annotation.SubscribeMapping @SubscribeMapping}（例如STOMP订阅）和{@link  org.springframework.messaging.rsocket。 
 * 注解。 
 * ConnectMapping@ConnectMapping}（例如RSocket连接）。 
 * 两者都进一步缩小了主映射的范围，并且还与消息类型匹配。 
 * 两者都可以与声明一个公共模式前缀（一个或多个前缀）的类型级别{@code  @MessageMapping}结合使用。 
 *  <p>有关在不同上下文中使用此注解的更多详细信息，请参见Spring框架参考的以下部分：<ul> <li>基于WebSocket的STOMP <a href ="https://docs.spring.io/ spring / docs / current / spring-framework-reference / web.html＃websocket-stomp-handle-annotations">"带注释的控制器"</a>。 
 *  <li> RSocket <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#rsocket-annot-responders">"带注释的响应者"</ </一个>。 
 *  </ ul> <p> <b>注意：</ b>使用控制器接口（例如用于AOP代理）时，请确保一致地放置<i>所有</ i>您的映射注释-例如{<@code > @MessageMapping}和{@code  @SubscribeMapping}-在控制器<i>接口</ i>上，而不是在实现类上。 
 *  @author  Rossen Stoyanchev @从4.0开始
 * @see  org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler 
 * @see  org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MessageMapping {

	/**
	 * Destination-based mapping expressed by this annotation.
	 * <p>For STOMP over WebSocket messages this is
	 * {@link org.springframework.util.AntPathMatcher AntPathMatcher}-style
	 * patterns matched against the STOMP destination of the message.
	 * <p>for RSocket this is either
	 * {@link org.springframework.util.AntPathMatcher AntPathMatcher} or
	 * {@link org.springframework.web.util.pattern.PathPattern PathPattern}
	 * based pattern, depending on which is configured, matched to the route of
	 * the stream request.
	 * <p>If no patterns are configured, the mapping matches all destinations.
	 */
	/**
	 * 此注释表示的基于目标的映射。 
	 *  <p>对于基于WebSocket消息的STOMP，这是{@link  org.springframework.util.AntPathMatcher AntPathMatcher}样式的模式，与消息的STOMP目标匹配。 
	 *  <p>对于RSocket，这是{@link  org.springframework.util.AntPathMatcher AntPathMatcher}或{@link  org.springframework.web.util.pattern.PathPattern PathPattern}模式，具体取决于配置的模式，与流请求的路由匹配。 
	 *  <p>如果未配置任何模式，则映射将匹配所有目标。 
	 * 
	 */
	String[] value() default {};

}
