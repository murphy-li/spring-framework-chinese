/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.propertyeditors;

import java.beans.PropertyEditorSupport;

import org.springframework.lang.Nullable;
import org.springframework.util.StringUtils;

/**
 * Property editor for Boolean/boolean properties.
 *
 * <p>This is not meant to be used as system PropertyEditor but rather as
 * locale-specific Boolean editor within custom controller code, to parse
 * UI-caused boolean strings into boolean properties of beans and check
 * them in the UI form.
 *
 * <p>In web MVC code, this editor will typically be registered with
 * {@code binder.registerCustomEditor} calls.
 *
 * @author Juergen Hoeller
 * @since 10.06.2003
 * @see org.springframework.validation.DataBinder#registerCustomEditor
 */
/**
 * 布尔/布尔属性的属性编辑器。 
 *  <p>这并不是要用作系统PropertyEditor，而是用作自定义控制器代码中特定于语言环境的布尔编辑器，以将UI引起的布尔字符串解析为bean的布尔属性，并以UI形式进行检查。 
 *  <p>在Web MVC代码中，通常会通过{@code  inder.registerCustomEditor}调用来注册此编辑器。 
 *  @author  Juergen Hoeller @2003年6月10日以来
 * @see  org.springframework.validation.DataBinder＃registerCustomEditor
 */
public class CustomBooleanEditor extends PropertyEditorSupport {

	/**
	 * Value of {@code "true"}.
	 */
	/**
	 * 值{@code "true"}。 
	 * 
	 */
	public static final String VALUE_TRUE = "true";

	/**
	 * Value of {@code "false"}.
	 */
	/**
	 * 值{@code "false"}。 
	 * 
	 */
	public static final String VALUE_FALSE = "false";

	/**
	 * Value of {@code "on"}.
	 */
	/**
	 * {@code "on"}的值。 
	 * 
	 */
	public static final String VALUE_ON = "on";

	/**
	 * Value of {@code "off"}.
	 */
	/**
	 * 值{@code "off"}。 
	 * 
	 */
	public static final String VALUE_OFF = "off";

	/**
	 * Value of {@code "yes"}.
	 */
	/**
	 * 值{@code "是"}。 
	 * 
	 */
	public static final String VALUE_YES = "yes";

	/**
	 * Value of {@code "no"}.
	 */
	/**
	 * 值{@code "no"}。 
	 * 
	 */
	public static final String VALUE_NO = "no";

	/**
	 * Value of {@code "1"}.
	 */
	/**
	 * 值{@code "1"}。 
	 * 
	 */
	public static final String VALUE_1 = "1";

	/**
	 * Value of {@code "0"}.
	 */
	/**
	 * 值{@code "0"}。 
	 * 
	 */
	public static final String VALUE_0 = "0";


	@Nullable
	private final String trueString;

	@Nullable
	private final String falseString;

	private final boolean allowEmpty;


	/**
	 * Create a new CustomBooleanEditor instance, with "true"/"on"/"yes"
	 * and "false"/"off"/"no" as recognized String values.
	 * <p>The "allowEmpty" parameter states if an empty String should
	 * be allowed for parsing, i.e. get interpreted as null value.
	 * Else, an IllegalArgumentException gets thrown in that case.
	 * @param allowEmpty if empty strings should be allowed
	 */
	/**
	 * 创建一个新的CustomBooleanEditor实例，将"true"/"on"/"yes"和"false"/"off"/"no"作为可识别的String值。 
	 *  <p>"allowEmpty"参数说明是否应允许使用空字符串进行解析，即被解释为空值。 
	 * 否则，在这种情况下将抛出IllegalArgumentException。 
	 *  
	 * @param  allowEmpty如果应该允许空字符串
	 */
	public CustomBooleanEditor(boolean allowEmpty) {
		this(null, null, allowEmpty);
	}

	/**
	 * Create a new CustomBooleanEditor instance,
	 * with configurable String values for true and false.
	 * <p>The "allowEmpty" parameter states if an empty String should
	 * be allowed for parsing, i.e. get interpreted as null value.
	 * Else, an IllegalArgumentException gets thrown in that case.
	 * @param trueString the String value that represents true:
	 * for example, "true" (VALUE_TRUE), "on" (VALUE_ON),
	 * "yes" (VALUE_YES) or some custom value
	 * @param falseString the String value that represents false:
	 * for example, "false" (VALUE_FALSE), "off" (VALUE_OFF),
	 * "no" (VALUE_NO) or some custom value
	 * @param allowEmpty if empty strings should be allowed
	 * @see #VALUE_TRUE
	 * @see #VALUE_FALSE
	 * @see #VALUE_ON
	 * @see #VALUE_OFF
	 * @see #VALUE_YES
	 * @see #VALUE_NO
	 */
	/**
	 * 创建一个新的CustomBooleanEditor实例，并使用true和false的可配置String值。 
	 *  <p>"allowEmpty"参数说明是否应允许使用空字符串进行解析，即被解释为空值。 
	 * 否则，在这种情况下将抛出IllegalArgumentException。 
	 *  
	 * @param  trueString表示true的字符串值：例如，"true"（VALUE_TRUE），"on"（VALUE_ON），"yes"（VALUE_YES）或某些自定义值
	 * @param  falseString表示false的String值：例如，"假"（VALUE_FALSE），"关闭"（VALUE_OFF），"否"（VALUE_NO）或某些自定义值
	 * @param  allowEmpty如果应该允许空字符串
	 * @see  #VALUE_TRUE 
	 * @see ＃ VALUE_FALSE 
	 * @see  #VALUE_ON 
	 * @see  #VALUE_OFF 
	 * @see  #VALUE_YES 
	 * @see  #VALUE_NO
	 */
	public CustomBooleanEditor(@Nullable String trueString, @Nullable String falseString, boolean allowEmpty) {
		this.trueString = trueString;
		this.falseString = falseString;
		this.allowEmpty = allowEmpty;
	}


	@Override
	public void setAsText(@Nullable String text) throws IllegalArgumentException {
		String input = (text != null ? text.trim() : null);
		if (this.allowEmpty && !StringUtils.hasLength(input)) {
			// Treat empty String as null value.
			setValue(null);
		}
		else if (this.trueString != null && this.trueString.equalsIgnoreCase(input)) {
			setValue(Boolean.TRUE);
		}
		else if (this.falseString != null && this.falseString.equalsIgnoreCase(input)) {
			setValue(Boolean.FALSE);
		}
		else if (this.trueString == null &&
				(VALUE_TRUE.equalsIgnoreCase(input) || VALUE_ON.equalsIgnoreCase(input) ||
						VALUE_YES.equalsIgnoreCase(input) || VALUE_1.equals(input))) {
			setValue(Boolean.TRUE);
		}
		else if (this.falseString == null &&
				(VALUE_FALSE.equalsIgnoreCase(input) || VALUE_OFF.equalsIgnoreCase(input) ||
						VALUE_NO.equalsIgnoreCase(input) || VALUE_0.equals(input))) {
			setValue(Boolean.FALSE);
		}
		else {
			throw new IllegalArgumentException("Invalid boolean value [" + text + "]");
		}
	}

	@Override
	public String getAsText() {
		if (Boolean.TRUE.equals(getValue())) {
			return (this.trueString != null ? this.trueString : VALUE_TRUE);
		}
		else if (Boolean.FALSE.equals(getValue())) {
			return (this.falseString != null ? this.falseString : VALUE_FALSE);
		}
		else {
			return "";
		}
	}

}
