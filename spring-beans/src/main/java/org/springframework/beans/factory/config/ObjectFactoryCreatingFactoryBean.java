/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.config;

import java.io.Serializable;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * A {@link org.springframework.beans.factory.FactoryBean} implementation that
 * returns a value which is an {@link org.springframework.beans.factory.ObjectFactory}
 * that in turn returns a bean sourced from a {@link org.springframework.beans.factory.BeanFactory}.
 *
 * <p>As such, this may be used to avoid having a client object directly calling
 * {@link org.springframework.beans.factory.BeanFactory#getBean(String)} to get
 * a (typically prototype) bean from a
 * {@link org.springframework.beans.factory.BeanFactory}, which would be a
 * violation of the inversion of control principle. Instead, with the use
 * of this class, the client object can be fed an
 * {@link org.springframework.beans.factory.ObjectFactory} instance as a
 * property which directly returns only the one target bean (again, which is
 * typically a prototype bean).
 *
 * <p>A sample config in an XML-based
 * {@link org.springframework.beans.factory.BeanFactory} might look as follows:
 *
 * <pre class="code">&lt;beans&gt;
 *
 *   &lt;!-- Prototype bean since we have state --&gt;
 *   &lt;bean id="myService" class="a.b.c.MyService" scope="prototype"/&gt;
 *
 *   &lt;bean id="myServiceFactory"
 *       class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"&gt;
 *     &lt;property name="targetBeanName"&gt;&lt;idref local="myService"/&gt;&lt;/property&gt;
 *   &lt;/bean&gt;
 *
 *   &lt;bean id="clientBean" class="a.b.c.MyClientBean"&gt;
 *     &lt;property name="myServiceFactory" ref="myServiceFactory"/&gt;
 *   &lt;/bean&gt;
 *
 *&lt;/beans&gt;</pre>
 *
 * <p>The attendant {@code MyClientBean} class implementation might look
 * something like this:
 *
 * <pre class="code">package a.b.c;
 *
 * import org.springframework.beans.factory.ObjectFactory;
 *
 * public class MyClientBean {
 *
 *   private ObjectFactory&lt;MyService&gt; myServiceFactory;
 *
 *   public void setMyServiceFactory(ObjectFactory&lt;MyService&gt; myServiceFactory) {
 *     this.myServiceFactory = myServiceFactory;
 *   }
 *
 *   public void someBusinessMethod() {
 *     // get a 'fresh', brand new MyService instance
 *     MyService service = this.myServiceFactory.getObject();
 *     // use the service object to effect the business logic...
 *   }
 * }</pre>
 *
 * <p>An alternate approach to this application of an object creational pattern
 * would be to use the {@link ServiceLocatorFactoryBean}
 * to source (prototype) beans. The {@link ServiceLocatorFactoryBean} approach
 * has the advantage of the fact that one doesn't have to depend on any
 * Spring-specific interface such as {@link org.springframework.beans.factory.ObjectFactory},
 * but has the disadvantage of requiring runtime class generation. Please do
 * consult the {@link ServiceLocatorFactoryBean ServiceLocatorFactoryBean JavaDoc}
 * for a fuller discussion of this issue.
 *
 * @author Colin Sampaleanu
 * @author Juergen Hoeller
 * @since 1.0.2
 * @see org.springframework.beans.factory.ObjectFactory
 * @see ServiceLocatorFactoryBean
 */
/**
 * 一个{@link  org.springframework.beans.factory.FactoryBean}实现，返回一个值为{@link  org.springframework.beans.factory.ObjectFactory}的值，该值又返回一个源自{@link  org.springframework.beans.factory.BeanFactory}。 
 *  <p>这样，这可以避免客户端对象直接调用{@link  org.springframework.beans.factory.BeanFactory＃getBean（String）}来从{@link  org.springframework.beans.factory.BeanFactory}，这将违反控制原理的规定。 
 * 相反，使用此类可以为客户对象提供{@link  org.springframework.beans.factory.ObjectFactory}实例作为直接返回一个目标Bean的属性（再次，通常是一个目标Bean）。 
 * 原型豆）。 
 *  <p>基于XML的{@link  org.springframework.beans.factory.BeanFactory}中的示例配置可能如下所示：<pre class ="code"> <beans> <！ 
 * -原型bean，因为我们具有状态-> <bean id ="myService"class ="abcMyService"scope ="prototype"/> <bean id ="myServiceFactory"class ="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"> <属性name ="targetBeanName"> <idref local ="myService"/> </ property> </ bean> <bean id ="clientBean"class ="abcMyClientBean"> <property name ="myServiceFactory"ref ="myServiceFactory"/ > </ bean> </ beans> </ pre> <p>伴随的{@code  MyClientBean}类实现可能看起来像这样：<pre class ="code"> package abc;导入org.springframework.beans.factory.ObjectFactory;公共类MyClientBean {私有ObjectFactory <MyService> myServiceFactory;公共无效setMyServiceFactory（ObjectFactory <MyService> myServiceFactory）{this.myServiceFactory = myServiceFactory; } public void someBusinessMethod（）{//获得一个"新的"全新MyService实例MyService service = this.myServiceFactory.getObject（）; //使用服务对象来实现业务逻辑...} </ pre> <p>此对象创建模式应用程序的另一种方法是使用{@link  ServiceLocatorFactoryBean}作为源（原型） 豆子。 
 *  {@link  ServiceLocatorFactoryBean}方法的优势在于，不必依赖于任何特定于Spring的接口，例如{@link  org.springframework.beans.factory.ObjectFactory}，但具有以下优点：需要运行时类生成的缺点。 
 * 请确实参考{​​@link  ServiceLocatorFactoryBean ServiceLocatorFactoryBean JavaDoc}，以获取有关此问题的更完整讨论。 
 *  @author  Colin Sampaleanu @author  Juergen Hoeller @始于1.0.2 
 * @see  org.springframework.beans.factory.ObjectFactory 
 * @see  ServiceLocatorFactoryBean
 */
public class ObjectFactoryCreatingFactoryBean extends AbstractFactoryBean<ObjectFactory<Object>> {

	@Nullable
	private String targetBeanName;


	/**
	 * Set the name of the target bean.
	 * <p>The target does not <i>have</i> to be a non-singleton bean, but realistically
	 * always will be (because if the target bean were a singleton, then said singleton
	 * bean could simply be injected straight into the dependent object, thus obviating
	 * the need for the extra level of indirection afforded by this factory approach).
	 */
	/**
	 * 设置目标bean的名称。 
	 *  <p>目标不是<i>不是非单例bean，但实际上总是这样（因为如果目标bean是单例，则可以简单地将单例bean直接注入从属豆中。 
	 * 对象，从而消除了这种工厂方法所提供的额外的间接级别需求。 
	 * 
	 */
	public void setTargetBeanName(String targetBeanName) {
		this.targetBeanName = targetBeanName;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		Assert.hasText(this.targetBeanName, "Property 'targetBeanName' is required");
		super.afterPropertiesSet();
	}


	@Override
	public Class<?> getObjectType() {
		return ObjectFactory.class;
	}

	@Override
	protected ObjectFactory<Object> createInstance() {
		BeanFactory beanFactory = getBeanFactory();
		Assert.state(beanFactory != null, "No BeanFactory available");
		Assert.state(this.targetBeanName != null, "No target bean name specified");
		return new TargetBeanObjectFactory(beanFactory, this.targetBeanName);
	}


	/**
	 * Independent inner class - for serialization purposes.
	 */
	/**
	 * 独立的内部类-用于序列化目的。 
	 * 
	 */
	@SuppressWarnings("serial")
	private static class TargetBeanObjectFactory implements ObjectFactory<Object>, Serializable {

		private final BeanFactory beanFactory;

		private final String targetBeanName;

		public TargetBeanObjectFactory(BeanFactory beanFactory, String targetBeanName) {
			this.beanFactory = beanFactory;
			this.targetBeanName = targetBeanName;
		}

		@Override
		public Object getObject() throws BeansException {
			return this.beanFactory.getBean(this.targetBeanName);
		}
	}

}
