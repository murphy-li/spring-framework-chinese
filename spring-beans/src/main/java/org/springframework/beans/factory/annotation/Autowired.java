/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks a constructor, field, setter method, or config method as to be autowired by
 * Spring's dependency injection facilities. This is an alternative to the JSR-330
 * {@link javax.inject.Inject} annotation, adding required-vs-optional semantics.
 *
 * <h3>Autowired Constructors</h3>
 * <p>Only one constructor of any given bean class may declare this annotation with the
 * {@link #required} attribute set to {@code true}, indicating <i>the</i> constructor
 * to autowire when used as a Spring bean. Furthermore, if the {@code required}
 * attribute is set to {@code true}, only a single constructor may be annotated
 * with {@code @Autowired}. If multiple <i>non-required</i> constructors declare the
 * annotation, they will be considered as candidates for autowiring. The constructor
 * with the greatest number of dependencies that can be satisfied by matching beans
 * in the Spring container will be chosen. If none of the candidates can be satisfied,
 * then a primary/default constructor (if present) will be used. If a class only
 * declares a single constructor to begin with, it will always be used, even if not
 * annotated. An annotated constructor does not have to be public.
 *
 * <h3>Autowired Fields</h3>
 * <p>Fields are injected right after construction of a bean, before any config methods
 * are invoked. Such a config field does not have to be public.
 *
 * <h3>Autowired Methods</h3>
 * <p>Config methods may have an arbitrary name and any number of arguments; each of
 * those arguments will be autowired with a matching bean in the Spring container.
 * Bean property setter methods are effectively just a special case of such a general
 * config method. Such config methods do not have to be public.
 *
 * <h3>Autowired Parameters</h3>
 * <p>Although {@code @Autowired} can technically be declared on individual method
 * or constructor parameters since Spring Framework 5.0, most parts of the
 * framework ignore such declarations. The only part of the core Spring Framework
 * that actively supports autowired parameters is the JUnit Jupiter support in
 * the {@code spring-test} module (see the
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di">TestContext framework</a>
 * reference documentation for details).
 *
 * <h3>Multiple Arguments and 'required' Semantics</h3>
 * <p>In the case of a multi-arg constructor or method, the {@link #required} attribute
 * is applicable to all arguments. Individual parameters may be declared as Java-8 style
 * {@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable}
 * or a not-null parameter type in Kotlin, overriding the base 'required' semantics.
 *
 * <h3>Autowiring Arrays, Collections, and Maps</h3>
 * <p>In case of an array, {@link java.util.Collection}, or {@link java.util.Map}
 * dependency type, the container autowires all beans matching the declared value
 * type. For such purposes, the map keys must be declared as type {@code String}
 * which will be resolved to the corresponding bean names. Such a container-provided
 * collection will be ordered, taking into account
 * {@link org.springframework.core.Ordered Ordered} and
 * {@link org.springframework.core.annotation.Order @Order} values of the target
 * components, otherwise following their registration order in the container.
 * Alternatively, a single matching target bean may also be a generally typed
 * {@code Collection} or {@code Map} itself, getting injected as such.
 *
 * <h3>Not supported in {@code BeanPostProcessor} or {@code BeanFactoryPostProcessor}</h3>
 * <p>Note that actual injection is performed through a
 * {@link org.springframework.beans.factory.config.BeanPostProcessor
 * BeanPostProcessor} which in turn means that you <em>cannot</em>
 * use {@code @Autowired} to inject references into
 * {@link org.springframework.beans.factory.config.BeanPostProcessor
 * BeanPostProcessor} or
 * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}
 * types. Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor}
 * class (which, by default, checks for the presence of this annotation).
 *
 * @author Juergen Hoeller
 * @author Mark Fisher
 * @author Sam Brannen
 * @since 2.5
 * @see AutowiredAnnotationBeanPostProcessor
 * @see Qualifier
 * @see Value
 */
/**
 * 将构造函数，字段，setter方法或config方法标记为由Spring的依赖项注入工具自动装配。 
 * 这是JSR-330 {@link  javax.inject.Inject}注释的替代方法，添加了required-vs-optional语义。 
 *  <h3>自动装配构造函数</ h3> <p>任何给定bean类的构造函数都只能使用{@link  #required}属性设置为{@code  true}的声明此注解，表示<i> </ i>构造函数在用作Spring bean时可以自动装配。 
 * 此外，如果{@code  required}属性设置为{@code  true}，则只有单个构造函数可以用{@code  @Autowired}进行注释。 
 * 如果多个<i>非必需</ i>构造函数声明了注释，则它们将被视为自动装配的候选对象。 
 * 将选择通过匹配Spring容器中的bean可以满足的依赖关系数量最多的构造函数。 
 * 如果没有一个候选者满意，则将使用主/默认构造函数（如果存在）。 
 * 如果一个类仅声明一个单一的构造函数开始，即使没有注释，也将始终使用它。 
 * 带注释的构造函数不必是公共的。 
 *  <h3>自动装配字段</ h3> <p>在构造任何bean之后，调用任何配置方法之前立即注入字段。 
 * 这样的配置字段不必是公共的。 
 *  <h3>自动装配方法</ h3> <p>配置方法可以具有任意名称和任意数量的参数； 
 * 这些参数中的每个参数都将与Spring容器中的匹配bean自动装配在一起。 
 *  Bean属性设置器方法实际上只是这种常规config方法的特例。 
 * 这样的配置方法不必是公共的。 
 *  <h3>自动装配参数</ h3> <p>尽管从Spring Framework 5.0开始，可以在单个方法或构造函数参数上声明{@code  @Autowired}，但该框架的大多数部分都忽略了此类声明。 
 * 主动支持自动装配参数的核心Spring框架的唯一部分是{@code  spring-test}模块中的JUnit Jupiter支持（请参见<a href ="https://docs.spring.io/spring/ docs / current / spring-framework-reference / testing.html＃testcontext-junit-jupiter-di"> TestContext框架</a>参考文档以了解详细信息）。 
 *  <h3>多个参数和"必选"语义</ h3> <p>对于多参数构造函数或方法，{<@link> #required}属性适用于所有参数。 
 * 各个参数可以声明为Java-8样式的{@link  java.util.Optional}，或者从Spring Framework 5.0开始，也可以声明为{@code  @Nullable}或Kotlin中的非空参数类型，覆盖基本的"必需"语义。 
 *  <h3>自动装配数组，集合和映射</ h3> <p>如果是数组，{<@link> java.util.Collection}或{@link  java.util.Map}依赖项类型，容器自动装配所有与声明值类型匹配的bean。 
 * 为此，必须将映射键声明为{@code  String}类型，它将解析为相应的bean名称。 
 * 将考虑目标组件的{@link  org.springframework.core.Ordered Ordered}和{@link  org.springframework.core.annotation.Order @Order}值，对此类容器提供的集合进行排序。 
 *  ，否则请遵循其在容器中的注册顺序。 
 * 替代地，单个匹配的目标bean也可以是通常键入的{@code  Collection}或{@code  Map}本身，就这样注入。 
 *  <h3> {<@code> BeanPostProcessor}或{@code  BeanFactoryPostProcessor}中不支持</ h3> <p>请注意，实际注入是通过{@link  org.springframework.beans.factory.config执行的.BeanPostProcessor BeanPostProcessor}意味着您<em>不能</ em>使用{@code  @Autowired}将引用注入到{@link  org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor}中，或者{@link  org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}类型。 
 * 请查阅javadoc中的{@link  AutowiredAnnotationBeanPostProcessor}类（默认情况下，该类检查此注释的存在）。 
 *  @author  Juergen Hoeller @author  Mark Fisher @author  Sam Brannen @since 2.5 
 * @see  AutowiredAnnotationBeanPostProcessor 
 * @see 限定符
 * @see 值
 */
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {

	/**
	 * Declares whether the annotated dependency is required.
	 * <p>Defaults to {@code true}.
	 */
	/**
	 * 声明是否需要带注释的依赖项。 
	 *  <p>默认为{@code  true}。 
	 * 
	 */
	boolean required() default true;

}
