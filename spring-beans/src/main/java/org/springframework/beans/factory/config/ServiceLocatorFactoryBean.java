/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.config;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Properties;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.BeansException;
import org.springframework.beans.FatalBeanException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * A {@link FactoryBean} implementation that takes an interface which must have one or more
 * methods with the signatures {@code MyType xxx()} or {@code MyType xxx(MyIdType id)}
 * (typically, {@code MyService getService()} or {@code MyService getService(String id)})
 * and creates a dynamic proxy which implements that interface, delegating to an
 * underlying {@link org.springframework.beans.factory.BeanFactory}.
 *
 * <p>Such service locators permit the decoupling of calling code from
 * the {@link org.springframework.beans.factory.BeanFactory} API, by using an
 * appropriate custom locator interface. They will typically be used for
 * <b>prototype beans</b>, i.e. for factory methods that are supposed to
 * return a new instance for each call. The client receives a reference to the
 * service locator via setter or constructor injection, to be able to invoke
 * the locator's factory methods on demand. <b>For singleton beans, direct
 * setter or constructor injection of the target bean is preferable.</b>
 *
 * <p>On invocation of the no-arg factory method, or the single-arg factory
 * method with a String id of {@code null} or empty String, if exactly
 * <b>one</b> bean in the factory matches the return type of the factory
 * method, that bean is returned, otherwise a
 * {@link org.springframework.beans.factory.NoSuchBeanDefinitionException}
 * is thrown.
 *
 * <p>On invocation of the single-arg factory method with a non-null (and
 * non-empty) argument, the proxy returns the result of a
 * {@link org.springframework.beans.factory.BeanFactory#getBean(String)} call,
 * using a stringified version of the passed-in id as bean name.
 *
 * <p>A factory method argument will usually be a String, but can also be an
 * int or a custom enumeration type, for example, stringified via
 * {@code toString}. The resulting String can be used as bean name as-is,
 * provided that corresponding beans are defined in the bean factory.
 * Alternatively, {@linkplain #setServiceMappings(java.util.Properties) a custom
 * mapping} between service IDs and bean names can be defined.
 *
 * <p>By way of an example, consider the following service locator interface.
 * Note that this interface is not dependent on any Spring APIs.
 *
 * <pre class="code">package a.b.c;
 *
 *public interface ServiceFactory {
 *
 *    public MyService getService();
 *}</pre>
 *
 * <p>A sample config in an XML-based
 * {@link org.springframework.beans.factory.BeanFactory} might look as follows:
 *
 * <pre class="code">&lt;beans>
 *
 *   &lt;!-- Prototype bean since we have state -->
 *   &lt;bean id="myService" class="a.b.c.MyService" singleton="false"/>
 *
 *   &lt;!-- will lookup the above 'myService' bean by *TYPE* -->
 *   &lt;bean id="myServiceFactory"
 *            class="org.springframework.beans.factory.config.ServiceLocatorFactoryBean">
 *     &lt;property name="serviceLocatorInterface" value="a.b.c.ServiceFactory"/>
 *   &lt;/bean>
 *
 *   &lt;bean id="clientBean" class="a.b.c.MyClientBean">
 *     &lt;property name="myServiceFactory" ref="myServiceFactory"/>
 *   &lt;/bean>
 *
 *&lt;/beans></pre>
 *
 * <p>The attendant {@code MyClientBean} class implementation might then
 * look something like this:
 *
 * <pre class="code">package a.b.c;
 *
 *public class MyClientBean {
 *
 *    private ServiceFactory myServiceFactory;
 *
 *    // actual implementation provided by the Spring container
 *    public void setServiceFactory(ServiceFactory myServiceFactory) {
 *        this.myServiceFactory = myServiceFactory;
 *    }
 *
 *    public void someBusinessMethod() {
 *        // get a 'fresh', brand new MyService instance
 *        MyService service = this.myServiceFactory.getService();
 *        // use the service object to effect the business logic...
 *    }
 *}</pre>
 *
 * <p>By way of an example that looks up a bean <b>by name</b>, consider
 * the following service locator interface. Again, note that this
 * interface is not dependent on any Spring APIs.
 *
 * <pre class="code">package a.b.c;
 *
 *public interface ServiceFactory {
 *
 *    public MyService getService (String serviceName);
 *}</pre>
 *
 * <p>A sample config in an XML-based
 * {@link org.springframework.beans.factory.BeanFactory} might look as follows:
 *
 * <pre class="code">&lt;beans>
 *
 *   &lt;!-- Prototype beans since we have state (both extend MyService) -->
 *   &lt;bean id="specialService" class="a.b.c.SpecialService" singleton="false"/>
 *   &lt;bean id="anotherService" class="a.b.c.AnotherService" singleton="false"/>
 *
 *   &lt;bean id="myServiceFactory"
 *            class="org.springframework.beans.factory.config.ServiceLocatorFactoryBean">
 *     &lt;property name="serviceLocatorInterface" value="a.b.c.ServiceFactory"/>
 *   &lt;/bean>
 *
 *   &lt;bean id="clientBean" class="a.b.c.MyClientBean">
 *     &lt;property name="myServiceFactory" ref="myServiceFactory"/>
 *   &lt;/bean>
 *
 *&lt;/beans></pre>
 *
 * <p>The attendant {@code MyClientBean} class implementation might then
 * look something like this:
 *
 * <pre class="code">package a.b.c;
 *
 *public class MyClientBean {
 *
 *    private ServiceFactory myServiceFactory;
 *
 *    // actual implementation provided by the Spring container
 *    public void setServiceFactory(ServiceFactory myServiceFactory) {
 *        this.myServiceFactory = myServiceFactory;
 *    }
 *
 *    public void someBusinessMethod() {
 *        // get a 'fresh', brand new MyService instance
 *        MyService service = this.myServiceFactory.getService("specialService");
 *        // use the service object to effect the business logic...
 *    }
 *
 *    public void anotherBusinessMethod() {
 *        // get a 'fresh', brand new MyService instance
 *        MyService service = this.myServiceFactory.getService("anotherService");
 *        // use the service object to effect the business logic...
 *    }
 *}</pre>
 *
 * <p>See {@link ObjectFactoryCreatingFactoryBean} for an alternate approach.
 *
 * @author Colin Sampaleanu
 * @author Juergen Hoeller
 * @since 1.1.4
 * @see #setServiceLocatorInterface
 * @see #setServiceMappings
 * @see ObjectFactoryCreatingFactoryBean
 */
/**
 * 一个{<< @link >> FactoryBean}实现，该实现采用一个接口，该接口必须具有一个或多个带有签名{<< @code >> MyType xxx（）}或{<< @code >> MyType xxx（MyIdType id ）}（通常为{<< @code >> MyService getService（）}或{<< @code >> MyService getService（String id）}），并创建一个实现该接口的动态代理，委托给基础的{<< @link >> org.springframework.beans.factory.BeanFactory}。 
 *  <p>通过使用适当的自定义定位器接口，此类服务定位器允许从{<< @link >> org.springframework.beans.factory.BeanFactory} API解耦调用代码。 
 * 它们通常用于<b>原型bean </ b>，即用于工厂方法，该方法应为每次调用返回一个新实例。 
 * 客户端通过设置器或构造函数注入接收对服务定位器的引用，以便能够按需调用定位器的工厂方法。 
 *  <b>对于单例bean，最好直接注入目标bean的setter或构造方法。 
 * </ b> <p>调用no-arg工厂方法或String id为{< <@code >> null}或为空字符串，如果工厂中的<b>一个</ b> bean与工厂方法的返回类型完全匹配，则返回该bean，否则返回{<< @link >>组织。 
 * 抛出springframework.beans.factory.NoSuchBeanDefinitionException}。 
 *  <p>在使用非空（且非空）参数调用单参数工厂方法时，代理将返回{<< @link >> org.springframework.beans.factory.BeanFactory＃getBean的结果（字符串）}调用，使用传入ID的字符串化版本作为Bean名称。 
 *  <p>工厂方法的参数通常是字符串，但也可以是int或自定义枚举类型，例如，通过{<< @code >> toString}进行了字符串化。 
 * 如果在bean工厂中定义了相应的bean，则所得的String可以按原样用作bean名称。 
 * 或者，可以定义服务ID和Bean名称之间的{<< @link >> plain #setServiceMappings（java.util.Properties）自定义映射}。 
 *  <p>通过一个示例，考虑以下服务定位器接口。 
 * 请注意，此接口不依赖于任何Spring API。 
 *  <pre class ="code">包装a.b.c;公共接口ServiceFactory {public MyService getService（）; } </ pre> <p>基于XML的{<< @link >> org.springframework.beans.factory.BeanFactory}中的示例配置可能如下所示：<pre class ="code"> <beans> < ！ 
 * -原型bean，因为我们有状态-> <bean id ="myService"class ="abcMyService"singleton ="false"/> <！ 
 * -将通过TYPE查找上面的'myService'bean –> < bean id ="myServiceFactory"class ="org.springframework.beans.factory.config.ServiceLocatorFactoryBean"> <属性名="serviceLocatorInterface"value ="abcServiceFactory"/> </ bean> <bean id ="clientBean"class = "abcMyClientBean"> <属性名称="myServiceFactory"ref ="myServiceFactory"/> </ bean> </ beans> </ pre> <p>随之而来的{<< @code >> MyClientBean}类实现像这样：<pre class ="code"> package abc;公共类MyClientBean {私有ServiceFactory myServiceFactory; //由Spring容器提供的实际实现。 
 * public void setServiceFactory（ServiceFactory myServiceFactory）{this.myServiceFactory = myServiceFactory; } public void someBusinessMethod（）{//获得一个"新的"全新MyService实例MyService service = this.myServiceFactory.getService（）; //使用服务对象来实现业务逻辑...} </ pre> <p>通过以名称查找bean <b>的示例</ b>，请考虑以下服务定位器接口。 
 * 再次注意，此接口不依赖于任何Spring API
 */
/**
 * <pre class ="code">包装a.b.c;公共接口ServiceFactory {public MyService getService（String serviceName）; } </ pre> <p>基于XML的{<< @link >> org.springframework.beans.factory.BeanFactory}中的示例配置可能如下所示：<pre class ="code"> <beans> < ！ 
 * -原型bean，因为我们有状态（都扩展了MyService）-> <bean id ="specialService"class ="abcSpecialService"singleton ="false"/> <bean id ="anotherService"class ="abcAnotherService"singleton ="false"/> <bean id ="myServiceFactory"class ="org.springframework.beans.factory.config.ServiceLocatorFactoryBean"> <属性名称="serviceLocatorInterface"value ="abcServiceFactory"/> </ bean> < bean id ="clientBean"class ="abcMyClientBean"> <属性名称="myServiceFactory"ref ="myServiceFactory"/> </ bean> </ beans> </ pre> <p>服务员{<< @@> > MyClientBean}类的实现可能看起来像这样：<pre class ="code"> package abc;公共类MyClientBean {私有ServiceFactory myServiceFactory; //由Spring容器提供的实际实现。 
 * public void setServiceFactory（ServiceFactory myServiceFactory）{this.myServiceFactory = myServiceFactory; } public void someBusinessMethod（）{//获得一个"新的"全新MyService实例MyService service = this.myServiceFactory.getService（"specialService"）; // //使用服务对象来实现业务逻辑...} public void anotherBusinessMethod（）{//获得一个"新的"全新MyService实例MyService service = this.myServiceFactory.getService（"anotherService"）; //使用服务对象来实现业务逻辑...} </ pre> <p>有关替代方法，请参见{<< @link >> ObjectFactoryCreatingFactoryBean}。 
 *  << @author >>科林·桑帕林（Colin Sampaleanu）<< @author >> Juergen Hoeller @始于1.1.4 << 
 * @see >> #setServiceLocatorInterface << 
 * @see >> #setServiceMappings << 
 * @see >> ObjectFactoryCreatingFactoryBean
 */
public class ServiceLocatorFactoryBean implements FactoryBean<Object>, BeanFactoryAware, InitializingBean {

	@Nullable
	private Class<?> serviceLocatorInterface;

	@Nullable
	private Constructor<Exception> serviceLocatorExceptionConstructor;

	@Nullable
	private Properties serviceMappings;

	@Nullable
	private ListableBeanFactory beanFactory;

	@Nullable
	private Object proxy;


	/**
	 * Set the service locator interface to use, which must have one or more methods with
	 * the signatures {@code MyType xxx()} or {@code MyType xxx(MyIdType id)}
	 * (typically, {@code MyService getService()} or {@code MyService getService(String id)}).
	 * See the {@link ServiceLocatorFactoryBean class-level Javadoc} for
	 * information on the semantics of such methods.
	 */
	/**
	 * 设置要使用的服务定位器接口，该接口必须具有一个或多个带有签名{@code  MyType xxx（）}或{@code  MyType xxx（MyIdType id）}（通常为{@code  MyService）的方法getService（）}或{@code  MyService getService（String id）}）。 
	 * 有关此类方法的语义的信息，请参见{@link  ServiceLocatorFactoryBean类级Javadoc}。 
	 * 
	 */
	public void setServiceLocatorInterface(Class<?> interfaceType) {
		this.serviceLocatorInterface = interfaceType;
	}

	/**
	 * Set the exception class that the service locator should throw if service
	 * lookup failed. The specified exception class must have a constructor
	 * with one of the following parameter types: {@code (String, Throwable)}
	 * or {@code (Throwable)} or {@code (String)}.
	 * <p>If not specified, subclasses of Spring's BeansException will be thrown,
	 * for example NoSuchBeanDefinitionException. As those are unchecked, the
	 * caller does not need to handle them, so it might be acceptable that
	 * Spring exceptions get thrown as long as they are just handled generically.
	 * @see #determineServiceLocatorExceptionConstructor
	 * @see #createServiceLocatorException
	 */
	/**
	 * 设置在服务查找失败时服务定位器应引发的异常类。 
	 * 指定的异常类必须具有带有以下参数类型之一的构造函数：{@code （字符串，可抛出）}或{@code （可抛出）}或{@code （字符串）}。 
	 *  <p>如果未指定，将抛出Spring BeansException的子类，例如NoSuchBeanDefinitionException。 
	 * 由于那些未检查的对象，调用者不需要处理它们，因此只要对它们进行一般处理，就可以抛出Spring异常，这是可以接受的。 
	 *  
	 * @see  #determineServiceLocatorExceptionConstructor 
	 * @see  #createServiceLocatorException
	 */
	public void setServiceLocatorExceptionClass(Class<? extends Exception> serviceLocatorExceptionClass) {
		this.serviceLocatorExceptionConstructor =
				determineServiceLocatorExceptionConstructor(serviceLocatorExceptionClass);
	}

	/**
	 * Set mappings between service ids (passed into the service locator)
	 * and bean names (in the bean factory). Service ids that are not defined
	 * here will be treated as bean names as-is.
	 * <p>The empty string as service id key defines the mapping for {@code null} and
	 * empty string, and for factory methods without parameter. If not defined,
	 * a single matching bean will be retrieved from the bean factory.
	 * @param serviceMappings mappings between service ids and bean names,
	 * with service ids as keys as bean names as values
	 */
	/**
	 * 设置服务ID（传递到服务定位器中）和Bean名称（在Bean工厂中）之间的映射。 
	 * 此处未定义的服务ID将按原样视为Bean名称。 
	 *  <p>空字符串作为服务ID密钥定义{@code  null}和空字符串以及无参数的工厂方法的映射。 
	 * 如果未定义，则将从Bean工厂中检索单个匹配的Bean。 
	 *  
	 * @param  service映射服务ID和Bean名称之间的映射，其中服务ID作为键，Bean名称作为值
	 */
	public void setServiceMappings(Properties serviceMappings) {
		this.serviceMappings = serviceMappings;
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		if (!(beanFactory instanceof ListableBeanFactory)) {
			throw new FatalBeanException(
					"ServiceLocatorFactoryBean needs to run in a BeanFactory that is a ListableBeanFactory");
		}
		this.beanFactory = (ListableBeanFactory) beanFactory;
	}

	@Override
	public void afterPropertiesSet() {
		if (this.serviceLocatorInterface == null) {
			throw new IllegalArgumentException("Property 'serviceLocatorInterface' is required");
		}

		// Create service locator proxy.
		this.proxy = Proxy.newProxyInstance(
				this.serviceLocatorInterface.getClassLoader(),
				new Class<?>[] {this.serviceLocatorInterface},
				new ServiceLocatorInvocationHandler());
	}


	/**
	 * Determine the constructor to use for the given service locator exception
	 * class. Only called in case of a custom service locator exception.
	 * <p>The default implementation looks for a constructor with one of the
	 * following parameter types: {@code (String, Throwable)}
	 * or {@code (Throwable)} or {@code (String)}.
	 * @param exceptionClass the exception class
	 * @return the constructor to use
	 * @see #setServiceLocatorExceptionClass
	 */
	/**
	 * 确定用于给定服务定位符异常类的构造函数。 
	 * 仅在自定义服务定位符异常的情况下调用。 
	 *  <p>默认实现会寻找具有以下参数类型之一的构造函数：{@code （字符串，可抛出）}或{@code （可抛出）}或{@code （字符串）}。 
	 *  
	 * @param  exceptionClass异常类
	 * @return 构造函数以使用
	 * @see  #setServiceLocatorExceptionClass
	 */
	@SuppressWarnings("unchecked")
	protected Constructor<Exception> determineServiceLocatorExceptionConstructor(Class<? extends Exception> exceptionClass) {
		try {
			return (Constructor<Exception>) exceptionClass.getConstructor(String.class, Throwable.class);
		}
		catch (NoSuchMethodException ex) {
			try {
				return (Constructor<Exception>) exceptionClass.getConstructor(Throwable.class);
			}
			catch (NoSuchMethodException ex2) {
				try {
					return (Constructor<Exception>) exceptionClass.getConstructor(String.class);
				}
				catch (NoSuchMethodException ex3) {
					throw new IllegalArgumentException(
							"Service locator exception [" + exceptionClass.getName() +
							"] neither has a (String, Throwable) constructor nor a (String) constructor");
				}
			}
		}
	}

	/**
	 * Create a service locator exception for the given cause.
	 * Only called in case of a custom service locator exception.
	 * <p>The default implementation can handle all variations of
	 * message and exception arguments.
	 * @param exceptionConstructor the constructor to use
	 * @param cause the cause of the service lookup failure
	 * @return the service locator exception to throw
	 * @see #setServiceLocatorExceptionClass
	 */
	/**
	 * 为给定原因创建服务定位器异常。 
	 * 仅在自定义服务定位符异常的情况下调用。 
	 *  <p>默认实现可以处理message和exception参数的所有变体。 
	 *  
	 * @param  exceptionConstructor构造函数使用
	 * @param 导致服务查找失败的原因
	 * @return 服务定位器异常引发
	 * @see  #setServiceLocatorExceptionClass
	 */
	protected Exception createServiceLocatorException(Constructor<Exception> exceptionConstructor, BeansException cause) {
		Class<?>[] paramTypes = exceptionConstructor.getParameterTypes();
		Object[] args = new Object[paramTypes.length];
		for (int i = 0; i < paramTypes.length; i++) {
			if (String.class == paramTypes[i]) {
				args[i] = cause.getMessage();
			}
			else if (paramTypes[i].isInstance(cause)) {
				args[i] = cause;
			}
		}
		return BeanUtils.instantiateClass(exceptionConstructor, args);
	}


	@Override
	@Nullable
	public Object getObject() {
		return this.proxy;
	}

	@Override
	public Class<?> getObjectType() {
		return this.serviceLocatorInterface;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}


	/**
	 * Invocation handler that delegates service locator calls to the bean factory.
	 */
	/**
	 * 将服务定位器调用委派给Bean工厂的调用处理程序。 
	 * 
	 */
	private class ServiceLocatorInvocationHandler implements InvocationHandler {

		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			if (ReflectionUtils.isEqualsMethod(method)) {
				// Only consider equal when proxies are identical.
				return (proxy == args[0]);
			}
			else if (ReflectionUtils.isHashCodeMethod(method)) {
				// Use hashCode of service locator proxy.
				return System.identityHashCode(proxy);
			}
			else if (ReflectionUtils.isToStringMethod(method)) {
				return "Service locator: " + serviceLocatorInterface;
			}
			else {
				return invokeServiceLocatorMethod(method, args);
			}
		}

		private Object invokeServiceLocatorMethod(Method method, Object[] args) throws Exception {
			Class<?> serviceLocatorMethodReturnType = getServiceLocatorMethodReturnType(method);
			try {
				String beanName = tryGetBeanName(args);
				Assert.state(beanFactory != null, "No BeanFactory available");
				if (StringUtils.hasLength(beanName)) {
					// Service locator for a specific bean name
					return beanFactory.getBean(beanName, serviceLocatorMethodReturnType);
				}
				else {
					// Service locator for a bean type
					return beanFactory.getBean(serviceLocatorMethodReturnType);
				}
			}
			catch (BeansException ex) {
				if (serviceLocatorExceptionConstructor != null) {
					throw createServiceLocatorException(serviceLocatorExceptionConstructor, ex);
				}
				throw ex;
			}
		}

		/**
		 * Check whether a service id was passed in.
		 */
		/**
		 * 检查是否传递了服务ID。 
		 * 
		 */
		private String tryGetBeanName(@Nullable Object[] args) {
			String beanName = "";
			if (args != null && args.length == 1 && args[0] != null) {
				beanName = args[0].toString();
			}
			// Look for explicit serviceId-to-beanName mappings.
			if (serviceMappings != null) {
				String mappedName = serviceMappings.getProperty(beanName);
				if (mappedName != null) {
					beanName = mappedName;
				}
			}
			return beanName;
		}

		private Class<?> getServiceLocatorMethodReturnType(Method method) throws NoSuchMethodException {
			Assert.state(serviceLocatorInterface != null, "No service locator interface specified");
			Class<?>[] paramTypes = method.getParameterTypes();
			Method interfaceMethod = serviceLocatorInterface.getMethod(method.getName(), paramTypes);
			Class<?> serviceLocatorReturnType = interfaceMethod.getReturnType();

			// Check whether the method is a valid service locator.
			if (paramTypes.length > 1 || void.class == serviceLocatorReturnType) {
				throw new UnsupportedOperationException(
						"May only call methods with signature '<type> xxx()' or '<type> xxx(<idtype> id)' " +
						"on factory interface, but tried to call: " + interfaceMethod);
			}
			return serviceLocatorReturnType;
		}
	}

}
