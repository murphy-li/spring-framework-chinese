/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.beans.BeansException;
import org.springframework.core.ResolvableType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * Convenience methods operating on bean factories, in particular
 * on the {@link ListableBeanFactory} interface.
 *
 * <p>Returns bean counts, bean names or bean instances,
 * taking into account the nesting hierarchy of a bean factory
 * (which the methods defined on the ListableBeanFactory interface don't,
 * in contrast to the methods defined on the BeanFactory interface).
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Chris Beams
 * @since 04.07.2003
 */
/**
 * 在bean工厂上操作的便捷方法，尤其是在{@link  ListableBeanFactory}接口上。 
 *  <p>返回bean计数，​​bean名称或bean实例，并考虑bean工厂的嵌套层次结构（ListableBeanFactory接口上定义的方法与BeanFactory接口上定义的方法不同）。 
 *  @author  Rod Johnson @author  Juergen Hoeller @author  Chris Beams @自04.07.2003
 */
public abstract class BeanFactoryUtils {

	/**
	 * Separator for generated bean names. If a class name or parent name is not
	 * unique, "#1", "#2" etc will be appended, until the name becomes unique.
	 */
	/**
	 * 生成的Bean名称的分隔符。 
	 * 如果类名称或父名称不是唯一的，则将附加"＃1"，"＃2"等，直到名称变为唯一。 
	 * 
	 */
	public static final String GENERATED_BEAN_NAME_SEPARATOR = "#";

	/**
	 * Cache from name with factory bean prefix to stripped name without dereference.
	 * @since 5.1
	 * @see BeanFactory#FACTORY_BEAN_PREFIX
	 */
	/**
	 * 从具有工厂Bean前缀的名称缓存到剥离的名称，而无需取消引用。 
	 *  @始于5.1 
	 * @see  BeanFactory＃FACTORY_BEAN_PREFIX
	 */
	private static final Map<String, String> transformedBeanNameCache = new ConcurrentHashMap<>();


	/**
	 * Return whether the given name is a factory dereference
	 * (beginning with the factory dereference prefix).
	 * @param name the name of the bean
	 * @return whether the given name is a factory dereference
	 * @see BeanFactory#FACTORY_BEAN_PREFIX
	 */
	/**
	 * 返回给定名称是否为工厂取消引用（从工厂取消引用前缀开始）。 
	 *  
	 * @param 命名Bean的名称
	 * @return 给定名称是否是工厂取消引用
	 * @see  BeanFactory＃FACTORY_BEAN_PREFIX
	 */
	public static boolean isFactoryDereference(@Nullable String name) {
		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
	}

	/**
	 * Return the actual bean name, stripping out the factory dereference
	 * prefix (if any, also stripping repeated factory prefixes if found).
	 * @param name the name of the bean
	 * @return the transformed name
	 * @see BeanFactory#FACTORY_BEAN_PREFIX
	 */
	/**
	 * 返回实际的bean名称，删除工厂取消引用前缀（如果有的话，还删除重复的工厂前缀（如果找到））。 
	 *  
	 * @param 命名bean的名称
	 * @return 转换后的名称
	 * @see  BeanFactory＃FACTORY_BEAN_PREFIX
	 */
	public static String transformedBeanName(String name) {
		Assert.notNull(name, "'name' must not be null");
		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
			return name;
		}
		return transformedBeanNameCache.computeIfAbsent(name, beanName -> {
			do {
				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
			}
			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
			return beanName;
		});
	}

	/**
	 * Return whether the given name is a bean name which has been generated
	 * by the default naming strategy (containing a "#..." part).
	 * @param name the name of the bean
	 * @return whether the given name is a generated bean name
	 * @see #GENERATED_BEAN_NAME_SEPARATOR
	 * @see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName
	 * @see org.springframework.beans.factory.support.DefaultBeanNameGenerator
	 */
	/**
	 * 返回给定名称是否是默认命名策略（包含"＃..."部分）生成的Bean名称。 
	 *  
	 * @param 命名bean的名称
	 * @return 是否给定名称是生成的bean名称
	 * @see  #GENERATED_BEAN_NAME_SEPARATOR 
	 * @see  org.springframework.beans.factory.support.BeanDefinitionReaderUtils＃generateBeanName 
	 * @see  org.springframework.beans.factory.support.DefaultBeanNameGenerator
	 */
	public static boolean isGeneratedBeanName(@Nullable String name) {
		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR));
	}

	/**
	 * Extract the "raw" bean name from the given (potentially generated) bean name,
	 * excluding any "#..." suffixes which might have been added for uniqueness.
	 * @param name the potentially generated bean name
	 * @return the raw bean name
	 * @see #GENERATED_BEAN_NAME_SEPARATOR
	 */
	/**
	 * 从给定的（可能生成的）bean名称中提取"原始"bean名称，不包括为唯一起见添加的任何"＃..."后缀。 
	 *  
	 * @param 命名可能生成的bean名称
	 * @return 原始bean名称
	 * @see  #GENERATED_BEAN_NAME_SEPARATOR
	 */
	public static String originalBeanName(String name) {
		Assert.notNull(name, "'name' must not be null");
		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR);
		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name);
	}


	// Retrieval of bean names

	/**
	 * Count all beans in any hierarchy in which this factory participates.
	 * Includes counts of ancestor bean factories.
	 * <p>Beans that are "overridden" (specified in a descendant factory
	 * with the same name) are only counted once.
	 * @param lbf the bean factory
	 * @return count of beans including those defined in ancestor factories
	 * @see #beanNamesIncludingAncestors
	 */
	/**
	 * 计算该工厂参与的任何层次结构中的所有bean。 
	 * 包括祖先豆工厂的数量。 
	 *  <p>被"重写"（在同名子代工厂中指定）的Bean仅被计数一次。 
	 *  
	 * @param  lbf豆工厂
	 * @return 包括祖先工厂中定义的那些豆的数量
	 * @see  #beanNamesIn includedAncestors
	 */
	public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {
		return beanNamesIncludingAncestors(lbf).length;
	}

	/**
	 * Return all bean names in the factory, including ancestor factories.
	 * @param lbf the bean factory
	 * @return the array of matching bean names, or an empty array if none
	 * @see #beanNamesForTypeIncludingAncestors
	 */
	/**
	 * 返回工厂中的所有bean名称，包括祖先工厂。 
	 *  
	 * @param  lbf bean工厂
	 * @return 匹配的bean名称的数组，如果没有则为空数组
	 * @see  #beanNamesForTypeIn includedAncestors
	 */
	public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {
		return beanNamesForTypeIncludingAncestors(lbf, Object.class);
	}

	/**
	 * Get all bean names for the given type, including those defined in ancestor
	 * factories. Will return unique names in case of overridden bean definitions.
	 * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans
	 * will get initialized. If the object created by the FactoryBean doesn't match,
	 * the raw FactoryBean itself will be matched against the type.
	 * <p>This version of {@code beanNamesForTypeIncludingAncestors} automatically
	 * includes prototypes and FactoryBeans.
	 * @param lbf the bean factory
	 * @param type the type that beans must match (as a {@code ResolvableType})
	 * @return the array of matching bean names, or an empty array if none
	 * @since 4.2
	 * @see ListableBeanFactory#getBeanNamesForType(ResolvableType)
	 */
	/**
	 * 获取给定类型的所有bean名称，包括在祖先工厂中定义的名称。 
	 * 如果覆盖了bean定义，将返回唯一名称。 
	 *  <p>是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 *  <p>此版本的{@code  beanNamesForTypeIn includedAncestors}自动包含原型和FactoryBeans。 
	 *  
	 * @param  lbf bean工厂
	 * @param 键入bean必须匹配的类型（作为{@code  ResolvableType}）
	 * @return 匹配bean名称的数组； 
	 * 如果没有，则为空数组@4.2起
	 * @see  ListableBeanFactory＃getBeanNamesForType（ResolvableType）
	 */
	public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {
		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		String[] result = lbf.getBeanNamesForType(type);
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				String[] parentResult = beanNamesForTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type);
				result = mergeNamesWithParent(result, parentResult, hbf);
			}
		}
		return result;
	}

	/**
	 * Get all bean names for the given type, including those defined in ancestor
	 * factories. Will return unique names in case of overridden bean definitions.
	 * <p>Does consider objects created by FactoryBeans if the "allowEagerInit"
	 * flag is set, which means that FactoryBeans will get initialized. If the
	 * object created by the FactoryBean doesn't match, the raw FactoryBean itself
	 * will be matched against the type. If "allowEagerInit" is not set,
	 * only raw FactoryBeans will be checked (which doesn't require initialization
	 * of each FactoryBean).
	 * @param lbf the bean factory
	 * @param type the type that beans must match (as a {@code ResolvableType})
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and
	 * <i>objects created by FactoryBeans</i> (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 * @return the array of matching bean names, or an empty array if none
	 * @since 5.2
	 * @see ListableBeanFactory#getBeanNamesForType(ResolvableType, boolean, boolean)
	 */
	/**
	 * 获取给定类型的所有bean名称，包括在祖先工厂中定义的名称。 
	 * 如果覆盖了bean定义，将返回唯一名称。 
	 *  <p>如果设置了"allowEagerInit"标志，是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 * 如果未设置"allowEagerInit"，将仅检查原始FactoryBean（不需要初始化每个FactoryBean）。 
	 *  
	 * @param 如果是bean工厂
	 * @param ，则键入bean必须匹配的类型（作为{@code  ResolvableType}）。 
	 * 
	 * @param  includeNonSingletons是否也包括原型或范围内的bean还是仅包含单例（也适用FactoryBeans）
	 * @param  allowEagerInit是否初始化该类型的<i> lazy-init单例</ i>和由FactoryBeans </ i>（或带有"factory-bean"引用的工厂方法）创建的<i>对象。 
	 * 校验。 
	 * 请注意，必须急切初始化FactoryBeans以确定它们的类型：因此请注意，为此标志传递"true"将初始化FactoryBeans和"factory-bean"引用。 
	 *  
	 * @return 匹配的bean名称的数组，如果没有，则为空数组@since 5.2 
	 * @see  ListableBeanFactory＃getBeanNamesForType（ResolvableType，boolean，boolean）
	 */
	public static String[] beanNamesForTypeIncludingAncestors(
			ListableBeanFactory lbf, ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				String[] parentResult = beanNamesForTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);
				result = mergeNamesWithParent(result, parentResult, hbf);
			}
		}
		return result;
	}

	/**
	 * Get all bean names for the given type, including those defined in ancestor
	 * factories. Will return unique names in case of overridden bean definitions.
	 * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans
	 * will get initialized. If the object created by the FactoryBean doesn't match,
	 * the raw FactoryBean itself will be matched against the type.
	 * <p>This version of {@code beanNamesForTypeIncludingAncestors} automatically
	 * includes prototypes and FactoryBeans.
	 * @param lbf the bean factory
	 * @param type the type that beans must match (as a {@code Class})
	 * @return the array of matching bean names, or an empty array if none
	 * @see ListableBeanFactory#getBeanNamesForType(Class)
	 */
	/**
	 * 获取给定类型的所有bean名称，包括在祖先工厂中定义的名称。 
	 * 如果覆盖了bean定义，将返回唯一名称。 
	 *  <p>是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 *  <p>此版本的{@code  beanNamesForTypeIn includedAncestors}自动包含原型和FactoryBeans。 
	 *  
	 * @param  lbf bean工厂
	 * @param 键入bean必须匹配的类型（作为{@code  Class}）
	 * @return 匹配的bean名称的数组； 
	 * 如果没有，则为空数组<
	 * @see > ListableBeanFactory＃getBeanNamesForType（Class）
	 */
	public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {
		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		String[] result = lbf.getBeanNamesForType(type);
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				String[] parentResult = beanNamesForTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type);
				result = mergeNamesWithParent(result, parentResult, hbf);
			}
		}
		return result;
	}

	/**
	 * Get all bean names for the given type, including those defined in ancestor
	 * factories. Will return unique names in case of overridden bean definitions.
	 * <p>Does consider objects created by FactoryBeans if the "allowEagerInit"
	 * flag is set, which means that FactoryBeans will get initialized. If the
	 * object created by the FactoryBean doesn't match, the raw FactoryBean itself
	 * will be matched against the type. If "allowEagerInit" is not set,
	 * only raw FactoryBeans will be checked (which doesn't require initialization
	 * of each FactoryBean).
	 * @param lbf the bean factory
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and
	 * <i>objects created by FactoryBeans</i> (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 * @param type the type that beans must match
	 * @return the array of matching bean names, or an empty array if none
	 * @see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)
	 */
	/**
	 * 获取给定类型的所有bean名称，包括在祖先工厂中定义的名称。 
	 * 如果覆盖了bean定义，将返回唯一名称。 
	 *  <p>如果设置了"allowEagerInit"标志，是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 * 如果未设置"allowEagerInit"，将仅检查原始FactoryBean（不需要初始化每个FactoryBean）。 
	 *  
	 * @param 如果是豆工厂
	 * @param  includeNonSingletons，是否也要包含原型或范围内的bean，还是仅包含单例（也适用于FactoryBeans），请使用@
	 * @param> allowEagerInit是否初始化<i>惰性初始化单例</ i> <i>由FactoryBeans </ i>（或通过带有"factory-bean"引用的工厂方法）创建的对象，用于类型检查。 
	 * 请注意，必须急切初始化FactoryBeans以确定它们的类型：因此请注意，为此标志传递"true"将初始化FactoryBeans和"factory-bean"引用。 
	 *  
	 * @param 键入bean必须匹配的类型
	 * @return 匹配bean名称的数组，如果没有则为空数组
	 * @see  ListableBeanFactory＃getBeanNamesForType（Class，boolean，boolean）
	 */
	public static String[] beanNamesForTypeIncludingAncestors(
			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				String[] parentResult = beanNamesForTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);
				result = mergeNamesWithParent(result, parentResult, hbf);
			}
		}
		return result;
	}

	/**
	 * Get all bean names whose {@code Class} has the supplied {@link Annotation}
	 * type, including those defined in ancestor factories, without creating any bean
	 * instances yet. Will return unique names in case of overridden bean definitions.
	 * @param lbf the bean factory
	 * @param annotationType the type of annotation to look for
	 * @return the array of matching bean names, or an empty array if none
	 * @since 5.0
	 * @see ListableBeanFactory#getBeanNamesForAnnotation(Class)
	 */
	/**
	 * 获取所有其{@code  Class}具有提供的{@link  Annotation}类型的bean名称，包括在祖先工厂中定义的名称，而无需创建任何bean实例。 
	 * 如果覆盖了bean定义，将返回唯一名称。 
	 *  
	 * @param  lbf bean工厂
	 * @param 注记键入注解的类型以查找
	 * @return 匹配的bean名称的数组，如果没有，则返回一个空数组@since 5.0 
	 * @see  ListableBeanFactory＃getBeanNamesForAnnotation（Class）
	 */
	public static String[] beanNamesForAnnotationIncludingAncestors(
			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		String[] result = lbf.getBeanNamesForAnnotation(annotationType);
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				String[] parentResult = beanNamesForAnnotationIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType);
				result = mergeNamesWithParent(result, parentResult, hbf);
			}
		}
		return result;
	}


	// Retrieval of bean instances

	/**
	 * Return all beans of the given type or subtypes, also picking up beans defined in
	 * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.
	 * The returned Map will only contain beans of this type.
	 * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans
	 * will get initialized. If the object created by the FactoryBean doesn't match,
	 * the raw FactoryBean itself will be matched against the type.
	 * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,
	 * i.e. such beans will be returned from the lowest factory that they are being found in,
	 * hiding corresponding beans in ancestor factories.</b> This feature allows for
	 * 'replacing' beans by explicitly choosing the same bean name in a child factory;
	 * the bean in the ancestor factory won't be visible then, not even for by-type lookups.
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @return the Map of matching bean instances, or an empty Map if none
	 * @throws BeansException if a bean could not be created
	 * @see ListableBeanFactory#getBeansOfType(Class)
	 */
	/**
	 * 返回所有给定类型或子类型的bean，如果当前的bean工厂是HierarchicalBeanFactory，则还返回在祖先bean工厂中定义的bean。 
	 * 返回的Map将仅包含此类型的bean。 
	 *  <p>是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 *  <p> <b>注意：同名的Bean在"最低"工厂级别具有优先权，即，这些Bean将从其所在的最低工厂返回，将相应的Bean隐藏在祖先工厂中。 
	 *  b>此功能允许通过在子工厂中显式选择相同的bean名称来"替换"bean； 
	 * 这样，即使对于按类型查找，祖先工厂中的bean也将不可见。 
	 *  
	 * @param  lbf要匹配的bean工厂
	 * @param 类型的豆类型
	 * @return 匹配的bean实例的Map，如果没有，则为空Map 
	 * @throws  BeansException如果无法创建bean <
	 * @see > ListableBeanFactory＃getBeansOfType（Class）
	 */
	public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)
			throws BeansException {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		Map<String, T> result = new LinkedHashMap<>(4);
		result.putAll(lbf.getBeansOfType(type));
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				Map<String, T> parentResult = beansOfTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type);
				parentResult.forEach((beanName, beanInstance) -> {
					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {
						result.put(beanName, beanInstance);
					}
				});
			}
		}
		return result;
	}

	/**
	 * Return all beans of the given type or subtypes, also picking up beans defined in
	 * ancestor bean factories if the current bean factory is a HierarchicalBeanFactory.
	 * The returned Map will only contain beans of this type.
	 * <p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,
	 * which means that FactoryBeans will get initialized. If the object created by the
	 * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the
	 * type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked
	 * (which doesn't require initialization of each FactoryBean).
	 * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,
	 * i.e. such beans will be returned from the lowest factory that they are being found in,
	 * hiding corresponding beans in ancestor factories.</b> This feature allows for
	 * 'replacing' beans by explicitly choosing the same bean name in a child factory;
	 * the bean in the ancestor factory won't be visible then, not even for by-type lookups.
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and
	 * <i>objects created by FactoryBeans</i> (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 * @return the Map of matching bean instances, or an empty Map if none
	 * @throws BeansException if a bean could not be created
	 * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)
	 */
	/**
	 * 返回所有给定类型或子类型的bean，如果当前的bean工厂是HierarchicalBeanFactory，则还返回在祖先bean工厂中定义的bean。 
	 * 返回的Map将仅包含此类型的bean。 
	 *  <p>如果设置了"allowEagerInit"标志，是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 * 如果未设置"allowEagerInit"，将仅检查原始FactoryBean（不需要初始化每个FactoryBean）。 
	 *  <p> <b>注意：同名的Bean在"最低"工厂级别具有优先权，即，这些Bean将从其所在的最低工厂返回，将相应的Bean隐藏在祖先工厂中。 
	 *  b>此功能允许通过在子工厂中显式选择相同的bean名称来"替换"bean； 
	 * 这样，即使对于按类型查找，祖先工厂中的bean也将不可见。 
	 *  
	 * @param 与Bean工厂
	 * @param 类型匹配的豆类型
	 * @param  includeNonSingletons是否也包含原型或范围内的bean还是仅包含单例（也适用于FactoryBeans）
	 * @param  allowEagerInit是否初始化<i > lazy-init单例</ i>和<i>由FactoryBeans </ i>（或通过带有"factory-bean"引用的工厂方法）创建的对象进行类型检查。 
	 * 请注意，必须急切初始化FactoryBeans以确定它们的类型：因此请注意，为此标志传递"true"将初始化FactoryBeans和"factory-bean"引用。 
	 *  
	 * @return 匹配的bean实例的Map，如果没有则为空Map 
	 * @throws  BeansException如果无法创建bean 
	 * @see  ListableBeanFactory＃getBeansOfType（Class，boolean，boolean）
	 */
	public static <T> Map<String, T> beansOfTypeIncludingAncestors(
			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)
			throws BeansException {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		Map<String, T> result = new LinkedHashMap<>(4);
		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));
		if (lbf instanceof HierarchicalBeanFactory) {
			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
				Map<String, T> parentResult = beansOfTypeIncludingAncestors(
						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);
				parentResult.forEach((beanName, beanInstance) -> {
					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {
						result.put(beanName, beanInstance);
					}
				});
			}
		}
		return result;
	}

	/**
	 * Return a single bean of the given type or subtypes, also picking up beans
	 * defined in ancestor bean factories if the current bean factory is a
	 * HierarchicalBeanFactory. Useful convenience method when we expect a
	 * single bean and don't care about the bean name.
	 * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans
	 * will get initialized. If the object created by the FactoryBean doesn't match,
	 * the raw FactoryBean itself will be matched against the type.
	 * <p>This version of {@code beanOfTypeIncludingAncestors} automatically includes
	 * prototypes and FactoryBeans.
	 * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,
	 * i.e. such beans will be returned from the lowest factory that they are being found in,
	 * hiding corresponding beans in ancestor factories.</b> This feature allows for
	 * 'replacing' beans by explicitly choosing the same bean name in a child factory;
	 * the bean in the ancestor factory won't be visible then, not even for by-type lookups.
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @return the matching bean instance
	 * @throws NoSuchBeanDefinitionException if no bean of the given type was found
	 * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
	 * @throws BeansException if the bean could not be created
	 * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class)
	 */
	/**
	 * 返回给定类型或子类型的单个bean，如果当前bean工厂是HierarchicalBeanFactory，则还拾取祖先bean工厂中定义的bean。 
	 * 当我们期望单个bean而不关心bean名称时的一种有用的便捷方法。 
	 *  <p>是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 *  <p>此版本的{@code  beanOfTypeIn includedAncestors}自动包含原型和FactoryBeans。 
	 *  <p> <b>注意：同名的Bean在"最低"工厂级别具有优先权，即，这些Bean将从其所在的最低工厂返回，将相应的Bean隐藏在祖先工厂中。 
	 *  b>此功能允许通过在子工厂中显式选择相同的bean名称来"替换"bean； 
	 * 这样，即使对于按类型查找，祖先工厂中的bean也将不可见。 
	 *  
	 * @param  lbf要匹配的bean工厂
	 * @param 类型的豆类型
	 * @return 匹配的bean实例
	 * @throws  NoSuchBeanDefinitionException如果找不到给定类型的bean 
	 * @throws  NoUniqueBeanDefinitionException如果一个以上的bean如果无法创建Bean，则找到给定类型的
	 * @throws  BeansException 
	 * @see  #beansOfTypeIn includedAncestors（ListableBeanFactory，Class）
	 */
	public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)
			throws BeansException {

		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type);
		return uniqueBean(type, beansOfType);
	}

	/**
	 * Return a single bean of the given type or subtypes, also picking up beans
	 * defined in ancestor bean factories if the current bean factory is a
	 * HierarchicalBeanFactory. Useful convenience method when we expect a
	 * single bean and don't care about the bean name.
	 * <p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,
	 * which means that FactoryBeans will get initialized. If the object created by the
	 * FactoryBean doesn't match, the raw FactoryBean itself will be matched against the
	 * type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked
	 * (which doesn't require initialization of each FactoryBean).
	 * <p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,
	 * i.e. such beans will be returned from the lowest factory that they are being found in,
	 * hiding corresponding beans in ancestor factories.</b> This feature allows for
	 * 'replacing' beans by explicitly choosing the same bean name in a child factory;
	 * the bean in the ancestor factory won't be visible then, not even for by-type lookups.
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and
	 * <i>objects created by FactoryBeans</i> (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 * @return the matching bean instance
	 * @throws NoSuchBeanDefinitionException if no bean of the given type was found
	 * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
	 * @throws BeansException if the bean could not be created
	 * @see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)
	 */
	/**
	 * 返回给定类型或子类型的单个bean，如果当前bean工厂是HierarchicalBeanFactory，则还拾取祖先bean工厂中定义的bean。 
	 * 当我们期望单个bean而不关心bean名称时的一种有用的便捷方法。 
	 *  <p>如果设置了"allowEagerInit"标志，是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 * 如果未设置"allowEagerInit"，将仅检查原始FactoryBean（不需要初始化每个FactoryBean）。 
	 *  <p> <b>注意：同名的Bean在"最低"工厂级别具有优先权，即，这些Bean将从其所在的最低工厂返回，将相应的Bean隐藏在祖先工厂中。 
	 *  b>此功能允许通过在子工厂中显式选择相同的bean名称来"替换"bean； 
	 * 这样，即使对于按类型查找，祖先工厂中的bean也将不可见。 
	 *  
	 * @param 与Bean工厂
	 * @param 类型匹配的豆类型
	 * @param  includeNonSingletons是否也包含原型或范围内的bean还是仅包含单例（也适用于FactoryBeans）
	 * @param  allowEagerInit是否初始化<i > lazy-init单例</ i>和<i>由FactoryBeans </ i>（或通过带有"factory-bean"引用的工厂方法）创建的对象进行类型检查。 
	 * 请注意，必须急切初始化FactoryBeans以确定它们的类型：因此请注意，为此标志传递"true"将初始化FactoryBeans和"factory-bean"引用。 
	 *  
	 * @return 匹配的bean实例
	 * @throws  NoSuchBeanDefinitionException如果找不到给定类型的bean 
	 * @throws  NoUniqueBeanDefinitionException如果找到多个给定类型的bean 
	 * @throws  BeansException如果无法创建bean 
	 * @see  #beansOfTypeIn includedAncestors（ListableBeanFactory，Class，boolean，boolean）
	 */
	public static <T> T beanOfTypeIncludingAncestors(
			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)
			throws BeansException {

		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit);
		return uniqueBean(type, beansOfType);
	}

	/**
	 * Return a single bean of the given type or subtypes, not looking in ancestor
	 * factories. Useful convenience method when we expect a single bean and
	 * don't care about the bean name.
	 * <p>Does consider objects created by FactoryBeans, which means that FactoryBeans
	 * will get initialized. If the object created by the FactoryBean doesn't match,
	 * the raw FactoryBean itself will be matched against the type.
	 * <p>This version of {@code beanOfType} automatically includes
	 * prototypes and FactoryBeans.
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @return the matching bean instance
	 * @throws NoSuchBeanDefinitionException if no bean of the given type was found
	 * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
	 * @throws BeansException if the bean could not be created
	 * @see ListableBeanFactory#getBeansOfType(Class)
	 */
	/**
	 * 返回给定类型或子类型的单个bean，而不在祖先工厂中查找。 
	 * 当我们期望单个bean而不关心bean名称时的一种有用的便捷方法。 
	 *  <p>是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 *  <p>此版本的{@code  beanOfType}自动包含原型和FactoryBeans。 
	 *  
	 * @param  lbf要匹配的bean工厂
	 * @param 类型的豆类型
	 * @return 匹配的bean实例
	 * @throws  NoSuchBeanDefinitionException如果找不到给定类型的bean 
	 * @throws  NoUniqueBeanDefinitionException如果一个以上的bean如果无法创建Bean，则找到给定类型的
	 * @throws  BeansException 
	 * @see  ListableBeanFactory＃getBeansOfType（Class）
	 */
	public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {
		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		Map<String, T> beansOfType = lbf.getBeansOfType(type);
		return uniqueBean(type, beansOfType);
	}

	/**
	 * Return a single bean of the given type or subtypes, not looking in ancestor
	 * factories. Useful convenience method when we expect a single bean and
	 * don't care about the bean name.
	 * <p>Does consider objects created by FactoryBeans if the "allowEagerInit"
	 * flag is set, which means that FactoryBeans will get initialized. If the
	 * object created by the FactoryBean doesn't match, the raw FactoryBean itself
	 * will be matched against the type. If "allowEagerInit" is not set,
	 * only raw FactoryBeans will be checked (which doesn't require initialization
	 * of each FactoryBean).
	 * @param lbf the bean factory
	 * @param type type of bean to match
	 * @param includeNonSingletons whether to include prototype or scoped beans too
	 * or just singletons (also applies to FactoryBeans)
	 * @param allowEagerInit whether to initialize <i>lazy-init singletons</i> and
	 * <i>objects created by FactoryBeans</i> (or by factory methods with a
	 * "factory-bean" reference) for the type check. Note that FactoryBeans need to be
	 * eagerly initialized to determine their type: So be aware that passing in "true"
	 * for this flag will initialize FactoryBeans and "factory-bean" references.
	 * @return the matching bean instance
	 * @throws NoSuchBeanDefinitionException if no bean of the given type was found
	 * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
	 * @throws BeansException if the bean could not be created
	 * @see ListableBeanFactory#getBeansOfType(Class, boolean, boolean)
	 */
	/**
	 * 返回给定类型或子类型的单个bean，而不在祖先工厂中查找。 
	 * 当我们期望单个bean而不关心bean名称时的一种有用的便捷方法。 
	 *  <p>如果设置了"allowEagerInit"标志，是否考虑由FactoryBeans创建的对象，这意味着将初始化FactoryBeans。 
	 * 如果由FactoryBean创建的对象不匹配，则原始FactoryBean本身将与该类型匹配。 
	 * 如果未设置"allowEagerInit"，将仅检查原始FactoryBean（不需要初始化每个FactoryBean）。 
	 *  
	 * @param 与Bean工厂
	 * @param 类型匹配的豆类型
	 * @param  includeNonSingletons是否也包含原型或范围内的bean还是仅包含单例（也适用于FactoryBeans）
	 * @param  allowEagerInit是否初始化<i > lazy-init单例</ i>和<i>由FactoryBeans </ i>（或通过带有"factory-bean"引用的工厂方法）创建的对象进行类型检查。 
	 * 请注意，必须急切初始化FactoryBeans以确定它们的类型：因此请注意，为此标志传递"true"将初始化FactoryBeans和"factory-bean"引用。 
	 *  
	 * @return 匹配的bean实例
	 * @throws  NoSuchBeanDefinitionException如果找不到给定类型的bean 
	 * @throws  NoUniqueBeanDefinitionException如果找到多个给定类型的bean 
	 * @throws  BeansException如果无法创建bean 
	 * @see  ListableBeanFactory＃getBeansOfType（Class，boolean，boolean）
	 */
	public static <T> T beanOfType(
			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)
			throws BeansException {

		Assert.notNull(lbf, "ListableBeanFactory must not be null");
		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit);
		return uniqueBean(type, beansOfType);
	}


	/**
	 * Merge the given bean names result with the given parent result.
	 * @param result the local bean name result
	 * @param parentResult the parent bean name result (possibly empty)
	 * @param hbf the local bean factory
	 * @return the merged result (possibly the local result as-is)
	 * @since 4.3.15
	 */
	/**
	 * 将给定的bean名称结果与给定的父结果合并。 
	 *  
	 * @param 结果本地bean名称结果
	 * @param  parentResult父bean名称结果（可能为空）
	 * @param  hbf本地bean工厂
	 * @return 合并结果（可能是本地结果）从4.3.15开始
	 */
	private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf) {
		if (parentResult.length == 0) {
			return result;
		}
		List<String> merged = new ArrayList<>(result.length + parentResult.length);
		merged.addAll(Arrays.asList(result));
		for (String beanName : parentResult) {
			if (!merged.contains(beanName) && !hbf.containsLocalBean(beanName)) {
				merged.add(beanName);
			}
		}
		return StringUtils.toStringArray(merged);
	}

	/**
	 * Extract a unique bean for the given type from the given Map of matching beans.
	 * @param type type of bean to match
	 * @param matchingBeans all matching beans found
	 * @return the unique bean instance
	 * @throws NoSuchBeanDefinitionException if no bean of the given type was found
	 * @throws NoUniqueBeanDefinitionException if more than one bean of the given type was found
	 */
	/**
	 * 从给定的匹配bean映射中提取给定类型的唯一bean。 
	 *  
	 * @param 要匹配的bean的类型
	 * @param  matchingBeans找到所有匹配的bean 
	 * @return 唯一的bean实例
	 * @throws  NoSuchBeanDefinitionException如果没有找到给定类型的bean 
	 * @throws  NoUniqueBeanDefinitionException如果一个以上找到了给定类型的bean
	 */
	private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {
		int count = matchingBeans.size();
		if (count == 1) {
			return matchingBeans.values().iterator().next();
		}
		else if (count > 1) {
			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());
		}
		else {
			throw new NoSuchBeanDefinitionException(type);
		}
	}

}
