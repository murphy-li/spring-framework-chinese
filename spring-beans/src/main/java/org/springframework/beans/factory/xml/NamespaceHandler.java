/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2012的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.xml;

import org.w3c.dom.Element;
import org.w3c.dom.Node;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.lang.Nullable;

/**
 * Base interface used by the {@link DefaultBeanDefinitionDocumentReader}
 * for handling custom namespaces in a Spring XML configuration file.
 *
 * <p>Implementations are expected to return implementations of the
 * {@link BeanDefinitionParser} interface for custom top-level tags and
 * implementations of the {@link BeanDefinitionDecorator} interface for
 * custom nested tags.
 *
 * <p>The parser will call {@link #parse} when it encounters a custom tag
 * directly under the {@code <beans>} tags and {@link #decorate} when
 * it encounters a custom tag directly under a {@code <bean>} tag.
 *
 * <p>Developers writing their own custom element extensions typically will
 * not implement this interface directly, but rather make use of the provided
 * {@link NamespaceHandlerSupport} class.
 *
 * @author Rob Harrop
 * @author Erik Wiersma
 * @since 2.0
 * @see DefaultBeanDefinitionDocumentReader
 * @see NamespaceHandlerResolver
 */
/**
 * {@link  DefaultBeanDefinitionDocumentReader}使用的基本接口用于处理Spring XML配置文件中的自定义名称空间。 
 *  <p>该实现应返回用于自定义顶级标签的{@link  BeanDefinitionParser}接口的实现和用于自定义嵌套标签的{@link  BeanDefinitionDecorator}接口的实现。 
 *  <p>当解析器在{@code  <beans>}标签正下方遇到自定义标签时，将调用{@link  #parse}； 
 * 当解析器直接遇到自定义标签时，它将调用{@link  #decorate}在{@code  <bean>}标签下。 
 *  <p>开发人员编写自己的自定义元素扩展通常不会直接实现此接口，而是使用提供的{@link  NamespaceHandlerSupport}类。 
 *  @author  Rob Harrop @author  Erik Wiersma @since 2.0起
 * @see  DefaultBeanDefinitionDocumentReader 
 * @see  NamespaceHandlerResolver
 */
public interface NamespaceHandler {

	/**
	 * Invoked by the {@link DefaultBeanDefinitionDocumentReader} after
	 * construction but before any custom elements are parsed.
	 * @see NamespaceHandlerSupport#registerBeanDefinitionParser(String, BeanDefinitionParser)
	 */
	/**
	 * 在构造之后但在解析任何自定义元素之前，由{@link  DefaultBeanDefinitionDocumentReader}调用。 
	 *  
	 * @see  NamespaceHandlerSupport＃registerBeanDefinitionParser（String，BeanDefinitionParser）
	 */
	void init();

	/**
	 * Parse the specified {@link Element} and register any resulting
	 * {@link BeanDefinition BeanDefinitions} with the
	 * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}
	 * that is embedded in the supplied {@link ParserContext}.
	 * <p>Implementations should return the primary {@code BeanDefinition}
	 * that results from the parse phase if they wish to be used nested
	 * inside (for example) a {@code <property>} tag.
	 * <p>Implementations may return {@code null} if they will
	 * <strong>not</strong> be used in a nested scenario.
	 * @param element the element that is to be parsed into one or more {@code BeanDefinitions}
	 * @param parserContext the object encapsulating the current state of the parsing process
	 * @return the primary {@code BeanDefinition} (can be {@code null} as explained above)
	 */
	/**
	 * 解析指定的{@link 元素}，并使用嵌入在提供的{<@中的{@link  org.springframework.beans.factory.support.BeanDefinitionRegistry}注册所有结果{@link  BeanDefinition BeanDefinitions}。 
	 * 链接> ParserContext}。 
	 *  <p>如果实现希望嵌套在{@code  <property>}标记中，则实现应返回从解析阶段产生的主{@code  BeanDefinition}。 
	 *  <p>如果<strong>不</ strong>将在嵌套方案中使用，则实现可能返回{@code  null}。 
	 *  
	 * @param 元素要解析为一个或多个{@code  BeanDefinitions}的元素
	 * @param  parserContext封装解析过程当前状态的对象
	 * @return 主{@code  BeanDefinition }（如上所述，可以为{@code  null}）
	 */
	@Nullable
	BeanDefinition parse(Element element, ParserContext parserContext);

	/**
	 * Parse the specified {@link Node} and decorate the supplied
	 * {@link BeanDefinitionHolder}, returning the decorated definition.
	 * <p>The {@link Node} may be either an {@link org.w3c.dom.Attr} or an
	 * {@link Element}, depending on whether a custom attribute or element
	 * is being parsed.
	 * <p>Implementations may choose to return a completely new definition,
	 * which will replace the original definition in the resulting
	 * {@link org.springframework.beans.factory.BeanFactory}.
	 * <p>The supplied {@link ParserContext} can be used to register any
	 * additional beans needed to support the main definition.
	 * @param source the source element or attribute that is to be parsed
	 * @param definition the current bean definition
	 * @param parserContext the object encapsulating the current state of the parsing process
	 * @return the decorated definition (to be registered in the BeanFactory),
	 * or simply the original bean definition if no decoration is required.
	 * A {@code null} value is strictly speaking invalid, but will be leniently
	 * treated like the case where the original bean definition gets returned.
	 */
	/**
	 * 解析指定的{@link 节点}，并修饰提供的{@link  BeanDefinitionHolder}，返回修饰后的定义。 
	 *  <p> {<@link>节点}可以是{@link  org.w3c.dom.Attr}或{@link 元素}，具体取决于是否解析自定义属性或元素。 
	 *  <p>实现可以选择返回一个全新的定义，它将替换生成的{@link  org.springframework.beans.factory.BeanFactory}中的原始定义。 
	 *  <p>提供的{@link  ParserContext}可以用于注册支持主定义所需的任何其他bean。 
	 *  
	 * @param 源将要解析的源元素或属性
	 * @param 定义当前bean定义
	 * @param  parserContext封装解析过程当前状态的对象
	 * @return 装饰的定义（待注册） （在BeanFactory中），或者如果不需要装饰，则只需原始Bean定义即可。 
	 *  {@code  null}值严格来说是无效的，但将被宽容地对待，就像返回原始bean定义的情况一样。 
	 * 
	 */
	@Nullable
	BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder definition, ParserContext parserContext);

}
