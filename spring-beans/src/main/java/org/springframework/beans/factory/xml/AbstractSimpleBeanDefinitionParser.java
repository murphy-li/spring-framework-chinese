/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2014 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2014的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.xml;

import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.core.Conventions;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * Convenient base class for when there exists a one-to-one mapping
 * between attribute names on the element that is to be parsed and
 * the property names on the {@link Class} being configured.
 *
 * <p>Extend this parser class when you want to create a single
 * bean definition from a relatively simple custom XML element. The
 * resulting {@code BeanDefinition} will be automatically
 * registered with the relevant
 * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}.
 *
 * <p>An example will hopefully make the use of this particular parser
 * class immediately clear. Consider the following class definition:
 *
 * <pre class="code">public class SimpleCache implements Cache {
 *
 *     public void setName(String name) {...}
 *     public void setTimeout(int timeout) {...}
 *     public void setEvictionPolicy(EvictionPolicy policy) {...}
 *
 *     // remaining class definition elided for clarity...
 * }</pre>
 *
 * <p>Then let us assume the following XML tag has been defined to
 * permit the easy configuration of instances of the above class;
 *
 * <pre class="code">&lt;caching:cache name="..." timeout="..." eviction-policy="..."/&gt;</pre>
 *
 * <p>All that is required of the Java developer tasked with writing
 * the parser to parse the above XML tag into an actual
 * {@code SimpleCache} bean definition is the following:
 *
 * <pre class="code">public class SimpleCacheBeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {
 *
 *     protected Class getBeanClass(Element element) {
 *         return SimpleCache.class;
 *     }
 * }</pre>
 *
 * <p>Please note that the {@code AbstractSimpleBeanDefinitionParser}
 * is limited to populating the created bean definition with property values.
 * if you want to parse constructor arguments and nested elements from the
 * supplied XML element, then you will have to implement the
 * {@link #postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.w3c.dom.Element)}
 * method and do such parsing yourself, or (more likely) subclass the
 * {@link AbstractSingleBeanDefinitionParser} or {@link AbstractBeanDefinitionParser}
 * classes directly.
 *
 * <p>The process of actually registering the
 * {@code SimpleCacheBeanDefinitionParser} with the Spring XML parsing
 * infrastructure is described in the Spring Framework reference documentation
 * (in one of the appendices).
 *
 * <p>For an example of this parser in action (so to speak), do look at
 * the source code for the
 * {@link org.springframework.beans.factory.xml.UtilNamespaceHandler.PropertiesBeanDefinitionParser};
 * the observant (and even not so observant) reader will immediately notice that
 * there is next to no code in the implementation. The
 * {@code PropertiesBeanDefinitionParser} populates a
 * {@link org.springframework.beans.factory.config.PropertiesFactoryBean}
 * from an XML element that looks like this:
 *
 * <pre class="code">&lt;util:properties location="jdbc.properties"/&gt;</pre>
 *
 * <p>The observant reader will notice that the sole attribute on the
 * {@code <util:properties/>} element matches the
 * {@link org.springframework.beans.factory.config.PropertiesFactoryBean#setLocation(org.springframework.core.io.Resource)}
 * method name on the {@code PropertiesFactoryBean} (the general
 * usage thus illustrated holds true for any number of attributes).
 * All that the {@code PropertiesBeanDefinitionParser} needs
 * actually do is supply an implementation of the
 * {@link #getBeanClass(org.w3c.dom.Element)} method to return the
 * {@code PropertiesFactoryBean} type.
 *
 * @author Rob Harrop
 * @author Rick Evans
 * @author Juergen Hoeller
 * @since 2.0
 * @see Conventions#attributeNameToPropertyName(String)
 */
/**
 * 方便的基类，用于当要解析的元素上的属性名称与正在配置的{@link  Class}上的属性名称之间存在一对一映射时。 
 *  <p>要从相对简单的自定义XML元素创建单个bean定义时，请扩展此解析器类。 
 * 生成的{@code  BeanDefinition}将自动注册到相关的{@link  org.springframework.beans.factory.support.BeanDefinitionRegistry}。 
 *  <p>一个例子有望使这个特定的解析器类的使用立即变得清晰。 
 * 请考虑以下类定义：<pre class ="code">公共类SimpleCache实现Cache {public void setName（String name）{...} public void setTimeout（int timeout）{...} public void setEvictionPolicy（EvictionPolicy策略} {...} //为了清晰起见，省略了剩余的类定义...} </ pre> <p>然后让我们假设已经定义了以下XML标记，以允许轻松配置上述类的实例； 
 *  <pre class ="code"> <caching：cache name ="..."timeout ="..."eviction-policy ="..."/> </ pre> <p>负责编写解析器以将上述XML标签解析为实际的{@code  SimpleCache} bean定义的Java开发人员如下：<pre class ="code">公共类SimpleCacheBeanDefinitionParser扩展AbstractSimpleBeanDefinitionParser {protected Class getBeanClass（Element element） {return SimpleCache.class; }} </ pre> <p>请注意，{<@code> AbstractSimpleBeanDefinitionParser}仅限于用属性值填充创建的bean定义。 
 * 如果要解析提供的XML元素中的构造函数参数和嵌套元素，则必须实现{@link  #postProcess（org.springframework.beans.factory.support.BeanDefinitionBuilder，org.w3c.dom.Element ）}方法并自己进行此类解析，或者（更可能是）直接将{@link  AbstractSingleBeanDefinitionParser}或{@link  AbstractBeanDefinitionParser}类子类化。 
 *  <p> Spring框架参考文档（在附录之一中）中描述了使用Spring XML解析基础结构实际注册{@code  SimpleCacheBeanDefinitionParser}的过程。 
 *  <p>有关这个解析器的例子（可以这么说），请查看{@link  org.springframework.beans.factory.xml.UtilNamespaceHandler.PropertiesBeanDefinitionParser}的源代码。 
 * 细心的读者（甚至不是那么细心的读者）将立即注意到实现中几乎没有代码。 
 *  {@code  PropertiesBeanDefinitionParser}从如下所示的XML元素填充{@link  org.springframework.beans.factory.config.PropertiesFactoryBean}：<pre class ="code"> <util：properties location = "jdbc.properties"/> </ pre> <p>细心的读者会注意到{@code  <util：properties />}元素上的唯一属性与{@link  org.springframework.beans {@code  PropertiesFactoryBean}上的.factory.config.PropertiesFactoryBean＃setLocation（org.springframework.core.io.Resource）}方法名称（因此，所示的一般用法对于任意数量的属性都适用）。 
 *  {@code  PropertiesBeanDefinitionParser}实际需要做的全部工作就是提供{@link  #getBeanClass（org.w3c.dom.Element）}方法的实现，以返回{@code  PropertiesFactoryBean}类型。 
 *  @author  Rob Harrop @author  Rick Evans @author  Juergen Hoeller @since 2.0起
 * @see  Conventions＃attributeNameToPropertyName（String）
 */
public abstract class AbstractSimpleBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {

	/**
	 * Parse the supplied {@link Element} and populate the supplied
	 * {@link BeanDefinitionBuilder} as required.
	 * <p>This implementation maps any attributes present on the
	 * supplied element to {@link org.springframework.beans.PropertyValue}
	 * instances, and
	 * {@link BeanDefinitionBuilder#addPropertyValue(String, Object) adds them}
	 * to the
	 * {@link org.springframework.beans.factory.config.BeanDefinition builder}.
	 * <p>The {@link #extractPropertyName(String)} method is used to
	 * reconcile the name of an attribute with the name of a JavaBean
	 * property.
	 * @param element the XML element being parsed
	 * @param builder used to define the {@code BeanDefinition}
	 * @see #extractPropertyName(String)
	 */
	/**
	 * 解析提供的{@link 元素}，并根据需要填充提供的{@link  BeanDefinitionBuilder}。 
	 *  <p>此实现将提供的元素上存在的所有属性映射到{@link  org.springframework.beans.PropertyValue}实例，并且{@link  BeanDefinitionBuilder＃addPropertyValue（String，Object）将它们添加到} { @link> org.springframework.beans.factory.config.BeanDefinition构建器}。 
	 *  <p> {<@link> #extractPropertyName（String）}方法用于将属性名称与JavaBean属性名称进行协调。 
	 *  
	 * @param 元素正在解析的XML元素
	 * @param 构建器，用于定义{@code  BeanDefinition} 
	 * @see  #extractPropertyName（String）
	 */
	@Override
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		NamedNodeMap attributes = element.getAttributes();
		for (int x = 0; x < attributes.getLength(); x++) {
			Attr attribute = (Attr) attributes.item(x);
			if (isEligibleAttribute(attribute, parserContext)) {
				String propertyName = extractPropertyName(attribute.getLocalName());
				Assert.state(StringUtils.hasText(propertyName),
						"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.");
				builder.addPropertyValue(propertyName, attribute.getValue());
			}
		}
		postProcess(builder, element);
	}

	/**
	 * Determine whether the given attribute is eligible for being
	 * turned into a corresponding bean property value.
	 * <p>The default implementation considers any attribute as eligible,
	 * except for the "id" attribute and namespace declaration attributes.
	 * @param attribute the XML attribute to check
	 * @param parserContext the {@code ParserContext}
	 * @see #isEligibleAttribute(String)
	 */
	/**
	 * 确定给定的属性是否适合转换为相应的bean属性值。 
	 *  <p>默认实现将任何属性视为合格，但"id"属性和命名空间声明属性除外。 
	 *  
	 * @param 属性XML属性来检查
	 * @param  parserContext {{@code> ParserContext} 
	 * @see  #isEligibleAttribute（String）
	 */
	protected boolean isEligibleAttribute(Attr attribute, ParserContext parserContext) {
		String fullName = attribute.getName();
		return (!fullName.equals("xmlns") && !fullName.startsWith("xmlns:") &&
				isEligibleAttribute(parserContext.getDelegate().getLocalName(attribute)));
	}

	/**
	 * Determine whether the given attribute is eligible for being
	 * turned into a corresponding bean property value.
	 * <p>The default implementation considers any attribute as eligible,
	 * except for the "id" attribute.
	 * @param attributeName the attribute name taken straight from the
	 * XML element being parsed (never {@code null})
	 */
	/**
	 * 确定给定的属性是否适合转换为相应的bean属性值。 
	 *  <p>默认实现将任何属性视为合格，但"id"属性除外。 
	 *  
	 * @param  attributeName直接从要解析的XML元素中获取的属性名称（绝不{@code  null}）
	 */
	protected boolean isEligibleAttribute(String attributeName) {
		return !ID_ATTRIBUTE.equals(attributeName);
	}

	/**
	 * Extract a JavaBean property name from the supplied attribute name.
	 * <p>The default implementation uses the
	 * {@link Conventions#attributeNameToPropertyName(String)}
	 * method to perform the extraction.
	 * <p>The name returned must obey the standard JavaBean property name
	 * conventions. For example for a class with a setter method
	 * '{@code setBingoHallFavourite(String)}', the name returned had
	 * better be '{@code bingoHallFavourite}' (with that exact casing).
	 * @param attributeName the attribute name taken straight from the
	 * XML element being parsed (never {@code null})
	 * @return the extracted JavaBean property name (must never be {@code null})
	 */
	/**
	 * 从提供的属性名称中提取JavaBean属性名称。 
	 *  <p>默认实现使用{@link  Conventions＃attributeNameToPropertyName（String）}方法执行提取。 
	 *  <p>返回的名称必须遵守标准的JavaBean属性名称约定。 
	 * 例如，对于具有setter方法'{@code  setBingoHallFavourite（String）}'的类，返回的名称最好为'{@code  bingoHallFavourite}'（具有确切的大小写）。 
	 *  
	 * @param  attributeName直接从要解析的XML元素中获取的属性名称（绝不能为{@code  null}）
	 * @return 提取的JavaBean属性名称（绝不能为{@code  null}）
	 */
	protected String extractPropertyName(String attributeName) {
		return Conventions.attributeNameToPropertyName(attributeName);
	}

	/**
	 * Hook method that derived classes can implement to inspect/change a
	 * bean definition after parsing is complete.
	 * <p>The default implementation does nothing.
	 * @param beanDefinition the parsed (and probably totally defined) bean definition being built
	 * @param element the XML element that was the source of the bean definition's metadata
	 */
	/**
	 * 解析完成后，派生类可以实现的Hook方法来检查/更改Bean定义。 
	 *  <p>默认实现不执行任何操作。 
	 *  
	 * @param  beanDefinition正在构建的已解析（并且可能已完全定义）的bean定义
	 * @param 元素XML元素是bean定义的元数据的来源
	 */
	protected void postProcess(BeanDefinitionBuilder beanDefinition, Element element) {
	}

}
