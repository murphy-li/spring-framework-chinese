/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2016的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.config;

import org.springframework.beans.factory.ObjectFactory;
import org.springframework.lang.Nullable;

/**
 * Strategy interface used by a {@link ConfigurableBeanFactory},
 * representing a target scope to hold bean instances in.
 * This allows for extending the BeanFactory's standard scopes
 * {@link ConfigurableBeanFactory#SCOPE_SINGLETON "singleton"} and
 * {@link ConfigurableBeanFactory#SCOPE_PROTOTYPE "prototype"}
 * with custom further scopes, registered for a
 * {@link ConfigurableBeanFactory#registerScope(String, Scope) specific key}.
 *
 * <p>{@link org.springframework.context.ApplicationContext} implementations
 * such as a {@link org.springframework.web.context.WebApplicationContext}
 * may register additional standard scopes specific to their environment,
 * e.g. {@link org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST "request"}
 * and {@link org.springframework.web.context.WebApplicationContext#SCOPE_SESSION "session"},
 * based on this Scope SPI.
 *
 * <p>Even if its primary use is for extended scopes in a web environment,
 * this SPI is completely generic: It provides the ability to get and put
 * objects from any underlying storage mechanism, such as an HTTP session
 * or a custom conversation mechanism. The name passed into this class's
 * {@code get} and {@code remove} methods will identify the
 * target object in the current scope.
 *
 * <p>{@code Scope} implementations are expected to be thread-safe.
 * One {@code Scope} instance can be used with multiple bean factories
 * at the same time, if desired (unless it explicitly wants to be aware of
 * the containing BeanFactory), with any number of threads accessing
 * the {@code Scope} concurrently from any number of factories.
 *
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @since 2.0
 * @see ConfigurableBeanFactory#registerScope
 * @see CustomScopeConfigurer
 * @see org.springframework.aop.scope.ScopedProxyFactoryBean
 * @see org.springframework.web.context.request.RequestScope
 * @see org.springframework.web.context.request.SessionScope
 */
/**
 * {@link  ConfigurableBeanFactory}使用的策略接口，代表用于容纳Bean实例的目标范围。 
 * 这允许扩展BeanFactory的标准范围{@link  ConfigurableBeanFactory＃SCOPE_SINGLETON"singleton"}和{@link  ConfigurableBeanFactory具有自定义其他作用域的#SCOPE_PROTOTYPE"prototype"}，已为{@link  ConfigurableBeanFactory＃registerScope（String，Scope）specific key}注册。 
 *  <p> {<@link> org.springframework.context.ApplicationContext}实现，例如{@link  org.springframework.web.context.WebApplicationContext}可以注册特定于其环境的其他标准范围，例如根据此范围SPI，{<@link> org.springframework.web.context.WebApplicationContext＃SCOPE_REQUEST"请求"}和{@link  org.springframework.webtext.WebApplicationContext＃SCOPE_SESSION"会话"}。 
 *  <p>即使它的主要用途是用于Web环境中的扩展范围，此SPI也是完全通用的：它提供了从任何基础存储机制（例如HTTP会话或自定义对话机制）获取和放置对象的能力。 
 * 传递给此类的{@code  get}和{@code  remove}方法的名称将标识当前作用域中的目标对象。 
 *  <p> {<@code> Scope}实现应该是线程安全的。 
 * 一个{{@code> Scope}实例可以同时与多个bean工厂一起使用（如果需要的话（除非它明确地希望知道包含的BeanFactory）），并且任何数量的线程都可以访问{@code  Scope }同时来自任何数量的工厂。 
 *  @author  Juergen Hoeller @author  Rob Harrop @since 2.0起
 * @see  ConfigurableBeanFactory＃registerScope 
 * @see  CustomScopeConfigurer 
 * @see  org.springframework.aop.scope.ScopedProxyFactoryBean 
 * @see  org.springframework.web。 
 *  context.request.RequestScope 
 * @see  org.springframework.web.context.request.SessionScope
 */
public interface Scope {

	/**
	 * Return the object with the given name from the underlying scope,
	 * {@link org.springframework.beans.factory.ObjectFactory#getObject() creating it}
	 * if not found in the underlying storage mechanism.
	 * <p>This is the central operation of a Scope, and the only operation
	 * that is absolutely required.
	 * @param name the name of the object to retrieve
	 * @param objectFactory the {@link ObjectFactory} to use to create the scoped
	 * object if it is not present in the underlying storage mechanism
	 * @return the desired object (never {@code null})
	 * @throws IllegalStateException if the underlying scope is not currently active
	 */
	/**
	 * 如果未在基础存储机制中找到，则从基础作用域{@link  org.springframework.beans.factory.ObjectFactory＃getObject（）创建}返回具有给定名称的对象。 
	 *  <p>这是示波器的中央操作，并且是绝对必需的唯一操作。 
	 *  
	 * @param 命名要检索的对象的名称
	 * @param  objectFactory {{@link> ObjectFactory}用于创建范围对象（如果基础存储机制中不存在该对象）
	 * @return 所需对象（从不{@code  null}）
	 * @throws 如果基础作用域当前未激活，则抛出IllegalStateException
	 */
	Object get(String name, ObjectFactory<?> objectFactory);

	/**
	 * Remove the object with the given {@code name} from the underlying scope.
	 * <p>Returns {@code null} if no object was found; otherwise
	 * returns the removed {@code Object}.
	 * <p>Note that an implementation should also remove a registered destruction
	 * callback for the specified object, if any. It does, however, <i>not</i>
	 * need to <i>execute</i> a registered destruction callback in this case,
	 * since the object will be destroyed by the caller (if appropriate).
	 * <p><b>Note: This is an optional operation.</b> Implementations may throw
	 * {@link UnsupportedOperationException} if they do not support explicitly
	 * removing an object.
	 * @param name the name of the object to remove
	 * @return the removed object, or {@code null} if no object was present
	 * @throws IllegalStateException if the underlying scope is not currently active
	 * @see #registerDestructionCallback
	 */
	/**
	 * 从基础范围中删除具有给定{@code 名称}的对象。 
	 *  <p>如果未找到对象，则返回{@code  null}； 
	 * 否则返回删除的{@code  Object}。 
	 *  <p>请注意，实现还应删除指定对象的已注册销毁回调（如果有）。 
	 * 但是，在这种情况下，<i>不需要</ i>执行<i>执行</ i>已注册的销毁回调，因为调用方将销毁该对象（如果适用）。 
	 *  <p> <b>注意：这是一个可选操作。 
	 * </ b>如果实现不支持显式删除对象，则它们可能会抛出{@link  UnsupportedOperationException}。 
	 *  
	 * @param 命名要删除的对象的名称
	 * @return 删除的对象，如果没有对象，则为{@code  null} 
	 * @throws 如果基础作用域当前未激活，则为IllegalStateException 
	 * @see  #registerDestructionCallback
	 */
	@Nullable
	Object remove(String name);

	/**
	 * Register a callback to be executed on destruction of the specified
	 * object in the scope (or at destruction of the entire scope, if the
	 * scope does not destroy individual objects but rather only terminates
	 * in its entirety).
	 * <p><b>Note: This is an optional operation.</b> This method will only
	 * be called for scoped beans with actual destruction configuration
	 * (DisposableBean, destroy-method, DestructionAwareBeanPostProcessor).
	 * Implementations should do their best to execute a given callback
	 * at the appropriate time. If such a callback is not supported by the
	 * underlying runtime environment at all, the callback <i>must be
	 * ignored and a corresponding warning should be logged</i>.
	 * <p>Note that 'destruction' refers to automatic destruction of
	 * the object as part of the scope's own lifecycle, not to the individual
	 * scoped object having been explicitly removed by the application.
	 * If a scoped object gets removed via this facade's {@link #remove(String)}
	 * method, any registered destruction callback should be removed as well,
	 * assuming that the removed object will be reused or manually destroyed.
	 * @param name the name of the object to execute the destruction callback for
	 * @param callback the destruction callback to be executed.
	 * Note that the passed-in Runnable will never throw an exception,
	 * so it can safely be executed without an enclosing try-catch block.
	 * Furthermore, the Runnable will usually be serializable, provided
	 * that its target object is serializable as well.
	 * @throws IllegalStateException if the underlying scope is not currently active
	 * @see org.springframework.beans.factory.DisposableBean
	 * @see org.springframework.beans.factory.support.AbstractBeanDefinition#getDestroyMethodName()
	 * @see DestructionAwareBeanPostProcessor
	 */
	/**
	 * 注册一个回调，以在破坏范围内的指定对象时执行（或破坏整个范围，如果该作用域不破坏单个对象而是仅完全终止）。 
	 *  <p> <b>注意：这是一个可选操作。 
	 * </ b>该方法仅在具有实际销毁配置（DisposableBean，destroy-method，DestructionAwareBeanPostProcessor）的范围内的bean中调用。 
	 * 实现应尽力在适当的时间执行给定的回调。 
	 * 如果底层运行时环境根本不支持此类回调，则必须忽略该回调<i>，并记录相应的警告</ i>。 
	 *  <p>请注意，"销毁"是指将对象自动销毁为作用域自身生命周期的一部分，而不是指已被应用程序明确删除的单个作用域对象。 
	 * 如果通过此立面的{@link  #remove（String）}方法删除了范围对象，则假定已删除的对象将被重用或手动销毁，所有已注册的销毁回调也应被删除。 
	 *  
	 * @param 命名要执行销毁回调的对象的名称，而
	 * @param 回调将执行销毁回调。 
	 * 请注意，传入的Runnable将永远不会引发异常，因此无需封闭try-catch块就可以安全地执行该异常。 
	 * 此外，Runnable通常将可序列化，前提是其目标对象也可序列化。 
	 *  
	 * @throws  IllegalStateException如果基础作用域当前未激活
	 * @see  org.springframework.beans.factory.DisposableBean 
	 * @see  org.springframework.beans.factory.support.AbstractBeanDefinition＃getDestroyMethodName（）
	 * @see  DestructionAwareBeanPostProcessor
	 */
	void registerDestructionCallback(String name, Runnable callback);

	/**
	 * Resolve the contextual object for the given key, if any.
	 * E.g. the HttpServletRequest object for key "request".
	 * @param key the contextual key
	 * @return the corresponding object, or {@code null} if none found
	 * @throws IllegalStateException if the underlying scope is not currently active
	 */
	/**
	 * 解决给定键的上下文对象（如果有）。 
	 * 例如。 
	 * 密钥"request"的HttpServletRequest对象。 
	 *  
	 * @param 键，上下文键
	 * @return 相应的对象，或者{@code  null}（如果找不到）
	 * @throws  IllegalStateException如果基础作用域当前未激活
	 */
	@Nullable
	Object resolveContextualObject(String key);

	/**
	 * Return the <em>conversation ID</em> for the current underlying scope, if any.
	 * <p>The exact meaning of the conversation ID depends on the underlying
	 * storage mechanism. In the case of session-scoped objects, the
	 * conversation ID would typically be equal to (or derived from) the
	 * {@link javax.servlet.http.HttpSession#getId() session ID}; in the
	 * case of a custom conversation that sits within the overall session,
	 * the specific ID for the current conversation would be appropriate.
	 * <p><b>Note: This is an optional operation.</b> It is perfectly valid to
	 * return {@code null} in an implementation of this method if the
	 * underlying storage mechanism has no obvious candidate for such an ID.
	 * @return the conversation ID, or {@code null} if there is no
	 * conversation ID for the current scope
	 * @throws IllegalStateException if the underlying scope is not currently active
	 */
	/**
	 * 返回当前基础范围的<em>对话ID </ em>（如果有）。 
	 *  <p>对话ID的确切含义取决于基础存储机制。 
	 * 对于会话范围的对象，会话ID通常等于（或派生自）{@link  javax.servlet.http.HttpSession＃getId（）会话ID}； 
	 * 如果自定义对话位于整个会话中，则当前对话的特定ID是合适的。 
	 *  <p> <b>注意：这是一个可选操作。 
	 * </ b>如果基础存储机制没有明显的候选者可以返回{@code  null}，则在此方法的实现中是完全有效的。 
	 *  
	 * @return 对话ID，如果当前作用域没有对话ID，则为{@code  null} 
	 * @throws  IllegalStateException如果基础作用域当前未激活
	 */
	@Nullable
	String getConversationId();

}
