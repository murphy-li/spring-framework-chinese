/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.factory.config;

import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.lang.Nullable;
import org.springframework.util.StringValueResolver;

/**
 * Abstract base class for property resource configurers that resolve placeholders
 * in bean definition property values. Implementations <em>pull</em> values from a
 * properties file or other {@linkplain org.springframework.core.env.PropertySource
 * property source} into bean definitions.
 *
 * <p>The default placeholder syntax follows the Ant / Log4J / JSP EL style:
 *
 * <pre class="code">${...}</pre>
 *
 * Example XML bean definition:
 *
 * <pre class="code">
 * &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"/&gt;
 *   &lt;property name="driverClassName" value="${driver}"/&gt;
 *   &lt;property name="url" value="jdbc:${dbname}"/&gt;
 * &lt;/bean&gt;
 * </pre>
 *
 * Example properties file:
 *
 * <pre class="code">driver=com.mysql.jdbc.Driver
 * dbname=mysql:mydb</pre>
 *
 * Annotated bean definitions may take advantage of property replacement using
 * the {@link org.springframework.beans.factory.annotation.Value @Value} annotation:
 *
 * <pre class="code">@Value("${person.age}")</pre>
 *
 * Implementations check simple property values, lists, maps, props, and bean names
 * in bean references. Furthermore, placeholder values can also cross-reference
 * other placeholders, like:
 *
 * <pre class="code">rootPath=myrootdir
 * subPath=${rootPath}/subdir</pre>
 *
 * In contrast to {@link PropertyOverrideConfigurer}, subclasses of this type allow
 * filling in of explicit placeholders in bean definitions.
 *
 * <p>If a configurer cannot resolve a placeholder, a {@link BeanDefinitionStoreException}
 * will be thrown. If you want to check against multiple properties files, specify multiple
 * resources via the {@link #setLocations locations} property. You can also define multiple
 * configurers, each with its <em>own</em> placeholder syntax. Use {@link
 * #ignoreUnresolvablePlaceholders} to intentionally suppress throwing an exception if a
 * placeholder cannot be resolved.
 *
 * <p>Default property values can be defined globally for each configurer instance
 * via the {@link #setProperties properties} property, or on a property-by-property basis
 * using the default value separator which is {@code ":"} by default and
 * customizable via {@link #setValueSeparator(String)}.
 *
 * <p>Example XML property with default value:
 *
 * <pre class="code">
 *   <property name="url" value="jdbc:${dbname:defaultdb}"/>
 * </pre>
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see PropertyPlaceholderConfigurer
 * @see org.springframework.context.support.PropertySourcesPlaceholderConfigurer
 */
/**
 * 属性资源配置程序的抽象基类，用于解析bean定义属性值中的占位符。 
 * 将属性文件或其他{@link  plain org.springframework.core.env.PropertySource属性source}的实现<em> pull </ em>值转换为bean定义。 
 *  <p>默认的占位符语法遵循Ant / Log4J / JSP EL样式：<pre class ="code"> $ {...} </ pre> XML bean定义示例：<pre class ="code"> <bean id ="dataSource"class ="org.springframework.jdbc.datasource.DriverManagerDataSource"/> <属性名称="driverClassName"value ="$ {driver}"/> <属性名称="url"value ="jdbc：$ {dbname}"/> </ bean> </ pre>示例属性文件：<pre class ="code"> driver = com.mysql.jdbc.Driver dbname = mysql：mydb </ pre>带注释的Bean定义可以利用使用{@link  org.springframework.beans.factory.annotation.Value @Value}注释进行属性替换：<pre class ="code"> @Value（"$ {person.age}"）</ pre>实现检查Bean引用中的简单属性值，列表，地图，道具和Bean名称。 
 * 此外，占位符值还可以交叉引用其他占位符，例如：<pre class ="code"> rootPath = myrootdir subPath = $ {rootPath} / subdir </ pre>与{@link  PropertyOverrideConfigurer}相比，此类型允许在bean定义中填充显式占位符。 
 *  <p>如果配置程序无法解析占位符，则将引发{@link  BeanDefinitionStoreException}。 
 * 如果要检查多个属性文件，请通过{@link  #setLocations位置}属性指定多个资源。 
 * 您还可以定义多个配置器，每个配置器都具有其<em> own </ em>占位符语法。 
 * 如果无法解析占位符，请使用{@link  #ignoreUnresolvablePlaceholders}故意禁止引发异常。 
 *  <p>可以通过{@link  #setProperties properties}属性为每个配置程序实例全局定义默认属性值，也可以使用默认值分隔符{@code "在逐个属性的基础上定义： "}默认情况下，可以通过{@link  #setValueSeparator（String）}进行自定义。 
 *  <p>示例XML属性，默认值为：<pre class ="code"> <属性名="url"value ="jdbc：$ {dbname：defaultdb}"/> </ pre> @author 克里斯·贝姆斯@author  Juergen Hoeller @since 3.1 
 * @see  PropertyPlaceholderConfigurer 
 * @see  org.springframework.context.support.PropertySourcesPlaceholderConfigurer
 */
public abstract class PlaceholderConfigurerSupport extends PropertyResourceConfigurer
		implements BeanNameAware, BeanFactoryAware {

	/** Default placeholder prefix: {@value}. */
	/**
	 * 默认的占位符前缀：{@value}。 
	 * 
	 */
	public static final String DEFAULT_PLACEHOLDER_PREFIX = "${";

	/** Default placeholder suffix: {@value}. */
	/**
	 * 默认占位符后缀：{@value}。 
	 * 
	 */
	public static final String DEFAULT_PLACEHOLDER_SUFFIX = "}";

	/** Default value separator: {@value}. */
	/**
	 * 默认值分隔符：{@value}。 
	 * 
	 */
	public static final String DEFAULT_VALUE_SEPARATOR = ":";


	/** Defaults to {@value #DEFAULT_PLACEHOLDER_PREFIX}. */
	/**
	 * 默认为{@value #DEFAULT_PLACEHOLDER_PREFIX}。 
	 * 
	 */
	protected String placeholderPrefix = DEFAULT_PLACEHOLDER_PREFIX;

	/** Defaults to {@value #DEFAULT_PLACEHOLDER_SUFFIX}. */
	/**
	 * 默认为{@value #DEFAULT_PLACEHOLDER_SUFFIX}。 
	 * 
	 */
	protected String placeholderSuffix = DEFAULT_PLACEHOLDER_SUFFIX;

	/** Defaults to {@value #DEFAULT_VALUE_SEPARATOR}. */
	/**
	 * 默认为{@value #DEFAULT_VALUE_SEPARATOR}。 
	 * 
	 */
	@Nullable
	protected String valueSeparator = DEFAULT_VALUE_SEPARATOR;

	protected boolean trimValues = false;

	@Nullable
	protected String nullValue;

	protected boolean ignoreUnresolvablePlaceholders = false;

	@Nullable
	private String beanName;

	@Nullable
	private BeanFactory beanFactory;


	/**
	 * Set the prefix that a placeholder string starts with.
	 * The default is {@value #DEFAULT_PLACEHOLDER_PREFIX}.
	 */
	/**
	 * 设置占位符字符串开头的前缀。 
	 * 默认值为{@value #DEFAULT_PLACEHOLDER_PREFIX}。 
	 * 
	 */
	public void setPlaceholderPrefix(String placeholderPrefix) {
		this.placeholderPrefix = placeholderPrefix;
	}

	/**
	 * Set the suffix that a placeholder string ends with.
	 * The default is {@value #DEFAULT_PLACEHOLDER_SUFFIX}.
	 */
	/**
	 * 设置占位符字符串结尾的后缀。 
	 * 默认值为{@value #DEFAULT_PLACEHOLDER_SUFFIX}。 
	 * 
	 */
	public void setPlaceholderSuffix(String placeholderSuffix) {
		this.placeholderSuffix = placeholderSuffix;
	}

	/**
	 * Specify the separating character between the placeholder variable
	 * and the associated default value, or {@code null} if no such
	 * special character should be processed as a value separator.
	 * The default is {@value #DEFAULT_VALUE_SEPARATOR}.
	 */
	/**
	 * 指定占位符变量和关联的默认值之间的分隔字符，如果没有此类特殊字符应作为值分隔符处理，则指定{@code  null}。 
	 * 默认值为{@value #DEFAULT_VALUE_SEPARATOR}。 
	 * 
	 */
	public void setValueSeparator(@Nullable String valueSeparator) {
		this.valueSeparator = valueSeparator;
	}

	/**
	 * Specify whether to trim resolved values before applying them,
	 * removing superfluous whitespace from the beginning and end.
	 * <p>Default is {@code false}.
	 * @since 4.3
	 */
	/**
	 * 指定在应用解析值之前是否修剪它们，从开头和结尾删除多余的空格。 
	 *  <p>默认值为{@code  false}。 
	 *  @4.3起
	 */
	public void setTrimValues(boolean trimValues) {
		this.trimValues = trimValues;
	}

	/**
	 * Set a value that should be treated as {@code null} when resolved
	 * as a placeholder value: e.g. "" (empty String) or "null".
	 * <p>Note that this will only apply to full property values,
	 * not to parts of concatenated values.
	 * <p>By default, no such null value is defined. This means that
	 * there is no way to express {@code null} as a property value
	 * unless you explicitly map a corresponding value here.
	 */
	/**
	 * 设置一个在解析为占位符值时应视为{@code  null}的值： ""（空字符串）或"null"。 
	 *  <p>请注意，这仅适用于完整属性值，不适用于部分串联值。 
	 *  <p>默认情况下，未定义任何空值。 
	 * 这意味着除非在此显式映射对应的值，否则无法将{@code  null}表示为属性值。 
	 * 
	 */
	public void setNullValue(String nullValue) {
		this.nullValue = nullValue;
	}

	/**
	 * Set whether to ignore unresolvable placeholders.
	 * <p>Default is "false": An exception will be thrown if a placeholder fails
	 * to resolve. Switch this flag to "true" in order to preserve the placeholder
	 * String as-is in such a case, leaving it up to other placeholder configurers
	 * to resolve it.
	 */
	/**
	 * 设置是否忽略不可解析的占位符。 
	 *  <p>默认为"false"：如果占位符解析失败，将引发异常。 
	 * 在这种情况下，将此标志切换为"true"，以按原样保留占位符字符串，然后将其留给其他占位符配置程序来解决。 
	 * 
	 */
	public void setIgnoreUnresolvablePlaceholders(boolean ignoreUnresolvablePlaceholders) {
		this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;
	}

	/**
	 * Only necessary to check that we're not parsing our own bean definition,
	 * to avoid failing on unresolvable placeholders in properties file locations.
	 * The latter case can happen with placeholders for system properties in
	 * resource locations.
	 * @see #setLocations
	 * @see org.springframework.core.io.ResourceEditor
	 */
	/**
	 * 只需检查我们是否未解析自己的bean定义，就可以避免在属性文件位置中无法解析的占位符失败。 
	 * 后一种情况可能发生在资源位置中系统属性的占位符。 
	 *  
	 * @see  #setLocations 
	 * @see  org.springframework.core.io.ResourceEditor
	 */
	@Override
	public void setBeanName(String beanName) {
		this.beanName = beanName;
	}

	/**
	 * Only necessary to check that we're not parsing our own bean definition,
	 * to avoid failing on unresolvable placeholders in properties file locations.
	 * The latter case can happen with placeholders for system properties in
	 * resource locations.
	 * @see #setLocations
	 * @see org.springframework.core.io.ResourceEditor
	 */
	/**
	 * 只需检查我们是否未解析自己的bean定义，就可以避免在属性文件位置中无法解析的占位符失败。 
	 * 后一种情况可能发生在资源位置中系统属性的占位符。 
	 *  
	 * @see  #setLocations 
	 * @see  org.springframework.core.io.ResourceEditor
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}


	protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
			StringValueResolver valueResolver) {

		BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);

		String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();
		for (String curName : beanNames) {
			// Check that we're not parsing our own bean definition,
			// to avoid failing on unresolvable placeholders in properties file locations.
			if (!(curName.equals(this.beanName) && beanFactoryToProcess.equals(this.beanFactory))) {
				BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);
				try {
					visitor.visitBeanDefinition(bd);
				}
				catch (Exception ex) {
					throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);
				}
			}
		}

		// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
		beanFactoryToProcess.resolveAliases(valueResolver);

		// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
		beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);
	}

}
