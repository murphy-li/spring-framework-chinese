/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans;

import java.beans.PropertyDescriptor;
import java.beans.PropertyEditor;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URL;
import java.time.temporal.Temporal;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import kotlin.jvm.JvmClassMappingKt;
import kotlin.reflect.KFunction;
import kotlin.reflect.KParameter;
import kotlin.reflect.full.KClasses;
import kotlin.reflect.jvm.ReflectJvmMapping;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.KotlinDetector;
import org.springframework.core.MethodParameter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * Static convenience methods for JavaBeans: for instantiating beans,
 * checking bean property types, copying bean properties, etc.
 *
 * <p>Mainly for internal use within the framework, but to some degree also
 * useful for application classes. Consider
 * <a href="https://commons.apache.org/proper/commons-beanutils/">Apache Commons BeanUtils</a>,
 * <a href="https://hotelsdotcom.github.io/bull/">BULL - Bean Utils Light Library</a>,
 * or similar third-party frameworks for more comprehensive bean utilities.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Sam Brannen
 * @author Sebastien Deleuze
 */
/**
 * JavaBean的静态便捷方法：用于实例化bean，检查bean属性类型，复制bean属性等。 
 * <p>主要供框架内部使用，但在某种程度上也对应用程序类有用。 
 * 考虑<a href="https://commons.apache.org/proper/commons-beanutils/"> Apache Commons BeanUtils </a>，<a href ="https://hotelsdotcom.github.io/bull/"> BULL-Bean Utils Light库</a>，或类似的第三方框架，用于更全面的Bean实用程序。 
 *  @author 罗德·约翰逊@author  Juergen Hoeller @author  Rob Harrop @author  Sam Brannen @author 塞巴斯蒂安·德勒兹（Sebastien Deleuze）
 */
public abstract class BeanUtils {

	private static final Log logger = LogFactory.getLog(BeanUtils.class);

	private static final Set<Class<?>> unknownEditorTypes =
			Collections.newSetFromMap(new ConcurrentReferenceHashMap<>(64));

	private static final Map<Class<?>, Object> DEFAULT_TYPE_VALUES;

	static {
		Map<Class<?>, Object> values = new HashMap<>();
		values.put(boolean.class, false);
		values.put(byte.class, (byte) 0);
		values.put(short.class, (short) 0);
		values.put(int.class, 0);
		values.put(long.class, (long) 0);
		DEFAULT_TYPE_VALUES = Collections.unmodifiableMap(values);
	}


	/**
	 * Convenience method to instantiate a class using its no-arg constructor.
	 * @param clazz class to instantiate
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @deprecated as of Spring 5.0, following the deprecation of
	 * {@link Class#newInstance()} in JDK 9
	 * @see Class#newInstance()
	 */
	/**
	 * 使用其无参数构造函数实例化类的便捷方法。 
	 *  
	 * @param  clazz类以实例化
	 * @return 新实例
	 * @throws  BeanInstantiationException如果在JDK中弃用了{@link  Class＃newInstance（）}之后，无法在Spring 5.0之前实例化@Bean，则实例化BeanInstantiationException。 
	 *  9 
	 * @see  Class＃newInstance（）
	 */
	@Deprecated
	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {
		Assert.notNull(clazz, "Class must not be null");
		if (clazz.isInterface()) {
			throw new BeanInstantiationException(clazz, "Specified class is an interface");
		}
		try {
			return clazz.newInstance();
		}
		catch (InstantiationException ex) {
			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex);
		}
		catch (IllegalAccessException ex) {
			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex);
		}
	}

	/**
	 * Instantiate a class using its 'primary' constructor (for Kotlin classes,
	 * potentially having default arguments declared) or its default constructor
	 * (for regular Java classes, expecting a standard no-arg setup).
	 * <p>Note that this method tries to set the constructor accessible
	 * if given a non-accessible (that is, non-public) constructor.
	 * @param clazz the class to instantiate
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated.
	 * The cause may notably indicate a {@link NoSuchMethodException} if no
	 * primary/default constructor was found, a {@link NoClassDefFoundError}
	 * or other {@link LinkageError} in case of an unresolvable class definition
	 * (e.g. due to a missing dependency at runtime), or an exception thrown
	 * from the constructor invocation itself.
	 * @see Constructor#newInstance
	 */
	/**
	 * 使用其"主要"构造函数（对于Kotlin类，可能声明了默认参数）或其缺省构造函数（对于常规Java类，需要标准无参数设置）实例化一个类。 
	 *  <p>请注意，如果给定了不可访问的（即非公共的）构造函数，则此方法尝试将构造函数设置为可访问。 
	 * 如果无法实例化bean，则
	 * @param 使类实例化，以实例化
	 * @return 新实例
	 * @throws  BeanInstantiationException。 
	 * 如果未找到主/默认构造函数，则原因可能会特别指示{@link  NoSuchMethodException}，在无法解析的类定义（例如，由于在运行时缺少依赖项），或者从构造函数调用本身引发的异常。 
	 *  
	 * @see 构造函数#newInstance
	 */
	public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {
		Assert.notNull(clazz, "Class must not be null");
		if (clazz.isInterface()) {
			throw new BeanInstantiationException(clazz, "Specified class is an interface");
		}
		try {
			return instantiateClass(clazz.getDeclaredConstructor());
		}
		catch (NoSuchMethodException ex) {
			Constructor<T> ctor = findPrimaryConstructor(clazz);
			if (ctor != null) {
				return instantiateClass(ctor);
			}
			throw new BeanInstantiationException(clazz, "No default constructor found", ex);
		}
		catch (LinkageError err) {
			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err);
		}
	}

	/**
	 * Instantiate a class using its no-arg constructor and return the new instance
	 * as the specified assignable type.
	 * <p>Useful in cases where the type of the class to instantiate (clazz) is not
	 * available, but the type desired (assignableTo) is known.
	 * <p>Note that this method tries to set the constructor accessible if given a
	 * non-accessible (that is, non-public) constructor.
	 * @param clazz class to instantiate
	 * @param assignableTo type that clazz must be assignableTo
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @see Constructor#newInstance
	 */
	/**
	 * 使用其无参数构造函数实例化一个类，并以指定的可分配类型返回新实例。 
	 *  <p>在无法实例化的类的类型（clazz）可用，但是所需类型（assignableTo）已知的情况下有用。 
	 *  <p>请注意，如果给定了不可访问的（即非公共的）构造函数，则此方法尝试将构造函数设置为可访问。 
	 *  
	 * @param 实例化的clazz类
	 * @param  AssignableTo键入clazz必须可分配到
	 * @return 新实例
	 * @throws  BeanInstantiationException如果无法实例化Bean 
	 * @see  Constructor＃newInstance
	 */
	@SuppressWarnings("unchecked")
	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {
		Assert.isAssignable(assignableTo, clazz);
		return (T) instantiateClass(clazz);
	}

	/**
	 * Convenience method to instantiate a class using the given constructor.
	 * <p>Note that this method tries to set the constructor accessible if given a
	 * non-accessible (that is, non-public) constructor, and supports Kotlin classes
	 * with optional parameters and default values.
	 * @param ctor the constructor to instantiate
	 * @param args the constructor arguments to apply (use {@code null} for an unspecified
	 * parameter, Kotlin optional parameters and Java primitive types are supported)
	 * @return the new instance
	 * @throws BeanInstantiationException if the bean cannot be instantiated
	 * @see Constructor#newInstance
	 */
	/**
	 * 使用给定构造函数实例化类的便捷方法。 
	 *  <p>请注意，如果给定了不可访问的（即非公共的）构造函数，则此方法尝试将构造函数设置为可访问，并支持带有可选参数和默认值的Kotlin类。 
	 *  
	 * @param 构造函数实例化
	 * @param  args应用构造函数参数（对于未指定的参数使用{@code  null}，支持Kotlin可选参数和Java基本类型）
	 * @return 新实例
	 * @throws  BeanInstantiationException如果无法实例化bean 
	 * @see  Constructor＃newInstance
	 */
	public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {
		Assert.notNull(ctor, "Constructor must not be null");
		try {
			ReflectionUtils.makeAccessible(ctor);
			if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {
				return KotlinDelegate.instantiateClass(ctor, args);
			}
			else {
				Class<?>[] parameterTypes = ctor.getParameterTypes();
				Assert.isTrue(args.length <= parameterTypes.length, "Can't specify more arguments than constructor parameters");
				Object[] argsWithDefaultValues = new Object[args.length];
				for (int i = 0 ; i < args.length; i++) {
					if (args[i] == null) {
						Class<?> parameterType = parameterTypes[i];
						argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);
					}
					else {
						argsWithDefaultValues[i] = args[i];
					}
				}
				// 真正实例化对象的地方
				// 真正实例化对象的地方
				// 真正实例化对象的地方
				return ctor.newInstance(argsWithDefaultValues);
			}
		}
		catch (InstantiationException ex) {
			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex);
		}
		catch (IllegalAccessException ex) {
			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex);
		}
		catch (IllegalArgumentException ex) {
			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex);
		}
		catch (InvocationTargetException ex) {
			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException());
		}
	}

	/**
	 * Return the primary constructor of the provided class. For Kotlin classes, this
	 * returns the Java constructor corresponding to the Kotlin primary constructor
	 * (as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin
	 * classes, this simply returns {@code null}.
	 * @param clazz the class to check
	 * @since 5.0
	 * @see <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>
	 */
	/**
	 * 返回所提供类的主要构造函数。 
	 * 对于Kotlin类，这将返回与Kotlin主构造函数（如Kotlin规范中定义）相对应的Java构造函数。 
	 * 否则，特别是对于非Kotlin类，这仅返回{@code  null}。 
	 *  
	 * @param 让班级检查@since 5.0起
	 * @see  <a href="https://kotlinlang.org/docs/reference/classes.html#constructors"> Kotlin文档</a>
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {
		Assert.notNull(clazz, "Class must not be null");
		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {
			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz);
			if (kotlinPrimaryConstructor != null) {
				return kotlinPrimaryConstructor;
			}
		}
		return null;
	}

	/**
	 * Find a method with the given method name and the given parameter types,
	 * declared on the given class or one of its superclasses. Prefers public methods,
	 * but will return a protected, package access, or private method too.
	 * <p>Checks {@code Class.getMethod} first, falling back to
	 * {@code findDeclaredMethod}. This allows to find public methods
	 * without issues even in environments with restricted Java security settings.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @param paramTypes the parameter types of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @see Class#getMethod
	 * @see #findDeclaredMethod
	 */
	/**
	 * 查找在给定类或其超类之一上声明的具有给定方法名称和给定参数类型的方法。 
	 * 首选公共方法，但也将返回受保护的，程序包访问或私有方法。 
	 *  <p>首先检查{@code  Class.getMethod}，然后退回到{@code  findDeclaredMethod}。 
	 * 这样，即使在Java安全设置受限制的环境中，也可以找到没有问题的公共方法。 
	 *  
	 * @param 使类检查
	 * @param  methodName查找方法的名称
	 * @param  paramTypes查找方法的参数类型
	 * @return  Method对象，或者{@code  null}如果未找到
	 * @see  Class＃getMethod 
	 * @see  #findDeclaredMethod
	 */
	@Nullable
	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
		try {
			return clazz.getMethod(methodName, paramTypes);
		}
		catch (NoSuchMethodException ex) {
			return findDeclaredMethod(clazz, methodName, paramTypes);
		}
	}

	/**
	 * Find a method with the given method name and the given parameter types,
	 * declared on the given class or one of its superclasses. Will return a public,
	 * protected, package access, or private method.
	 * <p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @param paramTypes the parameter types of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @see Class#getDeclaredMethod
	 */
	/**
	 * 查找在给定类或其超类之一上声明的具有给定方法名称和给定参数类型的方法。 
	 * 将返回公共，受保护的，程序包访问或私有方法。 
	 *  <p>检查{@code  Class.getDeclaredMethod}，向上级联到所有超类。 
	 *  
	 * @param 使类检查
	 * @param  methodName查找方法的名称
	 * @param  paramTypes查找方法的参数类型
	 * @return  Method对象，或者{@code  null}如果找不到
	 * @see  Class＃getDeclaredMethod
	 */
	@Nullable
	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
		try {
			return clazz.getDeclaredMethod(methodName, paramTypes);
		}
		catch (NoSuchMethodException ex) {
			if (clazz.getSuperclass() != null) {
				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes);
			}
			return null;
		}
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none),
	 * declared on the given class or one of its superclasses. Prefers public methods,
	 * but will return a protected, package access, or private method too.
	 * <p>Checks {@code Class.getMethods} first, falling back to
	 * {@code findDeclaredMethodWithMinimalParameters}. This allows for finding public
	 * methods without issues even in environments with restricted Java security settings.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 * @see Class#getMethods
	 * @see #findDeclaredMethodWithMinimalParameters
	 */
	/**
	 * 查找在给定的类或其父类之一上声明的具有给定方法名称和最小参数（最好的情况：无）的方法。 
	 * 首选公共方法，但也将返回受保护的，程序包访问或私有方法。 
	 *  <p>首先检查{@code  Class.getMethods}，然后退回到{@code  findDeclaredMethodWithMinimalParameters}。 
	 * 这样，即使在Java安全设置受限制的环境中，也可以找到没有问题的公共方法。 
	 *  
	 * @param 使类检查
	 * @param  methodName查找要查找的方法的名称
	 * @return  Method对象，如果找不到，则返回{@code  null} 
	 * @throws  IllegalArgumentException如果给定的方法找到名称，但无法将其解析为具有最小参数的唯一方法
	 * @see  Class＃getMethods 
	 * @see  #findDeclaredMethodWithMinimalParameters
	 */
	@Nullable
	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)
			throws IllegalArgumentException {

		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName);
		if (targetMethod == null) {
			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName);
		}
		return targetMethod;
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none),
	 * declared on the given class or one of its superclasses. Will return a public,
	 * protected, package access, or private method.
	 * <p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses.
	 * @param clazz the class to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 * @see Class#getDeclaredMethods
	 */
	/**
	 * 查找在给定的类或其父类之一上声明的具有给定方法名称和最小参数（最好的情况：无）的方法。 
	 * 将返回公共，受保护的，程序包访问或私有方法。 
	 *  <p>检查{@code  Class.getDeclaredMethods}，向上级联到所有超类。 
	 *  
	 * @param 使类检查
	 * @param  methodName查找要查找的方法的名称
	 * @return  Method对象，如果找不到，则返回{@code  null} 
	 * @throws  IllegalArgumentException如果给定的方法找到名称，但无法将其解析为具有最少参数的唯一方法
	 * @see  Class＃getDeclaredMethods
	 */
	@Nullable
	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)
			throws IllegalArgumentException {

		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName);
		if (targetMethod == null && clazz.getSuperclass() != null) {
			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName);
		}
		return targetMethod;
	}

	/**
	 * Find a method with the given method name and minimal parameters (best case: none)
	 * in the given list of methods.
	 * @param methods the methods to check
	 * @param methodName the name of the method to find
	 * @return the Method object, or {@code null} if not found
	 * @throws IllegalArgumentException if methods of the given name were found but
	 * could not be resolved to a unique method with minimal parameters
	 */
	/**
	 * 在给定的方法列表中找到具有给定方法名称和最少参数（最好的情况：无）的方法。 
	 *  
	 * @param 方法检查方法的方法
	 * @param  methodName查找方法对象的名称
	 * @return  Method对象，如果找不到，则返回{@code  null} 
	 * @throws  IllegalArgumentException如果给定的方法找到名称，但无法将其解析为具有最少参数的唯一方法
	 */
	@Nullable
	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)
			throws IllegalArgumentException {

		Method targetMethod = null;
		int numMethodsFoundWithCurrentMinimumArgs = 0;
		for (Method method : methods) {
			if (method.getName().equals(methodName)) {
				int numParams = method.getParameterCount();
				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {
					targetMethod = method;
					numMethodsFoundWithCurrentMinimumArgs = 1;
				}
				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {
					if (targetMethod.isBridge()) {
						// Prefer regular method over bridge...
						targetMethod = method;
					}
					else {
						// Additional candidate with same length
						numMethodsFoundWithCurrentMinimumArgs++;
					}
				}
			}
		}
		if (numMethodsFoundWithCurrentMinimumArgs > 1) {
			throw new IllegalArgumentException("Cannot resolve method '" + methodName +
					"' to a unique method. Attempted to resolve to overloaded method with " +
					"the least number of parameters but there were " +
					numMethodsFoundWithCurrentMinimumArgs + " candidates.");
		}
		return targetMethod;
	}

	/**
	 * Parse a method signature in the form {@code methodName[([arg_list])]},
	 * where {@code arg_list} is an optional, comma-separated list of fully-qualified
	 * type names, and attempts to resolve that signature against the supplied {@code Class}.
	 * <p>When not supplying an argument list ({@code methodName}) the method whose name
	 * matches and has the least number of parameters will be returned. When supplying an
	 * argument type list, only the method whose name and argument types match will be returned.
	 * <p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>
	 * resolved in the same way. The signature {@code methodName} means the method called
	 * {@code methodName} with the least number of arguments, whereas {@code methodName()}
	 * means the method called {@code methodName} with exactly 0 arguments.
	 * <p>If no method can be found, then {@code null} is returned.
	 * @param signature the method signature as String representation
	 * @param clazz the class to resolve the method signature against
	 * @return the resolved Method
	 * @see #findMethod
	 * @see #findMethodWithMinimalParameters
	 */
	/**
	 * 解析形式为{@code  methodName [（[[arg_list]）]}的方法签名，其中{@code  arg_list}是一个可选的，用逗号分隔的完全限定类型名称的列表，并尝试解决该问题针对提供的{@code 类}签名。 
	 *  <p>不提供参数列表（{@code  methodName}）时，将返回名称匹配且参数数量最少的方法。 
	 * 提供参数类型列表时，仅返回名称和参数类型匹配的方法。 
	 *  <p>然后请注意，<strong>不能</ strong>以相同的方式解析{@code  methodName}和{@code  methodName（）}。 
	 * 签名{@code  methodName}表示参数最少的称为{@code  methodName}的方法，而{@code  methodName（）}表示具有完全自变量的称为{@code  methodName}的方法0个参数。 
	 *  <p>如果找不到方法，则返回{@code  null}。 
	 *  
	 * @param 以字符串表示形式对方法签名进行签名
	 * @param 吸引类，以针对已解决的方法
	 * @return 解析方法
	 * @see  #findMethod 
	 * @see  #findMethodWithMinimalParameters
	 */
	@Nullable
	public static Method resolveSignature(String signature, Class<?> clazz) {
		Assert.hasText(signature, "'signature' must not be empty");
		Assert.notNull(clazz, "Class must not be null");
		int startParen = signature.indexOf('(');
		int endParen = signature.indexOf(')');
		if (startParen > -1 && endParen == -1) {
			throw new IllegalArgumentException("Invalid method signature '" + signature +
					"': expected closing ')' for args list");
		}
		else if (startParen == -1 && endParen > -1) {
			throw new IllegalArgumentException("Invalid method signature '" + signature +
					"': expected opening '(' for args list");
		}
		else if (startParen == -1) {
			return findMethodWithMinimalParameters(clazz, signature);
		}
		else {
			String methodName = signature.substring(0, startParen);
			String[] parameterTypeNames =
					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen));
			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];
			for (int i = 0; i < parameterTypeNames.length; i++) {
				String parameterTypeName = parameterTypeNames[i].trim();
				try {
					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader());
				}
				catch (Throwable ex) {
					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +
							parameterTypeName + "] for argument " + i + ". Root cause: " + ex);
				}
			}
			return findMethod(clazz, methodName, parameterTypes);
		}
	}


	/**
	 * Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class.
	 * @param clazz the Class to retrieve the PropertyDescriptors for
	 * @return an array of {@code PropertyDescriptors} for the given class
	 * @throws BeansException if PropertyDescriptor look fails
	 */
	/**
	 * 检索给定类的JavaBeans {@code  PropertyDescriptor}。 
	 * 如果给定的类
	 * @throws ，<
	 * @param>会吸引类，以获取给定类
	 * @throws 的{@code  PropertyDescriptors}数组的
	 * @return 的PropertyDescriptors BeansException，如果PropertyDescriptor外观失败
	 */
	public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {
		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);
		return cr.getPropertyDescriptors();
	}

	/**
	 * Retrieve the JavaBeans {@code PropertyDescriptors} for the given property.
	 * @param clazz the Class to retrieve the PropertyDescriptor for
	 * @param propertyName the name of the property
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 */
	/**
	 * 检索给定属性的JavaBeans {@code  PropertyDescriptors}。 
	 *  
	 * @param 吸引类，以获取
	 * @param  property的PropertyDescriptor名称属性的名称
	 * @return 对应的PropertyDescriptor，如果没有，则为{@code  null} 
	 * @throws  BeansException如果PropertyDescriptor查找失败
	 */
	@Nullable
	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)
			throws BeansException {

		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);
		return cr.getPropertyDescriptor(propertyName);
	}

	/**
	 * Find a JavaBeans {@code PropertyDescriptor} for the given method,
	 * with the method either being the read method or the write method for
	 * that bean property.
	 * @param method the method to find a corresponding PropertyDescriptor for,
	 * introspecting its declaring class
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 */
	/**
	 * 查找给定方法的JavaBeans {@code  PropertyDescriptor}，该方法可以是该bean属性的read方法或write方法。 
	 *  
	 * @param 方法，用于为其找到对应的PropertyDescriptor的方法，将其声明类
	 * @return 内省到相应的PropertyDescriptor，如果没有，则返回{@code  null} 
	 * @throws  BeansException如果PropertyDescriptor查找失败
	 */
	@Nullable
	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {
		return findPropertyForMethod(method, method.getDeclaringClass());
	}

	/**
	 * Find a JavaBeans {@code PropertyDescriptor} for the given method,
	 * with the method either being the read method or the write method for
	 * that bean property.
	 * @param method the method to find a corresponding PropertyDescriptor for
	 * @param clazz the (most specific) class to introspect for descriptors
	 * @return the corresponding PropertyDescriptor, or {@code null} if none
	 * @throws BeansException if PropertyDescriptor lookup fails
	 * @since 3.2.13
	 */
	/**
	 * 查找给定方法的JavaBeans {@code  PropertyDescriptor}，该方法可以是该bean属性的read方法或write方法。 
	 *  
	 * @param 方法为
	 * @param 找到相应的PropertyDescriptor的方法使（最具体的）类内省到描述符
	 * @return 相应的PropertyDescriptor，或者如果没有，则{@code  null} BeansException，如果PropertyDescriptor查找失败（自3.2.13开始）
	 */
	@Nullable
	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {
		Assert.notNull(method, "Method must not be null");
		PropertyDescriptor[] pds = getPropertyDescriptors(clazz);
		for (PropertyDescriptor pd : pds) {
			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {
				return pd;
			}
		}
		return null;
	}

	/**
	 * Find a JavaBeans PropertyEditor following the 'Editor' suffix convention
	 * (e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor").
	 * <p>Compatible to the standard JavaBeans convention as implemented by
	 * {@link java.beans.PropertyEditorManager} but isolated from the latter's
	 * registered default editors for primitive types.
	 * @param targetType the type to find an editor for
	 * @return the corresponding editor, or {@code null} if none found
	 */
	/**
	 * 按照"编辑器"后缀约定找到JavaBeans PropertyEditor（例如"mypackage.MyDomainClass"->"mypackage.MyDomainClassEditor"）。 
	 *  <p>与{@link  java.beans.PropertyEditorManager}实现的标准JavaBeans约定兼容，但与后者针对原始类型的已注册默认编辑器隔离。 
	 *  
	 * @param  targetType类型以找到
	 * @return 相应编辑器的编辑器，如果找不到，则为{@code  null}
	 */
	@Nullable
	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {
		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {
			return null;
		}
		ClassLoader cl = targetType.getClassLoader();
		if (cl == null) {
			try {
				cl = ClassLoader.getSystemClassLoader();
				if (cl == null) {
					return null;
				}
			}
			catch (Throwable ex) {
				// e.g. AccessControlException on Google App Engine
				if (logger.isDebugEnabled()) {
					logger.debug("Could not access system ClassLoader: " + ex);
				}
				return null;
			}
		}
		String targetTypeName = targetType.getName();
		String editorName = targetTypeName + "Editor";
		try {
			Class<?> editorClass = cl.loadClass(editorName);
			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {
				if (logger.isInfoEnabled()) {
					logger.info("Editor class [" + editorName +
							"] does not implement [java.beans.PropertyEditor] interface");
				}
				unknownEditorTypes.add(targetType);
				return null;
			}
			return (PropertyEditor) instantiateClass(editorClass);
		}
		catch (ClassNotFoundException ex) {
			if (logger.isTraceEnabled()) {
				logger.trace("No property editor [" + editorName + "] found for type " +
						targetTypeName + " according to 'Editor' suffix convention");
			}
			unknownEditorTypes.add(targetType);
			return null;
		}
	}

	/**
	 * Determine the bean property type for the given property from the
	 * given classes/interfaces, if possible.
	 * @param propertyName the name of the bean property
	 * @param beanClasses the classes to check against
	 * @return the property type, or {@code Object.class} as fallback
	 */
	/**
	 * 如果可能，从给定的类/接口确定给定属性的bean属性类型。 
	 *  
	 * @param  propertyName Bean属性的名称。 
	 * 
	 * @param  beanClasses类以检查
	 * @return 属性类型或{@code  Object.class}作为后备
	 */
	public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {
		if (beanClasses != null) {
			for (Class<?> beanClass : beanClasses) {
				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName);
				if (pd != null) {
					return pd.getPropertyType();
				}
			}
		}
		return Object.class;
	}

	/**
	 * Obtain a new MethodParameter object for the write method of the
	 * specified property.
	 * @param pd the PropertyDescriptor for the property
	 * @return a corresponding MethodParameter object
	 */
	/**
	 * 为指定属性的write方法获取一个新的MethodParameter对象。 
	 *  
	 * @param  pd属性的PropertyDescriptor 
	 * @return 对应的MethodParameter对象
	 */
	public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {
		if (pd instanceof GenericTypeAwarePropertyDescriptor) {
			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter());
		}
		else {
			Method writeMethod = pd.getWriteMethod();
			Assert.state(writeMethod != null, "No write method available");
			return new MethodParameter(writeMethod, 0);
		}
	}

	/**
	 * Check if the given type represents a "simple" property: a simple value
	 * type or an array of simple value types.
	 * <p>See {@link #isSimpleValueType(Class)} for the definition of <em>simple
	 * value type</em>.
	 * <p>Used to determine properties to check for a "simple" dependency-check.
	 * @param type the type to check
	 * @return whether the given type represents a "simple" property
	 * @see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE
	 * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies
	 * @see #isSimpleValueType(Class)
	 */
	/**
	 * 检查给定类型是否表示"简单"属性：简单值类型或简单值类型数组。 
	 *  <p>有关<em>简单值类型</ em>的定义，请参见{@link  #isSimpleValueType（Class）}。 
	 *  <p>用于确定用于检查"简单"依赖项检查的属性。 
	 *  
	 * @param 键入类型以检查
	 * @return 给定类型是否表示"简单"属性
	 * @see  org.springframework.beans.factory.support.RootBeanDefinition＃DEPENDENCY_CHECK_SIMPLE 
	 * @see  org.springframework.beans。 
	 *  factory.support.AbstractAutowireCapableBeanFactory＃checkDependencies 
	 * @see  #isSimpleValueType（Class）
	 */
	public static boolean isSimpleProperty(Class<?> type) {
		Assert.notNull(type, "'type' must not be null");
		return isSimpleValueType(type) || (type.isArray() && isSimpleValueType(type.getComponentType()));
	}

	/**
	 * Check if the given type represents a "simple" value type: a primitive or
	 * primitive wrapper, an enum, a String or other CharSequence, a Number, a
	 * Date, a Temporal, a URI, a URL, a Locale, or a Class.
	 * <p>{@code Void} and {@code void} are not considered simple value types.
	 * @param type the type to check
	 * @return whether the given type represents a "simple" value type
	 * @see #isSimpleProperty(Class)
	 */
	/**
	 * 检查给定类型是否表示"简单"值类型：原始或原始包装器，枚举，字符串或其他CharSequence，数字，日期，时间，URI，URL，语言环境或类。 
	 *  <p> {<@code>无效}和{@code 无效}不被视为简单值类型。 
	 *  
	 * @param 键入要检查的类型
	 * @return 给定类型是否表示"简单"值类型
	 * @see  #isSimpleProperty（Class）
	 */
	public static boolean isSimpleValueType(Class<?> type) {
		return (Void.class != type && void.class != type &&
				(ClassUtils.isPrimitiveOrWrapper(type) ||
				Enum.class.isAssignableFrom(type) ||
				CharSequence.class.isAssignableFrom(type) ||
				Number.class.isAssignableFrom(type) ||
				Date.class.isAssignableFrom(type) ||
				Temporal.class.isAssignableFrom(type) ||
				URI.class == type ||
				URL.class == type ||
				Locale.class == type ||
				Class.class == type));
	}


	/**
	 * Copy the property values of the given source bean into the target bean.
	 * <p>Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * <p>This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	/**
	 * 将给定源bean的属性值复制到目标bean中。 
	 *  <p>注意：只要属性匹配，源类和目标类就不必相互匹配，甚至不必彼此派生。 
	 * 源Bean公开但目标Bean没有公开的任何Bean属性都将被静默忽略。 
	 *  <p>这只是一种方便的方法。 
	 * 对于更复杂的传输需求，请考虑使用完整的BeanWrapper。 
	 *  
	 * @param 源源bean 
	 * @param 目标目标bean 
	 * @throws  BeansException如果复制失败
	 * @see  BeanWrapper
	 */
	public static void copyProperties(Object source, Object target) throws BeansException {
		copyProperties(source, target, null, (String[]) null);
	}

	/**
	 * Copy the property values of the given source bean into the given target bean,
	 * only setting properties defined in the given "editable" class (or interface).
	 * <p>Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * <p>This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @param editable the class (or interface) to restrict property setting to
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	/**
	 * 将给定源bean的属性值复制到给定目标bean中，仅设置在给定的"可编辑"类（或接口）中定义的属性。 
	 *  <p>注意：只要属性匹配，源类和目标类就不必相互匹配，甚至不必彼此派生。 
	 * 源Bean公开但目标Bean没有公开的任何Bean属性都将被静默忽略。 
	 *  <p>这只是一种方便的方法。 
	 * 对于更复杂的传输需求，请考虑使用完整的BeanWrapper。 
	 *  
	 * @param 源source bean 
	 * @param 目标target bean 
	 * @param 可编辑类（或接口）以将属性设置限制为
	 * @throws  BeansException，如果复制失败
	 * @see  BeanWrapper
	 */
	public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {
		copyProperties(source, target, editable, (String[]) null);
	}

	/**
	 * Copy the property values of the given source bean into the given target bean,
	 * ignoring the given "ignoreProperties".
	 * <p>Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * <p>This is just a convenience method. For more complex transfer needs,
	 * consider using a full BeanWrapper.
	 * @param source the source bean
	 * @param target the target bean
	 * @param ignoreProperties array of property names to ignore
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	/**
	 * 将给定的源bean的属性值复制到给定的目标bean中，而忽略给定的"ignoreProperties"。 
	 *  <p>注意：只要属性匹配，源类和目标类就不必相互匹配，甚至不必彼此派生。 
	 * 源Bean公开但目标Bean没有公开的任何Bean属性都将被静默忽略。 
	 *  <p>这只是一种方便的方法。 
	 * 对于更复杂的传输需求，请考虑使用完整的BeanWrapper。 
	 *  
	 * @param 源bean的源
	 * @param 目标bean的目标物
	 * @param  ignoreProperties属性名称数组，以忽略
	 * @throws  BeansException，如果复制失败
	 * @see  BeanWrapper
	 */
	public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {
		copyProperties(source, target, null, ignoreProperties);
	}

	/**
	 * Copy the property values of the given source bean into the given target bean.
	 * <p>Note: The source and target classes do not have to match or even be derived
	 * from each other, as long as the properties match. Any bean properties that the
	 * source bean exposes but the target bean does not will silently be ignored.
	 * @param source the source bean
	 * @param target the target bean
	 * @param editable the class (or interface) to restrict property setting to
	 * @param ignoreProperties array of property names to ignore
	 * @throws BeansException if the copying failed
	 * @see BeanWrapper
	 */
	/**
	 * 将给定源bean的属性值复制到给定目标bean中。 
	 *  <p>注意：只要属性匹配，源类和目标类就不必相互匹配，甚至不必彼此派生。 
	 * 源Bean公开但目标Bean没有公开的任何Bean属性都将被静默忽略。 
	 *  
	 * @param 源源bean 
	 * @param 目标目标bean 
	 * @param 可编辑类（或接口）以将属性设置限制为
	 * @param 属性名的ignoreProperties数组以忽略
	 * @throws  BeansException，如果复制失败
	 * @see  BeanWrapper
	 */
	private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,
			@Nullable String... ignoreProperties) throws BeansException {

		Assert.notNull(source, "Source must not be null");
		Assert.notNull(target, "Target must not be null");

		Class<?> actualEditable = target.getClass();
		if (editable != null) {
			if (!editable.isInstance(target)) {
				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +
						"] not assignable to Editable class [" + editable.getName() + "]");
			}
			actualEditable = editable;
		}
		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);
		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);

		for (PropertyDescriptor targetPd : targetPds) {
			Method writeMethod = targetPd.getWriteMethod();
			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {
				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
				if (sourcePd != null) {
					Method readMethod = sourcePd.getReadMethod();
					if (readMethod != null &&
							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {
						try {
							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {
								readMethod.setAccessible(true);
							}
							Object value = readMethod.invoke(source);
							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
								writeMethod.setAccessible(true);
							}
							writeMethod.invoke(target, value);
						}
						catch (Throwable ex) {
							throw new FatalBeanException(
									"Could not copy property '" + targetPd.getName() + "' from source to target", ex);
						}
					}
				}
			}
		}
	}


	/**
	 * Inner class to avoid a hard dependency on Kotlin at runtime.
	 */
	/**
	 * 内部类，以避免在运行时严重依赖Kotlin。 
	 * 
	 */
	private static class KotlinDelegate {

		/**
		 * Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any.
		 * @param clazz the {@link Class} of the Kotlin class
		 * @see <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">
		 * https://kotlinlang.org/docs/reference/classes.html#constructors</a>
		 */
		/**
		 * 检索与Kotlin主构造函数相对应的Java构造函数（如果有）。 
		 *  
		 * @param 提倡Kotlin类的{@link 类} 
		 * @see  <a href="https://kotlinlang.org/docs/reference/classes.html#constructors"> https：// kotlinlang .org / docs / reference / classes.html＃constructors </a>
		 */
		@Nullable
		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {
			try {
				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));
				if (primaryCtor == null) {
					return null;
				}
				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor);
				if (constructor == null) {
					throw new IllegalStateException(
							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName());
				}
				return constructor;
			}
			catch (UnsupportedOperationException ex) {
				return null;
			}
		}

		/**
		 * Instantiate a Kotlin class using the provided constructor.
		 * @param ctor the constructor of the Kotlin class to instantiate
		 * @param args the constructor arguments to apply
		 * (use {@code null} for unspecified parameter if needed)
		 */
		/**
		 * 使用提供的构造函数实例化Kotlin类。 
		 *  
		 * @param 引用Kotlin类的构造函数以实例化
		 * @param  args应用构造函数参数（如果需要，请使用{@code  null}来指定参数）
		 */
		public static <T> T instantiateClass(Constructor<T> ctor, Object... args)
				throws IllegalAccessException, InvocationTargetException, InstantiationException {

			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor);
			if (kotlinConstructor == null) {
				return ctor.newInstance(args);
			}
			List<KParameter> parameters = kotlinConstructor.getParameters();
			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size());
			Assert.isTrue(args.length <= parameters.size(),
					"Number of provided arguments should be less of equals than number of constructor parameters");
			for (int i = 0 ; i < args.length ; i++) {
				if (!(parameters.get(i).isOptional() && args[i] == null)) {
					argParameters.put(parameters.get(i), args[i]);
				}
			}
			return kotlinConstructor.callBy(argParameters);
		}

	}

}
