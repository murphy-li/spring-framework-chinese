/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.beans.support;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * PagedListHolder is a simple state holder for handling lists of objects,
 * separating them into pages. Page numbering starts with 0.
 *
 * <p>This is mainly targeted at usage in web UIs. Typically, an instance will be
 * instantiated with a list of beans, put into the session, and exported as model.
 * The properties can all be set/get programmatically, but the most common way will
 * be data binding, i.e. populating the bean from request parameters. The getters
 * will mainly be used by the view.
 *
 * <p>Supports sorting the underlying list via a {@link SortDefinition} implementation,
 * available as property "sort". By default, a {@link MutableSortDefinition} instance
 * will be used, toggling the ascending value on setting the same property again.
 *
 * <p>The data binding names have to be called "pageSize" and "sort.ascending",
 * as expected by BeanWrapper. Note that the names and the nesting syntax match
 * the respective JSTL EL expressions, like "myModelAttr.pageSize" and
 * "myModelAttr.sort.ascending".
 *
 * @author Juergen Hoeller
 * @since 19.05.2003
 * @param <E> the element type
 * @see #getPageList()
 * @see org.springframework.beans.support.MutableSortDefinition
 */
/**
 * PagedListHolder是一个简单的状态持有者，用于处理对象列表，将它们分成页面。 
 * 页码从0开始。 
 * <p>这主要是针对Web UI中的用法。 
 * 通常，实例将使用一列bean实例化，放入会话中，并作为模型导出。 
 * 这些属性都可以通过编程方式设置/获取，但最常见的方式是数据绑定，即从请求参数填充Bean。 
 * 该吸气剂将主要由视图使用。 
 *  <p>支持通过{@link  SortDefinition}实现对基础列表进行排序，该实现可作为属性"sort"使用。 
 * 默认情况下，将使用{@link  MutableSortDefinition}实例，在再次设置相同属性时切换升序值。 
 *  <p>如BeanWrapper所期望的那样，数据绑定名称必须称为"pageSize"和"sort.ascending"。 
 * 请注意，名称和嵌套语法与相应的JSTL EL表达式匹配，例如"myModelAttr.pageSize"和"myModelAttr.sort.ascending"。 
 *  @author  Juergen Hoeller @2003年5月19日开始
 * @param  <E>元素类型
 * @see  #getPageList（）
 * @see  org.springframework.beans.support.MutableSortDefinition
 */
@SuppressWarnings("serial")
public class PagedListHolder<E> implements Serializable {

	/**
	 * The default page size.
	 */
	/**
	 * 默认页面大小。 
	 * 
	 */
	public static final int DEFAULT_PAGE_SIZE = 10;

	/**
	 * The default maximum number of page links.
	 */
	/**
	 * 默认的最大页面链接数。 
	 * 
	 */
	public static final int DEFAULT_MAX_LINKED_PAGES = 10;


	private List<E> source = Collections.emptyList();

	@Nullable
	private Date refreshDate;

	@Nullable
	private SortDefinition sort;

	@Nullable
	private SortDefinition sortUsed;

	private int pageSize = DEFAULT_PAGE_SIZE;

	private int page = 0;

	private boolean newPageSet;

	private int maxLinkedPages = DEFAULT_MAX_LINKED_PAGES;


	/**
	 * Create a new holder instance.
	 * You'll need to set a source list to be able to use the holder.
	 * @see #setSource
	 */
	/**
	 * 创建一个新的holder实例。 
	 * 您需要设置一个源列表才能使用持有人。 
	 *  
	 * @see  #setSource
	 */
	public PagedListHolder() {
		this(new ArrayList<>(0));
	}

	/**
	 * Create a new holder instance with the given source list, starting with
	 * a default sort definition (with "toggleAscendingOnProperty" activated).
	 * @param source the source List
	 * @see MutableSortDefinition#setToggleAscendingOnProperty
	 */
	/**
	 * 从给定的源列表创建一个新的holder实例，从默认的排序定义开始（激活"toggleAscendingOnProperty"）。 
	 *  
	 * @param 来源来源列表
	 * @see  MutableSortDefinition＃setToggleAscendingOnProperty
	 */
	public PagedListHolder(List<E> source) {
		this(source, new MutableSortDefinition(true));
	}

	/**
	 * Create a new holder instance with the given source list.
	 * @param source the source List
	 * @param sort the SortDefinition to start with
	 */
	/**
	 * 使用给定的源列表创建一个新的holder实例。 
	 *  
	 * @param 来源来源列表
	 * @param 对SortDefinition进行排序
	 */
	public PagedListHolder(List<E> source, SortDefinition sort) {
		setSource(source);
		setSort(sort);
	}


	/**
	 * Set the source list for this holder.
	 */
	/**
	 * 设置此持有人的来源列表。 
	 * 
	 */
	public void setSource(List<E> source) {
		Assert.notNull(source, "Source List must not be null");
		this.source = source;
		this.refreshDate = new Date();
		this.sortUsed = null;
	}

	/**
	 * Return the source list for this holder.
	 */
	/**
	 * 返回此持有人的来源清单。 
	 * 
	 */
	public List<E> getSource() {
		return this.source;
	}

	/**
	 * Return the last time the list has been fetched from the source provider.
	 */
	/**
	 * 返回上一次从源提供者获取列表的时间。 
	 * 
	 */
	@Nullable
	public Date getRefreshDate() {
		return this.refreshDate;
	}

	/**
	 * Set the sort definition for this holder.
	 * Typically an instance of MutableSortDefinition.
	 * @see org.springframework.beans.support.MutableSortDefinition
	 */
	/**
	 * 设置此持有人的排序定义。 
	 * 通常是MutableSortDefinition的实例。 
	 *  
	 * @see  org.springframework.beans.support.MutableSortDefinition
	 */
	public void setSort(@Nullable SortDefinition sort) {
		this.sort = sort;
	}

	/**
	 * Return the sort definition for this holder.
	 */
	/**
	 * 返回此持有人的排序定义。 
	 * 
	 */
	@Nullable
	public SortDefinition getSort() {
		return this.sort;
	}

	/**
	 * Set the current page size.
	 * Resets the current page number if changed.
	 * <p>Default value is 10.
	 */
	/**
	 * 设置当前页面大小。 
	 * 如果更改，则重置当前页码。 
	 *  <p>默认值为10。 
	 * 
	 */
	public void setPageSize(int pageSize) {
		if (pageSize != this.pageSize) {
			this.pageSize = pageSize;
			if (!this.newPageSet) {
				this.page = 0;
			}
		}
	}

	/**
	 * Return the current page size.
	 */
	/**
	 * 返回当前页面大小。 
	 * 
	 */
	public int getPageSize() {
		return this.pageSize;
	}

	/**
	 * Set the current page number.
	 * Page numbering starts with 0.
	 */
	/**
	 * 设置当前页码。 
	 * 页码从0开始。 
	 * 
	 */
	public void setPage(int page) {
		this.page = page;
		this.newPageSet = true;
	}

	/**
	 * Return the current page number.
	 * Page numbering starts with 0.
	 */
	/**
	 * 返回当前页码。 
	 * 页码从0开始。 
	 * 
	 */
	public int getPage() {
		this.newPageSet = false;
		if (this.page >= getPageCount()) {
			this.page = getPageCount() - 1;
		}
		return this.page;
	}

	/**
	 * Set the maximum number of page links to a few pages around the current one.
	 */
	/**
	 * 将最大页面链接数设置为当前页面附近的几页。 
	 * 
	 */
	public void setMaxLinkedPages(int maxLinkedPages) {
		this.maxLinkedPages = maxLinkedPages;
	}

	/**
	 * Return the maximum number of page links to a few pages around the current one.
	 */
	/**
	 * 将最大页面链接数返回到当前页面周围的几页。 
	 * 
	 */
	public int getMaxLinkedPages() {
		return this.maxLinkedPages;
	}


	/**
	 * Return the number of pages for the current source list.
	 */
	/**
	 * 返回当前来源列表的页数。 
	 * 
	 */
	public int getPageCount() {
		float nrOfPages = (float) getNrOfElements() / getPageSize();
		return (int) ((nrOfPages > (int) nrOfPages || nrOfPages == 0.0) ? nrOfPages + 1 : nrOfPages);
	}

	/**
	 * Return if the current page is the first one.
	 */
	/**
	 * 如果当前页面是第一页，则返回。 
	 * 
	 */
	public boolean isFirstPage() {
		return getPage() == 0;
	}

	/**
	 * Return if the current page is the last one.
	 */
	/**
	 * 如果当前页面是最后一页，则返回。 
	 * 
	 */
	public boolean isLastPage() {
		return getPage() == getPageCount() -1;
	}

	/**
	 * Switch to previous page.
	 * Will stay on first page if already on first page.
	 */
	/**
	 * 切换到上一页。 
	 * 如果已经在首页上，则将停留在首页上。 
	 * 
	 */
	public void previousPage() {
		if (!isFirstPage()) {
			this.page--;
		}
	}

	/**
	 * Switch to next page.
	 * Will stay on last page if already on last page.
	 */
	/**
	 * 切换到下一页。 
	 * 如果已经在最后一页，将停留在最后一页。 
	 * 
	 */
	public void nextPage() {
		if (!isLastPage()) {
			this.page++;
		}
	}

	/**
	 * Return the total number of elements in the source list.
	 */
	/**
	 * 返回源列表中的元素总数。 
	 * 
	 */
	public int getNrOfElements() {
		return getSource().size();
	}

	/**
	 * Return the element index of the first element on the current page.
	 * Element numbering starts with 0.
	 */
	/**
	 * 返回当前页面上第一个元素的元素索引。 
	 * 元素编号从0开始。 
	 * 
	 */
	public int getFirstElementOnPage() {
		return (getPageSize() * getPage());
	}

	/**
	 * Return the element index of the last element on the current page.
	 * Element numbering starts with 0.
	 */
	/**
	 * 返回当前页面上最后一个元素的元素索引。 
	 * 元素编号从0开始。 
	 * 
	 */
	public int getLastElementOnPage() {
		int endIndex = getPageSize() * (getPage() + 1);
		int size = getNrOfElements();
		return (endIndex > size ? size : endIndex) - 1;
	}

	/**
	 * Return a sub-list representing the current page.
	 */
	/**
	 * 返回代表当前页面的子列表。 
	 * 
	 */
	public List<E> getPageList() {
		return getSource().subList(getFirstElementOnPage(), getLastElementOnPage() + 1);
	}

	/**
	 * Return the first page to which create a link around the current page.
	 */
	/**
	 * 返回在当前页面周围创建链接的第一页。 
	 * 
	 */
	public int getFirstLinkedPage() {
		return Math.max(0, getPage() - (getMaxLinkedPages() / 2));
	}

	/**
	 * Return the last page to which create a link around the current page.
	 */
	/**
	 * 返回在当前页面周围创建链接的最后一页。 
	 * 
	 */
	public int getLastLinkedPage() {
		return Math.min(getFirstLinkedPage() + getMaxLinkedPages() - 1, getPageCount() - 1);
	}


	/**
	 * Resort the list if necessary, i.e. if the current {@code sort} instance
	 * isn't equal to the backed-up {@code sortUsed} instance.
	 * <p>Calls {@code doSort} to trigger actual sorting.
	 * @see #doSort
	 */
	/**
	 * 如果有必要，即如果当前{@code  sort}实例不等于备份的{@code  sortUsed}实例，请对列表进行重新排序。 
	 *  <p>调用{@code  doSort}触发实际排序。 
	 *  
	 * @see  #doSort
	 */
	public void resort() {
		SortDefinition sort = getSort();
		if (sort != null && !sort.equals(this.sortUsed)) {
			this.sortUsed = copySortDefinition(sort);
			doSort(getSource(), sort);
			setPage(0);
		}
	}

	/**
	 * Create a deep copy of the given sort definition,
	 * for use as state holder to compare a modified sort definition against.
	 * <p>Default implementation creates a MutableSortDefinition instance.
	 * Can be overridden in subclasses, in particular in case of custom
	 * extensions to the SortDefinition interface. Is allowed to return
	 * null, which means that no sort state will be held, triggering
	 * actual sorting for each {@code resort} call.
	 * @param sort the current SortDefinition object
	 * @return a deep copy of the SortDefinition object
	 * @see MutableSortDefinition#MutableSortDefinition(SortDefinition)
	 */
	/**
	 * 创建给定排序定义的深层副本，用作状态持有者，以与修改后的排序定义进行比较。 
	 *  <p>默认实现创建一个MutableSortDefinition实例。 
	 * 可以在子类中重写，特别是在对SortDefinition接口进行自定义扩展的情况下。 
	 * 允许返回null，这意味着将不保留任何排序状态，从而触发每个{@code  resort}调用的实际排序。 
	 *  
	 * @param 对当前的SortDefinition对象进行排序
	 * @return  SortDefinition对象的深层副本
	 * @see  MutableSortDefinition＃MutableSortDefinition（SortDefinition）
	 */
	protected SortDefinition copySortDefinition(SortDefinition sort) {
		return new MutableSortDefinition(sort);
	}

	/**
	 * Actually perform sorting of the given source list, according to
	 * the given sort definition.
	 * <p>The default implementation uses Spring's PropertyComparator.
	 * Can be overridden in subclasses.
	 * @see PropertyComparator#sort(java.util.List, SortDefinition)
	 */
	/**
	 * 根据给定的排序定义实际执行给定源列表的排序。 
	 *  <p>默认实现使用Spring的PropertyComparator。 
	 * 可以在子类中覆盖。 
	 *  
	 * @see  PropertyComparator＃sort（java.util.List，SortDefinition）
	 */
	protected void doSort(List<E> source, SortDefinition sort) {
		PropertyComparator.sort(source, sort);
	}

}
