/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.ui.freemarker;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import freemarker.cache.FileTemplateLoader;
import freemarker.cache.MultiTemplateLoader;
import freemarker.cache.TemplateLoader;
import freemarker.template.Configuration;
import freemarker.template.SimpleHash;
import freemarker.template.TemplateException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PropertiesLoaderUtils;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;

/**
 * Factory that configures a FreeMarker Configuration. Can be used standalone, but
 * typically you will either use FreeMarkerConfigurationFactoryBean for preparing a
 * Configuration as bean reference, or FreeMarkerConfigurer for web views.
 *
 * <p>The optional "configLocation" property sets the location of a FreeMarker
 * properties file, within the current application. FreeMarker properties can be
 * overridden via "freemarkerSettings". All of these properties will be set by
 * calling FreeMarker's {@code Configuration.setSettings()} method and are
 * subject to constraints set by FreeMarker.
 *
 * <p>The "freemarkerVariables" property can be used to specify a Map of
 * shared variables that will be applied to the Configuration via the
 * {@code setAllSharedVariables()} method. Like {@code setSettings()},
 * these entries are subject to FreeMarker constraints.
 *
 * <p>The simplest way to use this class is to specify a "templateLoaderPath";
 * FreeMarker does not need any further configuration then.
 *
 * <p>Note: Spring's FreeMarker support requires FreeMarker 2.3 or higher.
 *
 * @author Darren Davison
 * @author Juergen Hoeller
 * @since 03.03.2004
 * @see #setConfigLocation
 * @see #setFreemarkerSettings
 * @see #setFreemarkerVariables
 * @see #setTemplateLoaderPath
 * @see #createConfiguration
 * @see FreeMarkerConfigurationFactoryBean
 * @see org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer
 * @see freemarker.template.Configuration
 */
/**
 * 配置FreeMarker配置的工厂。 
 * 可以单独使用，但是通常您将使用FreeMarkerConfigurationFactoryBean将配置准备为bean引用，或者将FreeMarkerConfigurer用于Web视图。 
 *  <p>可选的"configLocation"属性设置FreeMarker属性文件在当前应用程序中的位置。 
 * 可以通过"freemarkerSettings"覆盖FreeMarker属性。 
 * 所有这些属性都可以通过调用FreeMarker的{@code  Configuration.setSettings（）}方法来设置，并受FreeMarker设置的约束。 
 *  <p>"freemarkerVariables"属性可用于指定将通过{@code  setAllSharedVariables（）}方法应用于配置的共享变量映射。 
 * 像{@code  setSettings（）}一样，这些条目也受FreeMarker约束。 
 *  <p>使用此类的最简单方法是指定"templateLoaderPath"； 
 *  FreeMarker不需要任何进一步的配置。 
 *  <p>注意：Spring的FreeMarker支持需要FreeMarker 2.3或更高版本。 
 *  @author 达伦·戴维森（Darren Davison）@author 于尔根·霍勒（Juergen Hoeller）@2004年3月3日起> FreeMarkerConfigurationFactoryBean 
 * @see  org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer 
 * @see  freemarker.template.Configuration
 */
public class FreeMarkerConfigurationFactory {

	protected final Log logger = LogFactory.getLog(getClass());

	@Nullable
	private Resource configLocation;

	@Nullable
	private Properties freemarkerSettings;

	@Nullable
	private Map<String, Object> freemarkerVariables;

	@Nullable
	private String defaultEncoding;

	private final List<TemplateLoader> templateLoaders = new ArrayList<>();

	@Nullable
	private List<TemplateLoader> preTemplateLoaders;

	@Nullable
	private List<TemplateLoader> postTemplateLoaders;

	@Nullable
	private String[] templateLoaderPaths;

	private ResourceLoader resourceLoader = new DefaultResourceLoader();

	private boolean preferFileSystemAccess = true;


	/**
	 * Set the location of the FreeMarker config file.
	 * Alternatively, you can specify all setting locally.
	 * @see #setFreemarkerSettings
	 * @see #setTemplateLoaderPath
	 */
	/**
	 * 设置FreeMarker配置文件的位置。 
	 * 或者，您可以在本地指定所有设置。 
	 *  
	 * @see  #setFreemarkerSettings 
	 * @see  #setTemplateLoaderPath
	 */
	public void setConfigLocation(Resource resource) {
		this.configLocation = resource;
	}

	/**
	 * Set properties that contain well-known FreeMarker keys which will be
	 * passed to FreeMarker's {@code Configuration.setSettings} method.
	 * @see freemarker.template.Configuration#setSettings
	 */
	/**
	 * 设置包含众所周知的FreeMarker键的属性，这些键将传递给FreeMarker的{@code  Configuration.setSettings}方法。 
	 *  
	 * @see  freemarker.template.Configuration＃setSettings
	 */
	public void setFreemarkerSettings(Properties settings) {
		this.freemarkerSettings = settings;
	}

	/**
	 * Set a Map that contains well-known FreeMarker objects which will be passed
	 * to FreeMarker's {@code Configuration.setAllSharedVariables()} method.
	 * @see freemarker.template.Configuration#setAllSharedVariables
	 */
	/**
	 * 设置一个包含众所周知的FreeMarker对象的Map，该对象将传递给FreeMarker的{@code  Configuration.setAllSharedVariables（）}方法。 
	 *  
	 * @see  freemarker.template.Configuration＃setAllSharedVariables
	 */
	public void setFreemarkerVariables(Map<String, Object> variables) {
		this.freemarkerVariables = variables;
	}

	/**
	 * Set the default encoding for the FreeMarker configuration.
	 * If not specified, FreeMarker will use the platform file encoding.
	 * <p>Used for template rendering unless there is an explicit encoding specified
	 * for the rendering process (for example, on Spring's FreeMarkerView).
	 * @see freemarker.template.Configuration#setDefaultEncoding
	 * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView#setEncoding
	 */
	/**
	 * 设置FreeMarker配置的默认编码。 
	 * 如果未指定，FreeMarker将使用平台文件编码。 
	 *  <p>用于模板渲染，除非为渲染过程指定了显式编码（例如，在Spring的FreeMarkerView上）。 
	 *  
	 * @see  freemarker.template.Configuration＃setDefaultEncoding 
	 * @see  org.springframework.web.servlet.view.freemarker.FreeMarkerView＃setEncoding
	 */
	public void setDefaultEncoding(String defaultEncoding) {
		this.defaultEncoding = defaultEncoding;
	}

	/**
	 * Set a List of {@code TemplateLoader}s that will be used to search
	 * for templates. For example, one or more custom loaders such as database
	 * loaders could be configured and injected here.
	 * <p>The {@link TemplateLoader TemplateLoaders} specified here will be
	 * registered <i>before</i> the default template loaders that this factory
	 * registers (such as loaders for specified "templateLoaderPaths" or any
	 * loaders registered in {@link #postProcessTemplateLoaders}).
	 * @see #setTemplateLoaderPaths
	 * @see #postProcessTemplateLoaders
	 */
	/**
	 * 设置{@code  TemplateLoader}的列表，这些列表将用于搜索模板。 
	 * 例如，可以在此处配置和注入一个或多个自定义加载程序，例如数据库加载程序。 
	 *  <p>此处指定的{@link  TemplateLoader TemplateLoaders}将在此工厂注册的默认模板加载器（例如指定的"templateLoaderPaths"的加载器或在{<@链接> #postProcessTemplateLoaders}）。 
	 *  
	 * @see  #setTemplateLoaderPaths 
	 * @see  #postProcessTemplateLoaders
	 */
	public void setPreTemplateLoaders(TemplateLoader... preTemplateLoaders) {
		this.preTemplateLoaders = Arrays.asList(preTemplateLoaders);
	}

	/**
	 * Set a List of {@code TemplateLoader}s that will be used to search
	 * for templates. For example, one or more custom loaders such as database
	 * loaders can be configured.
	 * <p>The {@link TemplateLoader TemplateLoaders} specified here will be
	 * registered <i>after</i> the default template loaders that this factory
	 * registers (such as loaders for specified "templateLoaderPaths" or any
	 * loaders registered in {@link #postProcessTemplateLoaders}).
	 * @see #setTemplateLoaderPaths
	 * @see #postProcessTemplateLoaders
	 */
	/**
	 * 设置{@code  TemplateLoader}的列表，这些列表将用于搜索模板。 
	 * 例如，可以配置一个或多个自定义加载程序，例如数据库加载程序。 
	 *  <p>此处指定的{@link  TemplateLoader TemplateLoaders}将在该工厂注册的默认模板加载器（例如指定的"templateLoaderPaths"的加载器或在{<@链接> #postProcessTemplateLoaders}）。 
	 *  
	 * @see  #setTemplateLoaderPaths 
	 * @see  #postProcessTemplateLoaders
	 */
	public void setPostTemplateLoaders(TemplateLoader... postTemplateLoaders) {
		this.postTemplateLoaders = Arrays.asList(postTemplateLoaders);
	}

	/**
	 * Set the Freemarker template loader path via a Spring resource location.
	 * See the "templateLoaderPaths" property for details on path handling.
	 * @see #setTemplateLoaderPaths
	 */
	/**
	 * 通过Spring资源位置设置Freemarker模板加载器路径。 
	 * 有关路径处理的详细信息，请参见"templateLoaderPaths"属性。 
	 *  
	 * @see  #setTemplateLoaderPaths
	 */
	public void setTemplateLoaderPath(String templateLoaderPath) {
		this.templateLoaderPaths = new String[] {templateLoaderPath};
	}

	/**
	 * Set multiple Freemarker template loader paths via Spring resource locations.
	 * <p>When populated via a String, standard URLs like "file:" and "classpath:"
	 * pseudo URLs are supported, as understood by ResourceEditor. Allows for
	 * relative paths when running in an ApplicationContext.
	 * <p>Will define a path for the default FreeMarker template loader.
	 * If a specified resource cannot be resolved to a {@code java.io.File},
	 * a generic SpringTemplateLoader will be used, without modification detection.
	 * <p>To enforce the use of SpringTemplateLoader, i.e. to not resolve a path
	 * as file system resource in any case, turn off the "preferFileSystemAccess"
	 * flag. See the latter's javadoc for details.
	 * <p>If you wish to specify your own list of TemplateLoaders, do not set this
	 * property and instead use {@code setTemplateLoaders(List templateLoaders)}
	 * @see org.springframework.core.io.ResourceEditor
	 * @see org.springframework.context.ApplicationContext#getResource
	 * @see freemarker.template.Configuration#setDirectoryForTemplateLoading
	 * @see SpringTemplateLoader
	 */
	/**
	 * 通过Spring资源位置设置多个Freemarker模板加载器路径。 
	 *  <p>通过String填充时，支持标准URL，例如"file："和"classpath："伪URL，ResourceEditor可以理解。 
	 * 在ApplicationContext中运行时允许相对路径。 
	 *  <p>将为默认的FreeMarker模板加载器定义路径。 
	 * 如果指定的资源无法解析为{@code  java.io.File}，则将使用常规SpringTemplateLoader，而不会进行修改检测。 
	 *  <p>要强制使用SpringTemplateLoader，即在任何情况下都不将路径解析为文件系统资源，请关闭"preferFileSystemAccess"标志。 
	 * 有关详细信息，请参见后者的javadoc。 
	 *  <p>如果要指定自己的TemplateLoaders列表，请不要设置此属性，而应使用{@code  setTemplateLoaders（List templateLoaders）} 
	 * @see  org.springframework.core.io.ResourceEditor 
	 * @see  org.springframework.context.ApplicationContext＃getResource 
	 * @see  freemarker.template.Configuration＃setDirectoryForTemplateLoading 
	 * @see  SpringTemplateLoader
	 */
	public void setTemplateLoaderPaths(String... templateLoaderPaths) {
		this.templateLoaderPaths = templateLoaderPaths;
	}

	/**
	 * Set the Spring ResourceLoader to use for loading FreeMarker template files.
	 * The default is DefaultResourceLoader. Will get overridden by the
	 * ApplicationContext if running in a context.
	 * @see org.springframework.core.io.DefaultResourceLoader
	 */
	/**
	 * 设置Spring ResourceLoader以用于加载FreeMarker模板文件。 
	 * 默认值为DefaultResourceLoader。 
	 * 如果在上下文中运行，它将被ApplicationContext覆盖。 
	 *  
	 * @see  org.springframework.core.io.DefaultResourceLoader
	 */
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}

	/**
	 * Return the Spring ResourceLoader to use for loading FreeMarker template files.
	 */
	/**
	 * 返回Spring ResourceLoader以用于加载FreeMarker模板文件。 
	 * 
	 */
	protected ResourceLoader getResourceLoader() {
		return this.resourceLoader;
	}

	/**
	 * Set whether to prefer file system access for template loading.
	 * File system access enables hot detection of template changes.
	 * <p>If this is enabled, FreeMarkerConfigurationFactory will try to resolve
	 * the specified "templateLoaderPath" as file system resource (which will work
	 * for expanded class path resources and ServletContext resources too).
	 * <p>Default is "true". Turn this off to always load via SpringTemplateLoader
	 * (i.e. as stream, without hot detection of template changes), which might
	 * be necessary if some of your templates reside in an expanded classes
	 * directory while others reside in jar files.
	 * @see #setTemplateLoaderPath
	 */
	/**
	 * 设置是否更喜欢文件系统访问进行模板加载。 
	 * 通过文件系统访问，可以热检测模板更改。 
	 *  <p>如果启用了此选项，则FreeMarkerConfigurationFactory将尝试将指定的"templateLoaderPath"解析为文件系统资源（也适用于扩展的类路径资源和ServletContext资源）。 
	 *  <p>默认为"true"。 
	 * 将此选项关闭即可始终通过SpringTemplateLoader加载（即作为流，而不会热检测模板更改），如果您的某些模板位于扩展的类目录中，而另一些模板位于jar文件中，则可能需要这样做。 
	 *  
	 * @see  #setTemplateLoaderPath
	 */
	public void setPreferFileSystemAccess(boolean preferFileSystemAccess) {
		this.preferFileSystemAccess = preferFileSystemAccess;
	}

	/**
	 * Return whether to prefer file system access for template loading.
	 */
	/**
	 * 返回是否更喜欢文件系统访问进行模板加载。 
	 * 
	 */
	protected boolean isPreferFileSystemAccess() {
		return this.preferFileSystemAccess;
	}


	/**
	 * Prepare the FreeMarker Configuration and return it.
	 * @return the FreeMarker Configuration object
	 * @throws IOException if the config file wasn't found
	 * @throws TemplateException on FreeMarker initialization failure
	 */
	/**
	 * 准备FreeMarker配置并返回它。 
	 *  
	 * @return  FreeMarker配置对象
	 * @throws  IOException，如果未找到配置文件
	 * @throws  FreeMarker初始化失败时出现TemplateException
	 */
	public Configuration createConfiguration() throws IOException, TemplateException {
		Configuration config = newConfiguration();
		Properties props = new Properties();

		// Load config file if specified.
		if (this.configLocation != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Loading FreeMarker configuration from " + this.configLocation);
			}
			PropertiesLoaderUtils.fillProperties(props, this.configLocation);
		}

		// Merge local properties if specified.
		if (this.freemarkerSettings != null) {
			props.putAll(this.freemarkerSettings);
		}

		// FreeMarker will only accept known keys in its setSettings and
		// setAllSharedVariables methods.
		if (!props.isEmpty()) {
			config.setSettings(props);
		}

		if (!CollectionUtils.isEmpty(this.freemarkerVariables)) {
			config.setAllSharedVariables(new SimpleHash(this.freemarkerVariables, config.getObjectWrapper()));
		}

		if (this.defaultEncoding != null) {
			config.setDefaultEncoding(this.defaultEncoding);
		}

		List<TemplateLoader> templateLoaders = new ArrayList<>(this.templateLoaders);

		// Register template loaders that are supposed to kick in early.
		if (this.preTemplateLoaders != null) {
			templateLoaders.addAll(this.preTemplateLoaders);
		}

		// Register default template loaders.
		if (this.templateLoaderPaths != null) {
			for (String path : this.templateLoaderPaths) {
				templateLoaders.add(getTemplateLoaderForPath(path));
			}
		}
		postProcessTemplateLoaders(templateLoaders);

		// Register template loaders that are supposed to kick in late.
		if (this.postTemplateLoaders != null) {
			templateLoaders.addAll(this.postTemplateLoaders);
		}

		TemplateLoader loader = getAggregateTemplateLoader(templateLoaders);
		if (loader != null) {
			config.setTemplateLoader(loader);
		}

		postProcessConfiguration(config);
		return config;
	}

	/**
	 * Return a new Configuration object. Subclasses can override this for custom
	 * initialization (e.g. specifying a FreeMarker compatibility level which is a
	 * new feature in FreeMarker 2.3.21), or for using a mock object for testing.
	 * <p>Called by {@code createConfiguration()}.
	 * @return the Configuration object
	 * @throws IOException if a config file wasn't found
	 * @throws TemplateException on FreeMarker initialization failure
	 * @see #createConfiguration()
	 */
	/**
	 * 返回一个新的Configuration对象。 
	 * 子类可以覆盖此属性以进行自定义初始化（例如，指定FreeMarker兼容性级别，这是FreeMarker 2.3.21中的新功能），或使用模拟对象进行测试。 
	 *  <p>由{@code  createConfiguration（）}调用。 
	 *  
	 * @return 配置对象
	 * @throws  IOException（如果未找到配置文件）
	 * @throws  FreeMarker初始化失败时出现TemplateException 
	 * @see  #createConfiguration（）
	 */
	protected Configuration newConfiguration() throws IOException, TemplateException {
		return new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
	}

	/**
	 * Determine a FreeMarker TemplateLoader for the given path.
	 * <p>Default implementation creates either a FileTemplateLoader or
	 * a SpringTemplateLoader.
	 * @param templateLoaderPath the path to load templates from
	 * @return an appropriate TemplateLoader
	 * @see freemarker.cache.FileTemplateLoader
	 * @see SpringTemplateLoader
	 */
	/**
	 * 确定给定路径的FreeMarker TemplateLoader。 
	 *  <p>默认实现会创建FileTemplateLoader或SpringTemplateLoader。 
	 *  
	 * @param  templateLoaderPath从
	 * @return 适当的TemplateLoader加载模板的路径
	 * @see  freemarker.cache.FileTemplateLoader 
	 * @see  SpringTemplateLoader
	 */
	protected TemplateLoader getTemplateLoaderForPath(String templateLoaderPath) {
		if (isPreferFileSystemAccess()) {
			// Try to load via the file system, fall back to SpringTemplateLoader
			// (for hot detection of template changes, if possible).
			try {
				Resource path = getResourceLoader().getResource(templateLoaderPath);
				File file = path.getFile();  // will fail if not resolvable in the file system
				if (logger.isDebugEnabled()) {
					logger.debug(
							"Template loader path [" + path + "] resolved to file path [" + file.getAbsolutePath() + "]");
				}
				return new FileTemplateLoader(file);
			}
			catch (Exception ex) {
				if (logger.isDebugEnabled()) {
					logger.debug("Cannot resolve template loader path [" + templateLoaderPath +
							"] to [java.io.File]: using SpringTemplateLoader as fallback", ex);
				}
				return new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);
			}
		}
		else {
			// Always load via SpringTemplateLoader (without hot detection of template changes).
			logger.debug("File system access not preferred: using SpringTemplateLoader");
			return new SpringTemplateLoader(getResourceLoader(), templateLoaderPath);
		}
	}

	/**
	 * To be overridden by subclasses that want to register custom
	 * TemplateLoader instances after this factory created its default
	 * template loaders.
	 * <p>Called by {@code createConfiguration()}. Note that specified
	 * "postTemplateLoaders" will be registered <i>after</i> any loaders
	 * registered by this callback; as a consequence, they are <i>not</i>
	 * included in the given List.
	 * @param templateLoaders the current List of TemplateLoader instances,
	 * to be modified by a subclass
	 * @see #createConfiguration()
	 * @see #setPostTemplateLoaders
	 */
	/**
	 * 在此工厂创建其默认模板加载器之后，这些子类将被要注册自定义TemplateLoader实例的子类覆盖。 
	 *  <p>由{@code  createConfiguration（）}调用。 
	 * 注意，指定的"postTemplateLoaders"将在此回调注册的所有加载器之后<i>注册</ i>； 
	 * 因此，它们<i>不</ i>包含在给定列表中。 
	 *  
	 * @param  templateLoaders当前的TemplateLoader实例列表，将由子类进行修改
	 * @see  #createConfiguration（）
	 * @see  #setPostTemplateLoaders
	 */
	protected void postProcessTemplateLoaders(List<TemplateLoader> templateLoaders) {
	}

	/**
	 * Return a TemplateLoader based on the given TemplateLoader list.
	 * If more than one TemplateLoader has been registered, a FreeMarker
	 * MultiTemplateLoader needs to be created.
	 * @param templateLoaders the final List of TemplateLoader instances
	 * @return the aggregate TemplateLoader
	 */
	/**
	 * 根据给定的TemplateLoader列表返回TemplateLoader。 
	 * 如果已注册多个TemplateLoader，则需要创建一个FreeMarker MultiTemplateLoader。 
	 *  
	 * @param  templateLoaders TemplateLoader实例的最终列表
	 * @return 聚合TemplateLoader
	 */
	@Nullable
	protected TemplateLoader getAggregateTemplateLoader(List<TemplateLoader> templateLoaders) {
		switch (templateLoaders.size()) {
			case 0:
				logger.debug("No FreeMarker TemplateLoaders specified");
				return null;
			case 1:
				return templateLoaders.get(0);
			default:
				TemplateLoader[] loaders = templateLoaders.toArray(new TemplateLoader[0]);
				return new MultiTemplateLoader(loaders);
		}
	}

	/**
	 * To be overridden by subclasses that want to perform custom
	 * post-processing of the Configuration object after this factory
	 * performed its default initialization.
	 * <p>Called by {@code createConfiguration()}.
	 * @param config the current Configuration object
	 * @throws IOException if a config file wasn't found
	 * @throws TemplateException on FreeMarker initialization failure
	 * @see #createConfiguration()
	 */
	/**
	 * 由要在此工厂执行默认初始化之后对Configuration对象执行自定义后处理的子类覆盖。 
	 *  <p>由{@code  createConfiguration（）}调用。 
	 *  
	 * @param 配置当前配置对象
	 * @throws  IOException，如果未找到配置文件
	 * @throws  FreeMarker初始化失败时出现TemplateException 
	 * @see  #createConfiguration（）
	 */
	protected void postProcessConfiguration(Configuration config) throws IOException, TemplateException {
	}

}
