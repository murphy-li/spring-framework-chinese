/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.mail;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.LinkedHashMap;
import java.util.Map;

import org.springframework.lang.Nullable;
import org.springframework.util.ObjectUtils;

/**
 * Exception thrown when a mail sending error is encountered.
 * Can register failed messages with their exceptions.
 *
 * @author Dmitriy Kopylenko
 * @author Juergen Hoeller
 */
/**
 * 遇到邮件发送错误时引发的异常。 
 * 可以注册失败的消息及其例外。 
 *  @author  Dmitriy Kopylenko @author 于尔根·霍勒（Juergen Hoeller）
 */
@SuppressWarnings("serial")
public class MailSendException extends MailException {

	private final transient Map<Object, Exception> failedMessages;

	@Nullable
	private final Exception[] messageExceptions;


	/**
	 * Constructor for MailSendException.
	 * @param msg the detail message
	 */
	/**
	 * MailSendException的构造方法。 
	 *  
	 * @param  msg详细信息
	 */
	public MailSendException(String msg) {
		this(msg, null);
	}

	/**
	 * Constructor for MailSendException.
	 * @param msg the detail message
	 * @param cause the root cause from the mail API in use
	 */
	/**
	 * MailSendException的构造方法。 
	 *  
	 * @param  msg详细消息
	 * @param 原因是所使用的邮件API的根本原因
	 */
	public MailSendException(String msg, @Nullable Throwable cause) {
		super(msg, cause);
		this.failedMessages = new LinkedHashMap<>();
		this.messageExceptions = null;
	}

	/**
	 * Constructor for registration of failed messages, with the
	 * messages that failed as keys, and the thrown exceptions as values.
	 * <p>The messages should be the same that were originally passed
	 * to the invoked send method.
	 * @param msg the detail message
	 * @param cause the root cause from the mail API in use
	 * @param failedMessages a Map of failed messages as keys and thrown
	 * exceptions as values
	 */
	/**
	 * 用于注册失败消息的构造函数，失败消息为键，抛出异常为值。 
	 *  <p>消息应该与最初传递给调用的send方法的消息相同。 
	 *  
	 * @param  msg详细消息
	 * @param 导致使用中的邮件API的根本原因
	 * @param  failedMessages将失败消息的映射作为键并将抛出的异常作为值
	 */
	public MailSendException(@Nullable String msg, @Nullable Throwable cause, Map<Object, Exception> failedMessages) {
		super(msg, cause);
		this.failedMessages = new LinkedHashMap<>(failedMessages);
		this.messageExceptions = failedMessages.values().toArray(new Exception[0]);
	}

	/**
	 * Constructor for registration of failed messages, with the
	 * messages that failed as keys, and the thrown exceptions as values.
	 * <p>The messages should be the same that were originally passed
	 * to the invoked send method.
	 * @param failedMessages a Map of failed messages as keys and thrown
	 * exceptions as values
	 */
	/**
	 * 用于注册失败消息的构造函数，失败消息为键，抛出异常为值。 
	 *  <p>消息应该与最初传递给调用的send方法的消息相同。 
	 *  
	 * @param  failedMessages将失败消息的映射作为键，将抛出的异常作为值
	 */
	public MailSendException(Map<Object, Exception> failedMessages) {
		this(null, null, failedMessages);
	}


	/**
	 * Return a Map with the failed messages as keys, and the thrown exceptions
	 * as values.
	 * <p>Note that a general mail server connection failure will not result
	 * in failed messages being returned here: A message will only be
	 * contained here if actually sending it was attempted but failed.
	 * <p>The messages will be the same that were originally passed to the
	 * invoked send method, that is, SimpleMailMessages in case of using
	 * the generic MailSender interface.
	 * <p>In case of sending MimeMessage instances via JavaMailSender,
	 * the messages will be of type MimeMessage.
	 * <p><b>NOTE:</b> This Map will not be available after serialization.
	 * Use {@link #getMessageExceptions()} in such a scenario, which will
	 * be available after serialization as well.
	 * @return the Map of failed messages as keys and thrown exceptions as values
	 * @see SimpleMailMessage
	 * @see javax.mail.internet.MimeMessage
	 */
	/**
	 * 返回一个Map，以失败的消息作为键，并以抛出的异常作为值。 
	 *  <p>请注意，一般的邮件服务器连接失败不会导致在此处返回失败的消息：仅在尝试实际发送但失败的情况下，消息才会包含在此处。 
	 *  <p>消息将与最初传递给调用的send方法的消息相同，即在使用通用MailSender接口的情况下为SimpleMailMessages。 
	 *  <p>如果通过JavaMailSender发送MimeMessage实例，则消息将为MimeMessage类型。 
	 *  <p> <b>注意：</ b>序列化后，此映射将不可用。 
	 * 在这种情况下，请使用{@link  #getMessageExceptions（）}，在序列化之后也将可用。 
	 *  
	 * @return 失败消息的映射作为键，将抛出的异常作为值
	 * @see  SimpleMailMessage 
	 * @see  javax.mail.internet.MimeMessage
	 */
	public final Map<Object, Exception> getFailedMessages() {
		return this.failedMessages;
	}

	/**
	 * Return an array with thrown message exceptions.
	 * <p>Note that a general mail server connection failure will not result
	 * in failed messages being returned here: A message will only be
	 * contained here if actually sending it was attempted but failed.
	 * @return the array of thrown message exceptions,
	 * or an empty array if no failed messages
	 */
	/**
	 * 返回带有引发的消息异常的数组。 
	 *  <p>请注意，一般的邮件服务器连接失败不会导致在此处返回失败的消息：仅在尝试实际发送但失败的情况下，消息才会包含在此处。 
	 *  
	 * @return 引发的消息异常数组； 
	 * 如果没有失败的消息，则为空数组
	 */
	public final Exception[] getMessageExceptions() {
		return (this.messageExceptions != null ? this.messageExceptions : new Exception[0]);
	}


	@Override
	@Nullable
	public String getMessage() {
		if (ObjectUtils.isEmpty(this.messageExceptions)) {
			return super.getMessage();
		}
		else {
			StringBuilder sb = new StringBuilder();
			String baseMessage = super.getMessage();
			if (baseMessage != null) {
				sb.append(baseMessage).append(". ");
			}
			sb.append("Failed messages: ");
			for (int i = 0; i < this.messageExceptions.length; i++) {
				Exception subEx = this.messageExceptions[i];
				sb.append(subEx.toString());
				if (i < this.messageExceptions.length - 1) {
					sb.append("; ");
				}
			}
			return sb.toString();
		}
	}

	@Override
	public String toString() {
		if (ObjectUtils.isEmpty(this.messageExceptions)) {
			return super.toString();
		}
		else {
			StringBuilder sb = new StringBuilder(super.toString());
			sb.append("; message exceptions (").append(this.messageExceptions.length).append(") are:");
			for (int i = 0; i < this.messageExceptions.length; i++) {
				Exception subEx = this.messageExceptions[i];
				sb.append('\n').append("Failed message ").append(i + 1).append(": ");
				sb.append(subEx);
			}
			return sb.toString();
		}
	}

	@Override
	public void printStackTrace(PrintStream ps) {
		if (ObjectUtils.isEmpty(this.messageExceptions)) {
			super.printStackTrace(ps);
		}
		else {
			ps.println(super.toString() + "; message exception details (" +
					this.messageExceptions.length + ") are:");
			for (int i = 0; i < this.messageExceptions.length; i++) {
				Exception subEx = this.messageExceptions[i];
				ps.println("Failed message " + (i + 1) + ":");
				subEx.printStackTrace(ps);
			}
		}
	}

	@Override
	public void printStackTrace(PrintWriter pw) {
		if (ObjectUtils.isEmpty(this.messageExceptions)) {
			super.printStackTrace(pw);
		}
		else {
			pw.println(super.toString() + "; message exception details (" +
					this.messageExceptions.length + ") are:");
			for (int i = 0; i < this.messageExceptions.length; i++) {
				Exception subEx = this.messageExceptions[i];
				pw.println("Failed message " + (i + 1) + ":");
				subEx.printStackTrace(pw);
			}
		}
	}

}
