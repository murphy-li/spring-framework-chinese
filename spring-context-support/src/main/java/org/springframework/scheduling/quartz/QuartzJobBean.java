/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2014 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2014的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.quartz;

import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.SchedulerException;

import org.springframework.beans.BeanWrapper;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.PropertyAccessorFactory;

/**
 * Simple implementation of the Quartz Job interface, applying the
 * passed-in JobDataMap and also the SchedulerContext as bean property
 * values. This is appropriate because a new Job instance will be created
 * for each execution. JobDataMap entries will override SchedulerContext
 * entries with the same keys.
 *
 * <p>For example, let's assume that the JobDataMap contains a key
 * "myParam" with value "5": The Job implementation can then expose
 * a bean property "myParam" of type int to receive such a value,
 * i.e. a method "setMyParam(int)". This will also work for complex
 * types like business objects etc.
 *
 * <p><b>Note that the preferred way to apply dependency injection
 * to Job instances is via a JobFactory:</b> that is, to specify
 * {@link SpringBeanJobFactory} as Quartz JobFactory (typically via
 * {@link SchedulerFactoryBean#setJobFactory} SchedulerFactoryBean's "jobFactory" property}).
 * This allows to implement dependency-injected Quartz Jobs without
 * a dependency on Spring base classes.
 *
 * @author Juergen Hoeller
 * @since 18.02.2004
 * @see org.quartz.JobExecutionContext#getMergedJobDataMap()
 * @see org.quartz.Scheduler#getContext()
 * @see SchedulerFactoryBean#setSchedulerContextAsMap
 * @see SpringBeanJobFactory
 * @see SchedulerFactoryBean#setJobFactory
 */
/**
 * Quartz Job接口的简单实现，将传入的JobDataMap以及SchedulerContext应用为bean属性值。 
 * 这是适当的，因为将为每次执行创建一个新的Job实例。 
 *  JobDataMap条目将使用相同的键覆盖SchedulerContext条目。 
 *  <p>例如，假设JobDataMap包含键"myParam"，其值为"5"：然后，Job实现可以公开类型为int的bean属性"myParam"以接收该值，即方法"setMyParam（ int）"。 
 * 这也适用于诸如业务对象等复杂类型。 
 * <p> <b>请注意，将依赖项注入应用于Job实例的首选方法是通过JobFactory：</ b>，即指定{@link  SpringBeanJobFactory }作为Quartz JobFactory（通常通过{@link  SchedulerFactoryBean＃setJobFactory} SchedulerFactoryBean的"jobFactory"属性}）。 
 * 这样可以实现注入依赖项的Quartz Job，而无需依赖Spring基类。 
 *  @author 于尔根·霍勒（Juergen Hoeller）@2004年2月18日开始
 * @see> SchedulerFactoryBean＃setJobFactory
 */
public abstract class QuartzJobBean implements Job {

	/**
	 * This implementation applies the passed-in job data map as bean property
	 * values, and delegates to {@code executeInternal} afterwards.
	 * @see #executeInternal
	 */
	/**
	 * 此实现将传入的作业数据映射应用为bean属性值，然后将其委托给{@code  executeInternal}。 
	 *  
	 * @see  #executeInternal
	 */
	@Override
	public final void execute(JobExecutionContext context) throws JobExecutionException {
		try {
			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
			MutablePropertyValues pvs = new MutablePropertyValues();
			pvs.addPropertyValues(context.getScheduler().getContext());
			pvs.addPropertyValues(context.getMergedJobDataMap());
			bw.setPropertyValues(pvs, true);
		}
		catch (SchedulerException ex) {
			throw new JobExecutionException(ex);
		}
		executeInternal(context);
	}

	/**
	 * Execute the actual job. The job data map will already have been
	 * applied as bean property values by execute. The contract is
	 * exactly the same as for the standard Quartz execute method.
	 * @see #execute
	 */
	/**
	 * 执行实际作业。 
	 * 作业数据映射将已被execute作为bean属性值应用。 
	 * 该合同与标准Quartz执行方法完全相同。 
	 *  
	 * @see ＃执行
	 */
	protected abstract void executeInternal(JobExecutionContext context) throws JobExecutionException;

}
