/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.quartz;

import java.io.IOException;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.impl.RemoteScheduler;
import org.quartz.impl.SchedulerRepository;
import org.quartz.impl.StdSchedulerFactory;
import org.quartz.simpl.SimpleThreadPool;
import org.quartz.spi.JobFactory;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.SmartLifecycle;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PropertiesLoaderUtils;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.SchedulingException;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;

/**
 * {@link FactoryBean} that creates and configures a Quartz {@link org.quartz.Scheduler},
 * manages its lifecycle as part of the Spring application context, and exposes the
 * Scheduler as bean reference for dependency injection.
 *
 * <p>Allows registration of JobDetails, Calendars and Triggers, automatically
 * starting the scheduler on initialization and shutting it down on destruction.
 * In scenarios that just require static registration of jobs at startup, there
 * is no need to access the Scheduler instance itself in application code.
 *
 * <p>For dynamic registration of jobs at runtime, use a bean reference to
 * this SchedulerFactoryBean to get direct access to the Quartz Scheduler
 * ({@code org.quartz.Scheduler}). This allows you to create new jobs
 * and triggers, and also to control and monitor the entire Scheduler.
 *
 * <p>Note that Quartz instantiates a new Job for each execution, in
 * contrast to Timer which uses a TimerTask instance that is shared
 * between repeated executions. Just JobDetail descriptors are shared.
 *
 * <p>When using persistent jobs, it is strongly recommended to perform all
 * operations on the Scheduler within Spring-managed (or plain JTA) transactions.
 * Else, database locking will not properly work and might even break.
 * (See {@link #setDataSource setDataSource} javadoc for details.)
 *
 * <p>The preferred way to achieve transactional execution is to demarcate
 * declarative transactions at the business facade level, which will
 * automatically apply to Scheduler operations performed within those scopes.
 * Alternatively, you may add transactional advice for the Scheduler itself.
 *
 * <p>Compatible with Quartz 2.1.4 and higher, as of Spring 4.1.
 *
 * @author Juergen Hoeller
 * @since 18.02.2004
 * @see #setDataSource
 * @see org.quartz.Scheduler
 * @see org.quartz.SchedulerFactory
 * @see org.quartz.impl.StdSchedulerFactory
 * @see org.springframework.transaction.interceptor.TransactionProxyFactoryBean
 */
/**
 * {@link  FactoryBean}创建和配置Quartz {@link  org.quartz.Scheduler}，将其生命周期作为Spring应用程序上下文的一部分进行管理，并将Scheduler作为bean引用公开给依赖项注入。 
 *  <p>允许注册JobDetails，日历和触发器，在初始化时自动启动调度程序，并在销毁时将其关闭。 
 * 在只需要在启动时静态注册作业的情况下，无需在应用程序代码中访问Scheduler实例本身。 
 *  <p>要在运行时动态注册作业，请使用对此SchedulerFactoryBean的Bean引用来直接访问Quartz Scheduler（{@code  org.quartz.Scheduler}）。 
 * 这使您可以创建新的作业和触发器，还可以控制和监视整个Scheduler。 
 *  <p>请注意，与使用在重复执行之间共享的TimerTask实例的Timer相比，Quartz为每个执行实例化一个新的Job。 
 * 只是JobDetail描述符是共享的。 
 *  <p>使用持久性作业时，强烈建议在Spring托管（或普通JTA）事务中对Scheduler执行所有操作。 
 * 否则，数据库锁定将无法正常工作，甚至可能中断。 
 *  （有关详细信息，请参见{@link  #setDataSource setDataSource} javadoc。 
 * ）<p>实现事务执行的首选方法是在业务外观级别划分声明性事务，这将自动应用于在这些范围内执行的Scheduler操作。 
 * 或者，您可以为调度程序本身添加事务建议。 
 *  <p>从Spring 4.1开始与Quartz 2.1.4及更高版本兼容。 
 *  @author  Juergen Hoeller @2004年2月18日开始
 * @see  #setDataSource 
 * @see  org.quartz.Scheduler 
 * @see  org.quartz.SchedulerFactory 
 * @see  org.quartz.impl.StdSchedulerFactory 
 * @see  org.springframework.transaction.interceptor.TransactionProxyFactoryBean
 */
public class SchedulerFactoryBean extends SchedulerAccessor implements FactoryBean<Scheduler>,
		BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean, SmartLifecycle {

	/**
	 * The thread count property.
	 */
	/**
	 * 线程计数属性。 
	 * 
	 */
	public static final String PROP_THREAD_COUNT = "org.quartz.threadPool.threadCount";

	/**
	 * The default thread count.
	 */
	/**
	 * 默认线程数。 
	 * 
	 */
	public static final int DEFAULT_THREAD_COUNT = 10;


	private static final ThreadLocal<ResourceLoader> configTimeResourceLoaderHolder = new ThreadLocal<>();

	private static final ThreadLocal<Executor> configTimeTaskExecutorHolder = new ThreadLocal<>();

	private static final ThreadLocal<DataSource> configTimeDataSourceHolder = new ThreadLocal<>();

	private static final ThreadLocal<DataSource> configTimeNonTransactionalDataSourceHolder = new ThreadLocal<>();


	/**
	 * Return the {@link ResourceLoader} for the currently configured Quartz Scheduler,
	 * to be used by {@link ResourceLoaderClassLoadHelper}.
	 * <p>This instance will be set before initialization of the corresponding Scheduler,
	 * and reset immediately afterwards. It is thus only available during configuration.
	 * @see #setApplicationContext
	 * @see ResourceLoaderClassLoadHelper
	 */
	/**
	 * 返回当前配置的Quartz Scheduler的{@link  ResourceLoader}，供{@link  ResourceLoaderClassLoadHelper}使用。 
	 *  <p>此实例将在相应的Scheduler初始化之前设置，并在之后立即重置。 
	 * 因此，仅在组态期间可用。 
	 *  
	 * @see  #setApplicationContext 
	 * @see  ResourceLoaderClassLoadHelper
	 */
	@Nullable
	public static ResourceLoader getConfigTimeResourceLoader() {
		return configTimeResourceLoaderHolder.get();
	}

	/**
	 * Return the {@link Executor} for the currently configured Quartz Scheduler,
	 * to be used by {@link LocalTaskExecutorThreadPool}.
	 * <p>This instance will be set before initialization of the corresponding Scheduler,
	 * and reset immediately afterwards. It is thus only available during configuration.
	 * @since 2.0
	 * @see #setTaskExecutor
	 * @see LocalTaskExecutorThreadPool
	 */
	/**
	 * 返回当前配置的Quartz Scheduler的{@link  Executor}，供{@link  LocalTask​​ExecutorThreadPool}使用。 
	 *  <p>此实例将在相应的Scheduler初始化之前设置，并在之后立即重置。 
	 * 因此，仅在组态期间可用。 
	 *  @since 2.0 
	 * @see  #setTaskExecutor 
	 * @see  LocalTask​​ExecutorThreadPool
	 */
	@Nullable
	public static Executor getConfigTimeTaskExecutor() {
		return configTimeTaskExecutorHolder.get();
	}

	/**
	 * Return the {@link DataSource} for the currently configured Quartz Scheduler,
	 * to be used by {@link LocalDataSourceJobStore}.
	 * <p>This instance will be set before initialization of the corresponding Scheduler,
	 * and reset immediately afterwards. It is thus only available during configuration.
	 * @since 1.1
	 * @see #setDataSource
	 * @see LocalDataSourceJobStore
	 */
	/**
	 * 返回当前配置的Quartz Scheduler的{@link  DataSource}，供{@link  LocalDataSourceJobStore}使用。 
	 *  <p>此实例将在相应的Scheduler初始化之前设置，并在之后立即重置。 
	 * 因此，仅在组态期间可用。 
	 *  @since 1.1 
	 * @see  #setDataSource 
	 * @see  LocalDataSourceJobStore
	 */
	@Nullable
	public static DataSource getConfigTimeDataSource() {
		return configTimeDataSourceHolder.get();
	}

	/**
	 * Return the non-transactional {@link DataSource} for the currently configured
	 * Quartz Scheduler, to be used by {@link LocalDataSourceJobStore}.
	 * <p>This instance will be set before initialization of the corresponding Scheduler,
	 * and reset immediately afterwards. It is thus only available during configuration.
	 * @since 1.1
	 * @see #setNonTransactionalDataSource
	 * @see LocalDataSourceJobStore
	 */
	/**
	 * 返回当前配置的Quartz Scheduler的非事务性{@link  DataSource}，供{@link  LocalDataSourceJobStore}使用。 
	 *  <p>此实例将在相应的Scheduler初始化之前设置，并在之后立即重置。 
	 * 因此，仅在组态期间可用。 
	 *  @since 1.1 
	 * @see  #setNonTransactionalDataSource 
	 * @see  LocalDataSourceJobStore
	 */
	@Nullable
	public static DataSource getConfigTimeNonTransactionalDataSource() {
		return configTimeNonTransactionalDataSourceHolder.get();
	}


	@Nullable
	private SchedulerFactory schedulerFactory;

	private Class<? extends SchedulerFactory> schedulerFactoryClass = StdSchedulerFactory.class;

	@Nullable
	private String schedulerName;

	@Nullable
	private Resource configLocation;

	@Nullable
	private Properties quartzProperties;

	@Nullable
	private Executor taskExecutor;

	@Nullable
	private DataSource dataSource;

	@Nullable
	private DataSource nonTransactionalDataSource;

	@Nullable
	private Map<String, ?> schedulerContextMap;

	@Nullable
	private String applicationContextSchedulerContextKey;

	@Nullable
	private JobFactory jobFactory;

	private boolean jobFactorySet = false;

	private boolean autoStartup = true;

	private int startupDelay = 0;

	private int phase = DEFAULT_PHASE;

	private boolean exposeSchedulerInRepository = false;

	private boolean waitForJobsToCompleteOnShutdown = false;

	@Nullable
	private String beanName;

	@Nullable
	private ApplicationContext applicationContext;

	@Nullable
	private Scheduler scheduler;


	/**
	 * Set an external Quartz {@link SchedulerFactory} instance to use.
	 * <p>Default is an internal {@link StdSchedulerFactory} instance. If this method is
	 * called, it overrides any class specified through {@link #setSchedulerFactoryClass}
	 * as well as any settings specified through {@link #setConfigLocation},
	 * {@link #setQuartzProperties}, {@link #setTaskExecutor} or {@link #setDataSource}.
	 * <p><b>NOTE:</b> With an externally provided {@code SchedulerFactory} instance,
	 * local settings such as {@link #setConfigLocation} or {@link #setQuartzProperties}
	 * will be ignored here in {@code SchedulerFactoryBean}, expecting the external
	 * {@code SchedulerFactory} instance to get initialized on its own.
	 * @since 4.3.15
	 * @see #setSchedulerFactoryClass
	 */
	/**
	 * 设置要使用的外部Quartz {@link  SchedulerFactory}实例。 
	 *  <p>默认为内部{@link  StdSchedulerFactory}实例。 
	 * 如果调用此方法，它将覆盖通过{@link  #setSchedulerFactoryClass}指定的任何类以及通过{@link  #setConfigLocation}，{<@link> #setQuartzProperties}，{<@link> #setTaskExecutor}或{@link  #setDataSource}。 
	 *  <p> <b>注意：</ b>对于外部提供的{@code  SchedulerFactory}实例，此处将忽略诸如{@link  #setConfigLocation}或{@link  #setQuartzProperties}之类的本地设置在{@code  SchedulerFactoryBean}中，期望外部{@code  SchedulerFactory}实例自行初始化。 
	 *  @since 4.3.15 
	 * @see  #setSchedulerFactoryClass
	 */
	public void setSchedulerFactory(SchedulerFactory schedulerFactory) {
		this.schedulerFactory = schedulerFactory;
	}

	/**
	 * Set the Quartz {@link SchedulerFactory} implementation to use.
	 * <p>Default is the {@link StdSchedulerFactory} class, reading in the standard
	 * {@code quartz.properties} from {@code quartz.jar}. For applying custom Quartz
	 * properties, specify {@link #setConfigLocation "configLocation"} and/or
	 * {@link #setQuartzProperties "quartzProperties"} etc on this local
	 * {@code SchedulerFactoryBean} instance.
	 * @see org.quartz.impl.StdSchedulerFactory
	 * @see #setConfigLocation
	 * @see #setQuartzProperties
	 * @see #setTaskExecutor
	 * @see #setDataSource
	 */
	/**
	 * 设置要使用的Quartz {@link  SchedulerFactory}实现。 
	 *  <p>默认为{@link  StdSchedulerFactory}类，从{@code  quartz.jar}中读取标准{@code  quartz.properties}。 
	 * 要应用自定义Quartz属性，请在此本地{@code  SchedulerFactoryBean}实例上指定{@link  #setConfigLocation"configLocation"}和/或{@link  #setQuartzProperties"quartzProperties"}等。 
	 *  
	 * @see  org.quartz.impl.StdSchedulerFactory 
	 * @see  #setConfigLocation 
	 * @see  #setQuartzProperties 
	 * @see  #setTaskExecutor 
	 * @see  #setDataSource
	 */
	public void setSchedulerFactoryClass(Class<? extends SchedulerFactory> schedulerFactoryClass) {
		this.schedulerFactoryClass = schedulerFactoryClass;
	}

	/**
	 * Set the name of the Scheduler to create via the SchedulerFactory, as an
	 * alternative to the {@code org.quartz.scheduler.instanceName} property.
	 * <p>If not specified, the name will be taken from Quartz properties
	 * ({@code org.quartz.scheduler.instanceName}), or from the declared
	 * {@code SchedulerFactoryBean} bean name as a fallback.
	 * @see #setBeanName
	 * @see StdSchedulerFactory#PROP_SCHED_INSTANCE_NAME
	 * @see org.quartz.SchedulerFactory#getScheduler()
	 * @see org.quartz.SchedulerFactory#getScheduler(String)
	 */
	/**
	 * 设置要通过SchedulerFactory创建的Scheduler的名称，以替代{@code  org.quartz.scheduler.instanceName}属性。 
	 *  <p>如果未指定，则名称将从Quartz属性（{@code  org.quartz.scheduler.instanceName}）中获取，或从声明的{@code  SchedulerFactoryBean} bean名称中获取。 
	 *  
	 * @see  #setBeanName 
	 * @see  StdSchedulerFactory＃PROP_SCHED_INSTANCE_NAME 
	 * @see  org.quartz.SchedulerFactory＃getScheduler（）
	 * @see  org.quartz.SchedulerFactory＃getScheduler（String）
	 */
	public void setSchedulerName(String schedulerName) {
		this.schedulerName = schedulerName;
	}

	/**
	 * Set the location of the Quartz properties config file, for example
	 * as classpath resource "classpath:quartz.properties".
	 * <p>Note: Can be omitted when all necessary properties are specified
	 * locally via this bean, or when relying on Quartz' default configuration.
	 * @see #setQuartzProperties
	 */
	/**
	 * 设置Quartz属性配置文件的位置，例如作为类路径资源"classpath：quartz.properties"。 
	 *  <p>注意：当通过此bean在本地指定了所有必需的属性时，或者依赖于Quartz的默认配置时，可以省略。 
	 *  
	 * @see  #setQuartzProperties
	 */
	public void setConfigLocation(Resource configLocation) {
		this.configLocation = configLocation;
	}

	/**
	 * Set Quartz properties, like "org.quartz.threadPool.class".
	 * <p>Can be used to override values in a Quartz properties config file,
	 * or to specify all necessary properties locally.
	 * @see #setConfigLocation
	 */
	/**
	 * 设置Quartz属性，例如"org.quartz.threadPool.class"。 
	 *  <p>可用于覆盖Quartz属性配置文件中的值，或在本地指定所有必需的属性。 
	 *  
	 * @see  #setConfigLocation
	 */
	public void setQuartzProperties(Properties quartzProperties) {
		this.quartzProperties = quartzProperties;
	}

	/**
	 * Set a Spring-managed {@link Executor} to use as Quartz backend.
	 * Exposed as thread pool through the Quartz SPI.
	 * <p>Can be used to assign a local JDK ThreadPoolExecutor or a CommonJ
	 * WorkManager as Quartz backend, to avoid Quartz's manual thread creation.
	 * <p>By default, a Quartz SimpleThreadPool will be used, configured through
	 * the corresponding Quartz properties.
	 * @since 2.0
	 * @see #setQuartzProperties
	 * @see LocalTaskExecutorThreadPool
	 * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor
	 * @see org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor
	 */
	/**
	 * 设置一个Spring管理的{@link  Executor}用作Quartz后端。 
	 * 通过Quartz SPI公开为线程池。 
	 *  <p>可用于将本地JDK ThreadPoolExecutor或CommonJ WorkManager分配为Quartz后端，以避免Quartz手动创建线程。 
	 *  <p>默认情况下，将使用Quartz SimpleThreadPool，并通过相应的Quartz属性进行配置。 
	 *  @since 2.0 
	 * @see  #setQuartzProperties 
	 * @see  LocalTask​​ExecutorThreadPool 
	 * @see  org.springframework.scheduling.concurrent.ThreadPoolTask​​Executor 
	 * @see  org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor
	 */
	public void setTaskExecutor(Executor taskExecutor) {
		this.taskExecutor = taskExecutor;
	}

	/**
	 * Set the default {@link DataSource} to be used by the Scheduler.
	 * If set, this will override corresponding settings in Quartz properties.
	 * <p>Note: If this is set, the Quartz settings should not define
	 * a job store "dataSource" to avoid meaningless double configuration.
	 * <p>A Spring-specific subclass of Quartz' JobStoreCMT will be used.
	 * It is therefore strongly recommended to perform all operations on
	 * the Scheduler within Spring-managed (or plain JTA) transactions.
	 * Else, database locking will not properly work and might even break
	 * (e.g. if trying to obtain a lock on Oracle without a transaction).
	 * <p>Supports both transactional and non-transactional DataSource access.
	 * With a non-XA DataSource and local Spring transactions, a single DataSource
	 * argument is sufficient. In case of an XA DataSource and global JTA transactions,
	 * SchedulerFactoryBean's "nonTransactionalDataSource" property should be set,
	 * passing in a non-XA DataSource that will not participate in global transactions.
	 * @since 1.1
	 * @see #setNonTransactionalDataSource
	 * @see #setQuartzProperties
	 * @see #setTransactionManager
	 * @see LocalDataSourceJobStore
	 */
	/**
	 * 设置调度程序要使用的默认{@link  DataSource}。 
	 * 如果设置，它将覆盖Quartz属性中的相应设置。 
	 *  <p>注意：如果设置了该选项，则Quartz设置不应定义作业存储"dataSource"，以避免无意义的双重配置。 
	 *  <p>将使用Quartz JobStoreCMT的特定于Spring的子类。 
	 * 因此，强烈建议在Spring管理的（或普通JTA）事务中对Scheduler执行所有操作。 
	 * 否则，数据库锁定将无法正常工作，甚至可能会中断（例如，如果尝试在没有事务的情况下获得对Oracle的锁定）。 
	 *  <p>支持事务性和非事务性数据源访问。 
	 * 对于非XA DataSource和本地Spring事务，单个DataSource参数就足够了。 
	 * 如果是XA数据源和全局JTA事务，则应该设置SchedulerFactoryBean的"nonTransactionalDataSource"属性，并传入将不参与全局事务的非XA数据源。 
	 *  @since 1.1 
	 * @see  #setNonTransactionalDataSource 
	 * @see  #setQuartzProperties 
	 * @see  #setTransactionManager 
	 * @see  LocalDataSourceJobStore
	 */
	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	/**
	 * Set the {@link DataSource} to be used <i>for non-transactional access</i>.
	 * <p>This is only necessary if the default DataSource is an XA DataSource that will
	 * always participate in transactions: A non-XA version of that DataSource should
	 * be specified as "nonTransactionalDataSource" in such a scenario.
	 * <p>This is not relevant with a local DataSource instance and Spring transactions.
	 * Specifying a single default DataSource as "dataSource" is sufficient there.
	 * @since 1.1
	 * @see #setDataSource
	 * @see LocalDataSourceJobStore
	 */
	/**
	 * 将{@link 数据源}设置为<i>用于非事务访问</ i>。 
	 *  <p>仅当默认数据源是将始终参与事务的XA数据源时，才有必要：在这种情况下，应将该数据源的非XA版本指定为"nonTransactionalDataSource"。 
	 *  <p>这与本地DataSource实例和Spring事务无关。 
	 * 在那里指定一个默认的默认数据源作为"数据源"就足够了。 
	 *  @since 1.1 
	 * @see  #setDataSource 
	 * @see  LocalDataSourceJobStore
	 */
	public void setNonTransactionalDataSource(DataSource nonTransactionalDataSource) {
		this.nonTransactionalDataSource = nonTransactionalDataSource;
	}

	/**
	 * Register objects in the Scheduler context via a given Map.
	 * These objects will be available to any Job that runs in this Scheduler.
	 * <p>Note: When using persistent Jobs whose JobDetail will be kept in the
	 * database, do not put Spring-managed beans or an ApplicationContext
	 * reference into the JobDataMap but rather into the SchedulerContext.
	 * @param schedulerContextAsMap a Map with String keys and any objects as
	 * values (for example Spring-managed beans)
	 * @see JobDetailFactoryBean#setJobDataAsMap
	 */
	/**
	 * 通过给定的Map在Scheduler上下文中注册对象。 
	 * 这些对象将可用于在此Scheduler中运行的任何Job。 
	 *  <p>注意：当使用持久性Jobs并将JobDetail保留在数据库中时，请勿将Spring托管的bean或ApplicationContext引用放入JobDataMap中，而应放入SchedulerContext中。 
	 *  
	 * @param  schedulerContextAsMap一个具有字符串键和任何对象作为值的地图（例如，Spring管理的Bean）
	 * @see  JobDetailFactoryBean＃setJobDataAsMap
	 */
	public void setSchedulerContextAsMap(Map<String, ?> schedulerContextAsMap) {
		this.schedulerContextMap = schedulerContextAsMap;
	}

	/**
	 * Set the key of an {@link ApplicationContext} reference to expose in the
	 * SchedulerContext, for example "applicationContext". Default is none.
	 * Only applicable when running in a Spring ApplicationContext.
	 * <p>Note: When using persistent Jobs whose JobDetail will be kept in the
	 * database, do not put an ApplicationContext reference into the JobDataMap
	 * but rather into the SchedulerContext.
	 * <p>In case of a QuartzJobBean, the reference will be applied to the Job
	 * instance as bean property. An "applicationContext" attribute will
	 * correspond to a "setApplicationContext" method in that scenario.
	 * <p>Note that BeanFactory callback interfaces like ApplicationContextAware
	 * are not automatically applied to Quartz Job instances, because Quartz
	 * itself is responsible for the lifecycle of its Jobs.
	 * @see JobDetailFactoryBean#setApplicationContextJobDataKey
	 * @see org.springframework.context.ApplicationContext
	 */
	/**
	 * 设置{@link  ApplicationContext}引用的键以在SchedulerContext中公开，例如"applicationContext"。 
	 * 默认为无。 
	 * 仅在Spring ApplicationContext中运行时适用。 
	 *  <p>注意：当使用其JobDetail将保存在数据库中的持久性Jobs时，不要将ApplicationContext引用放入JobDataMap中，而应放在SchedulerContext中。 
	 *  <p>如果是QuartzJobBean，则该引用将作为bean属性应用于Job实例。 
	 * 在这种情况下，"applicationContext"属性将对应于"setApplicationContext"方法。 
	 *  <p>请注意，像ApplicationContextAware这样的BeanFactory回调接口不会自动应用于Quartz Job实例，因为Quartz本身负责其Jobs的生命周期。 
	 *  
	 * @see  JobDetailFactoryBean＃setApplicationContextJobDataKey 
	 * @see  org.springframework.context.ApplicationContext
	 */
	public void setApplicationContextSchedulerContextKey(String applicationContextSchedulerContextKey) {
		this.applicationContextSchedulerContextKey = applicationContextSchedulerContextKey;
	}

	/**
	 * Set the Quartz {@link JobFactory} to use for this Scheduler.
	 * <p>Default is Spring's {@link AdaptableJobFactory}, which supports
	 * {@link java.lang.Runnable} objects as well as standard Quartz
	 * {@link org.quartz.Job} instances. Note that this default only applies
	 * to a <i>local</i> Scheduler, not to a RemoteScheduler (where setting
	 * a custom JobFactory is not supported by Quartz).
	 * <p>Specify an instance of Spring's {@link SpringBeanJobFactory} here
	 * (typically as an inner bean definition) to automatically populate a job's
	 * bean properties from the specified job data map and scheduler context.
	 * @since 2.0
	 * @see AdaptableJobFactory
	 * @see SpringBeanJobFactory
	 */
	/**
	 * 设置Quartz {@link  JobFactory}以用于此Scheduler。 
	 *  <p>默认是Spring的{@link  AdaptableJobFactory}，它支持{@link  java.lang.Runnable}对象以及标准的Quartz {@link  org.quartz.Job}实例。 
	 * 请注意，此默认设置仅适用于<i> local </ i>调度程序，而不适用于RemoteScheduler（Quartz不支持设置自定义JobFactory）。 
	 *  <p>在此处指定Spring的{@link  SpringBeanJobFactory}的实例（通常作为内部bean定义），以根据指定的作业数据映射和调度程序上下文自动填充作业的bean属性。 
	 *  @since 2.0 
	 * @see  AdaptableJobFactory 
	 * @see  SpringBeanJobFactory
	 */
	public void setJobFactory(JobFactory jobFactory) {
		this.jobFactory = jobFactory;
		this.jobFactorySet = true;
	}

	/**
	 * Set whether to automatically start the scheduler after initialization.
	 * <p>Default is "true"; set this to "false" to allow for manual startup.
	 */
	/**
	 * 设置是否在初始化后自动启动调度程序。 
	 *  <p>默认为"true"； 
	 * 将此设置为"false"以允许手动启动。 
	 * 
	 */
	public void setAutoStartup(boolean autoStartup) {
		this.autoStartup = autoStartup;
	}

	/**
	 * Return whether this scheduler is configured for auto-startup. If "true",
	 * the scheduler will start after the context is refreshed and after the
	 * start delay, if any.
	 */
	/**
	 * 返回是否将此调度程序配置为自动启动。 
	 * 如果为"true"，则调度程序将在刷新上下文之后以及启动延迟（如果有）之后启动。 
	 * 
	 */
	@Override
	public boolean isAutoStartup() {
		return this.autoStartup;
	}

	/**
	 * Specify the phase in which this scheduler should be started and stopped.
	 * The startup order proceeds from lowest to highest, and the shutdown order
	 * is the reverse of that. By default this value is {@code Integer.MAX_VALUE}
	 * meaning that this scheduler starts as late as possible and stops as soon
	 * as possible.
	 * @since 3.0
	 */
	/**
	 * 指定启动和停止此调度程序的阶段。 
	 * 启动顺序从最低到最高，而关闭顺序则相反。 
	 * 默认情况下，此值为{@code  Integer.MAX_VALUE}，表示此调度程序将尽可能晚地启动，并尽快停止。 
	 *  @从3.0起
	 */
	public void setPhase(int phase) {
		this.phase = phase;
	}

	/**
	 * Return the phase in which this scheduler will be started and stopped.
	 */
	/**
	 * 返回此调度程序将启动和停止的阶段。 
	 * 
	 */
	@Override
	public int getPhase() {
		return this.phase;
	}

	/**
	 * Set the number of seconds to wait after initialization before
	 * starting the scheduler asynchronously. Default is 0, meaning
	 * immediate synchronous startup on initialization of this bean.
	 * <p>Setting this to 10 or 20 seconds makes sense if no jobs
	 * should be run before the entire application has started up.
	 */
	/**
	 * 设置初始化后等待异步启动调度程序之前要等待的秒数。 
	 * 默认值为0，表示在初始化此bean时立即同步启动。 
	 *  <p>如果在整个应用程序启动之前不运行任何作业，则将其设置为10或20秒很有意义。 
	 * 
	 */
	public void setStartupDelay(int startupDelay) {
		this.startupDelay = startupDelay;
	}

	/**
	 * Set whether to expose the Spring-managed {@link Scheduler} instance in the
	 * Quartz {@link SchedulerRepository}. Default is "false", since the Spring-managed
	 * Scheduler is usually exclusively intended for access within the Spring context.
	 * <p>Switch this flag to "true" in order to expose the Scheduler globally.
	 * This is not recommended unless you have an existing Spring application that
	 * relies on this behavior. Note that such global exposure was the accidental
	 * default in earlier Spring versions; this has been fixed as of Spring 2.5.6.
	 */
	/**
	 * 设置是否在Quartz {@link  SchedulerRepository}中公开Spring管理的{@link  Scheduler}实例。 
	 * 默认值为"false"，因为Spring托管的Scheduler通常专门用于在Spring上下文中进行访问。 
	 *  <p>将此标志切换为"true"，以便全局公开调度程序。 
	 * 除非您具有依赖此行为的现有Spring应用程序，否则不建议这样做。 
	 * 请注意，在早期的Spring版本中，这种全局暴露是偶然的默认值； 
	 * 自Spring 2.5.6起已修复此问题。 
	 * 
	 */
	public void setExposeSchedulerInRepository(boolean exposeSchedulerInRepository) {
		this.exposeSchedulerInRepository = exposeSchedulerInRepository;
	}

	/**
	 * Set whether to wait for running jobs to complete on shutdown.
	 * <p>Default is "false". Switch this to "true" if you prefer
	 * fully completed jobs at the expense of a longer shutdown phase.
	 * @see org.quartz.Scheduler#shutdown(boolean)
	 */
	/**
	 * 设置是否等待正在运行的作业在关闭时完成。 
	 *  <p>默认为"false"。 
	 * 如果您希望以较长的关闭阶段为代价而选择完全完成的作业，则将其切换为"true"。 
	 *  
	 * @see  org.quartz.Scheduler＃shutdown（boolean）
	 */
	public void setWaitForJobsToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown) {
		this.waitForJobsToCompleteOnShutdown = waitForJobsToCompleteOnShutdown;
	}

	@Override
	public void setBeanName(String name) {
		this.beanName = name;
	}

	@Override
	public void setApplicationContext(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
	}


	//---------------------------------------------------------------------
	// Implementation of InitializingBean interface
	//---------------------------------------------------------------------

	@Override
	public void afterPropertiesSet() throws Exception {
		if (this.dataSource == null && this.nonTransactionalDataSource != null) {
			this.dataSource = this.nonTransactionalDataSource;
		}

		if (this.applicationContext != null && this.resourceLoader == null) {
			this.resourceLoader = this.applicationContext;
		}

		// Initialize the Scheduler instance...
		this.scheduler = prepareScheduler(prepareSchedulerFactory());
		try {
			registerListeners();
			registerJobsAndTriggers();
		}
		catch (Exception ex) {
			try {
				this.scheduler.shutdown(true);
			}
			catch (Exception ex2) {
				logger.debug("Scheduler shutdown exception after registration failure", ex2);
			}
			throw ex;
		}
	}


	/**
	 * Create a SchedulerFactory if necessary and apply locally defined Quartz properties to it.
	 * @return the initialized SchedulerFactory
	 */
	/**
	 * 如有必要，创建一个SchedulerFactory并将本地定义的Quartz属性应用于它。 
	 *  
	 * @return 初始化的SchedulerFactory
	 */
	private SchedulerFactory prepareSchedulerFactory() throws SchedulerException, IOException {
		SchedulerFactory schedulerFactory = this.schedulerFactory;
		if (schedulerFactory == null) {
			// Create local SchedulerFactory instance (typically a StdSchedulerFactory)
			schedulerFactory = BeanUtils.instantiateClass(this.schedulerFactoryClass);
			if (schedulerFactory instanceof StdSchedulerFactory) {
				initSchedulerFactory((StdSchedulerFactory) schedulerFactory);
			}
			else if (this.configLocation != null || this.quartzProperties != null ||
					this.taskExecutor != null || this.dataSource != null) {
				throw new IllegalArgumentException(
						"StdSchedulerFactory required for applying Quartz properties: " + schedulerFactory);
			}
			// Otherwise, no local settings to be applied via StdSchedulerFactory.initialize(Properties)
		}
		// Otherwise, assume that externally provided factory has been initialized with appropriate settings
		return schedulerFactory;
	}

	/**
	 * Initialize the given SchedulerFactory, applying locally defined Quartz properties to it.
	 * @param schedulerFactory the SchedulerFactory to initialize
	 */
	/**
	 * 初始化给定的SchedulerFactory，对其应用本地定义的Quartz属性。 
	 *  
	 * @param  schedulerFactory要初始化的SchedulerFactory
	 */
	private void initSchedulerFactory(StdSchedulerFactory schedulerFactory) throws SchedulerException, IOException {
		Properties mergedProps = new Properties();
		if (this.resourceLoader != null) {
			mergedProps.setProperty(StdSchedulerFactory.PROP_SCHED_CLASS_LOAD_HELPER_CLASS,
					ResourceLoaderClassLoadHelper.class.getName());
		}

		if (this.taskExecutor != null) {
			mergedProps.setProperty(StdSchedulerFactory.PROP_THREAD_POOL_CLASS,
					LocalTaskExecutorThreadPool.class.getName());
		}
		else {
			// Set necessary default properties here, as Quartz will not apply
			// its default configuration when explicitly given properties.
			mergedProps.setProperty(StdSchedulerFactory.PROP_THREAD_POOL_CLASS, SimpleThreadPool.class.getName());
			mergedProps.setProperty(PROP_THREAD_COUNT, Integer.toString(DEFAULT_THREAD_COUNT));
		}

		if (this.configLocation != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Loading Quartz config from [" + this.configLocation + "]");
			}
			PropertiesLoaderUtils.fillProperties(mergedProps, this.configLocation);
		}

		CollectionUtils.mergePropertiesIntoMap(this.quartzProperties, mergedProps);
		if (this.dataSource != null) {
			mergedProps.setProperty(StdSchedulerFactory.PROP_JOB_STORE_CLASS, LocalDataSourceJobStore.class.getName());
		}

		// Determine scheduler name across local settings and Quartz properties...
		if (this.schedulerName != null) {
			mergedProps.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, this.schedulerName);
		}
		else {
			String nameProp = mergedProps.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME);
			if (nameProp != null) {
				this.schedulerName = nameProp;
			}
			else if (this.beanName != null) {
				mergedProps.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, this.beanName);
				this.schedulerName = this.beanName;
			}
		}

		schedulerFactory.initialize(mergedProps);
	}

	private Scheduler prepareScheduler(SchedulerFactory schedulerFactory) throws SchedulerException {
		if (this.resourceLoader != null) {
			// Make given ResourceLoader available for SchedulerFactory configuration.
			configTimeResourceLoaderHolder.set(this.resourceLoader);
		}
		if (this.taskExecutor != null) {
			// Make given TaskExecutor available for SchedulerFactory configuration.
			configTimeTaskExecutorHolder.set(this.taskExecutor);
		}
		if (this.dataSource != null) {
			// Make given DataSource available for SchedulerFactory configuration.
			configTimeDataSourceHolder.set(this.dataSource);
		}
		if (this.nonTransactionalDataSource != null) {
			// Make given non-transactional DataSource available for SchedulerFactory configuration.
			configTimeNonTransactionalDataSourceHolder.set(this.nonTransactionalDataSource);
		}

		// Get Scheduler instance from SchedulerFactory.
		try {
			Scheduler scheduler = createScheduler(schedulerFactory, this.schedulerName);
			populateSchedulerContext(scheduler);

			if (!this.jobFactorySet && !(scheduler instanceof RemoteScheduler)) {
				// Use AdaptableJobFactory as default for a local Scheduler, unless when
				// explicitly given a null value through the "jobFactory" bean property.
				this.jobFactory = new AdaptableJobFactory();
			}
			if (this.jobFactory != null) {
				if (this.applicationContext != null && this.jobFactory instanceof ApplicationContextAware) {
					((ApplicationContextAware) this.jobFactory).setApplicationContext(this.applicationContext);
				}
				if (this.jobFactory instanceof SchedulerContextAware) {
					((SchedulerContextAware) this.jobFactory).setSchedulerContext(scheduler.getContext());
				}
				scheduler.setJobFactory(this.jobFactory);
			}
			return scheduler;
		}

		finally {
			if (this.resourceLoader != null) {
				configTimeResourceLoaderHolder.remove();
			}
			if (this.taskExecutor != null) {
				configTimeTaskExecutorHolder.remove();
			}
			if (this.dataSource != null) {
				configTimeDataSourceHolder.remove();
			}
			if (this.nonTransactionalDataSource != null) {
				configTimeNonTransactionalDataSourceHolder.remove();
			}
		}
	}

	/**
	 * Create the Scheduler instance for the given factory and scheduler name.
	 * Called by {@link #afterPropertiesSet}.
	 * <p>The default implementation invokes SchedulerFactory's {@code getScheduler}
	 * method. Can be overridden for custom Scheduler creation.
	 * @param schedulerFactory the factory to create the Scheduler with
	 * @param schedulerName the name of the scheduler to create
	 * @return the Scheduler instance
	 * @throws SchedulerException if thrown by Quartz methods
	 * @see #afterPropertiesSet
	 * @see org.quartz.SchedulerFactory#getScheduler
	 */
	/**
	 * 为给定的工厂和调度程序名称创建调度程序实例。 
	 * 由{@link  #afterPropertiesSet}调用。 
	 *  <p>默认实现调用SchedulerFactory的{@code  getScheduler}方法。 
	 * 可以覆盖以用于自定义Scheduler创建。 
	 *  
	 * @param  scheduler工厂使用
	 * @param  scheduler创建调度程序的工厂名称要创建的调度程序的名称<
	 * @returns调度程序实例
	 * @throws  SchedulerException如果被Quartz方法抛出
	 * @see  #afterPropertiesSet <
	 * @see > org.quartz.SchedulerFactory＃getScheduler
	 */
	protected Scheduler createScheduler(SchedulerFactory schedulerFactory, @Nullable String schedulerName)
			throws SchedulerException {

		// Override thread context ClassLoader to work around naive Quartz ClassLoadHelper loading.
		Thread currentThread = Thread.currentThread();
		ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
		boolean overrideClassLoader = (this.resourceLoader != null &&
				this.resourceLoader.getClassLoader() != threadContextClassLoader);
		if (overrideClassLoader) {
			currentThread.setContextClassLoader(this.resourceLoader.getClassLoader());
		}
		try {
			SchedulerRepository repository = SchedulerRepository.getInstance();
			synchronized (repository) {
				Scheduler existingScheduler = (schedulerName != null ? repository.lookup(schedulerName) : null);
				Scheduler newScheduler = schedulerFactory.getScheduler();
				if (newScheduler == existingScheduler) {
					throw new IllegalStateException("Active Scheduler of name '" + schedulerName + "' already registered " +
							"in Quartz SchedulerRepository. Cannot create a new Spring-managed Scheduler of the same name!");
				}
				if (!this.exposeSchedulerInRepository) {
					// Need to remove it in this case, since Quartz shares the Scheduler instance by default!
					SchedulerRepository.getInstance().remove(newScheduler.getSchedulerName());
				}
				return newScheduler;
			}
		}
		finally {
			if (overrideClassLoader) {
				// Reset original thread context ClassLoader.
				currentThread.setContextClassLoader(threadContextClassLoader);
			}
		}
	}

	/**
	 * Expose the specified context attributes and/or the current
	 * ApplicationContext in the Quartz SchedulerContext.
	 */
	/**
	 * 在Quartz SchedulerContext中公开指定的上下文属性和/或当前的ApplicationContext。 
	 * 
	 */
	private void populateSchedulerContext(Scheduler scheduler) throws SchedulerException {
		// Put specified objects into Scheduler context.
		if (this.schedulerContextMap != null) {
			scheduler.getContext().putAll(this.schedulerContextMap);
		}

		// Register ApplicationContext in Scheduler context.
		if (this.applicationContextSchedulerContextKey != null) {
			if (this.applicationContext == null) {
				throw new IllegalStateException(
					"SchedulerFactoryBean needs to be set up in an ApplicationContext " +
					"to be able to handle an 'applicationContextSchedulerContextKey'");
			}
			scheduler.getContext().put(this.applicationContextSchedulerContextKey, this.applicationContext);
		}
	}


	/**
	 * Start the Quartz Scheduler, respecting the "startupDelay" setting.
	 * @param scheduler the Scheduler to start
	 * @param startupDelay the number of seconds to wait before starting
	 * the Scheduler asynchronously
	 */
	/**
	 * 按照"startupDelay"设置启动Quartz Scheduler。 
	 *  
	 * @param 调度程序调度程序启动
	 * @param  startupDelay异步启动调度程序之前要等待的秒数
	 */
	protected void startScheduler(final Scheduler scheduler, final int startupDelay) throws SchedulerException {
		if (startupDelay <= 0) {
			logger.info("Starting Quartz Scheduler now");
			scheduler.start();
		}
		else {
			if (logger.isInfoEnabled()) {
				logger.info("Will start Quartz Scheduler [" + scheduler.getSchedulerName() +
						"] in " + startupDelay + " seconds");
			}
			// Not using the Quartz startDelayed method since we explicitly want a daemon
			// thread here, not keeping the JVM alive in case of all other threads ending.
			Thread schedulerThread = new Thread() {
				@Override
				public void run() {
					try {
						TimeUnit.SECONDS.sleep(startupDelay);
					}
					catch (InterruptedException ex) {
						Thread.currentThread().interrupt();
						// simply proceed
					}
					if (logger.isInfoEnabled()) {
						logger.info("Starting Quartz Scheduler now, after delay of " + startupDelay + " seconds");
					}
					try {
						scheduler.start();
					}
					catch (SchedulerException ex) {
						throw new SchedulingException("Could not start Quartz Scheduler after delay", ex);
					}
				}
			};
			schedulerThread.setName("Quartz Scheduler [" + scheduler.getSchedulerName() + "]");
			schedulerThread.setDaemon(true);
			schedulerThread.start();
		}
	}


	//---------------------------------------------------------------------
	// Implementation of FactoryBean interface
	//---------------------------------------------------------------------

	@Override
	public Scheduler getScheduler() {
		Assert.state(this.scheduler != null, "No Scheduler set");
		return this.scheduler;
	}

	@Override
	@Nullable
	public Scheduler getObject() {
		return this.scheduler;
	}

	@Override
	public Class<? extends Scheduler> getObjectType() {
		return (this.scheduler != null ? this.scheduler.getClass() : Scheduler.class);
	}

	@Override
	public boolean isSingleton() {
		return true;
	}


	//---------------------------------------------------------------------
	// Implementation of SmartLifecycle interface
	//---------------------------------------------------------------------

	@Override
	public void start() throws SchedulingException {
		if (this.scheduler != null) {
			try {
				startScheduler(this.scheduler, this.startupDelay);
			}
			catch (SchedulerException ex) {
				throw new SchedulingException("Could not start Quartz Scheduler", ex);
			}
		}
	}

	@Override
	public void stop() throws SchedulingException {
		if (this.scheduler != null) {
			try {
				this.scheduler.standby();
			}
			catch (SchedulerException ex) {
				throw new SchedulingException("Could not stop Quartz Scheduler", ex);
			}
		}
	}

	@Override
	public boolean isRunning() throws SchedulingException {
		if (this.scheduler != null) {
			try {
				return !this.scheduler.isInStandbyMode();
			}
			catch (SchedulerException ex) {
				return false;
			}
		}
		return false;
	}


	//---------------------------------------------------------------------
	// Implementation of DisposableBean interface
	//---------------------------------------------------------------------

	/**
	 * Shut down the Quartz scheduler on bean factory shutdown,
	 * stopping all scheduled jobs.
	 */
	/**
	 * 在bean工厂关闭时关闭Quartz调度程序，停止所有调度的作业。 
	 * 
	 */
	@Override
	public void destroy() throws SchedulerException {
		if (this.scheduler != null) {
			logger.info("Shutting down Quartz Scheduler");
			this.scheduler.shutdown(this.waitForJobsToCompleteOnShutdown);
		}
	}

}
