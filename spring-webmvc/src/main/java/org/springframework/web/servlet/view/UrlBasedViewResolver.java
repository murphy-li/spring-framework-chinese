/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.view;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;

import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.BeanUtils;
import org.springframework.context.ApplicationContext;
import org.springframework.core.Ordered;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.PatternMatchUtils;
import org.springframework.web.servlet.View;

/**
 * Simple implementation of the {@link org.springframework.web.servlet.ViewResolver}
 * interface, allowing for direct resolution of symbolic view names to URLs,
 * without explicit mapping definitions. This is useful if your symbolic names
 * match the names of your view resources in a straightforward manner
 * (i.e. the symbolic name is the unique part of the resource's filename),
 * without the need for a dedicated mapping to be defined for each view.
 *
 * <p>Supports {@link AbstractUrlBasedView} subclasses like {@link InternalResourceView}
 * and {@link org.springframework.web.servlet.view.freemarker.FreeMarkerView}.
 * The view class for all views generated by this resolver can be specified
 * via the "viewClass" property.
 *
 * <p>View names can either be resource URLs themselves, or get augmented by a
 * specified prefix and/or suffix. Exporting an attribute that holds the
 * RequestContext to all views is explicitly supported.
 *
 * <p>Example: prefix="/WEB-INF/jsp/", suffix=".jsp", viewname="test" ->
 * "/WEB-INF/jsp/test.jsp"
 *
 * <p>As a special feature, redirect URLs can be specified via the "redirect:"
 * prefix. E.g.: "redirect:myAction" will trigger a redirect to the given
 * URL, rather than resolution as standard view name. This is typically used
 * for redirecting to a controller URL after finishing a form workflow.
 *
 * <p>Furthermore, forward URLs can be specified via the "forward:" prefix.
 * E.g.: "forward:myAction" will trigger a forward to the given URL, rather than
 * resolution as standard view name. This is typically used for controller URLs;
 * it is not supposed to be used for JSP URLs - use logical view names there.
 *
 * <p>Note: This class does not support localized resolution, i.e. resolving
 * a symbolic view name to different resources depending on the current locale.
 *
 * <p><b>Note:</b> When chaining ViewResolvers, a UrlBasedViewResolver will check whether
 * the {@linkplain AbstractUrlBasedView#checkResource specified resource actually exists}.
 * However, with {@link InternalResourceView}, it is not generally possible to
 * determine the existence of the target resource upfront. In such a scenario,
 * a UrlBasedViewResolver will always return a View for any given view name;
 * as a consequence, it should be configured as the last ViewResolver in the chain.
 *
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Sam Brannen
 * @since 13.12.2003
 * @see #setViewClass
 * @see #setPrefix
 * @see #setSuffix
 * @see #setRequestContextAttribute
 * @see #REDIRECT_URL_PREFIX
 * @see AbstractUrlBasedView
 * @see InternalResourceView
 * @see org.springframework.web.servlet.view.freemarker.FreeMarkerView
 */
/**
 * {@link  org.springframework.web.servlet.ViewResolver}接口的简单实现，允许将符号视图名称直接解析为URL，而无需显式映射定义。 
 * 如果您的符号名称以直接的方式与视图资源的名称匹配（即符号名称是资源文件名的唯一部分），而无需为每个视图定义专用映射，则这将很有用。 
 *  <p>支持{@link  AbstractUrlBasedView}子类，例如{@link  InternalResourceView}和{@link  org.springframework.web.servlet.view.freemarker.FreeMarkerView}。 
 * 可以通过"viewClass"属性指定此解析器生成的所有视图的视图类。 
 *  <p>视图名称可以是资源URL本身，也可以通过指定的前缀和/或后缀进行扩充。 
 * 明确支持将保存RequestContext的属性导出到所有视图。 
 *  <p>示例：prefix ="/ WEB-INF / jsp /"，后缀="。 
 * jsp"，viewname ="test"->"/WEB-INF/jsp/test.jsp"<p>作为特殊功能，重定向网址可以通过"redirect："前缀指定。 
 * 例如："redirect：myAction"将触发重定向到给定的URL，而不是解析为标准视图名称。 
 * 这通常用于在完成表单工作流程后重定向到控制器URL。 
 *  <p>此外，转发URL可以通过"forward："前缀指定。 
 * 例如："forward：myAction"将触发对给定URL的转发，而不是作为标准视图名称的解析。 
 * 通常用于控制器URL。 
 * 它不应该用于JSP URL-在此使用逻辑视图名称。 
 *  <p>注意：此类不支持本地化的解析，即根据当前语言环境将符号视图名称解析为不同的资源。 
 *  <p> <b>注意：</ b>链接ViewResolvers时，UrlBasedViewResolver将检查{@link  plain AbstractUrlBasedView＃checkResource指定的资源是否确实存在}。 
 * 但是，使用{@link  InternalResourceView}，通常不可能预先确定目标资源的存在。 
 * 在这种情况下，UrlBasedViewResolver将始终为任何给定的视图名称返回一个View。 
 * 因此，应将其配置为链中的最后一个ViewResolver。 
 *  @author  Juergen Hoeller @author  Rob Harrop @author  Sam Brannen @2003年12月13日
 * @see  #setViewClass 
 * @see  #setPrefix 
 * @see  #setSuffix 
 * @see  #setRequestContextAttribute <
 * @see > #REDIRECT_URL_PREFIX 
 * @see  AbstractUrlBasedView 
 * @see  InternalResourceView 
 * @see  org.springframework.web.servlet.view.freemarker.FreeMarkerView
 */
public class UrlBasedViewResolver extends AbstractCachingViewResolver implements Ordered {

	/**
	 * Prefix for special view names that specify a redirect URL (usually
	 * to a controller after a form has been submitted and processed).
	 * Such view names will not be resolved in the configured default
	 * way but rather be treated as special shortcut.
	 */
	/**
	 * 指定重定向URL的特殊视图名称的前缀（通常在提交和处理表单后添加到控制器）。 
	 * 此类视图名称将不会以配置的默认方式解析，而是被视为特殊快捷方式。 
	 * 
	 */
	public static final String REDIRECT_URL_PREFIX = "redirect:";

	/**
	 * Prefix for special view names that specify a forward URL (usually
	 * to a controller after a form has been submitted and processed).
	 * Such view names will not be resolved in the configured default
	 * way but rather be treated as special shortcut.
	 */
	/**
	 * 指定前向URL的特殊视图名称的前缀（通常在提交并处理表单后发送给控制器）​​。 
	 * 此类视图名称将不会以配置的默认方式解析，而是被视为特殊快捷方式。 
	 * 
	 */
	public static final String FORWARD_URL_PREFIX = "forward:";


	@Nullable
	private Class<?> viewClass;

	private String prefix = "";

	private String suffix = "";

	@Nullable
	private String contentType;

	private boolean redirectContextRelative = true;

	private boolean redirectHttp10Compatible = true;

	@Nullable
	private String[] redirectHosts;

	@Nullable
	private String requestContextAttribute;

	/** Map of static attributes, keyed by attribute name (String). */
	/**
	 * 静态属性的映射，由属性名称（字符串）作为键。 
	 * 
	 */
	private final Map<String, Object> staticAttributes = new HashMap<>();

	@Nullable
	private Boolean exposePathVariables;

	@Nullable
	private Boolean exposeContextBeansAsAttributes;

	@Nullable
	private String[] exposedContextBeanNames;

	@Nullable
	private String[] viewNames;

	private int order = Ordered.LOWEST_PRECEDENCE;


	/**
	 * Set the view class that should be used to create views.
	 * @param viewClass class that is assignable to the required view class
	 * (by default, AbstractUrlBasedView)
	 * @see AbstractUrlBasedView
	 */
	/**
	 * 设置应用于创建视图的视图类。 
	 *  
	 * @param 可以分配给所需视图类的viewClass类（默认为AbstractUrlBasedView）
	 * @see  AbstractUrlBasedView
	 */
	public void setViewClass(@Nullable Class<?> viewClass) {
		if (viewClass != null && !requiredViewClass().isAssignableFrom(viewClass)) {
			throw new IllegalArgumentException("Given view class [" + viewClass.getName() +
					"] is not of type [" + requiredViewClass().getName() + "]");
		}
		this.viewClass = viewClass;
	}

	/**
	 * Return the view class to be used to create views.
	 */
	/**
	 * 返回用于创建视图的视图类。 
	 * 
	 */
	@Nullable
	protected Class<?> getViewClass() {
		return this.viewClass;
	}

	/**
	 * Return the required type of view for this resolver.
	 * This implementation returns AbstractUrlBasedView.
	 * @see AbstractUrlBasedView
	 */
	/**
	 * 返回此解析器所需的视图类型。 
	 * 此实现返回AbstractUrlBasedView。 
	 *  
	 * @see  AbstractUrlBasedView
	 */
	protected Class<?> requiredViewClass() {
		return AbstractUrlBasedView.class;
	}

	/**
	 * Set the prefix that gets prepended to view names when building a URL.
	 */
	/**
	 * 设置在构建URL时可用来查看名称的前缀。 
	 * 
	 */
	public void setPrefix(@Nullable String prefix) {
		this.prefix = (prefix != null ? prefix : "");
	}

	/**
	 * Return the prefix that gets prepended to view names when building a URL.
	 */
	/**
	 * 返回在构建URL时前缀为查看名称的前缀。 
	 * 
	 */
	protected String getPrefix() {
		return this.prefix;
	}

	/**
	 * Set the suffix that gets appended to view names when building a URL.
	 */
	/**
	 * 设置在构建URL时附加到视图名称的后缀。 
	 * 
	 */
	public void setSuffix(@Nullable String suffix) {
		this.suffix = (suffix != null ? suffix : "");
	}

	/**
	 * Return the suffix that gets appended to view names when building a URL.
	 */
	/**
	 * 返回构建URL时添加到视图名称后的后缀。 
	 * 
	 */
	protected String getSuffix() {
		return this.suffix;
	}

	/**
	 * Set the content type for all views.
	 * <p>May be ignored by view classes if the view itself is assumed
	 * to set the content type, e.g. in case of JSPs.
	 */
	/**
	 * 设置所有视图的内容类型。 
	 *  <p>如果假设视图本身设置了内容类型，则视图类可以忽略<p>对于JSP。 
	 * 
	 */
	public void setContentType(@Nullable String contentType) {
		this.contentType = contentType;
	}

	/**
	 * Return the content type for all views, if any.
	 */
	/**
	 * 返回所有视图的内容类型（如果有）。 
	 * 
	 */
	@Nullable
	protected String getContentType() {
		return this.contentType;
	}

	/**
	 * Set whether to interpret a given redirect URL that starts with a
	 * slash ("/") as relative to the current ServletContext, i.e. as
	 * relative to the web application root.
	 * <p>Default is "true": A redirect URL that starts with a slash will be
	 * interpreted as relative to the web application root, i.e. the context
	 * path will be prepended to the URL.
	 * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>
	 * E.g.: "redirect:myAction"
	 * @see RedirectView#setContextRelative
	 * @see #REDIRECT_URL_PREFIX
	 */
	/**
	 * 设置是否相对于当前ServletContext（即相对于Web应用程序根目录）解释以斜杠（"/"）开头的给定重定向URL。 
	 *  <p>默认值为"true"：以斜杠开头的重定向URL将被解释为相对于Web应用程序根目录，即上下文路径将位于URL之前。 
	 *  <p> <b>重定向URL可以通过"redirect："前缀指定。 
	 * </ b>例如："redirect：myAction"
	 * @see  RedirectView＃setContextRelative 
	 * @see  #REDIRECT_URL_PREFIX
	 */
	public void setRedirectContextRelative(boolean redirectContextRelative) {
		this.redirectContextRelative = redirectContextRelative;
	}

	/**
	 * Return whether to interpret a given redirect URL that starts with a
	 * slash ("/") as relative to the current ServletContext, i.e. as
	 * relative to the web application root.
	 */
	/**
	 * 返回是否相对于当前ServletContext（即相对于Web应用程序根目录）解释以斜杠（"/"）开头的给定重定向URL。 
	 * 
	 */
	protected boolean isRedirectContextRelative() {
		return this.redirectContextRelative;
	}

	/**
	 * Set whether redirects should stay compatible with HTTP 1.0 clients.
	 * <p>In the default implementation, this will enforce HTTP status code 302
	 * in any case, i.e. delegate to {@code HttpServletResponse.sendRedirect}.
	 * Turning this off will send HTTP status code 303, which is the correct
	 * code for HTTP 1.1 clients, but not understood by HTTP 1.0 clients.
	 * <p>Many HTTP 1.1 clients treat 302 just like 303, not making any
	 * difference. However, some clients depend on 303 when redirecting
	 * after a POST request; turn this flag off in such a scenario.
	 * <p><b>Redirect URLs can be specified via the "redirect:" prefix.</b>
	 * E.g.: "redirect:myAction"
	 * @see RedirectView#setHttp10Compatible
	 * @see #REDIRECT_URL_PREFIX
	 */
	/**
	 * 设置重定向是否应保持与HTTP 1.0客户端兼容。 
	 *  <p>在默认实现中，这将在任何情况下强制执行HTTP状态代码302，即委托给{@code  HttpServletResponse.sendRedirect}。 
	 * 关闭此选项将发送HTTP状态代码303，这是HTTP 1.1客户端的正确代码，但HTTP 1.0客户端无法理解。 
	 *  <p>许多HTTP 1.1客户端像303一样对待302，没有任何区别。 
	 * 但是，某些客户端在POST请求后进行重定向时依赖303。 
	 * 在这种情况下，请关闭此标志。 
	 *  <p> <b>可以通过"redirect："前缀指定重定向URL。 
	 * </ b>例如："redirect：myAction"
	 * @see  RedirectView＃setHttp10Compatible 
	 * @see  #REDIRECT_URL_PREFIX
	 */
	public void setRedirectHttp10Compatible(boolean redirectHttp10Compatible) {
		this.redirectHttp10Compatible = redirectHttp10Compatible;
	}

	/**
	 * Return whether redirects should stay compatible with HTTP 1.0 clients.
	 */
	/**
	 * 返回重定向是否应该与HTTP 1.0客户端兼容。 
	 * 
	 */
	protected boolean isRedirectHttp10Compatible() {
		return this.redirectHttp10Compatible;
	}

	/**
	 * Configure one or more hosts associated with the application.
	 * All other hosts will be considered external hosts.
	 * <p>In effect, this property provides a way turn off encoding on redirect
	 * via {@link HttpServletResponse#encodeRedirectURL} for URLs that have a
	 * host and that host is not listed as a known host.
	 * <p>If not set (the default) all URLs are encoded through the response.
	 * @param redirectHosts one or more application hosts
	 * @since 4.3
	 */
	/**
	 * 配置与该应用程序关联的一台或多台主机。 
	 * 所有其他主机将被视为外部主机。 
	 *  <p>实际上，此属性提供了一种方法，用于关闭通过{@link  HttpServletResponse＃encodeRedirectURL}重定向的具有主机且未将该主机列为已知主机的URL。 
	 *  <p>如果未设置（默认），则所有URL均通过响应进行编码。 
	 *  
	 * @param  redirectHosts自4.3起开始托管一台或多台应用程序主机
	 */
	public void setRedirectHosts(@Nullable String... redirectHosts) {
		this.redirectHosts = redirectHosts;
	}

	/**
	 * Return the configured application hosts for redirect purposes.
	 * @since 4.3
	 */
	/**
	 * 返回配置的应用程序主机以进行重定向。 
	 *  @4.3起
	 */
	@Nullable
	public String[] getRedirectHosts() {
		return this.redirectHosts;
	}

	/**
	 * Set the name of the RequestContext attribute for all views.
	 * @param requestContextAttribute name of the RequestContext attribute
	 * @see AbstractView#setRequestContextAttribute
	 */
	/**
	 * 为所有视图设置RequestContext属性的名称。 
	 *  
	 * @param  requestContextAttribute RequestContext属性的名称
	 * @see  AbstractView＃setRequestContextAttribute
	 */
	public void setRequestContextAttribute(@Nullable String requestContextAttribute) {
		this.requestContextAttribute = requestContextAttribute;
	}

	/**
	 * Return the name of the RequestContext attribute for all views, if any.
	 */
	/**
	 * 返回所有视图的RequestContext属性的名称（如果有）。 
	 * 
	 */
	@Nullable
	protected String getRequestContextAttribute() {
		return this.requestContextAttribute;
	}

	/**
	 * Set static attributes from a {@code java.util.Properties} object,
	 * for all views returned by this resolver.
	 * <p>This is the most convenient way to set static attributes. Note that
	 * static attributes can be overridden by dynamic attributes, if a value
	 * with the same name is included in the model.
	 * <p>Can be populated with a String "value" (parsed via PropertiesEditor)
	 * or a "props" element in XML bean definitions.
	 * @see org.springframework.beans.propertyeditors.PropertiesEditor
	 * @see AbstractView#setAttributes
	 */
	/**
	 * 从{@code  java.util.Properties}对象为此解析器返回的所有视图设置静态属性。 
	 *  <p>这是设置静态属性的最便捷方法。 
	 * 请注意，如果模型中包含具有相同名称的值，则静态属性可以被动态属性覆盖。 
	 *  <p>可以用XML bean定义中的字符串"值"（通过PropertiesEditor解析）或"props"元素填充。 
	 *  
	 * @see  org.springframework.beans.propertyeditors.PropertiesEditor 
	 * @see  AbstractView＃setAttributes
	 */
	public void setAttributes(Properties props) {
		CollectionUtils.mergePropertiesIntoMap(props, this.staticAttributes);
	}

	/**
	 * Set static attributes from a Map, for all views returned by this resolver.
	 * This allows to set any kind of attribute values, for example bean references.
	 * <p>Can be populated with a "map" or "props" element in XML bean definitions.
	 * @param attributes a Map with name Strings as keys and attribute objects as values
	 * @see AbstractView#setAttributesMap
	 */
	/**
	 * 针对此解析器返回的所有视图，从地图设置静态属性。 
	 * 这允许设置任何种类的属性值，例如bean引用。 
	 *  <p>可以在XML bean定义中填充"map"或"props"元素。 
	 *  
	 * @param 为名称为Map的Map分配属性，字符串为键，属性对象为值
	 * @see  AbstractView＃setAttributesMap
	 */
	public void setAttributesMap(@Nullable Map<String, ?> attributes) {
		if (attributes != null) {
			this.staticAttributes.putAll(attributes);
		}
	}

	/**
	 * Allow Map access to the static attributes for views returned by
	 * this resolver, with the option to add or override specific entries.
	 * <p>Useful for specifying entries directly, for example via
	 * "attributesMap[myKey]". This is particularly useful for
	 * adding or overriding entries in child view definitions.
	 */
	/**
	 * 允许地图访问此解析程序返回的视图的静态属性，并可以选择添加或覆盖特定条目。 
	 *  <p>可用于直接指定条目，例如通过"attributesMap [myKey]"。 
	 * 这对于在子视图定义中添加或覆盖条目特别有用。 
	 * 
	 */
	public Map<String, Object> getAttributesMap() {
		return this.staticAttributes;
	}

	/**
	 * Specify whether views resolved by this resolver should add path variables to the model or not.
	 * <p>>The default setting is to let each View decide (see {@link AbstractView#setExposePathVariables}.
	 * However, you can use this property to override that.
	 * @param exposePathVariables
	 * <ul>
	 * <li>{@code true} - all Views resolved by this resolver will expose path variables
	 * <li>{@code false} - no Views resolved by this resolver will expose path variables
	 * <li>{@code null} - individual Views can decide for themselves (this is used by the default)
	 * </ul>
	 * @see AbstractView#setExposePathVariables
	 */
	/**
	 * 指定此解析器解析的视图是否应将路径变量添加到模型。 
	 *  <p >>默认设置是让每个View决定（请参阅{@link  AbstractView＃setExposePathVariables}。 
	 * 但是，您可以使用此属性来覆盖它。 
	 * 
	 * @param 暴露PathVariables <ul> <li> {<@code> true}-此解析器解析的所有视图都将公开路径变量<li> {<@code> false}-没有此解析器解析的视图将公开路径变量<li> {<@code> null}-各个视图可以自行决定（默认情况下使用）</ ul> 
	 * @see  AbstractView＃setExposePathVariables
	 */
	public void setExposePathVariables(@Nullable Boolean exposePathVariables) {
		this.exposePathVariables = exposePathVariables;
	}

	/**
	 * Return whether views resolved by this resolver should add path variables to the model or not.
	 */
	/**
	 * 返回此解析器解析的视图是否应将路径变量添加到模型。 
	 * 
	 */
	@Nullable
	protected Boolean getExposePathVariables() {
		return this.exposePathVariables;
	}

	/**
	 * Set whether to make all Spring beans in the application context accessible
	 * as request attributes, through lazy checking once an attribute gets accessed.
	 * <p>This will make all such beans accessible in plain {@code ${...}}
	 * expressions in a JSP 2.0 page, as well as in JSTL's {@code c:out}
	 * value expressions.
	 * <p>Default is "false".
	 * @see AbstractView#setExposeContextBeansAsAttributes
	 */
	/**
	 * 设置是否通过访问属性后进行惰性检查来使应用程序上下文中的所有Spring Bean都可作为请求属性进行访问。 
	 *  <p>这将使所有这样的bean在JSP 2.0页面中的普通{@code  $ {...}}表达式以及JSTL的{@code  c：out}值表达式中均可访问。 
	 *  <p>默认为"false"。 
	 *  
	 * @see  AbstractView＃setExposeContextBeansAsAttributes
	 */
	public void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {
		this.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes;
	}

	@Nullable
	protected Boolean getExposeContextBeansAsAttributes() {
		return this.exposeContextBeansAsAttributes;
	}

	/**
	 * Specify the names of beans in the context which are supposed to be exposed.
	 * If this is non-null, only the specified beans are eligible for exposure as
	 * attributes.
	 * @see AbstractView#setExposedContextBeanNames
	 */
	/**
	 * 在上下文中指定应该公开的bean名称。 
	 * 如果这不是非null，则只有指定的bean才有资格作为属性公开。 
	 *  
	 * @see  AbstractView＃setExposedContextBeanNames
	 */
	public void setExposedContextBeanNames(@Nullable String... exposedContextBeanNames) {
		this.exposedContextBeanNames = exposedContextBeanNames;
	}

	@Nullable
	protected String[] getExposedContextBeanNames() {
		return this.exposedContextBeanNames;
	}

	/**
	 * Set the view names (or name patterns) that can be handled by this
	 * {@link org.springframework.web.servlet.ViewResolver}. View names can contain
	 * simple wildcards such that 'my*', '*Report' and '*Repo*' will all match the
	 * view name 'myReport'.
	 * @see #canHandle
	 */
	/**
	 * 设置可由此{@link  org.springframework.web.servlet.ViewResolver}处理的视图名称（或名称模式）。 
	 * 视图名称可以包含简单的通配符，例如"my"，"Report"和"Repo"都将与视图名称"myReport"匹配。 
	 *  
	 * @see  #canHandle
	 */
	public void setViewNames(@Nullable String... viewNames) {
		this.viewNames = viewNames;
	}

	/**
	 * Return the view names (or name patterns) that can be handled by this
	 * {@link org.springframework.web.servlet.ViewResolver}.
	 */
	/**
	 * 返回此{@link  org.springframework.web.servlet.ViewResolver}可以处理的视图名称（或名称模式）。 
	 * 
	 */
	@Nullable
	protected String[] getViewNames() {
		return this.viewNames;
	}

	/**
	 * Specify the order value for this ViewResolver bean.
	 * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.
	 * @see org.springframework.core.Ordered#getOrder()
	 */
	/**
	 * 指定此ViewResolver bean的订单值。 
	 *  <p>默认值为{@code  Ordered.LOWEST_PRECEDENCE}，表示无序。 
	 *  
	 * @see  org.springframework.core.Ordered＃getOrder（）
	 */
	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}

	@Override
	protected void initApplicationContext() {
		super.initApplicationContext();
		if (getViewClass() == null) {
			throw new IllegalArgumentException("Property 'viewClass' is required");
		}
	}


	/**
	 * This implementation returns just the view name,
	 * as this ViewResolver doesn't support localized resolution.
	 */
	/**
	 * 此实现仅返回视图名称，因为此ViewResolver不支持本地化的分辨率。 
	 * 
	 */
	@Override
	protected Object getCacheKey(String viewName, Locale locale) {
		return viewName;
	}

	/**
	 * Overridden to implement check for "redirect:" prefix.
	 * <p>Not possible in {@code loadView}, since overridden
	 * {@code loadView} versions in subclasses might rely on the
	 * superclass always creating instances of the required view class.
	 * @see #loadView
	 * @see #requiredViewClass
	 */
	/**
	 * 重写以实现对"redirect："前缀的检查。 
	 *  <p>在{@code  loadView}中是不可能的，因为子类中被覆盖的{@code  loadView}版本可能依赖于超类始终创建所需视图类的实例。 
	 *  
	 * @see  #loadView 
	 * @see  #requiredViewClass
	 */
	@Override
	protected View createView(String viewName, Locale locale) throws Exception {
		// If this resolver is not supposed to handle the given view,
		// return null to pass on to the next resolver in the chain.
		if (!canHandle(viewName, locale)) {
			return null;
		}

		// Check for special "redirect:" prefix.
		if (viewName.startsWith(REDIRECT_URL_PREFIX)) {
			String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
			RedirectView view = new RedirectView(redirectUrl,
					isRedirectContextRelative(), isRedirectHttp10Compatible());
			String[] hosts = getRedirectHosts();
			if (hosts != null) {
				view.setHosts(hosts);
			}
			return applyLifecycleMethods(REDIRECT_URL_PREFIX, view);
		}

		// Check for special "forward:" prefix.
		if (viewName.startsWith(FORWARD_URL_PREFIX)) {
			String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
			InternalResourceView view = new InternalResourceView(forwardUrl);
			return applyLifecycleMethods(FORWARD_URL_PREFIX, view);
		}

		// Else fall back to superclass implementation: calling loadView.
		return super.createView(viewName, locale);
	}

	/**
	 * Indicates whether or not this {@link org.springframework.web.servlet.ViewResolver} can
	 * handle the supplied view name. If not, {@link #createView(String, java.util.Locale)} will
	 * return {@code null}. The default implementation checks against the configured
	 * {@link #setViewNames view names}.
	 * @param viewName the name of the view to retrieve
	 * @param locale the Locale to retrieve the view for
	 * @return whether this resolver applies to the specified view
	 * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)
	 */
	/**
	 * 指示此{@link  org.springframework.web.servlet.ViewResolver}是否可以处理提供的视图名称。 
	 * 如果没有，{<@link> #createView（String，java.util.Locale）}将返回{@code  null}。 
	 * 默认实现会对照已配置的{@link  #setViewNames视图名称}进行检查。 
	 *  
	 * @param  viewName要检索的视图的名称
	 * @param 语言环境为
	 * @return 检索视图的语言环境是否此解析器适用于指定的视图
	 * @see  org.springframework.util.PatternMatchUtils＃simpleMatch（字符串，字符串）
	 */
	protected boolean canHandle(String viewName, Locale locale) {
		String[] viewNames = getViewNames();
		return (viewNames == null || PatternMatchUtils.simpleMatch(viewNames, viewName));
	}

	/**
	 * Delegates to {@code buildView} for creating a new instance of the
	 * specified view class. Applies the following Spring lifecycle methods
	 * (as supported by the generic Spring bean factory):
	 * <ul>
	 * <li>ApplicationContextAware's {@code setApplicationContext}
	 * <li>InitializingBean's {@code afterPropertiesSet}
	 * </ul>
	 * @param viewName the name of the view to retrieve
	 * @return the View instance
	 * @throws Exception if the view couldn't be resolved
	 * @see #buildView(String)
	 * @see org.springframework.context.ApplicationContextAware#setApplicationContext
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
	 */
	/**
	 * 委托给{@code  buildView}来创建指定视图类的新实例。 
	 * 应用以下Spring生命周期方法（由通用Spring bean工厂支持）：<ul> <li> ApplicationContextAware的{@code  setApplicationContext} <li> InitializingBean的{@code  afterPropertiesSet} </ ul> 
	 * @param  viewName要检索的视图名称
	 * @return 视图实例
	 * @throws 如果无法解析视图，则异常
	 * @see  #buildView（String）
	 * @see  org.springframework.context.ApplicationContextAware＃setApplicationContext 
	 * @see  org.springframework.beans.factory.InitializingBean＃afterPropertiesSet
	 */
	@Override
	protected View loadView(String viewName, Locale locale) throws Exception {
		AbstractUrlBasedView view = buildView(viewName);
		View result = applyLifecycleMethods(viewName, view);
		return (view.checkResource(locale) ? result : null);
	}

	/**
	 * Creates a new View instance of the specified view class and configures it.
	 * Does <i>not</i> perform any lookup for pre-defined View instances.
	 * <p>Spring lifecycle methods as defined by the bean container do not have to
	 * be called here; those will be applied by the {@code loadView} method
	 * after this method returns.
	 * <p>Subclasses will typically call {@code super.buildView(viewName)}
	 * first, before setting further properties themselves. {@code loadView}
	 * will then apply Spring lifecycle methods at the end of this process.
	 * @param viewName the name of the view to build
	 * @return the View instance
	 * @throws Exception if the view couldn't be resolved
	 * @see #loadView(String, java.util.Locale)
	 */
	/**
	 * 创建指定视图类的新View实例并对其进行配置。 
	 *  <i>不</ i>对预定义的View实例不执行任何查找。 
	 *  <p> bean容器定义的Spring生命周期方法不必在这里调用； 
	 * 这些方法将在此方法返回后由{@code  loadView}方法应用。 
	 *  <p>子类通常会在自己设置其他属性之前先调用{@code  super.buildView（viewName）}。 
	 * 然后，{<@code> loadView}将在此过程结束时应用Spring生命周期方法。 
	 *  
	 * @param  viewName要构建的视图的名称
	 * @return  View实例
	 * @throws 如果无法解析该视图，则异常
	 * @see  #loadView（String，java.util.Locale）
	 */
	protected AbstractUrlBasedView buildView(String viewName) throws Exception {
		Class<?> viewClass = getViewClass();
		Assert.state(viewClass != null, "No view class");

		AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);
		view.setUrl(getPrefix() + viewName + getSuffix());
		view.setAttributesMap(getAttributesMap());

		String contentType = getContentType();
		if (contentType != null) {
			view.setContentType(contentType);
		}

		String requestContextAttribute = getRequestContextAttribute();
		if (requestContextAttribute != null) {
			view.setRequestContextAttribute(requestContextAttribute);
		}

		Boolean exposePathVariables = getExposePathVariables();
		if (exposePathVariables != null) {
			view.setExposePathVariables(exposePathVariables);
		}
		Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();
		if (exposeContextBeansAsAttributes != null) {
			view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
		}
		String[] exposedContextBeanNames = getExposedContextBeanNames();
		if (exposedContextBeanNames != null) {
			view.setExposedContextBeanNames(exposedContextBeanNames);
		}

		return view;
	}

	/**
	 * Apply the containing {@link ApplicationContext}'s lifecycle methods
	 * to the given {@link View} instance, if such a context is available.
	 * @param viewName the name of the view
	 * @param view the freshly created View instance, pre-configured with
	 * {@link AbstractUrlBasedView}'s properties
	 * @return the {@link View} instance to use (either the original one
	 * or a decorated variant)
	 * @since 5.0
	 * @see #getApplicationContext()
	 * @see ApplicationContext#getAutowireCapableBeanFactory()
	 * @see org.springframework.beans.factory.config.AutowireCapableBeanFactory#initializeBean
	 */
	/**
	 * 如果有这样的上下文，请将包含的{@link  ApplicationContext}的生命周期方法应用于给定的{@link  View}实例。 
	 *  
	 * @param  viewName视图的名称
	 * @param 视图新创建的View实例，已预先配置了{@link  AbstractUrlBasedView}的属性
	 * @return  {@link  View}实例以供使用（原始版本或修饰版本）@since 5.0 
	 * @see  #getApplicationContext（）
	 * @see  ApplicationContext＃getAutowireCapableBeanFactory（）
	 * @see  org.springframework.beans.factory.config.AutowireCapableBeanFactory＃initializeBean
	 */
	protected View applyLifecycleMethods(String viewName, AbstractUrlBasedView view) {
		ApplicationContext context = getApplicationContext();
		if (context != null) {
			Object initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);
			if (initialized instanceof View) {
				return (View) initialized;
			}
		}
		return view;
	}

}
