/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.method.HandlerMethod;

/**
 * Extends {@code HandlerInterceptor} with a callback method invoked after the
 * start of asynchronous request handling.
 *
 * <p>When a handler starts an asynchronous request, the {@link DispatcherServlet}
 * exits without invoking {@code postHandle} and {@code afterCompletion} as it
 * normally does for a synchronous request, since the result of request handling
 * (e.g. ModelAndView) is likely not yet ready and will be produced concurrently
 * from another thread. In such scenarios, {@link #afterConcurrentHandlingStarted}
 * is invoked instead, allowing implementations to perform tasks such as cleaning
 * up thread-bound attributes before releasing the thread to the Servlet container.
 *
 * <p>When asynchronous handling completes, the request is dispatched to the
 * container for further processing. At this stage the {@code DispatcherServlet}
 * invokes {@code preHandle}, {@code postHandle}, and {@code afterCompletion}.
 * To distinguish between the initial request and the subsequent dispatch
 * after asynchronous handling completes, interceptors can check whether the
 * {@code javax.servlet.DispatcherType} of {@link javax.servlet.ServletRequest}
 * is {@code "REQUEST"} or {@code "ASYNC"}.
 *
 * <p>Note that {@code HandlerInterceptor} implementations may need to do work
 * when an async request times out or completes with a network error. For such
 * cases the Servlet container does not dispatch and therefore the
 * {@code postHandle} and {@code afterCompletion} methods will not be invoked.
 * Instead, interceptors can register to track an asynchronous request through
 * the {@code registerCallbackInterceptor} and {@code registerDeferredResultInterceptor}
 * methods on {@link org.springframework.web.context.request.async.WebAsyncManager
 * WebAsyncManager}. This can be done proactively on every request from
 * {@code preHandle} regardless of whether async request processing will start.
 *
 * @author Rossen Stoyanchev
 * @since 3.2
 * @see org.springframework.web.context.request.async.WebAsyncManager
 * @see org.springframework.web.context.request.async.CallableProcessingInterceptor
 * @see org.springframework.web.context.request.async.DeferredResultProcessingInterceptor
 */
/**
 * 在异步请求处理开始后，使用回调方法扩展{@code  HandlerInterceptor}。 
 *  <p>当处理程序启动异步请求时，{<@link> DispatcherServlet}会退出，而不会调用{@code  postHandle}和{@code  afterCompletion}，这通常是对同步请求的处理，因为请求处理（例如ModelAndView）可能尚未准备好，并且将从另一个线程同时生成。 
 * 在这种情况下，将改为调用{@link  #afterConcurrentHandlingStarted}，以允许实现在将线程释放到Servlet容器之前执行诸如清理线程绑定属性之类的任务。 
 *  <p>异步处理完成后，请求将分派到容器中进行进一步处理。 
 * 在此阶段，{<@code> DispatcherServlet}调用{@code  preHandle}，{<@code> postHandle}和{@code  afterCompletion}。 
 * 为了在异步处理完成之后区分初始请求和后续调度，拦截器可以检查{@link  javax.servlet.ServletRequest}的{@code  javax.servlet.DispatcherType}是否为{@code "REQUEST"}或{@code "ASYNC"}。 
 *  <p>请注意，当异步请求超时或因网络错误而完成时，{<@code> HandlerInterceptor}实现可能需要完成工作。 
 * 在这种情况下，Servlet容器不会分派，因此将不会调用{@code  postHandle}和{@code  afterCompletion}方法。 
 * 相反，拦截器可以通过{@link  org.springframework.web.context.request.async.WebAsyncManager WebAsyncManager}上的{@code  registerCallbackInterceptor}和{@code  registerDeferredResultInterceptor}方法进行注册，以跟踪异步请求。 
 * 无论是否开始异步请求，都可以对{@code  preHandle}发出的每个请求进行主动处理。 
 *  @author  Rossen Stoyanchev @自3.2起
 * @see  org.springframework.web.context.request.async.WebAsyncManager 
 * @see  org.springframework.web.context.request.async.CallableProcessingInterceptor 
 * @see  org.springframework .web.context.request.async.DeferredResultProcessingInterceptor
 */
public interface AsyncHandlerInterceptor extends HandlerInterceptor {

	/**
	 * Called instead of {@code postHandle} and {@code afterCompletion}
	 * when the handler is being executed concurrently.
	 * <p>Implementations may use the provided request and response but should
	 * avoid modifying them in ways that would conflict with the concurrent
	 * execution of the handler. A typical use of this method would be to
	 * clean up thread-local variables.
	 * @param request the current request
	 * @param response the current response
	 * @param handler the handler (or {@link HandlerMethod}) that started async
	 * execution, for type and/or instance examination
	 * @throws Exception in case of errors
	 */
	/**
	 * 并发执行处理程序时，调用而不是{@code  postHandle}和{@code  afterCompletion}。 
	 *  <p>实现可以使用所提供的请求和响应，但应避免以与处理程序的并发执行冲突的方式修改它们。 
	 * 此方法的典型用法是清除线程局部变量。 
	 *  
	 * @param 请求当前请求
	 * @param 响应当前响应
	 * @param 处理程序启动异步执行的处理程序（或{@link  HandlerMethod}），用于类型和/或实例检查
	 * @throws 异常如果有错误
	 */
	default void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response,
			Object handler) throws Exception {
	}

}
