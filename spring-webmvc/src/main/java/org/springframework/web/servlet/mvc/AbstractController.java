/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.mvc;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.http.HttpMethod;
import org.springframework.lang.Nullable;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.support.WebContentGenerator;
import org.springframework.web.util.WebUtils;

/**
 * Convenient superclass for controller implementations, using the Template Method
 * design pattern.
 *
 * <p><b>Workflow
 * (<a href="Controller.html#workflow">and that defined by interface</a>):</b><br>
 * <ol>
 * <li>{@link #handleRequest(HttpServletRequest, HttpServletResponse) handleRequest()}
 * will be called by the DispatcherServlet</li>
 * <li>Inspection of supported methods (ServletException if request method
 * is not support)</li>
 * <li>If session is required, try to get it (ServletException if not found)</li>
 * <li>Set caching headers if needed according to the cacheSeconds property</li>
 * <li>Call abstract method
 * {@link #handleRequestInternal(HttpServletRequest, HttpServletResponse) handleRequestInternal()}
 * (optionally synchronizing around the call on the HttpSession),
 * which should be implemented by extending classes to provide actual
 * functionality to return {@link org.springframework.web.servlet.ModelAndView ModelAndView} objects.</li>
 * </ol>
 *
 * <p><b><a name="config">Exposed configuration properties</a>
 * (<a href="Controller.html#config">and those defined by interface</a>):</b><br>
 * <table border="1">
 * <tr>
 * <td><b>name</b></td>
 * <td><b>default</b></td>
 * <td><b>description</b></td>
 * </tr>
 * <tr>
 * <td>supportedMethods</td>
 * <td>GET,POST</td>
 * <td>comma-separated (CSV) list of methods supported by this controller,
 * such as GET, POST and PUT</td>
 * </tr>
 * <tr>
 * <td>requireSession</td>
 * <td>false</td>
 * <td>whether a session should be required for requests to be able to
 * be handled by this controller. This ensures that derived controller
 * can - without fear of null pointers - call request.getSession() to
 * retrieve a session. If no session can be found while processing
 * the request, a ServletException will be thrown</td>
 * </tr>
 * <tr>
 * <td>cacheSeconds</td>
 * <td>-1</td>
 * <td>indicates the amount of seconds to include in the cache header
 * for the response following on this request. 0 (zero) will include
 * headers for no caching at all, -1 (the default) will not generate
 * <i>any headers</i> and any positive number will generate headers
 * that state the amount indicated as seconds to cache the content</td>
 * </tr>
 * <tr>
 * <td>synchronizeOnSession</td>
 * <td>false</td>
 * <td>whether the call to {@code handleRequestInternal} should be
 * synchronized around the HttpSession, to serialize invocations
 * from the same client. No effect if there is no HttpSession.
 * </td>
 * </tr>
 * </table>
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rossen Stoyanchev
 * @see WebContentInterceptor
 */
/**
 * 使用模板方法设计模式的控制器实现的便利超类。 
 *  <p> <b>工作流程（<a href="Controller.html#workflow">以及由接口定义的工作流程</a>）：</ b> <br> <ol> <li> {<@link>＃ DispatcherServlet将调用handleRequest（HttpServletRequest，HttpServletResponse）handleRequest（）} </ li> <li>检查受支持的方法（如果不支持请求方法，则为ServletException）</ li> <li>如果需要会话，请尝试得到它（如果找不到ServletException）</ li> <li>根据需要根据cacheSeconds属性设置缓存头</ li> <li>调用抽象方法{@link  #handleRequestInternal（HttpServletRequest，HttpServletResponse）handleRequestInternal（） }（可选地围绕HttpSession的调用进行同步），这应该通过扩展类来实现，以提供返回{@link  org.springframework.web.servlet.ModelAndView ModelAndView}对象的实际功能。 
 * </ li> </ ol > <p> <b> <a name="config">公开的配置属性</a>（<a href="Controller.html#config">以及由接口定义的属性</a>）：</ b> <br> <表格边框= "1"> <tr> <td> <b>名称</ b> </ td> <td> <b>默认</ b> </ td> <td> <b>说明</ b> </ td> </ tr> <tr> <td> supportedMethods </ td> <td> GET，POST </ td> <td>此控制器支持的方法（CSV）列表，例如GET，POST和PUT </ td> </ tr> <tr> <td> requireSession </ td> <td> false </ td> <td>是否需要会话才能使该控制器处理请求。 
 * 这确保派生的控制器可以-不用担心空指针-调用request.getSession（）来检索会话。 
 * 如果在处理请求时找不到会话，则将抛出ServletException </ td> </ tr> <tr> <td> cacheSeconds </ td> <td> -1 </ td> <td>表示数量此请求后响应的秒数（包括在缓存头中）。 
 *  0（零）将包含用于完全不进行缓存的标头，-1（默认值）将不生成<i>任何标头</ i>，并且任何正数将生成标明以秒为单位的标头，用于缓存内容< / td> </ tr> <tr> <td> synchronizeOnSession </ td> <td> false </ td> <td>是否应围绕HttpSession同步对{@code  handleRequestInternal}的调用，以序列化调用来自同一客户。 
 * 如果没有HttpSession，则无效。 
 *  </ td> </ tr> </ table> @author  Rod Johnson @author  Juergen Hoeller @author  Rossen Stoyanchev 
 * @see  WebContentInterceptor
 */
public abstract class AbstractController extends WebContentGenerator implements Controller {

	private boolean synchronizeOnSession = false;


	/**
	 * Create a new AbstractController which supports
	 * HTTP methods GET, HEAD and POST by default.
	 */
	/**
	 * 创建一个默认支持HTTP方法GET，HEAD和POST的新AbstractController。 
	 * 
	 */
	public AbstractController() {
		this(true);
	}

	/**
	 * Create a new AbstractController.
	 * @param restrictDefaultSupportedMethods {@code true} if this
	 * controller should support HTTP methods GET, HEAD and POST by default,
	 * or {@code false} if it should be unrestricted
	 * @since 4.3
	 */
	/**
	 * 创建一个新的AbstractController。 
	 *  
	 * @param  strictDefaultSupportedMethods {@code  true}（如果此控制器默认情况下应支持HTTP方法GET，HEAD和POST），或者{@code  false}（如果不受限制）（自4.3起）
	 */
	public AbstractController(boolean restrictDefaultSupportedMethods) {
		super(restrictDefaultSupportedMethods);
	}


	/**
	 * Set if controller execution should be synchronized on the session,
	 * to serialize parallel invocations from the same client.
	 * <p>More specifically, the execution of the {@code handleRequestInternal}
	 * method will get synchronized if this flag is "true". The best available
	 * session mutex will be used for the synchronization; ideally, this will
	 * be a mutex exposed by HttpSessionMutexListener.
	 * <p>The session mutex is guaranteed to be the same object during
	 * the entire lifetime of the session, available under the key defined
	 * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a
	 * safe reference to synchronize on for locking on the current session.
	 * <p>In many cases, the HttpSession reference itself is a safe mutex
	 * as well, since it will always be the same object reference for the
	 * same active logical session. However, this is not guaranteed across
	 * different servlet containers; the only 100% safe way is a session mutex.
	 * @see AbstractController#handleRequestInternal
	 * @see org.springframework.web.util.HttpSessionMutexListener
	 * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)
	 */
	/**
	 * 设置是否应在会话上同步控制器执行，以序列化来自同一客户端的并行调用。 
	 *  <p>更具体地说，如果此标志为"true"，则{@code  handleRequestInternal}方法的执行将同步。 
	 * 最佳的会话互斥量将用于同步； 
	 * 理想情况下，这将是HttpSessionMutexListener公开的互斥量。 
	 *  <p>在会话的整个生命周期中，保证会话互斥体是同一对象，可以在{@code  SESSION_MUTEX_ATTRIBUTE}常量定义的键下使用。 
	 * 它用作同步以锁定当前会话的安全参考。 
	 *  <p>在许多情况下，HttpSession引用本身也是安全的互斥体，因为对于同一活动的逻辑会话，它始终是相同的对象引用。 
	 * 但是，不能保证在不同的servlet容器之间都能做到这一点。 
	 * 唯一的100％安全方法是会话互斥。 
	 *  
	 * @see  AbstractController＃handleRequestInternal 
	 * @see  org.springframework.web.util.HttpSessionMutexListener 
	 * @see  org.springframework.web.util.WebUtils＃getSessionMutex（javax.servlet.http.HttpSession）
	 */
	public final void setSynchronizeOnSession(boolean synchronizeOnSession) {
		this.synchronizeOnSession = synchronizeOnSession;
	}

	/**
	 * Return whether controller execution should be synchronized on the session.
	 */
	/**
	 * 返回是否应在会话上同步控制器执行。 
	 * 
	 */
	public final boolean isSynchronizeOnSession() {
		return this.synchronizeOnSession;
	}


	@Override
	@Nullable
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)
			throws Exception {

		if (HttpMethod.OPTIONS.matches(request.getMethod())) {
			response.setHeader("Allow", getAllowHeader());
			return null;
		}

		// Delegate to WebContentGenerator for checking and preparing.
		checkRequest(request);
		prepareResponse(response);

		// Execute handleRequestInternal in synchronized block if required.
		if (this.synchronizeOnSession) {
			HttpSession session = request.getSession(false);
			if (session != null) {
				Object mutex = WebUtils.getSessionMutex(session);
				synchronized (mutex) {
					return handleRequestInternal(request, response);
				}
			}
		}

		return handleRequestInternal(request, response);
	}

	/**
	 * Template method. Subclasses must implement this.
	 * The contract is the same as for {@code handleRequest}.
	 * @see #handleRequest
	 */
	/**
	 * 模板方法。 
	 * 子类必须实现这一点。 
	 * 该合同与{@code  handleRequest}的合同相同。 
	 *  
	 * @see  #handleRequest
	 */
	@Nullable
	protected abstract ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)
			throws Exception;

}
