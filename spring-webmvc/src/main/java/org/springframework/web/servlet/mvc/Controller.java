/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2016的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.mvc;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.web.servlet.ModelAndView;

/**
 * Base Controller interface, representing a component that receives
 * {@code HttpServletRequest} and {@code HttpServletResponse}
 * instances just like a {@code HttpServlet} but is able to
 * participate in an MVC workflow. Controllers are comparable to the
 * notion of a Struts {@code Action}.
 *
 * <p>Any implementation of the Controller interface should be a
 * <i>reusable, thread-safe</i> class, capable of handling multiple
 * HTTP requests throughout the lifecycle of an application. To be able to
 * configure a Controller easily, Controller implementations are encouraged
 * to be (and usually are) JavaBeans.
 *
 * <h3><a name="workflow">Workflow</a></h3>
 *
 * <p>After a {@code DispatcherServlet} has received a request and has
 * done its work to resolve locales, themes, and suchlike, it then tries
 * to resolve a Controller, using a
 * {@link org.springframework.web.servlet.HandlerMapping HandlerMapping}.
 * When a Controller has been found to handle the request, the
 * {@link #handleRequest(HttpServletRequest, HttpServletResponse) handleRequest}
 * method of the located Controller will be invoked; the located Controller
 * is then responsible for handling the actual request and &mdash; if applicable
 * &mdash; returning an appropriate
 * {@link org.springframework.web.servlet.ModelAndView ModelAndView}.
 * So actually, this method is the main entry point for the
 * {@link org.springframework.web.servlet.DispatcherServlet DispatcherServlet}
 * which delegates requests to controllers.
 *
 * <p>So basically any <i>direct</i> implementation of the {@code Controller} interface
 * just handles HttpServletRequests and should return a ModelAndView, to be further
 * interpreted by the DispatcherServlet. Any additional functionality such as
 * optional validation, form handling, etc. should be obtained through extending
 * {@link org.springframework.web.servlet.mvc.AbstractController AbstractController}
 * or one of its subclasses.
 *
 * <h3>Notes on design and testing</h3>
 *
 * <p>The Controller interface is explicitly designed to operate on HttpServletRequest
 * and HttpServletResponse objects, just like an HttpServlet. It does not aim to
 * decouple itself from the Servlet API, in contrast to, for example, WebWork, JSF or Tapestry.
 * Instead, the full power of the Servlet API is available, allowing Controllers to be
 * general-purpose: a Controller is able to not only handle web user interface
 * requests but also to process remoting protocols or to generate reports on demand.
 *
 * <p>Controllers can easily be tested by passing in mock objects for the
 * HttpServletRequest and HttpServletResponse objects as parameters to the
 * {@link #handleRequest(HttpServletRequest, HttpServletResponse) handleRequest}
 * method. As a convenience, Spring ships with a set of Servlet API mocks
 * that are suitable for testing any kind of web components, but are particularly
 * suitable for testing Spring web controllers. In contrast to a Struts Action,
 * there is no need to mock the ActionServlet or any other infrastructure;
 * mocking HttpServletRequest and HttpServletResponse is sufficient.
 *
 * <p>If Controllers need to be aware of specific environment references, they can
 * choose to implement specific awareness interfaces, just like any other bean in a
 * Spring (web) application context can do, for example:
 * <ul>
 * <li>{@code org.springframework.context.ApplicationContextAware}</li>
 * <li>{@code org.springframework.context.ResourceLoaderAware}</li>
 * <li>{@code org.springframework.web.context.ServletContextAware}</li>
 * </ul>
 *
 * <p>Such environment references can easily be passed in testing environments,
 * through the corresponding setters defined in the respective awareness interfaces.
 * In general, it is recommended to keep the dependencies as minimal as possible:
 * for example, if all you need is resource loading, implement ResourceLoaderAware only.
 * Alternatively, derive from the WebApplicationObjectSupport base class, which gives
 * you all those references through convenient accessors but requires an
 * ApplicationContext reference on initialization.
 *
 * <p>Controllers can optionally implement the {@link LastModified} interface.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see LastModified
 * @see SimpleControllerHandlerAdapter
 * @see AbstractController
 * @see org.springframework.web.testfixture.servlet.MockHttpServletRequest
 * @see org.springframework.web.testfixture.servlet.MockHttpServletResponse
 * @see org.springframework.context.ApplicationContextAware
 * @see org.springframework.context.ResourceLoaderAware
 * @see org.springframework.web.context.ServletContextAware
 * @see org.springframework.web.context.support.WebApplicationObjectSupport
 */
/**
 * 基本控制器接口，代表一个组件，该组件像{@code  HttpServlet}一样接收{@code  HttpServletRequest}和{@code  HttpServletResponse}实例，但能够参与MVC工作流程。 
 * 控制器类似于Struts {@code  Action}的概念。 
 *  <p> Controller接口的任何实现均应为<i>可重用，线程安全的</ i>类，该类能够在应用程序的整个生命周期中处理多个HTTP请求。 
 * 为了能够轻松配置Controller，鼓励Controller实现为（通常是JavaBean）。 
 *  <h3> <a name="workflow">工作流程</a> </ h3> <p>在{@code  DispatcherServlet}收到请求并完成其工作以解决语言环境，主题等之后，然后，它尝试使用{@link  org.springframework.web.servlet.HandlerMapping HandlerMapping}解析控制器。 
 * 当找到一个Controller处理请求时，将调用所定位Controller的{@link  #handleRequest（HttpServletRequest，HttpServletResponse）handleRequest}方法； 
 * 然后，所定位的Controller负责处理实际请求，并在适用时返回适当的{@link  org.springframework.web.servlet.ModelAndView ModelAndView}。 
 * 因此，实际上，此方法是{@link  org.springframework.web.servlet.DispatcherServlet DispatcherServlet}的主要入口点，该请求将请求委托给控制器。 
 *  <p>因此，基本上{{@code> Controller}接口的任何<i> direct </ i>实现都只处理HttpServletRequests并应返回ModelAndView，由DispatcherServlet进一步解释。 
 * 任何其他功能，例如可选验证，表单处理等，都应通过扩展{@link  org.springframework.web.servlet.mvc.AbstractController AbstractController}或其子类之一来获得。 
 *  <h3>有关设计和测试的注意事项</ h3> <p> Controller接口已明确设计为可对HttpServletRequest和HttpServletResponse对象进行操作，就像HttpServlet一样。 
 * 与例如WebWork，JSF或Tapestry相比，它并不旨在使其自身与Servlet API脱钩。 
 * 取而代之的是，Servlet API的全部功能可用，从而使Controllers成为通用用途：Controller不仅能够处理Web用户界面请求，而且能够处理远程协议或按需生成报告。 
 *  <p>通过将HttpServletRequest和HttpServletResponse对象的模拟对象作为参数传递给{@link  #handleRequest（HttpServletRequest，HttpServletResponse）handleRequest}方法，可以轻松测试控制器。 
 * 为了方便起见，Spring附带了一组Servlet API模拟，这些模拟适用于测试任何种类的Web组件，但是特别适合于测试Spring Web控制器。 
 * 与Struts Action相比，不需要模拟ActionServlet或任何其他基础结构。 
 * 模拟HttpServletRequest和HttpServletResponse就足够了。 
 *  <p>如果控制器需要了解特定的环境引用，则可以选择实现特定的感知接口，就像Spring（web）应用程序上下文中的任何其他bean一样，例如：<ul> <li> {@code  org.springframework.context.ApplicationContextAware} </ li> <li> {<@code> org.springframework.context.ResourceLoaderAware} </ li> <li> {<@code> org.springframework.web.context .ServletContextAware} </ li> </ ul> <p>可以通过在相应的感知接口中定义的相应设置器，轻松地在测试环境中传递此类环境引用。 
 * 通常，建议使依赖关系尽可能地小：例如，如果您只需要资源加载，则仅实现ResourceLoaderAware。 
 * 或者，从WebApplicationObjectSupport基类派生，该基类通过便捷的访问器为您提供所有这些引用，但在初始化时需要ApplicationContext引用。 
 *  <p>控制器可以选择实现{@link  LastModified}接口。 
 *  @author  Rod Johnson @author  Juergen Hoeller 
 * @see  LastModified 
 * @see  SimpleControllerHandlerAdapter 
 * @see  AbstractController 
 * @see  org.springframework.web.testfixture.servlet.MockHttpServletRequest 
 * @see  org.springframework。 
 *  web.testfixture.servlet.MockHttpServletResponse 
 * @see  org.springframework.context.ApplicationContextAware 
 * @see  org.springframework.context.ResourceLoaderAware 
 * @see  org.springframework.web.context.ServletContextAware 
 * @see  org.springframework。 
 *  web.context.support.WebApplicationObjectSupport
 */
@FunctionalInterface
public interface Controller {

	/**
	 * Process the request and return a ModelAndView object which the DispatcherServlet
	 * will render. A {@code null} return value is not an error: it indicates that
	 * this object completed request processing itself and that there is therefore no
	 * ModelAndView to render.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @return a ModelAndView to render, or {@code null} if handled directly
	 * @throws Exception in case of errors
	 */
	/**
	 * 处理请求并返回DispatcherServlet将呈现的ModelAndView对象。 
	 *  {@code  null}的返回值不是错误：它表示此对象已完成请求本身的处理，因此没有要渲染的ModelAndView。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 响应当前HTTP响应
	 * @return 要渲染的ModelAndView，如果直接处理，则返回{@code  null} 
	 * @throws 错误时发生异常
	 */
	@Nullable
	ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;

}
