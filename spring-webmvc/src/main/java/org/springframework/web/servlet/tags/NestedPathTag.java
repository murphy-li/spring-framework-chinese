/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.tags;

import javax.servlet.jsp.JspException;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.TagSupport;
import javax.servlet.jsp.tagext.TryCatchFinally;

import org.springframework.beans.PropertyAccessor;
import org.springframework.lang.Nullable;

/**
 * <p>The {@code <nestedPath>} tag supports and assists with nested beans or
 * bean properties in the model. Exports a "nestedPath" variable of type String
 * in request scope, visible to the current page and also included pages, if any.
 *
 * <p>The BindTag will auto-detect the current nested path and automatically
 * prepend it to its own path to form a complete path to the bean or bean property.
 *
 * <p>This tag will also prepend any existing nested path that is currently set.
 * Thus, you can nest multiple nested-path tags.
 *
 * <table>
 * <caption>Attribute Summary</caption>
 * <thead>
 * <tr>
 * <th>Attribute</th>
 * <th>Required?</th>
 * <th>Runtime Expression?</th>
 * <th>Description</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>path</td>
 * <td>true</td>
 * <td>true</td>
 * <td>Set the path that this tag should apply. E.g. 'customer' to allow bind
 * paths like 'address.street' rather than 'customer.address.street'.</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * @author Juergen Hoeller
 * @since 1.1
 */
/**
 * <p> {<@code> <nestedPath>}标签支持并协助模型中的嵌套bean或bean属性。 
 * 在请求范围内导出字符串类型的"nestedPath"变量，该变量对当前页面以及包括的页面（如果有）可见。 
 *  <p> BindTag将自动检测当前的嵌套路径，并将其自动添加到自己的路径前，以形成bean或bean属性的完整路径。 
 *  <p>此标记还将在当前设置的所有现有嵌套路径之前添加前缀。 
 * 因此，您可以嵌套多个嵌套路径标签。 
 *  <table> <caption>属性摘要</ caption> <thead> <tr> <th>属性</ th> <th>是否必需？</ th> <th>运行时表达式？</ th> <th>描述< / th> </ tr> </ thead> <tbody> <tr> <td> path </ td> <td> true </ td> <td> true </ td> <td>设置此标记的路径应该适用。 
 * 例如。 
 *  'customer'允许绑定路径，例如'address.street'，而不是'customer.address.street'。 
 * </ td> </ tr> </ tbody> </ table> @author  Juergen Hoeller @since 1.1
 */
@SuppressWarnings("serial")
public class NestedPathTag extends TagSupport implements TryCatchFinally {

	/**
	 * Name of the exposed variable within the scope of this tag: "nestedPath".
	 */
	/**
	 * 在此标签范围内的公开变量的名称："nestedPath"。 
	 * 
	 */
	public static final String NESTED_PATH_VARIABLE_NAME = "nestedPath";


	@Nullable
	private String path;

	/** Caching a previous nested path, so that it may be reset. */
	/**
	 * 缓存先前的嵌套路径，以便将其重置。 
	 * 
	 */
	@Nullable
	private String previousNestedPath;


	/**
	 * Set the path that this tag should apply.
	 * <p>E.g. "customer" to allow bind paths like "address.street"
	 * rather than "customer.address.street".
	 * @see BindTag#setPath
	 */
	/**
	 * 设置此标签应应用的路径。 
	 *  <p>例如"客户"以允许绑定路径，例如"address.street"，而不是"customer.address.street"。 
	 *  
	 * @see  BindTag＃setPath
	 */
	public void setPath(@Nullable String path) {
		if (path == null) {
			path = "";
		}
		if (path.length() > 0 && !path.endsWith(PropertyAccessor.NESTED_PROPERTY_SEPARATOR)) {
			path += PropertyAccessor.NESTED_PROPERTY_SEPARATOR;
		}
		this.path = path;
	}

	/**
	 * Return the path that this tag applies to.
	 */
	/**
	 * 返回此标签适用的路径。 
	 * 
	 */
	@Nullable
	public String getPath() {
		return this.path;
	}


	@Override
	public int doStartTag() throws JspException {
		// Save previous nestedPath value, build and expose current nestedPath value.
		// Use request scope to expose nestedPath to included pages too.
		this.previousNestedPath =
				(String) this.pageContext.getAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);
		String nestedPath =
				(this.previousNestedPath != null ? this.previousNestedPath + getPath() : getPath());
		this.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME, nestedPath, PageContext.REQUEST_SCOPE);

		return EVAL_BODY_INCLUDE;
	}

	/**
	 * Reset any previous nestedPath value.
	 */
	/**
	 * 重置任何以前的nestedPath值。 
	 * 
	 */
	@Override
	public int doEndTag() {
		if (this.previousNestedPath != null) {
			// Expose previous nestedPath value.
			this.pageContext.setAttribute(NESTED_PATH_VARIABLE_NAME, this.previousNestedPath, PageContext.REQUEST_SCOPE);
		}
		else {
			// Remove exposed nestedPath value.
			this.pageContext.removeAttribute(NESTED_PATH_VARIABLE_NAME, PageContext.REQUEST_SCOPE);
		}

		return EVAL_PAGE;
	}

	@Override
	public void doCatch(Throwable throwable) throws Throwable {
		throw throwable;
	}

	@Override
	public void doFinally() {
		this.previousNestedPath = null;
	}

}
