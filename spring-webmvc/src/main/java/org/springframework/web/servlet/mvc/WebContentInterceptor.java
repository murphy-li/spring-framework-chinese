/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.mvc;

import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.CacheControl;
import org.springframework.lang.Nullable;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.PathMatcher;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.support.WebContentGenerator;
import org.springframework.web.util.UrlPathHelper;

/**
 * Handler interceptor that checks the request and prepares the response.
 * Checks for supported methods and a required session, and applies the
 * specified {@link org.springframework.http.CacheControl} builder.
 * See superclass bean properties for configuration options.
 *
 * <p>All the settings supported by this interceptor can also be set on
 * {@link AbstractController}. This interceptor is mainly intended for applying
 * checks and preparations to a set of controllers mapped by a HandlerMapping.
 *
 * @author Juergen Hoeller
 * @author Brian Clozel
 * @since 27.11.2003
 * @see AbstractController
 */
/**
 * 处理程序拦截器，用于检查请求并准备响应。 
 * 检查受支持的方法和所需的会话，并应用指定的{@link  org.springframework.http.CacheControl}构建器。 
 * 有关配置选项，请参见超类bean属性。 
 *  <p>此拦截器支持的所有设置也可以在{@link  AbstractController}上进行设置。 
 * 该拦截器主要用于将检查和准备应用于由HandlerMapping映射的一组控制器。 
 *  @author  Juergen Hoeller @author 布莱恩·克洛泽尔​​（Brian Clozel）@2003年11月27日起
 * @see  AbstractController
 */
public class WebContentInterceptor extends WebContentGenerator implements HandlerInterceptor {

	private UrlPathHelper urlPathHelper = new UrlPathHelper();

	private PathMatcher pathMatcher = new AntPathMatcher();

	private Map<String, Integer> cacheMappings = new HashMap<>();

	private Map<String, CacheControl> cacheControlMappings = new HashMap<>();


	public WebContentInterceptor() {
		// No restriction of HTTP methods by default,
		// in particular for use with annotated controllers...
		super(false);
	}


	/**
	 * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.
	 * <p>Only relevant for the "cacheMappings" setting.
	 * @see #setCacheMappings
	 * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath
	 */
	/**
	 * 基础{@link  #setUrlPathHelper UrlPathHelper}上相同属性的快捷方式。 
	 *  <p>仅与"cacheMappings"设置相关。 
	 *  
	 * @see  #setCacheMappings 
	 * @see  org.springframework.web.util.UrlPathHelper＃setAlwaysUseFullPath
	 */
	public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
		this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);
	}

	/**
	 * Shortcut to same property on underlying {@link #setUrlPathHelper UrlPathHelper}.
	 * <p>Only relevant for the "cacheMappings" setting.
	 * @see #setCacheMappings
	 * @see org.springframework.web.util.UrlPathHelper#setUrlDecode
	 */
	/**
	 * 基础{@link  #setUrlPathHelper UrlPathHelper}上相同属性的快捷方式。 
	 *  <p>仅与"cacheMappings"设置相关。 
	 *  
	 * @see  #setCacheMappings 
	 * @see  org.springframework.web.util.UrlPathHelper＃setUrlDecode
	 */
	public void setUrlDecode(boolean urlDecode) {
		this.urlPathHelper.setUrlDecode(urlDecode);
	}

	/**
	 * Set the UrlPathHelper to use for resolution of lookup paths.
	 * <p>Use this to override the default UrlPathHelper with a custom subclass,
	 * or to share common UrlPathHelper settings across multiple HandlerMappings
	 * and MethodNameResolvers.
	 * <p>Only relevant for the "cacheMappings" setting.
	 * @see #setCacheMappings
	 * @see org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#setUrlPathHelper
	 */
	/**
	 * 设置UrlPathHelper以用于解析查找路径。 
	 *  <p>使用它使用自定义子类覆盖默认的UrlPathHelper，或在多个HandlerMappings和MethodNameResolvers之间共享通用的UrlPathHelper设置。 
	 *  <p>仅与"cacheMappings"设置相关。 
	 *  
	 * @see  #setCacheMappings 
	 * @see  org.springframework.web.servlet.handler.AbstractUrlHandlerMapping＃setUrlPathHelper
	 */
	public void setUrlPathHelper(UrlPathHelper urlPathHelper) {
		Assert.notNull(urlPathHelper, "UrlPathHelper must not be null");
		this.urlPathHelper = urlPathHelper;
	}

	/**
	 * Map specific URL paths to specific cache seconds.
	 * <p>Overrides the default cache seconds setting of this interceptor.
	 * Can specify "-1" to exclude a URL path from default caching.
	 * <p>Supports direct matches, e.g. a registered "/test" matches "/test",
	 * and a various Ant-style pattern matches, e.g. a registered "/t*" matches
	 * both "/test" and "/team". For details, see the AntPathMatcher javadoc.
	 * <p><b>NOTE:</b> Path patterns are not supposed to overlap. If a request
	 * matches several mappings, it is effectively undefined which one will apply
	 * (due to the lack of key ordering in {@code java.util.Properties}).
	 * @param cacheMappings a mapping between URL paths (as keys) and
	 * cache seconds (as values, need to be integer-parsable)
	 * @see #setCacheSeconds
	 * @see org.springframework.util.AntPathMatcher
	 */
	/**
	 * 将特定的URL路径映射到特定的缓存秒数。 
	 *  <p>重写此拦截器的默认高速缓存秒设置。 
	 * 可以指定"-1"以从默认缓存中排除URL路径。 
	 *  <p>支持直接匹配，例如已注册的"/ test"匹配"/ test"，而各种Ant样式的模式匹配，例如注册的"/ t"匹配"/ test"和"/ team"。 
	 * 有关详细信息，请参见AntPathMatcher javadoc。 
	 *  <p> <b>注意：</ b>路径模式不应该重叠。 
	 * 如果一个请求匹配多个映射，则实际上是不确定要应用哪个映射（由于{@code  java.util.Properties}中缺少键顺序）。 
	 *  
	 * @param  cacheMapping URL路径（作为键）和缓存秒（作为值，需要是整数可解析）之间的映射
	 * @see  #setCacheSeconds 
	 * @see  org.springframework.util.AntPathMatcher
	 */
	public void setCacheMappings(Properties cacheMappings) {
		this.cacheMappings.clear();
		Enumeration<?> propNames = cacheMappings.propertyNames();
		while (propNames.hasMoreElements()) {
			String path = (String) propNames.nextElement();
			int cacheSeconds = Integer.parseInt(cacheMappings.getProperty(path));
			this.cacheMappings.put(path, cacheSeconds);
		}
	}

	/**
	 * Map specific URL paths to a specific {@link org.springframework.http.CacheControl}.
	 * <p>Overrides the default cache seconds setting of this interceptor.
	 * Can specify a empty {@link org.springframework.http.CacheControl} instance
	 * to exclude a URL path from default caching.
	 * <p>Supports direct matches, e.g. a registered "/test" matches "/test",
	 * and a various Ant-style pattern matches, e.g. a registered "/t*" matches
	 * both "/test" and "/team". For details, see the AntPathMatcher javadoc.
	 * <p><b>NOTE:</b> Path patterns are not supposed to overlap. If a request
	 * matches several mappings, it is effectively undefined which one will apply
	 * (due to the lack of key ordering in the underlying {@code java.util.HashMap}).
	 * @param cacheControl the {@code CacheControl} to use
	 * @param paths the URL paths that will map to the given {@code CacheControl}
	 * @since 4.2
	 * @see #setCacheSeconds
	 * @see org.springframework.util.AntPathMatcher
	 */
	/**
	 * 将特定的URL路径映射到特定的{@link  org.springframework.http.CacheControl}。 
	 *  <p>重写此拦截器的默认高速缓存秒设置。 
	 * 可以指定一个空的{@link  org.springframework.http.CacheControl}实例，以从默认缓存中排除URL路径。 
	 *  <p>支持直接匹配，例如已注册的"/ test"匹配"/ test"，而各种Ant样式的模式匹配，例如注册的"/ t"匹配"/ test"和"/ team"。 
	 * 有关详细信息，请参见AntPathMatcher javadoc。 
	 *  <p> <b>注意：</ b>路径模式不应该重叠。 
	 * 如果一个请求匹配多个映射，则实际上是不确定要应用哪个映射（由于基础{@code  java.util.HashMap}中缺少键顺序）。 
	 *  
	 * @param  cacheControl {@code  CacheControl}使用
	 * @param 路径，URL路径将映射到给定的{@code  CacheControl}，从4.2开始。 
	 * 
	 * @see  #setCacheSeconds 
	 * @see  org .springframework.util.AntPathMatcher
	 */
	public void addCacheMapping(CacheControl cacheControl, String... paths) {
		for (String path : paths) {
			this.cacheControlMappings.put(path, cacheControl);
		}
	}

	/**
	 * Set the PathMatcher implementation to use for matching URL paths
	 * against registered URL patterns, for determining cache mappings.
	 * Default is AntPathMatcher.
	 * @see #addCacheMapping
	 * @see #setCacheMappings
	 * @see org.springframework.util.AntPathMatcher
	 */
	/**
	 * 设置PathMatcher实现，以将URL路径与已注册的URL模式进行匹配，以确定缓存映射。 
	 * 默认值为AntPathMatcher。 
	 *  
	 * @see  #addCacheMapping 
	 * @see  #setCacheMappings 
	 * @see  org.springframework.util.AntPathMatcher
	 */
	public void setPathMatcher(PathMatcher pathMatcher) {
		Assert.notNull(pathMatcher, "PathMatcher must not be null");
		this.pathMatcher = pathMatcher;
	}


	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws ServletException {

		checkRequest(request);

		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request, HandlerMapping.LOOKUP_PATH);

		CacheControl cacheControl = lookupCacheControl(lookupPath);
		Integer cacheSeconds = lookupCacheSeconds(lookupPath);
		if (cacheControl != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Applying " + cacheControl);
			}
			applyCacheControl(response, cacheControl);
		}
		else if (cacheSeconds != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Applying cacheSeconds " + cacheSeconds);
			}
			applyCacheSeconds(response, cacheSeconds);
		}
		else {
			if (logger.isTraceEnabled()) {
				logger.trace("Applying default cacheSeconds");
			}
			prepareResponse(response);
		}

		return true;
	}

	/**
	 * Look up a {@link org.springframework.http.CacheControl} instance for the given URL path.
	 * <p>Supports direct matches, e.g. a registered "/test" matches "/test",
	 * and various Ant-style pattern matches, e.g. a registered "/t*" matches
	 * both "/test" and "/team". For details, see the AntPathMatcher class.
	 * @param urlPath the URL the bean is mapped to
	 * @return the associated {@code CacheControl}, or {@code null} if not found
	 * @see org.springframework.util.AntPathMatcher
	 */
	/**
	 * 查找给定URL路径的{@link  org.springframework.http.CacheControl}实例。 
	 *  <p>支持直接匹配，例如已注册的"/ test"匹配"/ test"，并且各种Ant样式的模式匹配，例如注册的"/ t"匹配"/ test"和"/ team"。 
	 * 有关详细信息，请参见AntPathMatcher类。 
	 *  
	 * @param  urlPath Bean映射到的URL，<
	 * @return>关联的{@code  CacheControl}，或者{{@@code> null}（如果找不到）
	 * @see  org.springframework.util.AntPathMatcher
	 */
	@Nullable
	protected CacheControl lookupCacheControl(String urlPath) {
		// Direct match?
		CacheControl cacheControl = this.cacheControlMappings.get(urlPath);
		if (cacheControl != null) {
			return cacheControl;
		}
		// Pattern match?
		for (Map.Entry<String, CacheControl> entry : this.cacheControlMappings.entrySet()) {
			if (this.pathMatcher.match(entry.getKey(), urlPath)) {
				return entry.getValue();
			}
		}
		return null;
	}

	/**
	 * Look up a cacheSeconds integer value for the given URL path.
	 * <p>Supports direct matches, e.g. a registered "/test" matches "/test",
	 * and various Ant-style pattern matches, e.g. a registered "/t*" matches
	 * both "/test" and "/team". For details, see the AntPathMatcher class.
	 * @param urlPath the URL the bean is mapped to
	 * @return the cacheSeconds integer value, or {@code null} if not found
	 * @see org.springframework.util.AntPathMatcher
	 */
	/**
	 * 查找给定URL路径的cacheSeconds整数值。 
	 *  <p>支持直接匹配，例如已注册的"/ test"匹配"/ test"，并且各种Ant样式的模式匹配，例如注册的"/ t"匹配"/ test"和"/ team"。 
	 * 有关详细信息，请参见AntPathMatcher类。 
	 *  
	 * @param  urlPath Bean映射到的URL 
	 * @return  cacheSeconds整数值，如果找不到，则返回{@code  null} 
	 * @see  org.springframework.util.AntPathMatcher
	 */
	@Nullable
	protected Integer lookupCacheSeconds(String urlPath) {
		// Direct match?
		Integer cacheSeconds = this.cacheMappings.get(urlPath);
		if (cacheSeconds != null) {
			return cacheSeconds;
		}
		// Pattern match?
		for (Map.Entry<String, Integer> entry : this.cacheMappings.entrySet()) {
			if (this.pathMatcher.match(entry.getKey(), urlPath)) {
				return entry.getValue();
			}
		}
		return null;
	}


	/**
	 * This implementation is empty.
	 */
	/**
	 * 此实现为空。 
	 * 
	 */
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable ModelAndView modelAndView) throws Exception {
	}

	/**
	 * This implementation is empty.
	 */
	/**
	 * 此实现为空。 
	 * 
	 */
	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable Exception ex) throws Exception {
	}

}
