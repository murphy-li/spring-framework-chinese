/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.function;

import java.util.Optional;

/**
 * Represents a function that routes to a {@linkplain HandlerFunction handler function}.
 *
 * @author Arjen Poutsma
 * @since 5.2
 * @param <T> the type of the {@linkplain HandlerFunction handler function} to route to
 * @see RouterFunctions
 */
/**
 * 表示一个路由到{@link  plain HandlerFunction handler function}的函数。 
 *  @author  Arjen Poutsma @自5.2起
 * @param  <T> {@link  plain HandlerFunction handler function}的类型，以路由到
 * @see  RouterFunctions
 */
@FunctionalInterface
public interface RouterFunction<T extends ServerResponse> {

	/**
	 * Return the {@linkplain HandlerFunction handler function} that matches the given request.
	 * @param request the request to route
	 * @return an {@code Optional} describing the {@code HandlerFunction} that matches this request,
	 * or an empty {@code Optional} if there is no match
	 */
	/**
	 * 返回与给定请求匹配的{@link  plain HandlerFunction handler function}。 
	 *  
	 * @param 请求路由
	 * @return 的请求，该请求描述与该请求匹配的{@code  HandlerFunction}的{@code 可选}，如果没有匹配项，则为空的{@code  Optional}
	 */
	Optional<HandlerFunction<T>> route(ServerRequest request);

	/**
	 * Return a composed routing function that first invokes this function,
	 * and then invokes the {@code other} function (of the same response type {@code T})
	 * if this route had {@linkplain Optional#empty() no result}.
	 * @param other the function of type {@code T} to apply when this function has no result
	 * @return a composed function that first routes with this function and then the
	 * {@code other} function if this function has no result
	 * @see #andOther(RouterFunction)
	 */
	/**
	 * 如果此路由具有{@link  plain可选#empty，则返回一个组合的路由函数，该路由函数首先调用此函数，然后调用{@code  other}函数（具有相同的响应类型{@code  T}） （） 没有结果}。 
	 *  
	 * @param 其他类型为{@code  T}的函数，当此函数没有结果时使用。 
	 * 
	 * @return 一个首先使用该函数进行路由的组合函数，然后使用{@code  other}函数进行路由函数没有结果
	 * @see  #andOther（RouterFunction）
	 */
	default RouterFunction<T> and(RouterFunction<T> other) {
		return new RouterFunctions.SameComposedRouterFunction<>(this, other);
	}

	/**
	 * Return a composed routing function that first invokes this function,
	 * and then invokes the {@code other} function (of a different response type) if this route had
	 * {@linkplain Optional#empty() no result}.
	 * @param other the function to apply when this function has no result
	 * @return a composed function that first routes with this function and then the
	 * {@code other} function if this function has no result
	 * @see #and(RouterFunction)
	 */
	/**
	 * 返回一个组合路由函数，该路由函数首先调用此函数，然后在此路由具有{@link  plain Optional＃empty（）no result}的情况下，调用{@code  other}函数（具有不同的响应类型）。 
	 *  
	 * @param 其他在该函数没有结果时要应用的函数
	 * @return 一个组合函数，该函数首先使用该函数进行路由，然后在{@code  other}函数进行路由，如果该函数没有结果
	 * @see ＃和（RouterFunction）
	 */
	default RouterFunction<?> andOther(RouterFunction<?> other) {
		return new RouterFunctions.DifferentComposedRouterFunction(this, other);
	}

	/**
	 * Return a composed routing function that routes to the given handler function if this
	 * route does not match and the given request predicate applies. This method is a convenient
	 * combination of {@link #and(RouterFunction)} and
	 * {@link RouterFunctions#route(RequestPredicate, HandlerFunction)}.
	 * @param predicate the predicate to test if this route does not match
	 * @param handlerFunction the handler function to route to if this route does not match and
	 * the predicate applies
	 * @return a composed function that route to {@code handlerFunction} if this route does not
	 * match and if {@code predicate} applies
	 */
	/**
	 * 如果此路由不匹配且给定的请求谓词适用，则返回一个路由到给定处理程序函数的组合路由函数。 
	 * 此方法是{@link  #and（RouterFunction）}和{@link  RouterFunctions＃route（RequestPredicate，HandlerFunction）}的便捷组合。 
	 *  
	 * @param 谓词以测试此路由是否不匹配谓词
	 * @param  handlerFunction如果此路由不匹配并且谓词应用到路由到{<@code > handlerFunction}（如果此路由不匹配并且适用{@code 谓词}）
	 */
	default RouterFunction<T> andRoute(RequestPredicate predicate, HandlerFunction<T> handlerFunction) {
		return and(RouterFunctions.route(predicate, handlerFunction));
	}

	/**
	 * Return a composed routing function that routes to the given router function if this
	 * route does not match and the given request predicate applies. This method is a convenient
	 * combination of {@link #and(RouterFunction)} and
	 * {@link RouterFunctions#nest(RequestPredicate, RouterFunction)}.
	 * @param predicate the predicate to test if this route does not match
	 * @param routerFunction the router function to route to if this route does not match and
	 * the predicate applies
	 * @return a composed function that route to {@code routerFunction} if this route does not
	 * match and if {@code predicate} applies
	 */
	/**
	 * 如果此路由不匹配并且给定的请求谓词适用，则返回一个路由到给定路由器功能的组合路由功能。 
	 * 此方法是{@link  #and（RouterFunction）}和{@link  RouterFunctions＃nest（RequestPredicate，RouterFunction）}}的便捷组合。 
	 *  
	 * @param 谓词，以测试此路由是否不匹配
	 * @param  router路由器功能，如果此路由不匹配，并且谓词应用到路由，则要路由到该路由的{<@code > routerFunction}（如果此路由不匹配并且适用{@code 谓词}）
	 */
	default RouterFunction<T> andNest(RequestPredicate predicate, RouterFunction<T> routerFunction) {
		return and(RouterFunctions.nest(predicate, routerFunction));
	}

	/**
	 * Filter all {@linkplain HandlerFunction handler functions} routed by this function with the given
	 * {@linkplain HandlerFilterFunction filter function}.
	 * @param <S> the filter return type
	 * @param filterFunction the filter to apply
	 * @return the filtered routing function
	 */
	/**
	 * 使用给定的{@link  plain HandlerFilterFunction过滤器函数}过滤由该函数路由的所有{@link  plain HandlerFunction处理器函数}。 
	 *  
	 * @param  <S>过滤器返回类型
	 * @param  filterFunction过滤器应用
	 * @return 过滤后的路由功能
	 */
	default <S extends ServerResponse> RouterFunction<S> filter(HandlerFilterFunction<T, S> filterFunction) {
		return new RouterFunctions.FilteredRouterFunction<>(this, filterFunction);
	}

	/**
	 * Accept the given visitor. Default implementation calls
	 * {@link RouterFunctions.Visitor#unknown(RouterFunction)}; composed {@code RouterFunction}
	 * implementations are expected to call {@code accept} for all components that make up this
	 * router function.
	 * @param visitor the visitor to accept
	 */
	/**
	 * 接受给定的访客。 
	 * 默认实现调用{@link  RouterFunctions.Visitor＃unknown（RouterFunction）}； 
	 * 组成{@code  RouterFunction}的实现，应该对构成此路由器功能的所有组件调用{@code  accept}。 
	 *  
	 * @param 访客访客接受
	 */
	default void accept(RouterFunctions.Visitor visitor) {
		visitor.unknown(this);
	}
}
