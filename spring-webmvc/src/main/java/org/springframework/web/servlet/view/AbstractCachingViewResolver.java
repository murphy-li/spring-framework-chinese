/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.view;

import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.web.context.support.WebApplicationObjectSupport;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;

/**
 * Convenient base class for {@link org.springframework.web.servlet.ViewResolver}
 * implementations. Caches {@link org.springframework.web.servlet.View} objects
 * once resolved: This means that view resolution won't be a performance problem,
 * no matter how costly initial view retrieval is.
 *
 * <p>Subclasses need to implement the {@link #loadView} template method,
 * building the View object for a specific view name and locale.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see #loadView
 */
/**
 * {@link  org.springframework.web.servlet.ViewResolver}实现的便捷基类。 
 * 缓存{@link  org.springframework.web.servlet.View}对象一旦解决：这意味着无论初始视图检索的成本如何，视图分辨率都不会成为性能问题。 
 *  <p>子类需要实现{@link  #loadView}模板方法，为特定的视图名称和区域设置构建View对象。 
 *  @author 罗德·约翰逊@author  Juergen Hoeller 
 * @see  #loadView
 */
public abstract class AbstractCachingViewResolver extends WebApplicationObjectSupport implements ViewResolver {

	/** Default maximum number of entries for the view cache: 1024. */
	/**
	 * 视图缓存的默认最大条目数：1024。 
	 * 
	 */
	public static final int DEFAULT_CACHE_LIMIT = 1024;

	/** Dummy marker object for unresolved views in the cache Maps. */
	/**
	 * 虚拟标记对象，用于缓存映射中的未解析视图。 
	 * 
	 */
	private static final View UNRESOLVED_VIEW = new View() {
		@Override
		@Nullable
		public String getContentType() {
			return null;
		}
		@Override
		public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {
		}
	};

	/** Default cache filter that always caches. */
	/**
	 * 始终缓存的默认缓存过滤器。 
	 * 
	 */
	private static final CacheFilter DEFAULT_CACHE_FILTER = (view, viewName, locale) -> true;


	/** The maximum number of entries in the cache. */
	/**
	 * 高速缓存中的最大条目数。 
	 * 
	 */
	private volatile int cacheLimit = DEFAULT_CACHE_LIMIT;

	/** Whether we should refrain from resolving views again if unresolved once. */
	/**
	 * 如果不解决一次，我们是否应该避免再次解决视图。 
	 * 
	 */
	private boolean cacheUnresolved = true;

	/** Filter function that determines if view should be cached. */
	/**
	 * 筛选器功能，用于确定是否应缓存视图。 
	 * 
	 */
	private CacheFilter cacheFilter = DEFAULT_CACHE_FILTER;

	/** Fast access cache for Views, returning already cached instances without a global lock. */
	/**
	 * View的快速访问缓存，返回已缓存的实例而没有全局锁定。 
	 * 
	 */
	private final Map<Object, View> viewAccessCache = new ConcurrentHashMap<>(DEFAULT_CACHE_LIMIT);

	/** Map from view key to View instance, synchronized for View creation. */
	/**
	 * 从视图键映射到View实例，同步以创建View。 
	 * 
	 */
	@SuppressWarnings("serial")
	private final Map<Object, View> viewCreationCache =
			new LinkedHashMap<Object, View>(DEFAULT_CACHE_LIMIT, 0.75f, true) {
				@Override
				protected boolean removeEldestEntry(Map.Entry<Object, View> eldest) {
					if (size() > getCacheLimit()) {
						viewAccessCache.remove(eldest.getKey());
						return true;
					}
					else {
						return false;
					}
				}
			};


	/**
	 * Specify the maximum number of entries for the view cache.
	 * Default is 1024.
	 */
	/**
	 * 指定视图缓存的最大条目数。 
	 * 默认值为1024。 
	 * 
	 */
	public void setCacheLimit(int cacheLimit) {
		this.cacheLimit = cacheLimit;
	}

	/**
	 * Return the maximum number of entries for the view cache.
	 */
	/**
	 * 返回视图缓存的最大条目数。 
	 * 
	 */
	public int getCacheLimit() {
		return this.cacheLimit;
	}

	/**
	 * Enable or disable caching.
	 * <p>This is equivalent to setting the {@link #setCacheLimit "cacheLimit"}
	 * property to the default limit (1024) or to 0, respectively.
	 * <p>Default is "true": caching is enabled.
	 * Disable this only for debugging and development.
	 */
	/**
	 * 启用或禁用缓存。 
	 *  <p>这等效于将{@link  #setCacheLimit"cacheLimit"}属性分别设置为默认限制（1024）或0。 
	 *  <p>默认值为"true"：启用缓存。 
	 * 仅在调试和开发时禁用此功能。 
	 * 
	 */
	public void setCache(boolean cache) {
		this.cacheLimit = (cache ? DEFAULT_CACHE_LIMIT : 0);
	}

	/**
	 * Return if caching is enabled.
	 */
	/**
	 * 如果启用了缓存，则返回。 
	 * 
	 */
	public boolean isCache() {
		return (this.cacheLimit > 0);
	}

	/**
	 * Whether a view name once resolved to {@code null} should be cached and
	 * automatically resolved to {@code null} subsequently.
	 * <p>Default is "true": unresolved view names are being cached, as of Spring 3.1.
	 * Note that this flag only applies if the general {@link #setCache "cache"}
	 * flag is kept at its default of "true" as well.
	 * <p>Of specific interest is the ability for some AbstractUrlBasedView
	 * implementations (FreeMarker, Tiles) to check if an underlying resource
	 * exists via {@link AbstractUrlBasedView#checkResource(Locale)}.
	 * With this flag set to "false", an underlying resource that re-appears
	 * is noticed and used. With the flag set to "true", one check is made only.
	 */
	/**
	 * 视图名称一旦解析为{@code  null}，是否应该缓存并随后自动解析为{@code  null}。 
	 *  <p>默认值为"true"：从Spring 3.1开始，将缓存未解析的视图名称。 
	 * 请注意，只有在常规{@link  #setCache"cache"}标志也保持其默认值"true"的情况下，此标志才适用。 
	 *  <p>一些特定的AbstractUrlBasedView实现（FreeMarker，Tiles）能够通过{@link  AbstractUrlBasedView＃checkResource（Locale）}检查基础资源是否存在。 
	 * 通过将此标志设置为"false"，可以发现并使用重新出现的基础资源。 
	 * 将标志设置为"true"时，仅进行一次检查。 
	 * 
	 */
	public void setCacheUnresolved(boolean cacheUnresolved) {
		this.cacheUnresolved = cacheUnresolved;
	}

	/**
	 * Return if caching of unresolved views is enabled.
	 */
	/**
	 * 如果启用了未解析视图的缓存，则返回。 
	 * 
	 */
	public boolean isCacheUnresolved() {
		return this.cacheUnresolved;
	}

	/**
	 * Sets the filter that determines if view should be cached.
	 * Default behaviour is to cache all views.
	 * @since 5.2
	 */
	/**
	 * 设置用于确定是否应缓存视图的过滤器。 
	 * 默认行为是缓存所有视图。 
	 *  @5.2起
	 */
	public void setCacheFilter(CacheFilter cacheFilter) {
		Assert.notNull(cacheFilter, "CacheFilter must not be null");
		this.cacheFilter = cacheFilter;
	}

	/**
	 * Return filter function that determines if view should be cached.
	 * @since 5.2
	 */
	/**
	 * 返回过滤器功能，用于确定是否应缓存视图。 
	 *  @5.2起
	 */
	public CacheFilter getCacheFilter() {
		return this.cacheFilter;
	}

	@Override
	@Nullable
	public View resolveViewName(String viewName, Locale locale) throws Exception {
		if (!isCache()) {
			return createView(viewName, locale);
		}
		else {
			Object cacheKey = getCacheKey(viewName, locale);
			View view = this.viewAccessCache.get(cacheKey);
			if (view == null) {
				synchronized (this.viewCreationCache) {
					view = this.viewCreationCache.get(cacheKey);
					if (view == null) {
						// Ask the subclass to create the View object.
						view = createView(viewName, locale);
						if (view == null && this.cacheUnresolved) {
							view = UNRESOLVED_VIEW;
						}
						if (view != null && this.cacheFilter.filter(view, viewName, locale)) {
							this.viewAccessCache.put(cacheKey, view);
							this.viewCreationCache.put(cacheKey, view);
						}
					}
				}
			}
			else {
				if (logger.isTraceEnabled()) {
					logger.trace(formatKey(cacheKey) + "served from cache");
				}
			}
			return (view != UNRESOLVED_VIEW ? view : null);
		}
	}

	private static String formatKey(Object cacheKey) {
		return "View with key [" + cacheKey + "] ";
	}

	/**
	 * Return the cache key for the given view name and the given locale.
	 * <p>Default is a String consisting of view name and locale suffix.
	 * Can be overridden in subclasses.
	 * <p>Needs to respect the locale in general, as a different locale can
	 * lead to a different view resource.
	 */
	/**
	 * 返回给定视图名称和给定语言环境的缓存键。 
	 *  <p>默认是一个由视图名称和语言环境后缀组成的字符串。 
	 * 可以在子类中覆盖。 
	 *  <p>通常需要尊重语言环境，因为不同的语言环境会导致不同的视图资源。 
	 * 
	 */
	protected Object getCacheKey(String viewName, Locale locale) {
		return viewName + '_' + locale;
	}

	/**
	 * Provides functionality to clear the cache for a certain view.
	 * <p>This can be handy in case developer are able to modify views
	 * (e.g. FreeMarker templates) at runtime after which you'd need to
	 * clear the cache for the specified view.
	 * @param viewName the view name for which the cached view object
	 * (if any) needs to be removed
	 * @param locale the locale for which the view object should be removed
	 */
	/**
	 * 提供清除特定视图缓存的功能。 
	 *  <p>如果开发人员能够在运行时修改视图（例如FreeMarker模板），然后需要清除指定视图的缓存，这将很方便。 
	 *  
	 * @param  viewName需要为其删除缓存的视图对象（如果有）的视图名称
	 * @param  locale应该为其删除视图对象的语言环境
	 */
	public void removeFromCache(String viewName, Locale locale) {
		if (!isCache()) {
			logger.warn("Caching is OFF (removal not necessary)");
		}
		else {
			Object cacheKey = getCacheKey(viewName, locale);
			Object cachedView;
			synchronized (this.viewCreationCache) {
				this.viewAccessCache.remove(cacheKey);
				cachedView = this.viewCreationCache.remove(cacheKey);
			}
			if (logger.isDebugEnabled()) {
				// Some debug output might be useful...
				logger.debug(formatKey(cacheKey) +
						(cachedView != null ? "cleared from cache" : "not found in the cache"));
			}
		}
	}

	/**
	 * Clear the entire view cache, removing all cached view objects.
	 * Subsequent resolve calls will lead to recreation of demanded view objects.
	 */
	/**
	 * 清除整个视图缓存，删除所有缓存的视图对象。 
	 * 随后的解析调用将导致重新创建所需的视图对象。 
	 * 
	 */
	public void clearCache() {
		logger.debug("Clearing all views from the cache");
		synchronized (this.viewCreationCache) {
			this.viewAccessCache.clear();
			this.viewCreationCache.clear();
		}
	}


	/**
	 * Create the actual View object.
	 * <p>The default implementation delegates to {@link #loadView}.
	 * This can be overridden to resolve certain view names in a special fashion,
	 * before delegating to the actual {@code loadView} implementation
	 * provided by the subclass.
	 * @param viewName the name of the view to retrieve
	 * @param locale the Locale to retrieve the view for
	 * @return the View instance, or {@code null} if not found
	 * (optional, to allow for ViewResolver chaining)
	 * @throws Exception if the view couldn't be resolved
	 * @see #loadView
	 */
	/**
	 * 创建实际的View对象。 
	 *  <p>默认实现委托给{@link  #loadView}。 
	 * 在委托给子类提供的实际{@code  loadView}实现之前，可以重写此方法以特殊方式解析某些视图名称。 
	 *  
	 * @param  viewName要检索的视图的名称
	 * @param 语言环境要检索视图实例的
	 * @return 的语言环境，如果找不到，则返回{@code  null}（可选，以允许ViewResolver链接）
	 * @throws 如果无法解析视图，则异常
	 * @see  #loadView
	 */
	@Nullable
	protected View createView(String viewName, Locale locale) throws Exception {
		return loadView(viewName, locale);
	}

	/**
	 * Subclasses must implement this method, building a View object
	 * for the specified view. The returned View objects will be
	 * cached by this ViewResolver base class.
	 * <p>Subclasses are not forced to support internationalization:
	 * A subclass that does not may simply ignore the locale parameter.
	 * @param viewName the name of the view to retrieve
	 * @param locale the Locale to retrieve the view for
	 * @return the View instance, or {@code null} if not found
	 * (optional, to allow for ViewResolver chaining)
	 * @throws Exception if the view couldn't be resolved
	 * @see #resolveViewName
	 */
	/**
	 * 子类必须实现此方法，为指定的视图构建View对象。 
	 * 返回的View对象将由此ViewResolver基类缓存。 
	 *  <p>不强制子类支持国际化：不能简单地忽略locale参数的子类。 
	 *  
	 * @param  viewName要检索的视图的名称
	 * @param 语言环境要检索视图实例的
	 * @return 的语言环境，如果找不到，则返回{@code  null}（可选，以允许ViewResolver链接）
	 * @throws 如果无法解析视图，则异常
	 * @see  #resolveViewName
	 */
	@Nullable
	protected abstract View loadView(String viewName, Locale locale) throws Exception;


	/**
	 * Filter that determines if view should be cached.
	 *
	 * @author Sergey Galkin
	 * @author Arjen Poutsma
	 * @since 5.2
	 */
	/**
	 * 确定是否应缓存视图的筛选器。 
	 *  @author 谢尔盖·加尔金（Sergey Galkin）@author  Arjen Poutsma @5.2起
	 */
	@FunctionalInterface
	public interface CacheFilter {

		/**
		 * Indicates whether the given view should be cached.
		 * The name and locale used to resolve the view are also provided.
		 * @param view the view
		 * @param viewName the name used to resolve the {@code view}
		 * @param locale the locale used to resolve the {@code view}
		 * @return {@code true} if the view should be cached; {@code false} otherwise
		 */
		/**
		 * 指示是否应缓存给定的视图。 
		 * 还提供了用于解析视图的名称和语言环境。 
		 *  
		 * @param 视图视图
		 * @param  viewName用于解析{@code 视图}的名称
		 * @param 语言环境用于解析{@code 视图的语言环境} 
		 * @return  {<@code> true}是否应该缓存视图； 
		 *  {@code  false}否则
		 */
		boolean filter(View view, String viewName, Locale locale);
	}

}
