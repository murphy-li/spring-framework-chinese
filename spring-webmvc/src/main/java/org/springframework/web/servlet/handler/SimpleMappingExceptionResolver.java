/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.handler;

import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.util.WebUtils;

/**
 * {@link org.springframework.web.servlet.HandlerExceptionResolver} implementation
 * that allows for mapping exception class names to view names, either for a set of
 * given handlers or for all handlers in the DispatcherServlet.
 *
 * <p>Error views are analogous to error page JSPs, but can be used with any kind of
 * exception including any checked one, with fine-granular mappings for specific handlers.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @author Rossen Stoyanchev
 * @since 22.11.2003
 * @see org.springframework.web.servlet.DispatcherServlet
 */
/**
 * {@link  org.springframework.web.servlet.HandlerExceptionResolver}实现，允许将异常类名称映射到视图名称，无论是一组给定的处理程序还是DispatcherServlet中的所有处理程序。 
 *  <p>错误视图类似于错误页面JSP，但是可以与任何类型的异常一起使用，包括任何已检查的异常，并且具有特定处理程序的细粒度映射。 
 *  @author  Juergen Hoeller @author  Arjen Poutsma @author  Rossen Stoyanchev @2003年11月22日以来
 * @see  org.springframework.web.servlet.DispatcherServlet
 */
public class SimpleMappingExceptionResolver extends AbstractHandlerExceptionResolver {

	/** The default name of the exception attribute: "exception". */
	/**
	 * 异常属性的默认名称："exception"。 
	 * 
	 */
	public static final String DEFAULT_EXCEPTION_ATTRIBUTE = "exception";


	@Nullable
	private Properties exceptionMappings;

	@Nullable
	private Class<?>[] excludedExceptions;

	@Nullable
	private String defaultErrorView;

	@Nullable
	private Integer defaultStatusCode;

	private Map<String, Integer> statusCodes = new HashMap<>();

	@Nullable
	private String exceptionAttribute = DEFAULT_EXCEPTION_ATTRIBUTE;


	/**
	 * Set the mappings between exception class names and error view names.
	 * The exception class name can be a substring, with no wildcard support at present.
	 * A value of "ServletException" would match {@code javax.servlet.ServletException}
	 * and subclasses, for example.
	 * <p><b>NB:</b> Consider carefully how
	 * specific the pattern is, and whether to include package information (which isn't mandatory).
	 * For example, "Exception" will match nearly anything, and will probably hide other rules.
	 * "java.lang.Exception" would be correct if "Exception" was meant to define a rule for all
	 * checked exceptions. With more unusual exception names such as "BaseBusinessException"
	 * there's no need to use a FQN.
	 * @param mappings exception patterns (can also be fully qualified class names) as keys,
	 * and error view names as values
	 */
	/**
	 * 设置异常类名称和错误视图名称之间的映射。 
	 * 异常类名称可以是子字符串，目前不支持通配符。 
	 * 例如，"ServletException"的值将与{@code  javax.servlet.ServletException}和子类匹配。 
	 *  <p> <b> NB：</ b>请仔细考虑模式的具体程度，以及是否包括软件包信息（这不是强制性的）。 
	 * 例如，"异常"将几乎匹配所有内容，并且可能会隐藏其他规则。 
	 * 如果"异常"旨在为所有检查的异常定义规则，则"java.lang.Exception"将是正确的。 
	 * 使用更特殊的异常名称（例如"BaseBusinessException"），就无需使用FQN。 
	 *  
	 * @param 将异常模式（也可以是完全限定的类名）映射为键，并将错误视图名称映射为值
	 */
	public void setExceptionMappings(Properties mappings) {
		this.exceptionMappings = mappings;
	}

	/**
	 * Set one or more exceptions to be excluded from the exception mappings.
	 * Excluded exceptions are checked first and if one of them equals the actual
	 * exception, the exception will remain unresolved.
	 * @param excludedExceptions one or more excluded exception types
	 */
	/**
	 * 设置一个或多个要从异常映射中排除的异常。 
	 * 首先检查排除的异常，如果其中一个等于实际异常，则该异常将保持未解决状态。 
	 *  
	 * @param  excludeExceptions一种或多种排除异常类型
	 */
	public void setExcludedExceptions(Class<?>... excludedExceptions) {
		this.excludedExceptions = excludedExceptions;
	}

	/**
	 * Set the name of the default error view.
	 * This view will be returned if no specific mapping was found.
	 * <p>Default is none.
	 */
	/**
	 * 设置默认错误视图的名称。 
	 * 如果未找到特定映射，将返回此视图。 
	 *  <p>默认为无。 
	 * 
	 */
	public void setDefaultErrorView(String defaultErrorView) {
		this.defaultErrorView = defaultErrorView;
	}

	/**
	 * Set the HTTP status code that this exception resolver will apply for a given
	 * resolved error view. Keys are view names; values are status codes.
	 * <p>Note that this error code will only get applied in case of a top-level request.
	 * It will not be set for an include request, since the HTTP status cannot be modified
	 * from within an include.
	 * <p>If not specified, the default status code will be applied.
	 * @see #setDefaultStatusCode(int)
	 */
	/**
	 * 设置此异常解析器将应用于给定的已解决错误视图的HTTP状态代码。 
	 * 键是视图名称； 
	 * 值是状态码。 
	 *  <p>请注意，仅在顶级请求的情况下才会应用此错误代码。 
	 * 由于无法从包含内部修改HTTP状态，因此不会为包含请求设置该属性。 
	 *  <p>如果未指定，则将应用默认状态代码。 
	 *  
	 * @see  #setDefaultStatusCode（int）
	 */
	public void setStatusCodes(Properties statusCodes) {
		for (Enumeration<?> enumeration = statusCodes.propertyNames(); enumeration.hasMoreElements();) {
			String viewName = (String) enumeration.nextElement();
			Integer statusCode = Integer.valueOf(statusCodes.getProperty(viewName));
			this.statusCodes.put(viewName, statusCode);
		}
	}

	/**
	 * An alternative to {@link #setStatusCodes(Properties)} for use with
	 * Java-based configuration.
	 */
	/**
	 * {@link  #setStatusCodes（Properties）}的替代方法，用于基于Java的配置。 
	 * 
	 */
	public void addStatusCode(String viewName, int statusCode) {
		this.statusCodes.put(viewName, statusCode);
	}

	/**
	 * Returns the HTTP status codes provided via {@link #setStatusCodes(Properties)}.
	 * Keys are view names; values are status codes.
	 */
	/**
	 * 返回通过{@link  #setStatusCodes（Properties）}提供的HTTP状态代码。 
	 * 键是视图名称； 
	 * 值是状态码。 
	 * 
	 */
	public Map<String, Integer> getStatusCodesAsMap() {
		return Collections.unmodifiableMap(this.statusCodes);
	}

	/**
	 * Set the default HTTP status code that this exception resolver will apply
	 * if it resolves an error view and if there is no status code mapping defined.
	 * <p>Note that this error code will only get applied in case of a top-level request.
	 * It will not be set for an include request, since the HTTP status cannot be modified
	 * from within an include.
	 * <p>If not specified, no status code will be applied, either leaving this to the
	 * controller or view, or keeping the servlet engine's default of 200 (OK).
	 * @param defaultStatusCode the HTTP status code value, for example 500
	 * ({@link HttpServletResponse#SC_INTERNAL_SERVER_ERROR}) or 404 ({@link HttpServletResponse#SC_NOT_FOUND})
	 * @see #setStatusCodes(Properties)
	 */
	/**
	 * 设置此异常解析器在解析错误视图且未定义状态码映射时将应用的默认HTTP状态码。 
	 *  <p>请注意，仅在顶级请求的情况下才会应用此错误代码。 
	 * 由于无法从包含内部修改HTTP状态，因此不会为包含请求设置该属性。 
	 *  <p>如果未指定，则不会应用任何状态代码，要么将其留给控制器或视图，要么将servlet引擎的默认值保持为200（确定）。 
	 *  
	 * @param  defaultStatusCode HTTP状态代码值，例如500（{@link  HttpServletResponse＃SC_INTERNAL_SERVER_ERROR}）或404（{@link  HttpServletResponse＃SC_NOT_FOUND}）
	 * @see  #setStatusCodes（Properties）
	 */
	public void setDefaultStatusCode(int defaultStatusCode) {
		this.defaultStatusCode = defaultStatusCode;
	}

	/**
	 * Set the name of the model attribute as which the exception should be exposed.
	 * Default is "exception".
	 * <p>This can be either set to a different attribute name or to {@code null}
	 * for not exposing an exception attribute at all.
	 * @see #DEFAULT_EXCEPTION_ATTRIBUTE
	 */
	/**
	 * 设置要公开其异常的模型属性的名称。 
	 * 默认值为"例外"。 
	 *  <p>可以将其设置为其他属性名称，也可以设置为{@code  null}，以完全不公开异常属性。 
	 *  
	 * @see  #DEFAULT_EXCEPTION_ATTRIBUTE
	 */
	public void setExceptionAttribute(@Nullable String exceptionAttribute) {
		this.exceptionAttribute = exceptionAttribute;
	}


	/**
	 * Actually resolve the given exception that got thrown during on handler execution,
	 * returning a ModelAndView that represents a specific error page if appropriate.
	 * <p>May be overridden in subclasses, in order to apply specific exception checks.
	 * Note that this template method will be invoked <i>after</i> checking whether this
	 * resolved applies ("mappedHandlers" etc), so an implementation may simply proceed
	 * with its actual exception handling.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param handler the executed handler, or {@code null} if none chosen at the time
	 * of the exception (for example, if multipart resolution failed)
	 * @param ex the exception that got thrown during handler execution
	 * @return a corresponding {@code ModelAndView} to forward to,
	 * or {@code null} for default processing in the resolution chain
	 */
	/**
	 * 实际解决在处理程序执行过程中引发的给定异常，如果合适的话，返回代表特定错误页面的ModelAndView。 
	 *  <p>可以在子类中重写，以应用特定的异常检查。 
	 * 请注意，此模板方法将在<i> </ i>检查此解析是否适用后调用（"mappedHandlers"等），因此实现可以简单地进行其实际的异常处理。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 响应当前HTTP响应
	 * @param 处理程序执行的处理程序； 
	 * 如果在异常发生时没有选择，则为{@code  null}（例如，多部分解析失败） ）
	 * @param 会在处理程序执行期间抛出异常，<
	 * @return>会将相应的{@code  ModelAndView}转发给，或者将{@code  null}用于解析链中的默认处理
	 */
	@Override
	@Nullable
	protected ModelAndView doResolveException(
			HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) {

		// Expose ModelAndView for chosen error view.
		String viewName = determineViewName(ex, request);
		if (viewName != null) {
			// Apply HTTP status code for error views, if specified.
			// Only apply it if we're processing a top-level request.
			Integer statusCode = determineStatusCode(request, viewName);
			if (statusCode != null) {
				applyStatusCodeIfPossible(request, response, statusCode);
			}
			return getModelAndView(viewName, ex, request);
		}
		else {
			return null;
		}
	}

	/**
	 * Determine the view name for the given exception, first checking against the
	 * {@link #setExcludedExceptions(Class[]) "excludedExecptions"}, then searching the
	 * {@link #setExceptionMappings "exceptionMappings"}, and finally using the
	 * {@link #setDefaultErrorView "defaultErrorView"} as a fallback.
	 * @param ex the exception that got thrown during handler execution
	 * @param request current HTTP request (useful for obtaining metadata)
	 * @return the resolved view name, or {@code null} if excluded or none found
	 */
	/**
	 * 确定给定异常的视图名称，首先检查{@link  #setExcludedExceptions（Class []）"excludedExecptions"}，然后搜索{@link  #setExceptionMappings"exceptionMappings"}，最后使用{ @link  #setDefaultErrorView"defaultErrorView"}作为后备广告。 
	 *  
	 * @param 在处理程序执行期间抛出的异常
	 * @param 请求当前HTTP请求（用于获取元数据）
	 * @return 解析的视图名称； 
	 * 如果排除或找不到，则为{@code  null}
	 */
	@Nullable
	protected String determineViewName(Exception ex, HttpServletRequest request) {
		String viewName = null;
		if (this.excludedExceptions != null) {
			for (Class<?> excludedEx : this.excludedExceptions) {
				if (excludedEx.equals(ex.getClass())) {
					return null;
				}
			}
		}
		// Check for specific exception mappings.
		if (this.exceptionMappings != null) {
			viewName = findMatchingViewName(this.exceptionMappings, ex);
		}
		// Return default error view else, if defined.
		if (viewName == null && this.defaultErrorView != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Resolving to default view '" + this.defaultErrorView + "'");
			}
			viewName = this.defaultErrorView;
		}
		return viewName;
	}

	/**
	 * Find a matching view name in the given exception mappings.
	 * @param exceptionMappings mappings between exception class names and error view names
	 * @param ex the exception that got thrown during handler execution
	 * @return the view name, or {@code null} if none found
	 * @see #setExceptionMappings
	 */
	/**
	 * 在给定的异常映射中找到匹配的视图名称。 
	 *  
	 * @param  exceptionMatching异常类名称和错误视图名称之间的映射
	 * @param 异常处理程序执行期间引发的异常
	 * @return 视图名称，如果找不到，则为{@code  null} 
	 * @see  #setExceptionMappings
	 */
	@Nullable
	protected String findMatchingViewName(Properties exceptionMappings, Exception ex) {
		String viewName = null;
		String dominantMapping = null;
		int deepest = Integer.MAX_VALUE;
		for (Enumeration<?> names = exceptionMappings.propertyNames(); names.hasMoreElements();) {
			String exceptionMapping = (String) names.nextElement();
			int depth = getDepth(exceptionMapping, ex);
			if (depth >= 0 && (depth < deepest || (depth == deepest &&
					dominantMapping != null && exceptionMapping.length() > dominantMapping.length()))) {
				deepest = depth;
				dominantMapping = exceptionMapping;
				viewName = exceptionMappings.getProperty(exceptionMapping);
			}
		}
		if (viewName != null && logger.isDebugEnabled()) {
			logger.debug("Resolving to view '" + viewName + "' based on mapping [" + dominantMapping + "]");
		}
		return viewName;
	}

	/**
	 * Return the depth to the superclass matching.
	 * <p>0 means ex matches exactly. Returns -1 if there's no match.
	 * Otherwise, returns depth. Lowest depth wins.
	 */
	/**
	 * 将深度返回到超类匹配。 
	 *  <p> 0表示ex完全匹配。 
	 * 如果不匹配，则返回-1。 
	 * 否则，返回深度。 
	 * 最低深度获胜。 
	 * 
	 */
	protected int getDepth(String exceptionMapping, Exception ex) {
		return getDepth(exceptionMapping, ex.getClass(), 0);
	}

	private int getDepth(String exceptionMapping, Class<?> exceptionClass, int depth) {
		if (exceptionClass.getName().contains(exceptionMapping)) {
			// Found it!
			return depth;
		}
		// If we've gone as far as we can go and haven't found it...
		if (exceptionClass == Throwable.class) {
			return -1;
		}
		return getDepth(exceptionMapping, exceptionClass.getSuperclass(), depth + 1);
	}

	/**
	 * Determine the HTTP status code to apply for the given error view.
	 * <p>The default implementation returns the status code for the given view name (specified through the
	 * {@link #setStatusCodes(Properties) statusCodes} property), or falls back to the
	 * {@link #setDefaultStatusCode defaultStatusCode} if there is no match.
	 * <p>Override this in a custom subclass to customize this behavior.
	 * @param request current HTTP request
	 * @param viewName the name of the error view
	 * @return the HTTP status code to use, or {@code null} for the servlet container's default
	 * (200 in case of a standard error view)
	 * @see #setDefaultStatusCode
	 * @see #applyStatusCodeIfPossible
	 */
	/**
	 * 确定HTTP状态代码以应用于给定的错误视图。 
	 *  <p>默认实现返回给定视图名称的状态代码（通过{@link  #setStatusCodes（Properties）statusCodes}属性指定），或返回到{@link  #setDefaultStatusCode defaultStatusCode}不匹配。 
	 *  <p>在自定义子类中对此进行重写以自定义此行为。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param  viewName错误视图的名称
	 * @return 要使用的HTTP状态代码，或servlet容器的默认状态为{@code  null}（标准情况下为200）错误视图）
	 * @see  #setDefaultStatusCode 
	 * @see  #applyStatusCodeIfPossible
	 */
	@Nullable
	protected Integer determineStatusCode(HttpServletRequest request, String viewName) {
		if (this.statusCodes.containsKey(viewName)) {
			return this.statusCodes.get(viewName);
		}
		return this.defaultStatusCode;
	}

	/**
	 * Apply the specified HTTP status code to the given response, if possible (that is,
	 * if not executing within an include request).
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param statusCode the status code to apply
	 * @see #determineStatusCode
	 * @see #setDefaultStatusCode
	 * @see HttpServletResponse#setStatus
	 */
	/**
	 * 如果可能的话（即，如果未在包含请求中执行），将指定的HTTP状态代码应用于给定的响应。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 响应当前HTTP响应
	 * @param  statusCode要应用的状态代码
	 * @see  #determineStatusCode 
	 * @see  #setDefaultStatusCode 
	 * @see  HttpServletResponse＃setStatus
	 */
	protected void applyStatusCodeIfPossible(HttpServletRequest request, HttpServletResponse response, int statusCode) {
		if (!WebUtils.isIncludeRequest(request)) {
			if (logger.isDebugEnabled()) {
				logger.debug("Applying HTTP status " + statusCode);
			}
			response.setStatus(statusCode);
			request.setAttribute(WebUtils.ERROR_STATUS_CODE_ATTRIBUTE, statusCode);
		}
	}

	/**
	 * Return a ModelAndView for the given request, view name and exception.
	 * <p>The default implementation delegates to {@link #getModelAndView(String, Exception)}.
	 * @param viewName the name of the error view
	 * @param ex the exception that got thrown during handler execution
	 * @param request current HTTP request (useful for obtaining metadata)
	 * @return the ModelAndView instance
	 */
	/**
	 * 返回给定请求，视图名称和异常的ModelAndView。 
	 *  <p>默认实现委托给{@link  #getModelAndView（String，Exception）}。 
	 *  
	 * @param  viewName错误视图的名称
	 * @param 除在处理程序执行过程中引发的异常外，<
	 * @param>请求当前的HTTP请求（用于获取元数据）
	 * @return  ModelAndView实例
	 */
	protected ModelAndView getModelAndView(String viewName, Exception ex, HttpServletRequest request) {
		return getModelAndView(viewName, ex);
	}

	/**
	 * Return a ModelAndView for the given view name and exception.
	 * <p>The default implementation adds the specified exception attribute.
	 * Can be overridden in subclasses.
	 * @param viewName the name of the error view
	 * @param ex the exception that got thrown during handler execution
	 * @return the ModelAndView instance
	 * @see #setExceptionAttribute
	 */
	/**
	 * 返回给定视图名称和异常的ModelAndView。 
	 *  <p>默认实现添加指定的异常属性。 
	 * 可以在子类中覆盖。 
	 *  
	 * @param  viewName错误视图的名称
	 * @param ，除了在处理程序执行期间引发的异常之外，还可以。 
	 * 
	 * @return  ModelAndView实例
	 * @see  #setExceptionAttribute
	 */
	protected ModelAndView getModelAndView(String viewName, Exception ex) {
		ModelAndView mv = new ModelAndView(viewName);
		if (this.exceptionAttribute != null) {
			mv.addObject(this.exceptionAttribute, ex);
		}
		return mv;
	}

}
