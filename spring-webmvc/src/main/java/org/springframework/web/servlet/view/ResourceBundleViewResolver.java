/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.view;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.support.PropertiesBeanDefinitionReader;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.Ordered;
import org.springframework.lang.Nullable;
import org.springframework.web.context.support.GenericWebApplicationContext;
import org.springframework.web.servlet.View;

/**
 * A {@link org.springframework.web.servlet.ViewResolver} implementation that uses
 * bean definitions in a {@link ResourceBundle}, specified by the bundle basename.
 *
 * <p>The bundle is typically defined in a properties file, located in the classpath.
 * The default bundle basename is "views".
 *
 * <p>This {@code ViewResolver} supports localized view definitions, using the
 * default support of {@link java.util.PropertyResourceBundle}. For example, the
 * basename "views" will be resolved as class path resources "views_de_AT.properties",
 * "views_de.properties", "views.properties" - for a given Locale "de_AT".
 *
 * <p>Note: This {@code ViewResolver} implements the {@link Ordered} interface
 * in order to allow for flexible participation in {@code ViewResolver} chaining.
 * For example, some special views could be defined via this {@code ViewResolver}
 * (giving it 0 as "order" value), while all remaining views could be resolved by
 * a {@link UrlBasedViewResolver}.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see java.util.ResourceBundle#getBundle
 * @see java.util.PropertyResourceBundle
 * @see UrlBasedViewResolver
 */
/**
 * 一个{@link  org.springframework.web.servlet.ViewResolver}实现，该实现使用由包基础名称指定的{@link  ResourceBundle}中的bean定义。 
 *  <p> bundle通常是在类文件中的属性文件中定义的。 
 * 默认捆绑软件的基本名称是"视图"。 
 *  <p>此{@code  ViewResolver}使用默认支持{@link  java.util.PropertyResourceBundle}来支持本地化的视图定义。 
 * 例如，对于给定的语言环境"de_AT"，基本名称"views"将解析为类路径资源"views_de_AT.properties"，"views_de.properties"，"views.properties"。 
 *  <p>注意：此{@code  ViewResolver}实现了{@link  Ordered}接口，以便灵活地参与{@code  ViewResolver}链接。 
 * 例如，可以通过此{@code  ViewResolver}定义一些特殊的视图（将其0表示为"order"值），而所有其余视图都可以由{@link  UrlBasedViewResolver}解析。 
 *  @author  Rod Johnson @author  Juergen Hoeller 
 * @see  java.util.ResourceBundle＃getBundle 
 * @see  java.util.PropertyResourceBundle 
 * @see  UrlBasedViewResolver
 */
public class ResourceBundleViewResolver extends AbstractCachingViewResolver
		implements Ordered, InitializingBean, DisposableBean {

	/** The default basename if no other basename is supplied. */
	/**
	 * 如果未提供其他基本名称，则为默认基本名称。 
	 * 
	 */
	public static final String DEFAULT_BASENAME = "views";


	private String[] basenames = new String[] {DEFAULT_BASENAME};

	private ClassLoader bundleClassLoader = Thread.currentThread().getContextClassLoader();

	@Nullable
	private String defaultParentView;

	@Nullable
	private Locale[] localesToInitialize;

	private int order = Ordered.LOWEST_PRECEDENCE;  // default: same as non-Ordered

	/* Locale -> BeanFactory */
	/**
	 * 语言环境-> BeanFactory
	 */
	private final Map<Locale, BeanFactory> localeCache = new HashMap<>();

	/* List of ResourceBundle -> BeanFactory */
	/**
	 * ResourceBundle的列表-> BeanFactory
	 */
	private final Map<List<ResourceBundle>, ConfigurableApplicationContext> bundleCache = new HashMap<>();


	/**
	 * Set a single basename, following {@link java.util.ResourceBundle} conventions.
	 * The default is "views".
	 * <p>{@code ResourceBundle} supports different locale suffixes. For example,
	 * a base name of "views" might map to {@code ResourceBundle} files
	 * "views", "views_en_au" and "views_de".
	 * <p>Note that ResourceBundle names are effectively classpath locations: As a
	 * consequence, the JDK's standard ResourceBundle treats dots as package separators.
	 * This means that "test.theme" is effectively equivalent to "test/theme",
	 * just like it is for programmatic {@code java.util.ResourceBundle} usage.
	 * @see #setBasenames
	 * @see ResourceBundle#getBundle(String)
	 * @see ResourceBundle#getBundle(String, Locale)
	 */
	/**
	 * 遵循{@link  java.util.ResourceBundle}约定设置一个基本名称。 
	 * 默认值为"视图"。 
	 *  <p> {<@code> ResourceBundle}支持不同的语言环境后缀。 
	 * 例如，基本名称"views"可能会映射到{@code  ResourceBundle}文件"views"，"views_en_au"和"views_de"。 
	 *  <p>请注意，ResourceBundle名称实际上是类路径位置：因此，JDK的标准ResourceBundle将点视为包分隔符。 
	 * 这意味着"test.theme"实际上等效于"test / theme"，就像程序性{@code  java.util.ResourceBundle}的用法一样。 
	 *  
	 * @see  #setBasenames 
	 * @see  ResourceBundle＃getBundle（String）
	 * @see  ResourceBundle＃getBundle（String，Locale）
	 */
	public void setBasename(String basename) {
		setBasenames(basename);
	}

	/**
	 * Set an array of basenames, each following {@link java.util.ResourceBundle}
	 * conventions. The default is a single basename "views".
	 * <p>{@code ResourceBundle} supports different locale suffixes. For example,
	 * a base name of "views" might map to {@code ResourceBundle} files
	 * "views", "views_en_au" and "views_de".
	 * <p>The associated resource bundles will be checked sequentially when resolving
	 * a message code. Note that message definitions in a <i>previous</i> resource
	 * bundle will override ones in a later bundle, due to the sequential lookup.
	 * <p>Note that ResourceBundle names are effectively classpath locations: As a
	 * consequence, the JDK's standard ResourceBundle treats dots as package separators.
	 * This means that "test.theme" is effectively equivalent to "test/theme",
	 * just like it is for programmatic {@code java.util.ResourceBundle} usage.
	 * @see #setBasename
	 * @see ResourceBundle#getBundle(String)
	 * @see ResourceBundle#getBundle(String, Locale)
	 */
	/**
	 * 设置一个基本名称数组，每个基本名称遵循{@link  java.util.ResourceBundle}约定。 
	 * 默认值为单个基本名称"views"。 
	 *  <p> {<@code> ResourceBundle}支持不同的语言环境后缀。 
	 * 例如，基本名称"views"可能会映射到{@code  ResourceBundle}文件"views"，"views_en_au"和"views_de"。 
	 *  <p>在解析消息代码时，将顺序检查关联的资源束。 
	 * 请注意，由于顺序查找，<i>上一个</ i>资源束中的消息定义将覆盖后一个束中的消息定义。 
	 *  <p>请注意，ResourceBundle名称实际上是类路径位置：因此，JDK的标准ResourceBundle将点视为包分隔符。 
	 * 这意味着"test.theme"实际上等效于"test / theme"，就像程序性{@code  java.util.ResourceBundle}的用法一样。 
	 *  
	 * @see  #setBasename 
	 * @see  ResourceBundle＃getBundle（String）
	 * @see  ResourceBundle＃getBundle（String，Locale）
	 */
	public void setBasenames(String... basenames) {
		this.basenames = basenames;
	}

	/**
	 * Set the {@link ClassLoader} to load resource bundles with.
	 * Default is the thread context {@code ClassLoader}.
	 */
	/**
	 * 设置{@link  ClassLoader}来加载资源束。 
	 * 默认值为线程上下文{@code  ClassLoader}。 
	 * 
	 */
	public void setBundleClassLoader(ClassLoader classLoader) {
		this.bundleClassLoader = classLoader;
	}

	/**
	 * Return the {@link ClassLoader} to load resource bundles with.
	 * <p>Default is the specified bundle {@code ClassLoader},
	 * usually the thread context {@code ClassLoader}.
	 */
	/**
	 * 返回{@link  ClassLoader}来加载资源包。 
	 *  <p>默认是指定的捆绑软件{@code  ClassLoader}，通常是线程上下文{@code  ClassLoader}。 
	 * 
	 */
	protected ClassLoader getBundleClassLoader() {
		return this.bundleClassLoader;
	}

	/**
	 * Set the default parent for views defined in the {@code ResourceBundle}.
	 * <p>This avoids repeated "yyy1.(parent)=xxx", "yyy2.(parent)=xxx" definitions
	 * in the bundle, especially if all defined views share the same parent.
	 * <p>The parent will typically define the view class and common attributes.
	 * Concrete views might simply consist of a URL definition then:
	 * a la "yyy1.url=/my.jsp", "yyy2.url=/your.jsp".
	 * <p>View definitions that define their own parent or carry their own
	 * class can still override this. Strictly speaking, the rule that a
	 * default parent setting does not apply to a bean definition that
	 * carries a class is there for backwards compatibility reasons.
	 * It still matches the typical use case.
	 */
	/**
	 * 为{@code  ResourceBundle}中定义的视图设置默认的父级。 
	 *  <p>这避免了捆绑软件中重复的"yyy1。 
	 * （父）= xxx"，"yyy2。 
	 * （父）= xxx"定义，尤其是在所有定义的视图共享同一父视图的情况下。 
	 *  <p>父级通常会定义视图类和公共属性。 
	 * 具体的视图可能仅由URL定义组成：la"yyy1.url = / my.jsp"，"yyy2.url = / your.jsp"。 
	 *  <p>定义自己的父级或带有自己的类的视图定义仍可以覆盖此定义。 
	 * 严格来说，出于向后兼容的原因，存在默认的父设置不适用于带有类的Bean定义的规则。 
	 * 它仍然符合典型的用例。 
	 * 
	 */
	public void setDefaultParentView(String defaultParentView) {
		this.defaultParentView = defaultParentView;
	}

	/**
	 * Specify Locales to initialize eagerly, rather than lazily when actually accessed.
	 * <p>Allows for pre-initialization of common Locales, eagerly checking
	 * the view configuration for those Locales.
	 */
	/**
	 * 指定"语言环境"以进行初始化，而不是在实际访问时进行延迟。 
	 *  <p>允许预先初始化通用语言环境，并热切地检查视图配置中的那些语言环境。 
	 * 
	 */
	public void setLocalesToInitialize(Locale... localesToInitialize) {
		this.localesToInitialize = localesToInitialize;
	}

	/**
	 * Specify the order value for this ViewResolver bean.
	 * <p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.
	 * @see org.springframework.core.Ordered#getOrder()
	 */
	/**
	 * 指定此ViewResolver bean的订单值。 
	 *  <p>默认值为{@code  Ordered.LOWEST_PRECEDENCE}，表示无序。 
	 *  
	 * @see  org.springframework.core.Ordered＃getOrder（）
	 */
	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}

	/**
	 * Eagerly initialize Locales if necessary.
	 * @see #setLocalesToInitialize
	 */
	/**
	 * 如有必要，请认真初始化语言环境。 
	 *  
	 * @see  #setLocalesToInitialize
	 */
	@Override
	public void afterPropertiesSet() throws BeansException {
		if (this.localesToInitialize != null) {
			for (Locale locale : this.localesToInitialize) {
				initFactory(locale);
			}
		}
	}


	@Override
	protected View loadView(String viewName, Locale locale) throws Exception {
		BeanFactory factory = initFactory(locale);
		try {
			return factory.getBean(viewName, View.class);
		}
		catch (NoSuchBeanDefinitionException ex) {
			// Allow for ViewResolver chaining...
			return null;
		}
	}

	/**
	 * Initialize the View {@link BeanFactory} from the {@code ResourceBundle},
	 * for the given {@link Locale locale}.
	 * <p>Synchronized because of access by parallel threads.
	 * @param locale the target {@code Locale}
	 * @return the View factory for the given Locale
	 * @throws BeansException in case of initialization errors
	 */
	/**
	 * 从{@code  ResourceBundle}初始化给定的{@link  Locale locale}的视图{@link  BeanFactory}。 
	 *  <p>由于并行线程的访问而同步。 
	 *  
	 * @param 语言环境目标{@code 语言环境} 
	 * @return 给定语言环境
	 * @throws  BeansException的视图工厂，如果发生初始化错误
	 */
	protected synchronized BeanFactory initFactory(Locale locale) throws BeansException {
		// Try to find cached factory for Locale:
		// Have we already encountered that Locale before?
		if (isCache()) {
			BeanFactory cachedFactory = this.localeCache.get(locale);
			if (cachedFactory != null) {
				return cachedFactory;
			}
		}

		// Build list of ResourceBundle references for Locale.
		List<ResourceBundle> bundles = new LinkedList<>();
		for (String basename : this.basenames) {
			ResourceBundle bundle = getBundle(basename, locale);
			bundles.add(bundle);
		}

		// Try to find cached factory for ResourceBundle list:
		// even if Locale was different, same bundles might have been found.
		if (isCache()) {
			BeanFactory cachedFactory = this.bundleCache.get(bundles);
			if (cachedFactory != null) {
				this.localeCache.put(locale, cachedFactory);
				return cachedFactory;
			}
		}

		// Create child ApplicationContext for views.
		GenericWebApplicationContext factory = new GenericWebApplicationContext();
		factory.setParent(getApplicationContext());
		factory.setServletContext(getServletContext());

		// Load bean definitions from resource bundle.
		PropertiesBeanDefinitionReader reader = new PropertiesBeanDefinitionReader(factory);
		reader.setDefaultParentBean(this.defaultParentView);
		for (ResourceBundle bundle : bundles) {
			reader.registerBeanDefinitions(bundle);
		}

		factory.refresh();

		// Cache factory for both Locale and ResourceBundle list.
		if (isCache()) {
			this.localeCache.put(locale, factory);
			this.bundleCache.put(bundles, factory);
		}

		return factory;
	}

	/**
	 * Obtain the resource bundle for the given basename and {@link Locale}.
	 * @param basename the basename to look for
	 * @param locale the {@code Locale} to look for
	 * @return the corresponding {@code ResourceBundle}
	 * @throws MissingResourceException if no matching bundle could be found
	 * @see ResourceBundle#getBundle(String, Locale, ClassLoader)
	 */
	/**
	 * 获取给定基名和{@link 语言环境}的资源包。 
	 *  
	 * @param  basename寻找
	 * @param 语言环境的基本名称{{@code> Locale}寻找
	 * @return 对应的{@code  ResourceBundle} 
	 * @throws  MissingResourceException如果找不到匹配的包找到
	 * @see  ResourceBundle＃getBundle（String，Locale，ClassLoader）
	 */
	protected ResourceBundle getBundle(String basename, Locale locale) throws MissingResourceException {
		return ResourceBundle.getBundle(basename, locale, getBundleClassLoader());
	}


	/**
	 * Close the bundle View factories on context shutdown.
	 */
	/**
	 * 在上下文关闭时关闭捆绑包查看工厂。 
	 * 
	 */
	@Override
	public void destroy() throws BeansException {
		for (ConfigurableApplicationContext factory : this.bundleCache.values()) {
			factory.close();
		}
		this.localeCache.clear();
		this.bundleCache.clear();
	}

}
