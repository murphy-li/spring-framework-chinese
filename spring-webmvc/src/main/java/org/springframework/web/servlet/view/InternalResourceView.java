/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.servlet.view;

import java.util.Map;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.web.util.WebUtils;

/**
 * Wrapper for a JSP or other resource within the same web application.
 * Exposes model objects as request attributes and forwards the request to
 * the specified resource URL using a {@link javax.servlet.RequestDispatcher}.
 *
 * <p>A URL for this view is supposed to specify a resource within the web
 * application, suitable for RequestDispatcher's {@code forward} or
 * {@code include} method.
 *
 * <p>If operating within an already included request or within a response that
 * has already been committed, this view will fall back to an include instead of
 * a forward. This can be enforced by calling {@code response.flushBuffer()}
 * (which will commit the response) before rendering the view.
 *
 * <p>Typical usage with {@link InternalResourceViewResolver} looks as follows,
 * from the perspective of the DispatcherServlet context definition:
 *
 * <pre class="code">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
 *   &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
 *   &lt;property name="suffix" value=".jsp"/&gt;
 * &lt;/bean&gt;</pre>
 *
 * Every view name returned from a handler will be translated to a JSP
 * resource (for example: "myView" -> "/WEB-INF/jsp/myView.jsp"), using
 * this view class by default.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @see javax.servlet.RequestDispatcher#forward
 * @see javax.servlet.RequestDispatcher#include
 * @see javax.servlet.ServletResponse#flushBuffer
 * @see InternalResourceViewResolver
 * @see JstlView
 */
/**
 * 同一Web应用程序中的JSP或其他资源的包装。 
 * 将模型对象公开为请求属性，然后使用{@link  javax.servlet.RequestDispatcher}将请求转发到指定的资源URL。 
 *  <p>该视图的URL应该在Web应用程序中指定一个资源，适用于RequestDispatcher的{@code  forward}或{@code  include}方法。 
 *  <p>如果在已包含的请求中或已提交的响应中进行操作，则此视图将退回到包含而不是前进。 
 * 可以通过在渲染视图之前调用{@code  response.flushBuffer（）}（将提交响应）来强制实施此操作。 
 * 从DispatcherServlet上下文定义的角度来看，<p> {<@link> InternalResourceViewResolver}的典型用法如下所示：<pre class ="code"> <bean id ="viewResolver"class ="org.springframework.web。 
 *  servlet.view.InternalResourceViewResolver"> <属性名称="前缀"value ="/ WEB-INF / jsp /"/> <属性名称="后缀"value ="。 
 * jsp"/> </ bean> </ pre>默认情况下，使用此视图类，将从处理程序返回的每个视图名称都转换为JSP资源（例如："myView"->"/WEB-INF/jsp/myView.jsp"）。 
 *  @author  Rod Johnson @author  Juergen Hoeller @author  Rob Harrop 
 * @see  javax.servlet.RequestDispatcher＃forward 
 * @see  javax.servlet.RequestDispatcher＃include 
 * @see  javax.servlet.ServletResponse＃ flushBuffer 
 * @see  InternalResourceViewResolver 
 * @see  JstlView
 */
public class InternalResourceView extends AbstractUrlBasedView {

	private boolean alwaysInclude = false;

	private boolean preventDispatchLoop = false;


	/**
	 * Constructor for use as a bean.
	 * @see #setUrl
	 * @see #setAlwaysInclude
	 */
	/**
	 * 用作bean的构造方法。 
	 *  
	 * @see  #setUrl 
	 * @see  #setAlwaysInclude
	 */
	public InternalResourceView() {
	}

	/**
	 * Create a new InternalResourceView with the given URL.
	 * @param url the URL to forward to
	 * @see #setAlwaysInclude
	 */
	/**
	 * 使用给定的URL创建一个新的InternalResourceView。 
	 *  
	 * @param 将该URL URL转发到
	 * @see  #setAlwaysInclude
	 */
	public InternalResourceView(String url) {
		super(url);
	}

	/**
	 * Create a new InternalResourceView with the given URL.
	 * @param url the URL to forward to
	 * @param alwaysInclude whether to always include the view rather than forward to it
	 */
	/**
	 * 使用给定的URL创建一个新的InternalResourceView。 
	 *  
	 * @param 将要转发到
	 * @param 的URL用作URL总是包含是否始终包含视图而不是转发给视图
	 */
	public InternalResourceView(String url, boolean alwaysInclude) {
		super(url);
		this.alwaysInclude = alwaysInclude;
	}


	/**
	 * Specify whether to always include the view rather than forward to it.
	 * <p>Default is "false". Switch this flag on to enforce the use of a
	 * Servlet include, even if a forward would be possible.
	 * @see javax.servlet.RequestDispatcher#forward
	 * @see javax.servlet.RequestDispatcher#include
	 * @see #useInclude(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
	 */
	/**
	 * 指定是否始终包含视图而不是转发至视图。 
	 *  <p>默认为"false"。 
	 * 启用此标志以强制使用Servlet include，即使可能进行转发也是如此。 
	 *  
	 * @see  javax.servlet.RequestDispatcher＃forward 
	 * @see  javax.servlet.RequestDispatcher＃include 
	 * @see  #useInclude（javax.servlet.http.HttpServletRequest，javax.servlet.http.HttpServletResponse）
	 */
	public void setAlwaysInclude(boolean alwaysInclude) {
		this.alwaysInclude = alwaysInclude;
	}

	/**
	 * Set whether to explicitly prevent dispatching back to the
	 * current handler path.
	 * <p>Default is "false". Switch this to "true" for convention-based
	 * views where a dispatch back to the current handler path is a
	 * definitive error.
	 */
	/**
	 * 设置是否明确阻止分派回当前处理程序路径。 
	 *  <p>默认为"false"。 
	 * 对于基于约定的视图，请将其切换为"true"，在该视图中，分派回当前处理程序路径是确定的错误。 
	 * 
	 */
	public void setPreventDispatchLoop(boolean preventDispatchLoop) {
		this.preventDispatchLoop = preventDispatchLoop;
	}

	/**
	 * An ApplicationContext is not strictly required for InternalResourceView.
	 */
	/**
	 * InternalResourceView并非严格要求ApplicationContext。 
	 * 
	 */
	@Override
	protected boolean isContextRequired() {
		return false;
	}


	/**
	 * Render the internal resource given the specified model.
	 * This includes setting the model as request attributes.
	 */
	/**
	 * 根据指定的模型渲染内部资源。 
	 * 这包括将模型设置为请求属性。 
	 * 
	 */
	@Override
	protected void renderMergedOutputModel(
			Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {

		// Expose the model object as request attributes.
		exposeModelAsRequestAttributes(model, request);

		// Expose helpers as request attributes, if any.
		exposeHelpers(request);

		// Determine the path for the request dispatcher.
		String dispatcherPath = prepareForRendering(request, response);

		// Obtain a RequestDispatcher for the target resource (typically a JSP).
		RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
		if (rd == null) {
			throw new ServletException("Could not get RequestDispatcher for [" + getUrl() +
					"]: Check that the corresponding file exists within your web application archive!");
		}

		// If already included or response already committed, perform include, else forward.
		if (useInclude(request, response)) {
			response.setContentType(getContentType());
			if (logger.isDebugEnabled()) {
				logger.debug("Including [" + getUrl() + "]");
			}
			rd.include(request, response);
		}

		else {
			// Note: The forwarded resource is supposed to determine the content type itself.
			if (logger.isDebugEnabled()) {
				logger.debug("Forwarding to [" + getUrl() + "]");
			}
			rd.forward(request, response);
		}
	}

	/**
	 * Expose helpers unique to each rendering operation. This is necessary so that
	 * different rendering operations can't overwrite each other's contexts etc.
	 * <p>Called by {@link #renderMergedOutputModel(Map, HttpServletRequest, HttpServletResponse)}.
	 * The default implementation is empty. This method can be overridden to add
	 * custom helpers as request attributes.
	 * @param request current HTTP request
	 * @throws Exception if there's a fatal error while we're adding attributes
	 * @see #renderMergedOutputModel
	 * @see JstlView#exposeHelpers
	 */
	/**
	 * 公开每个渲染操作特有的助手。 
	 * 这是必要的，以便不同的呈现操作不能覆盖彼此的上下文等。 
	 * <p>由{@link  #renderMergedOutputModel（Map，HttpServletRequest，HttpServletResponse）}调用。 
	 * 默认实现为空。 
	 * 可以重写此方法以将自定义帮助程序添加为请求属性。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @throws 如果在添加属性时出现致命错误，则会发生异常
	 * @see  #renderMergedOutputModel 
	 * @see  JstlView＃exposeHelpers
	 */
	protected void exposeHelpers(HttpServletRequest request) throws Exception {
	}

	/**
	 * Prepare for rendering, and determine the request dispatcher path
	 * to forward to (or to include).
	 * <p>This implementation simply returns the configured URL.
	 * Subclasses can override this to determine a resource to render,
	 * typically interpreting the URL in a different manner.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @return the request dispatcher path to use
	 * @throws Exception if preparations failed
	 * @see #getUrl()
	 */
	/**
	 * 准备渲染，并确定要转发到（或包括在内）的请求分派器路径。 
	 *  <p>此实现仅返回配置的URL。 
	 * 子类可以重写此方法以确定要渲染的资源，通常以不同的方式解释URL。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 响应当前HTTP响应
	 * @return 要使用的请求调度程序路径
	 * @throws 如果准备失败，则异常
	 * @see  #getUrl（）
	 */
	protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response)
			throws Exception {

		String path = getUrl();
		Assert.state(path != null, "'url' not set");

		if (this.preventDispatchLoop) {
			String uri = request.getRequestURI();
			if (path.startsWith("/") ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) {
				throw new ServletException("Circular view path [" + path + "]: would dispatch back " +
						"to the current handler URL [" + uri + "] again. Check your ViewResolver setup! " +
						"(Hint: This may be the result of an unspecified view, due to default view name generation.)");
			}
		}
		return path;
	}

	/**
	 * Obtain the RequestDispatcher to use for the forward/include.
	 * <p>The default implementation simply calls
	 * {@link HttpServletRequest#getRequestDispatcher(String)}.
	 * Can be overridden in subclasses.
	 * @param request current HTTP request
	 * @param path the target URL (as returned from {@link #prepareForRendering})
	 * @return a corresponding RequestDispatcher
	 */
	/**
	 * 获取用于转发/包含的RequestDispatcher。 
	 *  <p>默认实现只是调用{@link  HttpServletRequest＃getRequestDispatcher（String）}。 
	 * 可以在子类中覆盖。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 路径目标URL（从{@link  #prepareForRendering}返回）
	 * @return 相应的RequestDispatcher
	 */
	@Nullable
	protected RequestDispatcher getRequestDispatcher(HttpServletRequest request, String path) {
		return request.getRequestDispatcher(path);
	}

	/**
	 * Determine whether to use RequestDispatcher's {@code include} or
	 * {@code forward} method.
	 * <p>Performs a check whether an include URI attribute is found in the request,
	 * indicating an include request, and whether the response has already been committed.
	 * In both cases, an include will be performed, as a forward is not possible anymore.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @return {@code true} for include, {@code false} for forward
	 * @see javax.servlet.RequestDispatcher#forward
	 * @see javax.servlet.RequestDispatcher#include
	 * @see javax.servlet.ServletResponse#isCommitted
	 * @see org.springframework.web.util.WebUtils#isIncludeRequest
	 */
	/**
	 * 确定是使用RequestDispatcher的{@code  include}还是{@code  forward}方法。 
	 *  <p>执行检查是否在请求中找到包含URI属性（指示包含请求），以及是否已经提交响应。 
	 * 在这两种情况下，都将执行包含操作，因为不再可能进行转发。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 响应当前HTTP响应
	 * @return  {@code  true}表示包含，{<@code> false}表示转发
	 * @see  javax.servlet.RequestDispatcher＃forward 
	 * @see  javax.servlet.RequestDispatcher＃include 
	 * @see  javax.servlet.ServletResponse＃isCommitted 
	 * @see  org.springframework.web.util.WebUtils＃isIncludeRequest
	 */
	protected boolean useInclude(HttpServletRequest request, HttpServletResponse response) {
		return (this.alwaysInclude || WebUtils.isIncludeRequest(request) || response.isCommitted());
	}

}
