/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.oxm.support;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLEventWriter;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;

import org.springframework.lang.Nullable;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;
import org.springframework.oxm.UnmarshallingFailureException;
import org.springframework.oxm.XmlMappingException;
import org.springframework.util.Assert;
import org.springframework.util.xml.StaxUtils;

/**
 * Abstract implementation of the {@code Marshaller} and {@code Unmarshaller} interface.
 * This implementation inspects the given {@code Source} or {@code Result}, and
 * delegates further handling to overridable template methods.
 *
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @since 3.0
 */
/**
 * {@code  Marshaller}和{@code  Unmarshaller}接口的抽象实现。 
 * 此实现检查给定的{@code  Source}或{@code  Result}，并将进一步的处理委托给可覆盖的模板方法。 
 *  @author  Arjen Poutsma @author  Juergen Hoeller @从3.0开始
 */
public abstract class AbstractMarshaller implements Marshaller, Unmarshaller {

	private static final EntityResolver NO_OP_ENTITY_RESOLVER =
			(publicId, systemId) -> new InputSource(new StringReader(""));

	/** Logger available to subclasses. */
	/**
	 * 记录器可用于子类。 
	 * 
	 */
	protected final Log logger = LogFactory.getLog(getClass());

	private boolean supportDtd = false;

	private boolean processExternalEntities = false;

	@Nullable
	private DocumentBuilderFactory documentBuilderFactory;

	private final Object documentBuilderFactoryMonitor = new Object();


	/**
	 * Indicate whether DTD parsing should be supported.
	 * <p>Default is {@code false} meaning that DTD is disabled.
	 */
	/**
	 * 指示是否应支持DTD解析。 
	 *  <p>默认值为{@code  false}，表示禁用了DTD。 
	 * 
	 */
	public void setSupportDtd(boolean supportDtd) {
		this.supportDtd = supportDtd;
	}

	/**
	 * Return whether DTD parsing is supported.
	 */
	/**
	 * 返回是否支持DTD解析。 
	 * 
	 */
	public boolean isSupportDtd() {
		return this.supportDtd;
	}

	/**
	 * Indicate whether external XML entities are processed when unmarshalling.
	 * <p>Default is {@code false}, meaning that external entities are not resolved.
	 * Note that processing of external entities will only be enabled/disabled when the
	 * {@code Source} passed to {@link #unmarshal(Source)} is a {@link SAXSource} or
	 * {@link StreamSource}. It has no effect for {@link DOMSource} or {@link StAXSource}
	 * instances.
	 * <p><strong>Note:</strong> setting this option to {@code true} also
	 * automatically sets {@link #setSupportDtd} to {@code true}.
	 */
	/**
	 * 指示在解组时是否处理外部XML实体。 
	 *  <p>默认值为{@code  false}，表示不解析外部实体。 
	 * 请注意，只有在传递给{@link  #unmarshal（Source）}的{@code  Source}是{@link  SAXSource}或{@link  StreamSource时，才可以启用/禁用对外部实体的处理。 
	 *  }。 
	 * 它对{@link  DOMSource}或{@link  StAXSource}实例无效。 
	 *  <p> <strong>注意</ strong>：将此选项设置为{@code  true}也会自动将{@link  #setSupportDtd}设置为{@code  true}。 
	 * 
	 */
	public void setProcessExternalEntities(boolean processExternalEntities) {
		this.processExternalEntities = processExternalEntities;
		if (processExternalEntities) {
			this.supportDtd = true;
		}
	}

	/**
	 * Return whether XML external entities are allowed.
	 * @see #createXmlReader()
	 */
	/**
	 * 返回是否允许XML外部实体。 
	 *  
	 * @see  #createXmlReader（）
	 */
	public boolean isProcessExternalEntities() {
		return this.processExternalEntities;
	}


	/**
	 * Build a new {@link Document} from this marshaller's {@link DocumentBuilderFactory},
	 * as a placeholder for a DOM node.
	 * @see #createDocumentBuilderFactory()
	 * @see #createDocumentBuilder(DocumentBuilderFactory)
	 */
	/**
	 * 从此编组者的{@link  DocumentBuilderFactory}构建一个新的{@link  Document}，作为DOM节点的占位符。 
	 *  
	 * @see  #createDocumentBuilderFactory（）
	 * @see  #createDocumentBuilder（DocumentBuilderFactory）
	 */
	protected Document buildDocument() {
		try {
			DocumentBuilder documentBuilder;
			synchronized (this.documentBuilderFactoryMonitor) {
				if (this.documentBuilderFactory == null) {
					this.documentBuilderFactory = createDocumentBuilderFactory();
				}
				documentBuilder = createDocumentBuilder(this.documentBuilderFactory);
			}
			return documentBuilder.newDocument();
		}
		catch (ParserConfigurationException ex) {
			throw new UnmarshallingFailureException("Could not create document placeholder: " + ex.getMessage(), ex);
		}
	}

	/**
	 * Create a {@code DocumentBuilder} that this marshaller will use for creating
	 * DOM documents when passed an empty {@code DOMSource}.
	 * <p>The resulting {@code DocumentBuilderFactory} is cached, so this method
	 * will only be called once.
	 * @return the DocumentBuilderFactory
	 * @throws ParserConfigurationException if thrown by JAXP methods
	 */
	/**
	 * 创建一个{@code  DocumentBuilder}，该编组将在传递一个空的{@code  DOMSource}时用于创建DOM文档。 
	 *  <p>生成的{@code  DocumentBuilderFactory}被缓存，因此该方法将仅被调用一次。 
	 *  
	 * @return  DocumentBuilderFactory 
	 * @throws  ParserConfigurationException如果由JAXP方法抛出
	 */
	protected DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setValidating(false);
		factory.setNamespaceAware(true);
		factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd());
		factory.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());
		return factory;
	}

	/**
	 * Create a {@code DocumentBuilder} that this marshaller will use for creating
	 * DOM documents when passed an empty {@code DOMSource}.
	 * <p>Can be overridden in subclasses, adding further initialization of the builder.
	 * @param factory the {@code DocumentBuilderFactory} that the DocumentBuilder should be created with
	 * @return the {@code DocumentBuilder}
	 * @throws ParserConfigurationException if thrown by JAXP methods
	 */
	/**
	 * 创建一个{@code  DocumentBuilder}，该编组将在传递一个空的{@code  DOMSource}时用于创建DOM文档。 
	 *  <p>可以在子类中重写，从而添加了构建器的进一步初始化。 
	 *  
	 * @param 工厂应该使用以下方法创建DocumentBuilder的{@code  DocumentBuilderFactory}：{
	 * @return> {@code  DocumentBuilder} 
	 * @throws  ParserConfigurationException（如果由JAXP方法抛出）
	 */
	protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory)
			throws ParserConfigurationException {

		DocumentBuilder documentBuilder = factory.newDocumentBuilder();
		if (!isProcessExternalEntities()) {
			documentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER);
		}
		return documentBuilder;
	}

	/**
	 * Create an {@code XMLReader} that this marshaller will when passed an empty {@code SAXSource}.
	 * @return the XMLReader
	 * @throws SAXException if thrown by JAXP methods
	 */
	/**
	 * 创建一个{@code  XMLReader}，该编组将在传递一个空的{@code  SAXSource}时使用。 
	 *  
	 * @return  XMLReader 
	 * @throws  SAXException（如果由JAXP方法抛出）
	 */
	@SuppressWarnings("deprecation")  // on JDK 9
	protected XMLReader createXmlReader() throws SAXException {
		XMLReader xmlReader = org.xml.sax.helpers.XMLReaderFactory.createXMLReader();
		xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd());
		xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());
		if (!isProcessExternalEntities()) {
			xmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);
		}
		return xmlReader;
	}

	/**
	 * Determine the default encoding to use for marshalling or unmarshalling from
	 * a byte stream, or {@code null} if none.
	 * <p>The default implementation returns {@code null}.
	 */
	/**
	 * 确定用于从字节流进行编组或解组的默认编码，如果没有，则确定{@code  null}。 
	 *  <p>默认实现返回{@code  null}。 
	 * 
	 */
	@Nullable
	protected String getDefaultEncoding() {
		return null;
	}


	// Marshalling

	/**
	 * Marshals the object graph with the given root into the provided {@code javax.xml.transform.Result}.
	 * <p>This implementation inspects the given result, and calls {@code marshalDomResult},
	 * {@code marshalSaxResult}, or {@code marshalStreamResult}.
	 * @param graph the root of the object graph to marshal
	 * @param result the result to marshal to
	 * @throws IOException if an I/O exception occurs
	 * @throws XmlMappingException if the given object cannot be marshalled to the result
	 * @throws IllegalArgumentException if {@code result} if neither a {@code DOMResult},
	 * a {@code SAXResult}, nor a {@code StreamResult}
	 * @see #marshalDomResult(Object, javax.xml.transform.dom.DOMResult)
	 * @see #marshalSaxResult(Object, javax.xml.transform.sax.SAXResult)
	 * @see #marshalStreamResult(Object, javax.xml.transform.stream.StreamResult)
	 */
	/**
	 * 将具有给定根的对象图编组到提供的{@code  javax.xml.transform.Result}中。 
	 *  <p>此实现检查给定的结果，并调用{@code  marshalDomResult}，{<@code> marshalSaxResult}或{@code  marshalStreamResult}。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param 将结果保存到
	 * @throws  IOException如果发生I / O异常
	 * @throws  XmlMappingException如果无法将给定的对象编组到结果
	 * @throws  IllegalArgumentException如果为{@code  result}，如果{@code  DOMResult}，{<@code> SAXResult}或{@code  StreamResult}都不为
	 * @see  #marshalDomResult（Object ，javax.xml.transform.dom.DOMResult）
	 * @see  #marshalSaxResult（Object，javax.xml.transform.sax.SAXResult）
	 * @see  #marshalStreamResult（Object，javax.xml.transform.stream.StreamResult）
	 */
	@Override
	public final void marshal(Object graph, Result result) throws IOException, XmlMappingException {
		if (result instanceof DOMResult) {
			marshalDomResult(graph, (DOMResult) result);
		}
		else if (StaxUtils.isStaxResult(result)) {
			marshalStaxResult(graph, result);
		}
		else if (result instanceof SAXResult) {
			marshalSaxResult(graph, (SAXResult) result);
		}
		else if (result instanceof StreamResult) {
			marshalStreamResult(graph, (StreamResult) result);
		}
		else {
			throw new IllegalArgumentException("Unknown Result type: " + result.getClass());
		}
	}

	/**
	 * Template method for handling {@code DOMResult}s.
	 * <p>This implementation delegates to {@code marshalDomNode}.
	 * @param graph the root of the object graph to marshal
	 * @param domResult the {@code DOMResult}
	 * @throws XmlMappingException if the given object cannot be marshalled to the result
	 * @throws IllegalArgumentException if the {@code domResult} is empty
	 * @see #marshalDomNode(Object, org.w3c.dom.Node)
	 */
	/**
	 * 用于处理{@code  DOMResult} s的模板方法。 
	 *  <p>此实现委托给{@code  marshalDomNode}。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param  domResult {@code  DOMResult} 
	 * @throws  XmlMappingException如果给定的对象无法编组到结果
	 * @throws  IllegalArgumentException如果{@code  domResult}为空
	 * @see  #marshalDomNode（Object，org.w3c.dom.Node）
	 */
	protected void marshalDomResult(Object graph, DOMResult domResult) throws XmlMappingException {
		if (domResult.getNode() == null) {
			domResult.setNode(buildDocument());
		}
		marshalDomNode(graph, domResult.getNode());
	}

	/**
	 * Template method for handling {@code StaxResult}s.
	 * <p>This implementation delegates to {@code marshalXMLSteamWriter} or
	 * {@code marshalXMLEventConsumer}, depending on what is contained in the
	 * {@code StaxResult}.
	 * @param graph the root of the object graph to marshal
	 * @param staxResult a JAXP 1.4 {@link StAXSource}
	 * @throws XmlMappingException if the given object cannot be marshalled to the result
	 * @throws IllegalArgumentException if the {@code domResult} is empty
	 * @see #marshalDomNode(Object, org.w3c.dom.Node)
	 */
	/**
	 * 用于处理{@code  StaxResult} s的模板方法。 
	 *  <p>此实现将委托给{@code  marshalXMLSteamWriter}或{@code  marshalXMLEventConsumer}，具体取决于{@code  StaxResult}中包含的内容。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param  staxResult一个JAXP 1.4 {@link  StAXSource} 
	 * @throws  XmlMappingException如果给定对象不能被编组到结果
	 * @throws  IllegalArgumentException {@code  domResult}为空
	 * @see  #marshalDomNode（Object，org.w3c.dom.Node）
	 */
	protected void marshalStaxResult(Object graph, Result staxResult) throws XmlMappingException {
		XMLStreamWriter streamWriter = StaxUtils.getXMLStreamWriter(staxResult);
		if (streamWriter != null) {
			marshalXmlStreamWriter(graph, streamWriter);
		}
		else {
			XMLEventWriter eventWriter = StaxUtils.getXMLEventWriter(staxResult);
			if (eventWriter != null) {
				marshalXmlEventWriter(graph, eventWriter);
			}
			else {
				throw new IllegalArgumentException("StaxResult contains neither XMLStreamWriter nor XMLEventConsumer");
			}
		}
	}

	/**
	 * Template method for handling {@code SAXResult}s.
	 * <p>This implementation delegates to {@code marshalSaxHandlers}.
	 * @param graph the root of the object graph to marshal
	 * @param saxResult the {@code SAXResult}
	 * @throws XmlMappingException if the given object cannot be marshalled to the result
	 * @see #marshalSaxHandlers(Object, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)
	 */
	/**
	 * 用于处理{@code  SAXResult} s的模板方法。 
	 *  <p>此实现委托给{@code  marshalSaxHandlers}。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param  saxResult {@code  SAXResult} 
	 * @throws  XmlMappingException如果无法将给定的对象编组为结果
	 * @see  #marshalSaxHandlers（Object， org.xml.sax.ContentHandler，org.xml.sax.ext.LexicalHandler）
	 */
	protected void marshalSaxResult(Object graph, SAXResult saxResult) throws XmlMappingException {
		ContentHandler contentHandler = saxResult.getHandler();
		Assert.notNull(contentHandler, "ContentHandler not set on SAXResult");
		LexicalHandler lexicalHandler = saxResult.getLexicalHandler();
		marshalSaxHandlers(graph, contentHandler, lexicalHandler);
	}

	/**
	 * Template method for handling {@code StreamResult}s.
	 * <p>This implementation delegates to {@code marshalOutputStream} or {@code marshalWriter},
	 * depending on what is contained in the {@code StreamResult}
	 * @param graph the root of the object graph to marshal
	 * @param streamResult the {@code StreamResult}
	 * @throws IOException if an I/O Exception occurs
	 * @throws XmlMappingException if the given object cannot be marshalled to the result
	 * @throws IllegalArgumentException if {@code streamResult} does neither
	 * contain an {@code OutputStream} nor a {@code Writer}
	 */
	/**
	 * 用于处理{@code  StreamResult} s的模板方法。 
	 *  <p>此实现将{{@code> StreamResult} 
	 * @param 图中包含的内容委托给{@code  marshalOutputStream}或{@code  marshalWriter} 
	 * @param  streamResult {@code  StreamResult} 
	 * @throws  IOException如果发生I / O异常
	 * @throws  XmlMappingException如果给定对象无法编组到结果
	 * @throws  IllegalArgumentException如果{<@code > streamResult}既不包含{@code  OutputStream}也不包含{@code  Writer}
	 */
	protected void marshalStreamResult(Object graph, StreamResult streamResult)
			throws XmlMappingException, IOException {

		if (streamResult.getOutputStream() != null) {
			marshalOutputStream(graph, streamResult.getOutputStream());
		}
		else if (streamResult.getWriter() != null) {
			marshalWriter(graph, streamResult.getWriter());
		}
		else {
			throw new IllegalArgumentException("StreamResult contains neither OutputStream nor Writer");
		}
	}


	// Unmarshalling

	/**
	 * Unmarshals the given provided {@code javax.xml.transform.Source} into an object graph.
	 * <p>This implementation inspects the given result, and calls {@code unmarshalDomSource},
	 * {@code unmarshalSaxSource}, or {@code unmarshalStreamSource}.
	 * @param source the source to marshal from
	 * @return the object graph
	 * @throws IOException if an I/O Exception occurs
	 * @throws XmlMappingException if the given source cannot be mapped to an object
	 * @throws IllegalArgumentException if {@code source} is neither a {@code DOMSource},
	 * a {@code SAXSource}, nor a {@code StreamSource}
	 * @see #unmarshalDomSource(javax.xml.transform.dom.DOMSource)
	 * @see #unmarshalSaxSource(javax.xml.transform.sax.SAXSource)
	 * @see #unmarshalStreamSource(javax.xml.transform.stream.StreamSource)
	 */
	/**
	 * 将提供的{@code  javax.xml.transform.Source}解组为对象图。 
	 *  <p>此实现检查给定的结果，并调用{@code  unmarshalDomSource}，{<@code> unmarshalSaxSource}或{@code  unmarshalStreamSource}。 
	 *  
	 * @param 源将要从
	 * @return 对象图进行封送的源
	 * @throws  IOException如果发生I / O异常
	 * @throws  XmlMappingException如果给定的源无法映射到对象
	 * @throws  IllegalArgumentException {@code  source}既不是{@code  DOMSource}，也不是{@code  SAXSource}，也不是{@code  StreamSource} 
	 * @see  #unmarshalDomSource（javax.xml.transform.dom .DOMSource）
	 * @see  #unmarshalSaxSource（javax.xml.transform.sax.SAXSource）
	 * @see  #unmarshalStreamSource（javax.xml.transform.stream.StreamSource）
	 */
	@Override
	public final Object unmarshal(Source source) throws IOException, XmlMappingException {
		if (source instanceof DOMSource) {
			return unmarshalDomSource((DOMSource) source);
		}
		else if (StaxUtils.isStaxSource(source)) {
			return unmarshalStaxSource(source);
		}
		else if (source instanceof SAXSource) {
			return unmarshalSaxSource((SAXSource) source);
		}
		else if (source instanceof StreamSource) {
			return unmarshalStreamSource((StreamSource) source);
		}
		else {
			throw new IllegalArgumentException("Unknown Source type: " + source.getClass());
		}
	}

	/**
	 * Template method for handling {@code DOMSource}s.
	 * <p>This implementation delegates to {@code unmarshalDomNode}.
	 * If the given source is empty, an empty source {@code Document}
	 * will be created as a placeholder.
	 * @param domSource the {@code DOMSource}
	 * @return the object graph
	 * @throws XmlMappingException if the given source cannot be mapped to an object
	 * @throws IllegalArgumentException if the {@code domSource} is empty
	 * @see #unmarshalDomNode(org.w3c.dom.Node)
	 */
	/**
	 * 用于处理{@code  DOMSource}的模板方法。 
	 *  <p>此实现委托给{@code  unmarshalDomNode}。 
	 * 如果给定的源为空，则将创建一个空的源{@code  Document}作为占位符。 
	 *  
	 * @param  domSource {@code  DOMSource} 
	 * @return 对象图
	 * @throws  XmlMappingException如果给定的源无法映射到对象
	 * @throws  IllegalArgumentException如果{@code  domSource}是空
	 * @see  #unmarshalDomNode（org.w3c.dom.Node）
	 */
	protected Object unmarshalDomSource(DOMSource domSource) throws XmlMappingException {
		if (domSource.getNode() == null) {
			domSource.setNode(buildDocument());
		}
		try {
			return unmarshalDomNode(domSource.getNode());
		}
		catch (NullPointerException ex) {
			if (!isSupportDtd()) {
				throw new UnmarshallingFailureException("NPE while unmarshalling. " +
						"This can happen on JDK 1.6 due to the presence of DTD " +
						"declarations, which are disabled.", ex);
			}
			throw ex;
		}
	}

	/**
	 * Template method for handling {@code StaxSource}s.
	 * <p>This implementation delegates to {@code unmarshalXmlStreamReader} or
	 * {@code unmarshalXmlEventReader}.
	 * @param staxSource the {@code StaxSource}
	 * @return the object graph
	 * @throws XmlMappingException if the given source cannot be mapped to an object
	 */
	/**
	 * 用于处理{@code  StaxSource} s的模板方法。 
	 *  <p>此实现委托给{@code  unmarshalXmlStreamReader}或{@code  unmarshalXmlEventReader}。 
	 *  
	 * @param  staxSource {@code  StaxSource} 
	 * @return 对象图
	 * @throws  XmlMappingException如果给定的源无法映射到对象
	 */
	protected Object unmarshalStaxSource(Source staxSource) throws XmlMappingException {
		XMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);
		if (streamReader != null) {
			return unmarshalXmlStreamReader(streamReader);
		}
		else {
			XMLEventReader eventReader = StaxUtils.getXMLEventReader(staxSource);
			if (eventReader != null) {
				return unmarshalXmlEventReader(eventReader);
			}
			else {
				throw new IllegalArgumentException("StaxSource contains neither XMLStreamReader nor XMLEventReader");
			}
		}
	}

	/**
	 * Template method for handling {@code SAXSource}s.
	 * <p>This implementation delegates to {@code unmarshalSaxReader}.
	 * @param saxSource the {@code SAXSource}
	 * @return the object graph
	 * @throws XmlMappingException if the given source cannot be mapped to an object
	 * @throws IOException if an I/O Exception occurs
	 * @see #unmarshalSaxReader(org.xml.sax.XMLReader, org.xml.sax.InputSource)
	 */
	/**
	 * 用于处理{@code  SAXSource}的模板方法。 
	 *  <p>此实现委托给{@code  unmarshalSaxReader}。 
	 *  
	 * @param  saxSource {{@@code> SAXSource} 
	 * @return 对象图
	 * @throws  XmlMappingException如果给定的源无法映射到对象
	 * @throws  IOException如果发生I / O异常<
	 * @see > #unmarshalSaxReader（org.xml.sax.XMLReader，org.xml.sax.InputSource）
	 */
	protected Object unmarshalSaxSource(SAXSource saxSource) throws XmlMappingException, IOException {
		if (saxSource.getXMLReader() == null) {
			try {
				saxSource.setXMLReader(createXmlReader());
			}
			catch (SAXException ex) {
				throw new UnmarshallingFailureException("Could not create XMLReader for SAXSource", ex);
			}
		}
		if (saxSource.getInputSource() == null) {
			saxSource.setInputSource(new InputSource());
		}
		try {
			return unmarshalSaxReader(saxSource.getXMLReader(), saxSource.getInputSource());
		}
		catch (NullPointerException ex) {
			if (!isSupportDtd()) {
				throw new UnmarshallingFailureException("NPE while unmarshalling. " +
						"This can happen on JDK 1.6 due to the presence of DTD " +
						"declarations, which are disabled.");
			}
			throw ex;
		}
	}

	/**
	 * Template method for handling {@code StreamSource}s.
	 * <p>This implementation delegates to {@code unmarshalInputStream} or {@code unmarshalReader}.
	 * @param streamSource the {@code StreamSource}
	 * @return the object graph
	 * @throws IOException if an I/O exception occurs
	 * @throws XmlMappingException if the given source cannot be mapped to an object
	 */
	/**
	 * 用于处理{@code  StreamSource} s的模板方法。 
	 *  <p>此实现委托给{@code  unmarshalInputStream}或{@code  unmarshalReader}。 
	 *  
	 * @param  streamSource {@code  StreamSource} 
	 * @return 对象图
	 * @throws  IOException如果发生I / O异常
	 * @throws  XmlMappingException如果给定的源无法映射到对象
	 */
	protected Object unmarshalStreamSource(StreamSource streamSource) throws XmlMappingException, IOException {
		if (streamSource.getInputStream() != null) {
			if (isProcessExternalEntities() && isSupportDtd()) {
				return unmarshalInputStream(streamSource.getInputStream());
			}
			else {
				InputSource inputSource = new InputSource(streamSource.getInputStream());
				inputSource.setEncoding(getDefaultEncoding());
				return unmarshalSaxSource(new SAXSource(inputSource));
			}
		}
		else if (streamSource.getReader() != null) {
			if (isProcessExternalEntities() && isSupportDtd()) {
				return unmarshalReader(streamSource.getReader());
			}
			else {
				return unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getReader())));
			}
		}
		else {
			return unmarshalSaxSource(new SAXSource(new InputSource(streamSource.getSystemId())));
		}
	}


	// Abstract template methods

	/**
	 * Abstract template method for marshalling the given object graph to a DOM {@code Node}.
	 * <p>In practice, node is be a {@code Document} node, a {@code DocumentFragment} node,
	 * or a {@code Element} node. In other words, a node that accepts children.
	 * @param graph the root of the object graph to marshal
	 * @param node the DOM node that will contain the result tree
	 * @throws XmlMappingException if the given object cannot be marshalled to the DOM node
	 * @see org.w3c.dom.Document
	 * @see org.w3c.dom.DocumentFragment
	 * @see org.w3c.dom.Element
	 */
	/**
	 * 用于将给定对象图编组到DOM {@code  Node}的抽象模板方法。 
	 *  <p>在实践中，节点可以是{@code  Document}节点，{<@code> DocumentFragment}节点或{@code  Element}节点。 
	 * 换句话说，就是一个接受子节点的节点。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param 节点，该DOM节点将包含结果树
	 * @throws  XmlMappingException如果无法将给定的对象编组到DOM节点
	 * @see  org.w3c .dom.Document 
	 * @see  org.w3c.dom.DocumentFragment 
	 * @see  org.w3c.dom.Element
	 */
	protected abstract void marshalDomNode(Object graph, Node node)
			throws XmlMappingException;

	/**
	 * Abstract template method for marshalling the given object to a StAX {@code XMLEventWriter}.
	 * @param graph the root of the object graph to marshal
	 * @param eventWriter the {@code XMLEventWriter} to write to
	 * @throws XmlMappingException if the given object cannot be marshalled to the DOM node
	 */
	/**
	 * 用于将给定对象编组到StAX {@code  XMLEventWriter}的抽象模板方法。 
	 *  
	 * @param 绘制对象图的根，以封送
	 * @param  eventWriter，如果无法将给定对象编组到DOM节点，则将{@code  XMLEventWriter}写入
	 * @throws  XmlMappingException。 
	 * 
	 */
	protected abstract void marshalXmlEventWriter(Object graph, XMLEventWriter eventWriter)
			throws XmlMappingException;

	/**
	 * Abstract template method for marshalling the given object to a StAX {@code XMLStreamWriter}.
	 * @param graph the root of the object graph to marshal
	 * @param streamWriter the {@code XMLStreamWriter} to write to
	 * @throws XmlMappingException if the given object cannot be marshalled to the DOM node
	 */
	/**
	 * 用于将给定对象编组到StAX {@code  XMLStreamWriter}的抽象模板方法。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param  streamWriter {@code  XMLStreamWriter}以写入
	 * @throws  XmlMappingException如果给定的对象不能被编组到DOM节点
	 */
	protected abstract void marshalXmlStreamWriter(Object graph, XMLStreamWriter streamWriter)
			throws XmlMappingException;

	/**
	 * Abstract template method for marshalling the given object graph to a SAX {@code ContentHandler}.
	 * @param graph the root of the object graph to marshal
	 * @param contentHandler the SAX {@code ContentHandler}
	 * @param lexicalHandler the SAX2 {@code LexicalHandler}. Can be {@code null}.
	 * @throws XmlMappingException if the given object cannot be marshalled to the handlers
	 */
	/**
	 * 用于将给定的对象图编组到SAX {@code  ContentHandler}的抽象模板方法。 
	 *  
	 * @param 绘制对象图的根以编组
	 * @param  contentHandler SAX {@code  ContentHandler} 
	 * @param  lexicalHandler SAX2 {@code  LexicalHandler}。 
	 * 可以为{@code  null}。 
	 *  
	 * @throws  XmlMappingException如果给定对象无法编组到处理程序
	 */
	protected abstract void marshalSaxHandlers(
			Object graph, ContentHandler contentHandler, @Nullable LexicalHandler lexicalHandler)
			throws XmlMappingException;

	/**
	 * Abstract template method for marshalling the given object graph to a {@code OutputStream}.
	 * @param graph the root of the object graph to marshal
	 * @param outputStream the {@code OutputStream} to write to
	 * @throws XmlMappingException if the given object cannot be marshalled to the writer
	 * @throws IOException if an I/O exception occurs
	 */
	/**
	 * 用于将给定的对象图编组到{@code  OutputStream}的抽象模板方法。 
	 *  
	 * @param 绘制对象图的根以进行编组
	 * @param  outputStream {{@@code> OutputStream}写入
	 * @throws  XmlMappingException如果给定的对象不能被编组到编写者中
	 * @throws  IOException发生I / O异常
	 */
	protected abstract void marshalOutputStream(Object graph, OutputStream outputStream)
			throws XmlMappingException, IOException;

	/**
	 * Abstract template method for marshalling the given object graph to a {@code Writer}.
	 * @param graph the root of the object graph to marshal
	 * @param writer the {@code Writer} to write to
	 * @throws XmlMappingException if the given object cannot be marshalled to the writer
	 * @throws IOException if an I/O exception occurs
	 */
	/**
	 * 用于将给定的对象图编组到{@code  Writer}的抽象模板方法。 
	 *  
	 * @param 图形化对象图的根以编组
	 * @param  writer {@code  Writer}以写入
	 * @throws  XmlMappingException如果给定的对象不能被编组到writer 
	 * @throws  IOException发生I / O异常
	 */
	protected abstract void marshalWriter(Object graph, Writer writer)
			throws XmlMappingException, IOException;

	/**
	 * Abstract template method for unmarshalling from a given DOM {@code Node}.
	 * @param node the DOM node that contains the objects to be unmarshalled
	 * @return the object graph
	 * @throws XmlMappingException if the given DOM node cannot be mapped to an object
	 */
	/**
	 * 用于从给定DOM {@code  Node}解组的抽象模板方法。 
	 *  
	 * @param 节点是包含要解组的对象的DOM节点
	 * @return 对象图
	 * @throws  XmlMappingException如果给定的DOM节点无法映射到对象
	 */
	protected abstract Object unmarshalDomNode(Node node) throws XmlMappingException;

	/**
	 * Abstract template method for unmarshalling from a given Stax {@code XMLEventReader}.
	 * @param eventReader the {@code XMLEventReader} to read from
	 * @return the object graph
	 * @throws XmlMappingException if the given event reader cannot be converted to an object
	 */
	/**
	 * 用于从给定Stax {@code  XMLEventReader}解组的抽象模板方法。 
	 *  
	 * @param  eventReader {@code  XMLEventReader}从
	 * @return 对象图
	 * @throws  XmlMappingException中读取，如果给定的事件阅读器无法转换为对象
	 */
	protected abstract Object unmarshalXmlEventReader(XMLEventReader eventReader)
			throws XmlMappingException;

	/**
	 * Abstract template method for unmarshalling from a given Stax {@code XMLStreamReader}.
	 * @param streamReader the {@code XMLStreamReader} to read from
	 * @return the object graph
	 * @throws XmlMappingException if the given stream reader cannot be converted to an object
	 */
	/**
	 * 用于从给定Stax {@code  XMLStreamReader}解组的抽象模板方法。 
	 *  
	 * @param  streamReader {{@@code> XMLStreamReader}从
	 * @return 对象图
	 * @throws  XmlMappingException中读取，如果给定的流阅读器无法转换为对象
	 */
	protected abstract Object unmarshalXmlStreamReader(XMLStreamReader streamReader)
			throws XmlMappingException;

	/**
	 * Abstract template method for unmarshalling using a given SAX {@code XMLReader}
	 * and {@code InputSource}.
	 * @param xmlReader the SAX {@code XMLReader} to parse with
	 * @param inputSource the input source to parse from
	 * @return the object graph
	 * @throws XmlMappingException if the given reader and input source cannot be converted to an object
	 * @throws IOException if an I/O exception occurs
	 */
	/**
	 * 使用给定的SAX {@code  XMLReader}和{@code  InputSource}进行解组的抽象模板方法。 
	 *  
	 * @param  xmlReader SAX {@code  XMLReader}与
	 * @param  inputSource进行解析，如果无法转换给定的阅读器和输入源，则从
	 * @return 对象图
	 * @throws  XmlMappingException解析输入源。 
	 * 如果发生I / O异常，则返回到对象
	 * @throws  IOException
	 */
	protected abstract Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource)
			throws XmlMappingException, IOException;

	/**
	 * Abstract template method for unmarshalling from a given {@code InputStream}.
	 * @param inputStream the {@code InputStreamStream} to read from
	 * @return the object graph
	 * @throws XmlMappingException if the given stream cannot be converted to an object
	 * @throws IOException if an I/O exception occurs
	 */
	/**
	 * 用于从给定的{@code  InputStream}解组的抽象模板方法。 
	 *  
	 * @param  inputStream {{@@code> InputStreamStream}从
	 * @return 对象图
	 * @throws  XmlMappingException读取，如果给定的流不能转换为对象
	 * @throws  IOException如果发生I / O异常
	 */
	protected abstract Object unmarshalInputStream(InputStream inputStream)
			throws XmlMappingException, IOException;

	/**
	 * Abstract template method for unmarshalling from a given {@code Reader}.
	 * @param reader the {@code Reader} to read from
	 * @return the object graph
	 * @throws XmlMappingException if the given reader cannot be converted to an object
	 * @throws IOException if an I/O exception occurs
	 */
	/**
	 * 用于从给定的{@code  Reader}解组的抽象模板方法。 
	 *  
	 * @param 读取器{{@@code>读取器}从
	 * @return 对象图读取
	 * @throws  XmlMappingException如果给定的读取器无法转换为对象
	 * @throws  IOException如果发生I / O异常
	 */
	protected abstract Object unmarshalReader(Reader reader)
			throws XmlMappingException, IOException;

}
