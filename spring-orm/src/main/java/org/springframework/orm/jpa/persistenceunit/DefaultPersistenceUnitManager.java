/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.orm.jpa.persistenceunit;

import java.io.IOException;
import java.net.URL;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.persistence.Converter;
import javax.persistence.Embeddable;
import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceException;
import javax.persistence.SharedCacheMode;
import javax.persistence.ValidationMode;
import javax.persistence.spi.PersistenceUnitInfo;
import javax.sql.DataSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.context.index.CandidateComponentsIndex;
import org.springframework.context.index.CandidateComponentsIndexLoader;
import org.springframework.context.weaving.LoadTimeWeaverAware;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternUtils;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.core.type.filter.TypeFilter;
import org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver;
import org.springframework.instrument.classloading.LoadTimeWeaver;
import org.springframework.jdbc.datasource.lookup.DataSourceLookup;
import org.springframework.jdbc.datasource.lookup.JndiDataSourceLookup;
import org.springframework.jdbc.datasource.lookup.MapDataSourceLookup;
import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.ResourceUtils;

/**
 * Default implementation of the {@link PersistenceUnitManager} interface.
 * Used as internal default by
 * {@link org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean}.
 *
 * <p>Supports standard JPA scanning for {@code persistence.xml} files,
 * with configurable file locations, JDBC DataSource lookup and load-time weaving.
 *
 * <p>The default XML file location is {@code classpath*:META-INF/persistence.xml},
 * scanning for all matching files in the classpath (as defined in the JPA specification).
 * DataSource names are by default interpreted as JNDI names, and no load time weaving
 * is available (which requires weaving to be turned off in the persistence provider).
 *
 * <p><b>NOTE: Spring's JPA support requires JPA 2.1 or higher, as of Spring 5.0.</b>
 *
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 2.0
 * @see #setPersistenceXmlLocations
 * @see #setDataSourceLookup
 * @see #setLoadTimeWeaver
 * @see org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean#setPersistenceUnitManager
 */
/**
 * {@link  PersistenceUnitManager}接口的默认实现。 
 *  {@link  org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean}用作内部默认值。 
 *  <p>支持对{@code  persistence.xml}文件的标准JPA扫描，具有可配置的文件位置，JDBC数据源查找和加载时编织。 
 *  <p>默认XML文件位置为{@code  classpath：META-INF / persistence.xml}，扫描类路径中所有匹配的文件（如JPA规范中所定义）。 
 * 默认情况下，DataSource名称被解释为JNDI名称，并且没有可用的加载时间编织（这需要在持久性提供程序中关闭编织）。 
 *  <p> <b>注：从Spring 5.0开始，Spring的JPA支持需要JPA 2.1或更高版本。 
 * </ b> @author  Juergen Hoeller @author  Stephane Nicoll @since 2.0起> #setDataSourceLookup 
 * @see  #setLoadTimeWeaver 
 * @see  org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean＃setPersistenceUnitManager
 */
public class DefaultPersistenceUnitManager
		implements PersistenceUnitManager, ResourceLoaderAware, LoadTimeWeaverAware, InitializingBean {

	private static final String CLASS_RESOURCE_PATTERN = "/**/*.class";

	private static final String PACKAGE_INFO_SUFFIX = ".package-info";

	private static final String DEFAULT_ORM_XML_RESOURCE = "META-INF/orm.xml";

	private static final String PERSISTENCE_XML_FILENAME = "persistence.xml";

	/**
	 * Default location of the {@code persistence.xml} file:
	 * "classpath*:META-INF/persistence.xml".
	 */
	/**
	 * {@code  persistence.xml}文件的默认位置："classpath：META-INF / persistence.xml"。 
	 * 
	 */
	public static final String DEFAULT_PERSISTENCE_XML_LOCATION = "classpath*:META-INF/" + PERSISTENCE_XML_FILENAME;

	/**
	 * Default location for the persistence unit root URL:
	 * "classpath:", indicating the root of the classpath.
	 */
	/**
	 * 持久性单元根URL的默认位置："classpath："，指示类路径的根。 
	 * 
	 */
	public static final String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION = "classpath:";

	/**
	 * Default persistence unit name.
	 */
	/**
	 * 默认持久性单元名称。 
	 * 
	 */
	public static final String ORIGINAL_DEFAULT_PERSISTENCE_UNIT_NAME = "default";


	private static final Set<AnnotationTypeFilter> entityTypeFilters;

	static {
		entityTypeFilters = new LinkedHashSet<>(8);
		entityTypeFilters.add(new AnnotationTypeFilter(Entity.class, false));
		entityTypeFilters.add(new AnnotationTypeFilter(Embeddable.class, false));
		entityTypeFilters.add(new AnnotationTypeFilter(MappedSuperclass.class, false));
		entityTypeFilters.add(new AnnotationTypeFilter(Converter.class, false));
	}


	protected final Log logger = LogFactory.getLog(getClass());

	private String[] persistenceXmlLocations = new String[] {DEFAULT_PERSISTENCE_XML_LOCATION};

	@Nullable
	private String defaultPersistenceUnitRootLocation = ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION;

	@Nullable
	private String defaultPersistenceUnitName = ORIGINAL_DEFAULT_PERSISTENCE_UNIT_NAME;

	@Nullable
	private String[] packagesToScan;

	@Nullable
	private String[] mappingResources;

	@Nullable
	private SharedCacheMode sharedCacheMode;

	@Nullable
	private ValidationMode validationMode;

	private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();

	@Nullable
	private DataSource defaultDataSource;

	@Nullable
	private DataSource defaultJtaDataSource;

	@Nullable
	private PersistenceUnitPostProcessor[] persistenceUnitPostProcessors;

	@Nullable
	private LoadTimeWeaver loadTimeWeaver;

	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();

	@Nullable
	private CandidateComponentsIndex componentsIndex;

	private final Set<String> persistenceUnitInfoNames = new HashSet<>();

	private final Map<String, PersistenceUnitInfo> persistenceUnitInfos = new HashMap<>();


	/**
	 * Specify the location of the {@code persistence.xml} files to load.
	 * These can be specified as Spring resource locations and/or location patterns.
	 * <p>Default is "classpath*:META-INF/persistence.xml".
	 */
	/**
	 * 指定要加载的{@code  persistence.xml}文件的位置。 
	 * 这些可以指定为Spring资源位置和/或位置模式。 
	 *  <p>默认为"classpath：META-INF / persistence.xml"。 
	 * 
	 */
	public void setPersistenceXmlLocation(String persistenceXmlLocation) {
		this.persistenceXmlLocations = new String[] {persistenceXmlLocation};
	}

	/**
	 * Specify multiple locations of {@code persistence.xml} files to load.
	 * These can be specified as Spring resource locations and/or location patterns.
	 * <p>Default is "classpath*:META-INF/persistence.xml".
	 * @param persistenceXmlLocations an array of Spring resource Strings
	 * identifying the location of the {@code persistence.xml} files to read
	 */
	/**
	 * 指定{@code  persistence.xml}文件的多个位置以进行加载。 
	 * 这些可以指定为Spring资源位置和/或位置模式。 
	 *  <p>默认为"classpath：META-INF / persistence.xml"。 
	 *  
	 * @param  persistenceXmlLocations定位一个Spring资源字符串数组，该数组标识要读取的{@code  persistence.xml}文件的位置
	 */
	public void setPersistenceXmlLocations(String... persistenceXmlLocations) {
		this.persistenceXmlLocations = persistenceXmlLocations;
	}

	/**
	 * Set the default persistence unit root location, to be applied
	 * if no unit-specific persistence unit root could be determined.
	 * <p>Default is "classpath:", that is, the root of the current classpath
	 * (nearest root directory). To be overridden if unit-specific resolution
	 * does not work and the classpath root is not appropriate either.
	 */
	/**
	 * 设置默认的持久性单元根目录位置，如果无法确定特定于单元的持久性单元根目录，则应用该默认值。 
	 *  <p>默认值为"classpath："，即当前类路径的根（最近的根目录）。 
	 * 如果特定于单元的解析不起作用并且classpath根也不适合，则将其覆盖。 
	 * 
	 */
	public void setDefaultPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation) {
		this.defaultPersistenceUnitRootLocation = defaultPersistenceUnitRootLocation;
	}

	/**
	 * Specify the name of the default persistence unit, if any. Default is "default".
	 * <p>Primarily applied to a scanned persistence unit without {@code persistence.xml}.
	 * Also applicable to selecting a default unit from several persistence units available.
	 * @see #setPackagesToScan
	 * @see #obtainDefaultPersistenceUnitInfo
	 */
	/**
	 * 指定默认持久性单元的名称（如果有）。 
	 * 默认为"默认"。 
	 *  <p>主要应用于没有{@code  persistence.xml}的扫描的持久性单元。 
	 * 也适用于从几个可用的持久性单元中选择默认单元。 
	 *  
	 * @see  #setPackagesToScan 
	 * @see  #obtainDefaultPersistenceUnitInfo
	 */
	public void setDefaultPersistenceUnitName(String defaultPersistenceUnitName) {
		this.defaultPersistenceUnitName = defaultPersistenceUnitName;
	}

	/**
	 * Set whether to use Spring-based scanning for entity classes in the classpath
	 * instead of using JPA's standard scanning of jar files with {@code persistence.xml}
	 * markers in them. In case of Spring-based scanning, no {@code persistence.xml}
	 * is necessary; all you need to do is to specify base packages to search here.
	 * <p>Default is none. Specify packages to search for autodetection of your entity
	 * classes in the classpath. This is analogous to Spring's component-scan feature
	 * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).
	 * <p>Such package scanning defines a "default persistence unit" in Spring, which
	 * may live next to regularly defined units originating from {@code persistence.xml}.
	 * Its name is determined by {@link #setDefaultPersistenceUnitName}: by default,
	 * it's simply "default".
	 * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>
	 * In particular, JPA providers may pick up annotated packages for provider-specific
	 * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's
	 * scan can detect annotated packages as well if supported by the given
	 * {@link org.springframework.orm.jpa.JpaVendorAdapter} (e.g. for Hibernate).
	 * <p>If no explicit {@link #setMappingResources mapping resources} have been
	 * specified in addition to these packages, this manager looks for a default
	 * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping
	 * resource for the default unit if the mapping file is not co-located with a
	 * {@code persistence.xml} file (in which case we assume it is only meant to be
	 * used with the persistence units defined there, like in standard JPA).
	 * @see #setDefaultPersistenceUnitName
	 * @see #setMappingResources
	 */
	/**
	 * 设置是否对类路径中的实体类使用基于Spring的扫描，而不是对其中带有{@code  persistence.xml}标记的jar文件使用JPA的标准扫描。 
	 * 如果是基于Spring的扫描，则不需要{@code  persistence.xml}。 
	 * 您需要做的就是指定要在此处搜索的基本软件包。 
	 *  <p>默认为无。 
	 * 指定包以在类路径中搜索对实体类的自动检测。 
	 * 这类似于Spring的组件扫描功能（{@link  org.springframework.context.annotation.ClassPathBeanDefinitionScanner}）。 
	 *  <p>这种软件包扫描在Spring中定义了一个"默认持久性单元"，它可能位于源自{@code  persistence.xml}的定期定义的单元旁边。 
	 * 其名称由{@link  #setDefaultPersistenceUnitName}确定：默认情况下，它只是"默认"。 
	 *  <p> <b>注意：与常规JPA扫描相比，可能会有一些限制。 
	 * </ b>特别是，JPA提供程序只有在受{@code  persistence.xml驱动时，才可以为提供程序特定的注释选择带注释的程序包。 
	 *  }。 
	 * 从4.1开始，如果给定的{@link  org.springframework.orm.jpa.JpaVendorAdapter}支持，Spring的扫描程序也可以检测带注释的包（例如，对于Hibernate）。 
	 *  <p>如果除了这些软件包之外未指定任何明确的{@link  #setMappingResources映射资源}，则此管理器会在类路径中查找默认的{@code  META-INF / orm.xml}文件，进行注册如果映射文件未与{@code  persistence.xml}文件位于同一位置，则将其作为默认单元的映射资源（在这种情况下，我们假定它仅与在那里定义的持久性单元一起使用，就像在标准JPA中一样）。 
	 *  
	 * @see  #setDefaultPersistenceUnitName 
	 * @see  #setMappingResources
	 */
	public void setPackagesToScan(String... packagesToScan) {
		this.packagesToScan = packagesToScan;
	}

	/**
	 * Specify one or more mapping resources (equivalent to {@code <mapping-file>}
	 * entries in {@code persistence.xml}) for the default persistence unit.
	 * Can be used on its own or in combination with entity scanning in the classpath,
	 * in both cases avoiding {@code persistence.xml}.
	 * <p>Note that mapping resources must be relative to the classpath root,
	 * e.g. "META-INF/mappings.xml" or "com/mycompany/repository/mappings.xml",
	 * so that they can be loaded through {@code ClassLoader.getResource}.
	 * <p>If no explicit mapping resources have been specified next to
	 * {@link #setPackagesToScan packages to scan}, this manager looks for a default
	 * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping
	 * resource for the default unit if the mapping file is not co-located with a
	 * {@code persistence.xml} file (in which case we assume it is only meant to be
	 * used with the persistence units defined there, like in standard JPA).
	 * <p>Note that specifying an empty array/list here suppresses the default
	 * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying
	 * {@code META-INF/orm.xml} here will register that file even if it happens
	 * to be co-located with a {@code persistence.xml} file.
	 * @see #setDefaultPersistenceUnitName
	 * @see #setPackagesToScan
	 */
	/**
	 * 为默认持久性单元指定一个或多个映射资源（相当于{@code  persistence.xml}中的{@code  <mapping-file>}条目）。 
	 * 在两种情况下都可以避免使用{@code  persistence.xml}，可以单独使用或与类路径中的实体扫描结合使用。 
	 *  <p>请注意，映射资源必须相对于类路径根，例如"META-INF / mappings.xml"或"com / mycompany / repository / mappings.xml"，以便可以通过{@code  ClassLoader.getResource}加载它们。 
	 *  <p>如果未在{@link  #setPackagesToScan要扫描的软件包}旁边指定显式映射资源，则此管理器将在类路径中查找默认的{@code  META-INF / orm.xml}文件，进行注册如果映射文件未与{@code  persistence.xml}文件位于同一位置，则将其作为默认单元的映射资源（在这种情况下，我们假定它仅与在那里定义的持久性单元一起使用，就像在标准JPA中一样）。 
	 *  <p>请注意，在此处指定一个空数组/列表将禁止默认的{@code  META-INF / orm.xml}检查。 
	 * 另一方面，在此处明确指定{@code  META-INF / orm.xml}将注册该文件，即使该文件恰巧与{@code  persistence.xml}文件位于同一位置。 
	 *  
	 * @see  #setDefaultPersistenceUnitName 
	 * @see  #setPackagesToScan
	 */
	public void setMappingResources(String... mappingResources) {
		this.mappingResources = mappingResources;
	}

	/**
	 * Specify the JPA 2.0 shared cache mode for all of this manager's persistence
	 * units, overriding any value in {@code persistence.xml} if set.
	 * @since 4.0
	 * @see javax.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()
	 */
	/**
	 * 为该管理器的所有持久性单元指定JPA 2.0共享缓存模式，如果设置，则覆盖{@code  persistence.xml}中的任何值。 
	 *  @since 4.0 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getSharedCacheMode（）
	 */
	public void setSharedCacheMode(SharedCacheMode sharedCacheMode) {
		this.sharedCacheMode = sharedCacheMode;
	}

	/**
	 * Specify the JPA 2.0 validation mode for all of this manager's persistence
	 * units, overriding any value in {@code persistence.xml} if set.
	 * @since 4.0
	 * @see javax.persistence.spi.PersistenceUnitInfo#getValidationMode()
	 */
	/**
	 * 为该管理器的所有持久性单元指定JPA 2.0验证模式，如果设置则覆盖{@code  persistence.xml}中的任何值。 
	 *  @since 4.0 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getValidationMode（）
	 */
	public void setValidationMode(ValidationMode validationMode) {
		this.validationMode = validationMode;
	}

	/**
	 * Specify the JDBC DataSources that the JPA persistence provider is supposed
	 * to use for accessing the database, resolving data source names in
	 * {@code persistence.xml} against Spring-managed DataSources.
	 * <p>The specified Map needs to define data source names for specific DataSource
	 * objects, matching the data source names used in {@code persistence.xml}.
	 * If not specified, data source names will be resolved as JNDI names instead
	 * (as defined by standard JPA).
	 * @see org.springframework.jdbc.datasource.lookup.MapDataSourceLookup
	 */
	/**
	 * 指定JPA持久性提供程序用于访问数据库的JDBC数据源，并根据Spring托管的数据源解析{@code  persistence.xml}中的数据源名称。 
	 *  <p>指定的Map需要定义特定DataSource对象的数据源名称，以匹配{@code  persistence.xml}中使用的数据源名称。 
	 * 如果未指定，则将数据源名称解析为JNDI名称（由标准JPA定义）。 
	 *  
	 * @see  org.springframework.jdbc.datasource.lookup.MapDataSourceLookup
	 */
	public void setDataSources(Map<String, DataSource> dataSources) {
		this.dataSourceLookup = new MapDataSourceLookup(dataSources);
	}

	/**
	 * Specify the JDBC DataSourceLookup that provides DataSources for the
	 * persistence provider, resolving data source names in {@code persistence.xml}
	 * against Spring-managed DataSource instances.
	 * <p>Default is JndiDataSourceLookup, which resolves DataSource names as
	 * JNDI names (as defined by standard JPA). Specify a BeanFactoryDataSourceLookup
	 * instance if you want DataSource names to be resolved against Spring bean names.
	 * <p>Alternatively, consider passing in a map from names to DataSource instances
	 * via the "dataSources" property. If the {@code persistence.xml} file
	 * does not define DataSource names at all, specify a default DataSource
	 * via the "defaultDataSource" property.
	 * @see org.springframework.jdbc.datasource.lookup.JndiDataSourceLookup
	 * @see org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookup
	 * @see #setDataSources
	 * @see #setDefaultDataSource
	 */
	/**
	 * 指定JDBC DataSourceLookup，它为持久性提供程序提供数据源，从而针对Spring管理的DataSource实例解析{@code  persistence.xml}中的数据源名称。 
	 *  <p>默认值为JndiDataSourceLookup，它将数据源名称解析为JNDI名称（由标准JPA定义）。 
	 * 如果您想将数据源名称解析为Spring bean名称，请指定BeanFactoryDataSourceLookup实例。 
	 *  <p>或者，考虑通过"dataSources"属性将名称从映射传递到DataSource实例。 
	 * 如果{@code  persistence.xml}文件根本没有定义数据源名称，请通过"defaultDataSource"属性指定一个默认数据源。 
	 *  
	 * @see  org.springframework.jdbc.datasource.lookup.JndiDataSourceLookup 
	 * @see  org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookup 
	 * @see  #setDataSources 
	 * @see  #setDefaultDataSource
	 */
	public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {
		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());
	}

	/**
	 * Return the JDBC DataSourceLookup that provides DataSources for the
	 * persistence provider, resolving data source names in {@code persistence.xml}
	 * against Spring-managed DataSource instances.
	 */
	/**
	 * 返回为持久性提供程序提供数据源的JDBC DataSourceLookup，针对Spring托管的DataSource实例解析{@code  persistence.xml}中的数据源名称。 
	 * 
	 */
	@Nullable
	public DataSourceLookup getDataSourceLookup() {
		return this.dataSourceLookup;
	}

	/**
	 * Specify the JDBC DataSource that the JPA persistence provider is supposed to use
	 * for accessing the database if none has been specified in {@code persistence.xml}.
	 * This variant indicates no special transaction setup, i.e. typical resource-local.
	 * <p>In JPA speak, a DataSource passed in here will be uses as "nonJtaDataSource"
	 * on the PersistenceUnitInfo passed to the PersistenceProvider, provided that
	 * none has been registered before.
	 * @see javax.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()
	 */
	/**
	 * 如果在{@code  persistence.xml}中未指定JPA持久性提供程序用于访问数据库的JDBC数据源，则指定该数据源。 
	 * 此变体表示没有特殊的交易设置，即典型的本地资源。 
	 *  <p>用JPA讲，这里传递的数据源将用作传递给PersistenceProvider的PersistenceUnitInfo上的"nonJtaDataSource"，前提是以前没有注册过。 
	 *  
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getNonJtaDataSource（）
	 */
	public void setDefaultDataSource(@Nullable DataSource defaultDataSource) {
		this.defaultDataSource = defaultDataSource;
	}

	/**
	 * Return the JDBC DataSource that the JPA persistence provider is supposed to use
	 * for accessing the database if none has been specified in {@code persistence.xml}.
	 */
	/**
	 * 如果在{@code  persistence.xml}中未指定JPA持久性提供程序用于访问数据库的JDBC数据源，则返回该数据源。 
	 * 
	 */
	@Nullable
	public DataSource getDefaultDataSource() {
		return this.defaultDataSource;
	}

	/**
	 * Specify the JDBC DataSource that the JPA persistence provider is supposed to use
	 * for accessing the database if none has been specified in {@code persistence.xml}.
	 * This variant indicates that JTA is supposed to be used as transaction type.
	 * <p>In JPA speak, a DataSource passed in here will be uses as "jtaDataSource"
	 * on the PersistenceUnitInfo passed to the PersistenceProvider, provided that
	 * none has been registered before.
	 * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource()
	 */
	/**
	 * 如果在{@code  persistence.xml}中未指定JPA持久性提供程序用于访问数据库的JDBC数据源，则指定该数据源。 
	 * 此变体表明应该将JTA用作事务类型。 
	 *  <p>用JPA讲，如果之前没有注册过，则此处传递的数据源将用作传递给PersistenceProvider的PersistenceUnitInfo上的"jtaDataSource"。 
	 *  
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getJtaDataSource（）
	 */
	public void setDefaultJtaDataSource(@Nullable DataSource defaultJtaDataSource) {
		this.defaultJtaDataSource = defaultJtaDataSource;
	}

	/**
	 * Return the JTA-aware DataSource that the JPA persistence provider is supposed to use
	 * for accessing the database if none has been specified in {@code persistence.xml}.
	 */
	/**
	 * 如果在{@code  persistence.xml}中未指定JPA持久性提供程序用于访问数据库，则返回该JTA感知数据源。 
	 * 
	 */
	@Nullable
	public DataSource getDefaultJtaDataSource() {
		return this.defaultJtaDataSource;
	}

	/**
	 * Set the PersistenceUnitPostProcessors to be applied to each
	 * PersistenceUnitInfo that has been parsed by this manager.
	 * <p>Such post-processors can, for example, register further entity classes and
	 * jar files, in addition to the metadata read from {@code persistence.xml}.
	 */
	/**
	 * 将PersistenceUnitPostProcessors设置为将应用于该管理器已解析的每个PersistenceUnitInfo。 
	 *  <p>除了从{@code  persistence.xml}读取的元数据外，此类后处理器还可以例如注册其他实体类和jar文件。 
	 * 
	 */
	public void setPersistenceUnitPostProcessors(@Nullable PersistenceUnitPostProcessor... postProcessors) {
		this.persistenceUnitPostProcessors = postProcessors;
	}

	/**
	 * Return the PersistenceUnitPostProcessors to be applied to each
	 * PersistenceUnitInfo that has been parsed by this manager.
	 */
	/**
	 * 返回要应用到此管理器已解析的每个PersistenceUnitInfo的PersistenceUnitPostProcessors。 
	 * 
	 */
	@Nullable
	public PersistenceUnitPostProcessor[] getPersistenceUnitPostProcessors() {
		return this.persistenceUnitPostProcessors;
	}

	/**
	 * Specify the Spring LoadTimeWeaver to use for class instrumentation according
	 * to the JPA class transformer contract.
	 * <p>It is not required to specify a LoadTimeWeaver: Most providers will be able
	 * to provide a subset of their functionality without class instrumentation as well,
	 * or operate with their own VM agent specified on JVM startup. Furthermore,
	 * DefaultPersistenceUnitManager falls back to an InstrumentationLoadTimeWeaver
	 * if Spring's agent-based instrumentation is available at runtime.
	 * <p>In terms of Spring-provided weaving options, the most important ones are
	 * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)
	 * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts
	 * with an underlying ClassLoader based on specific extended methods being available
	 * on it (for example, interacting with Spring's TomcatInstrumentableClassLoader).
	 * Consider using the {@code context:load-time-weaver} XML tag for creating
	 * such a shared LoadTimeWeaver (autodetecting the environment by default).
	 * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver
	 * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver
	 */
	/**
	 * 根据JPA类转换器协定，指定要用于类检测的Spring LoadTimeWeaver。 
	 *  <p>不需要指定LoadTimeWeaver：大多数提供程序也将能够提供其功能的子集而无需类检测，也可以使用在JVM启动时指定的自己的VM代理进行操作。 
	 * 此外，如果Spring的基于代理的工具在运行时可用，则DefaultPersistenceUnitManager会退回到InstrumentationLoadTimeWeaver。 
	 *  <p>就Spring提供的编织选项而言，最重要的是InstrumentationLoadTimeWeaver，它需要在JVM启动时指定一个Spring特定（但非常通用）的VM代理； 
	 *  ReflectiveLoadTimeWeaver，它根据特定的扩展与底层的ClassLoader交互可用的方法（例如，与Spring的TomcatInstrumentableClassLoader交互）。 
	 * 考虑使用{@code  context：load-time-weaver} XML标签来创建这样的共享LoadTimeWeaver（默认情况下自动检测环境）。 
	 *  
	 * @see  org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver 
	 * @see  org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver
	 */
	@Override
	public void setLoadTimeWeaver(@Nullable LoadTimeWeaver loadTimeWeaver) {
		this.loadTimeWeaver = loadTimeWeaver;
	}

	/**
	 * Return the Spring LoadTimeWeaver to use for class instrumentation according
	 * to the JPA class transformer contract.
	 */
	/**
	 * 根据JPA类转换器协定，返回Spring LoadTimeWeaver以用于类检测。 
	 * 
	 */
	@Nullable
	public LoadTimeWeaver getLoadTimeWeaver() {
		return this.loadTimeWeaver;
	}

	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
		this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(resourceLoader.getClassLoader());
	}


	@Override
	public void afterPropertiesSet() {
		if (this.loadTimeWeaver == null && InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {
			this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(this.resourcePatternResolver.getClassLoader());
		}
		preparePersistenceUnitInfos();
	}

	/**
	 * Prepare the PersistenceUnitInfos according to the configuration
	 * of this manager: scanning for {@code persistence.xml} files,
	 * parsing all matching files, configuring and post-processing them.
	 * <p>PersistenceUnitInfos cannot be obtained before this preparation
	 * method has been invoked.
	 * @see #obtainDefaultPersistenceUnitInfo()
	 * @see #obtainPersistenceUnitInfo(String)
	 */
	/**
	 * 根据此管理器的配置来准备PersistenceUnitInfos：扫描{@code  persistence.xml}文件，解析所有匹配的文件，对其进行配置和后处理。 
	 *  <p>在调用此准备方法之前无法获得PersistenceUnitInfos。 
	 *  
	 * @see  #obtainDefaultPersistenceUnitInfo（）
	 * @see  #obtainPersistenceUnitInfo（String）
	 */
	public void preparePersistenceUnitInfos() {
		this.persistenceUnitInfoNames.clear();
		this.persistenceUnitInfos.clear();

		List<SpringPersistenceUnitInfo> puis = readPersistenceUnitInfos();
		for (SpringPersistenceUnitInfo pui : puis) {
			if (pui.getPersistenceUnitRootUrl() == null) {
				pui.setPersistenceUnitRootUrl(determineDefaultPersistenceUnitRootUrl());
			}
			if (pui.getJtaDataSource() == null && this.defaultJtaDataSource != null) {
				pui.setJtaDataSource(this.defaultJtaDataSource);
			}
			if (pui.getNonJtaDataSource() == null && this.defaultDataSource != null) {
				pui.setNonJtaDataSource(this.defaultDataSource);
			}
			if (this.sharedCacheMode != null) {
				pui.setSharedCacheMode(this.sharedCacheMode);
			}
			if (this.validationMode != null) {
				pui.setValidationMode(this.validationMode);
			}
			if (this.loadTimeWeaver != null) {
				pui.init(this.loadTimeWeaver);
			}
			else {
				pui.init(this.resourcePatternResolver.getClassLoader());
			}
			postProcessPersistenceUnitInfo(pui);
			String name = pui.getPersistenceUnitName();
			if (!this.persistenceUnitInfoNames.add(name) && !isPersistenceUnitOverrideAllowed()) {
				StringBuilder msg = new StringBuilder();
				msg.append("Conflicting persistence unit definitions for name '").append(name).append("': ");
				msg.append(pui.getPersistenceUnitRootUrl()).append(", ");
				msg.append(this.persistenceUnitInfos.get(name).getPersistenceUnitRootUrl());
				throw new IllegalStateException(msg.toString());
			}
			this.persistenceUnitInfos.put(name, pui);
		}
	}

	/**
	 * Read all persistence unit infos from {@code persistence.xml},
	 * as defined in the JPA specification.
	 */
	/**
	 * 按照JPA规范中的定义，从{@code  persistence.xml}中读取所有持久性单元信息。 
	 * 
	 */
	private List<SpringPersistenceUnitInfo> readPersistenceUnitInfos() {
		List<SpringPersistenceUnitInfo> infos = new LinkedList<>();
		String defaultName = this.defaultPersistenceUnitName;
		boolean buildDefaultUnit = (this.packagesToScan != null || this.mappingResources != null);
		boolean foundDefaultUnit = false;

		PersistenceUnitReader reader = new PersistenceUnitReader(this.resourcePatternResolver, this.dataSourceLookup);
		SpringPersistenceUnitInfo[] readInfos = reader.readPersistenceUnitInfos(this.persistenceXmlLocations);
		for (SpringPersistenceUnitInfo readInfo : readInfos) {
			infos.add(readInfo);
			if (defaultName != null && defaultName.equals(readInfo.getPersistenceUnitName())) {
				foundDefaultUnit = true;
			}
		}

		if (buildDefaultUnit) {
			if (foundDefaultUnit) {
				if (logger.isWarnEnabled()) {
					logger.warn("Found explicit default persistence unit with name '" + defaultName + "' in persistence.xml - " +
							"overriding local default persistence unit settings ('packagesToScan'/'mappingResources')");
				}
			}
			else {
				infos.add(buildDefaultPersistenceUnitInfo());
			}
		}
		return infos;
	}

	/**
	 * Perform Spring-based scanning for entity classes.
	 * @see #setPackagesToScan
	 */
	/**
	 * 对实体类执行基于Spring的扫描。 
	 *  
	 * @see  #setPackagesToScan
	 */
	private SpringPersistenceUnitInfo buildDefaultPersistenceUnitInfo() {
		SpringPersistenceUnitInfo scannedUnit = new SpringPersistenceUnitInfo();
		if (this.defaultPersistenceUnitName != null) {
			scannedUnit.setPersistenceUnitName(this.defaultPersistenceUnitName);
		}
		scannedUnit.setExcludeUnlistedClasses(true);

		if (this.packagesToScan != null) {
			for (String pkg : this.packagesToScan) {
				scanPackage(scannedUnit, pkg);
			}
		}

		if (this.mappingResources != null) {
			for (String mappingFileName : this.mappingResources) {
				scannedUnit.addMappingFileName(mappingFileName);
			}
		}
		else {
			Resource ormXml = getOrmXmlForDefaultPersistenceUnit();
			if (ormXml != null) {
				scannedUnit.addMappingFileName(DEFAULT_ORM_XML_RESOURCE);
				if (scannedUnit.getPersistenceUnitRootUrl() == null) {
					try {
						scannedUnit.setPersistenceUnitRootUrl(
								PersistenceUnitReader.determinePersistenceUnitRootUrl(ormXml));
					}
					catch (IOException ex) {
						logger.debug("Failed to determine persistence unit root URL from orm.xml location", ex);
					}
				}
			}
		}

		return scannedUnit;
	}

	private void scanPackage(SpringPersistenceUnitInfo scannedUnit, String pkg) {
		if (this.componentsIndex != null) {
			Set<String> candidates = new HashSet<>();
			for (AnnotationTypeFilter filter : entityTypeFilters) {
				candidates.addAll(this.componentsIndex.getCandidateTypes(pkg, filter.getAnnotationType().getName()));
			}
			candidates.forEach(scannedUnit::addManagedClassName);
			Set<String> managedPackages = this.componentsIndex.getCandidateTypes(pkg, "package-info");
			managedPackages.forEach(scannedUnit::addManagedPackage);
			return;
		}

		try {
			String pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
					ClassUtils.convertClassNameToResourcePath(pkg) + CLASS_RESOURCE_PATTERN;
			Resource[] resources = this.resourcePatternResolver.getResources(pattern);
			MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory(this.resourcePatternResolver);
			for (Resource resource : resources) {
				if (resource.isReadable()) {
					MetadataReader reader = readerFactory.getMetadataReader(resource);
					String className = reader.getClassMetadata().getClassName();
					if (matchesFilter(reader, readerFactory)) {
						scannedUnit.addManagedClassName(className);
						if (scannedUnit.getPersistenceUnitRootUrl() == null) {
							URL url = resource.getURL();
							if (ResourceUtils.isJarURL(url)) {
								scannedUnit.setPersistenceUnitRootUrl(ResourceUtils.extractJarFileURL(url));
							}
						}
					}
					else if (className.endsWith(PACKAGE_INFO_SUFFIX)) {
						scannedUnit.addManagedPackage(
								className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));
					}
				}
			}
		}
		catch (IOException ex) {
			throw new PersistenceException("Failed to scan classpath for unlisted entity classes", ex);
		}
	}

	/**
	 * Check whether any of the configured entity type filters matches
	 * the current class descriptor contained in the metadata reader.
	 */
	/**
	 * 检查是否有任何已配置的实体类型过滤器与元数据读取器中包含的当前类描述符匹配。 
	 * 
	 */
	private boolean matchesFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
		for (TypeFilter filter : entityTypeFilters) {
			if (filter.match(reader, readerFactory)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Try to determine the persistence unit root URL based on the given
	 * "defaultPersistenceUnitRootLocation".
	 * @return the persistence unit root URL to pass to the JPA PersistenceProvider
	 * @see #setDefaultPersistenceUnitRootLocation
	 */
	/**
	 * 尝试根据给定的"defaultPersistenceUnitRootLocation"确定持久性单元根URL。 
	 *  
	 * @return 持久化单元根URL，以传递给JPA PersistenceProvider 
	 * @see  #setDefaultPersistenceUnitRootLocation
	 */
	@Nullable
	private URL determineDefaultPersistenceUnitRootUrl() {
		if (this.defaultPersistenceUnitRootLocation == null) {
			return null;
		}
		try {
			URL url = this.resourcePatternResolver.getResource(this.defaultPersistenceUnitRootLocation).getURL();
			return (ResourceUtils.isJarURL(url) ? ResourceUtils.extractJarFileURL(url) : url);
		}
		catch (IOException ex) {
			throw new PersistenceException("Unable to resolve persistence unit root URL", ex);
		}
	}

	/**
	 * Determine JPA's default "META-INF/orm.xml" resource for use with Spring's default
	 * persistence unit, if any.
	 * <p>Checks whether a "META-INF/orm.xml" file exists in the classpath and uses it
	 * if it is not co-located with a "META-INF/persistence.xml" file.
	 */
	/**
	 * 确定JPA的默认"META-INF / orm.xml"资源，以与Spring的默认持久性单元（如果有）一起使用。 
	 *  <p>检查类路径中是否存在"META-INF / orm.xml"文件，如果该文件与"META-INF / persistence.xml"文件不在同一位置，则使用该文件。 
	 * 
	 */
	@Nullable
	private Resource getOrmXmlForDefaultPersistenceUnit() {
		Resource ormXml = this.resourcePatternResolver.getResource(
				this.defaultPersistenceUnitRootLocation + DEFAULT_ORM_XML_RESOURCE);
		if (ormXml.exists()) {
			try {
				Resource persistenceXml = ormXml.createRelative(PERSISTENCE_XML_FILENAME);
				if (!persistenceXml.exists()) {
					return ormXml;
				}
			}
			catch (IOException ex) {
				// Cannot resolve relative persistence.xml file - let's assume it's not there.
				return ormXml;
			}
		}
		return null;
	}


	/**
	 * Return the specified PersistenceUnitInfo from this manager's cache
	 * of processed persistence units, keeping it in the cache (i.e. not
	 * 'obtaining' it for use but rather just accessing it for post-processing).
	 * <p>This can be used in {@link #postProcessPersistenceUnitInfo} implementations,
	 * detecting existing persistence units of the same name and potentially merging them.
	 * @param persistenceUnitName the name of the desired persistence unit
	 * @return the PersistenceUnitInfo in mutable form, or {@code null} if not available
	 */
	/**
	 * 从此管理器的已处理持久性单元缓存中返回指定的PersistenceUnitInfo，并将其保留在缓存中（即，不是"获取"使用该信息，而只是对其进行访问以进行后处理）。 
	 *  <p>这可用于{@link  #postProcessPersistenceUnitInfo}实现中，检测现有的相同名称的持久性单元，并可能将它们合并。 
	 *  
	 * @param  persistenceUnitName所需持久性单元的名称
	 * @return 可变形式的PersistenceUnitInfo，如果不可用，则为{@code  null}
	 */
	@Nullable
	protected final MutablePersistenceUnitInfo getPersistenceUnitInfo(String persistenceUnitName) {
		PersistenceUnitInfo pui = this.persistenceUnitInfos.get(persistenceUnitName);
		return (MutablePersistenceUnitInfo) pui;
	}

	/**
	 * Hook method allowing subclasses to customize each PersistenceUnitInfo.
	 * <p>The default implementation delegates to all registered PersistenceUnitPostProcessors.
	 * It is usually preferable to register further entity classes, jar files etc there
	 * rather than in a subclass of this manager, to be able to reuse the post-processors.
	 * @param pui the chosen PersistenceUnitInfo, as read from {@code persistence.xml}.
	 * Passed in as MutablePersistenceUnitInfo.
	 * @see #setPersistenceUnitPostProcessors
	 */
	/**
	 * 允许子类自定义每个PersistenceUnitInfo的Hook方法。 
	 *  <p>默认实现将委托给所有已注册的PersistenceUnitPostProcessors。 
	 * 通常最好在此注册其他实体类，jar文件等，而不是在此管理器的子类中注册，以便能够重用后处理器。 
	 *  
	 * @param 可以从{@code  persistence.xml}中读取所选的PersistenceUnitInfo。 
	 * 作为MutablePersistenceUnitInfo传入。 
	 *  
	 * @see  #setPersistenceUnitPostProcessors
	 */
	protected void postProcessPersistenceUnitInfo(MutablePersistenceUnitInfo pui) {
		PersistenceUnitPostProcessor[] postProcessors = getPersistenceUnitPostProcessors();
		if (postProcessors != null) {
			for (PersistenceUnitPostProcessor postProcessor : postProcessors) {
				postProcessor.postProcessPersistenceUnitInfo(pui);
			}
		}
	}

	/**
	 * Return whether an override of a same-named persistence unit is allowed.
	 * <p>Default is {@code false}. May be overridden to return {@code true},
	 * for example if {@link #postProcessPersistenceUnitInfo} is able to handle that case.
	 */
	/**
	 * 返回是否允许覆盖同名持久性单元。 
	 *  <p>默认值为{@code  false}。 
	 * 可以重写以返回{@code  true}，例如，如果{@link  #postProcessPersistenceUnitInfo}能够处理这种情况。 
	 * 
	 */
	protected boolean isPersistenceUnitOverrideAllowed() {
		return false;
	}


	@Override
	public PersistenceUnitInfo obtainDefaultPersistenceUnitInfo() {
		if (this.persistenceUnitInfoNames.isEmpty()) {
			throw new IllegalStateException("No persistence units parsed from " +
					ObjectUtils.nullSafeToString(this.persistenceXmlLocations));
		}
		if (this.persistenceUnitInfos.isEmpty()) {
			throw new IllegalStateException("All persistence units from " +
					ObjectUtils.nullSafeToString(this.persistenceXmlLocations) + " already obtained");
		}
		if (this.persistenceUnitInfos.size() > 1 && this.defaultPersistenceUnitName != null) {
			return obtainPersistenceUnitInfo(this.defaultPersistenceUnitName);
		}
		PersistenceUnitInfo pui = this.persistenceUnitInfos.values().iterator().next();
		this.persistenceUnitInfos.clear();
		return pui;
	}

	@Override
	public PersistenceUnitInfo obtainPersistenceUnitInfo(String persistenceUnitName) {
		PersistenceUnitInfo pui = this.persistenceUnitInfos.remove(persistenceUnitName);
		if (pui == null) {
			if (!this.persistenceUnitInfoNames.contains(persistenceUnitName)) {
				throw new IllegalArgumentException(
						"No persistence unit with name '" + persistenceUnitName + "' found");
			}
			else {
				throw new IllegalStateException(
						"Persistence unit with name '" + persistenceUnitName + "' already obtained");
			}
		}
		return pui;
	}

}
