/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.orm.jpa;

import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceException;
import javax.persistence.SharedCacheMode;
import javax.persistence.ValidationMode;
import javax.persistence.spi.PersistenceProvider;
import javax.persistence.spi.PersistenceUnitInfo;
import javax.sql.DataSource;

import org.springframework.beans.BeanUtils;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.context.weaving.LoadTimeWeaverAware;
import org.springframework.core.io.ResourceLoader;
import org.springframework.instrument.classloading.LoadTimeWeaver;
import org.springframework.jdbc.datasource.lookup.SingleDataSourceLookup;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager;
import org.springframework.orm.jpa.persistenceunit.PersistenceUnitManager;
import org.springframework.orm.jpa.persistenceunit.PersistenceUnitPostProcessor;
import org.springframework.orm.jpa.persistenceunit.SmartPersistenceUnitInfo;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;

/**
 * {@link org.springframework.beans.factory.FactoryBean} that creates a JPA
 * {@link javax.persistence.EntityManagerFactory} according to JPA's standard
 * <i>container</i> bootstrap contract. This is the most powerful way to set
 * up a shared JPA EntityManagerFactory in a Spring application context;
 * the EntityManagerFactory can then be passed to JPA-based DAOs via
 * dependency injection. Note that switching to a JNDI lookup or to a
 * {@link LocalEntityManagerFactoryBean} definition is just a matter of
 * configuration!
 *
 * <p>As with {@link LocalEntityManagerFactoryBean}, configuration settings
 * are usually read in from a {@code META-INF/persistence.xml} config file,
 * residing in the class path, according to the general JPA configuration contract.
 * However, this FactoryBean is more flexible in that you can override the location
 * of the {@code persistence.xml} file, specify the JDBC DataSources to link to,
 * etc. Furthermore, it allows for pluggable class instrumentation through Spring's
 * {@link org.springframework.instrument.classloading.LoadTimeWeaver} abstraction,
 * instead of being tied to a special VM agent specified on JVM startup.
 *
 * <p>Internally, this FactoryBean parses the {@code persistence.xml} file
 * itself and creates a corresponding {@link javax.persistence.spi.PersistenceUnitInfo}
 * object (with further configuration merged in, such as JDBC DataSources and the
 * Spring LoadTimeWeaver), to be passed to the chosen JPA
 * {@link javax.persistence.spi.PersistenceProvider}. This corresponds to a
 * local JPA container with full support for the standard JPA container contract.
 *
 * <p>The exposed EntityManagerFactory object will implement all the interfaces of
 * the underlying native EntityManagerFactory returned by the PersistenceProvider,
 * plus the {@link EntityManagerFactoryInfo} interface which exposes additional
 * metadata as assembled by this FactoryBean.
 *
 * <p><b>NOTE: Spring's JPA support requires JPA 2.1 or higher, as of Spring 5.0.</b>
 * JPA 1.0/2.0 based applications are still supported; however, a JPA 2.1 compliant
 * persistence provider is needed at runtime.
 *
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @since 2.0
 * @see #setPersistenceXmlLocation
 * @see #setJpaProperties
 * @see #setJpaVendorAdapter
 * @see #setLoadTimeWeaver
 * @see #setDataSource
 * @see EntityManagerFactoryInfo
 * @see LocalEntityManagerFactoryBean
 * @see org.springframework.orm.jpa.support.SharedEntityManagerBean
 * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory
 */
/**
 * {@link  org.springframework.beans.factory.FactoryBean}根据JPA的标准<i>容器</ i>引导合同创建一个JPA {@link  javax.persistence.EntityManagerFactory}。 
 * 这是在Spring应用程序上下文中设置共享JPA EntityManagerFactory的最强大方法。 
 * 然后可以通过依赖注入将EntityManagerFactory传递到基于JPA的DAO。 
 * 请注意，切换到JNDI查找或{@link  LocalEntityManagerFactoryBean}定义只是配置问题！ 
 *  <p>与{@link  LocalEntityManagerFactoryBean}一样，配置设置通常是根据常规JPA配置协定从位于类路径中的{@code  META-INF / persistence.xml}配置文件中读取的。 
 * 但是，此FactoryBean更为灵活，因为您可以覆盖{@code  persistence.xml}文件的位置，指定要链接到的JDBC DataSource，等等。 
 * 此外，它允许通过Spring的{<@链接> org.springframework.instrument.classloading.LoadTimeWeaver}抽象，而不是绑定到JVM启动时指定的特殊VM代理。 
 *  <p>在内部，此FactoryBean解析{@code  persistence.xml}文件本身，并创建相应的{@link  javax.persistence.spi.PersistenceUnitInfo}对象（合并了进一步的配置，例如JDBC DataSources和Spring LoadTimeWeaver）传递给所选的JPA {@link  javax.persistence.spi.PersistenceProvider}。 
 * 这对应于本地JPA容器，并完全支持标准JPA容器合同。 
 *  <p>公开的EntityManagerFactory对象将实现PersistenceProvider返回的基础本机EntityManagerFactory的所有接口，再加上{@link  EntityManagerFactoryInfo}接口，该接口公开此FactoryBean组装的其他元数据。 
 *  <p> <b>注意：从Spring 5.0开始，Spring的JPA支持需要JPA 2.1或更高版本。 
 * </ b>仍支持基于JPA 1.0 / 2.0的应用程序； 
 * 但是，在运行时需要符合JPA 2.1的持久性提供程序。 
 *  @author  Juergen Hoeller @author  Rod Johnson @since 2.0起
 * @see  #setPersistenceXmlLocation 
 * @see  #setJpaProperties 
 * @see  #setJpaVendorAdapter 
 * @see  #setLoadTimeWeaver 
 * @see  #setDataSource 
 * @see  EntityManagerFactoryInfo 
 * @see  LocalEntityManagerFactoryBean 
 * @see  org.springframework.orm.jpa.support.SharedEntityManagerBean 
 * @see  javax.persistence.spi.PersistenceProvider＃createContainerEntityManagerFactory
 */
@SuppressWarnings("serial")
public class LocalContainerEntityManagerFactoryBean extends AbstractEntityManagerFactoryBean
		implements ResourceLoaderAware, LoadTimeWeaverAware {

	@Nullable
	private PersistenceUnitManager persistenceUnitManager;

	private final DefaultPersistenceUnitManager internalPersistenceUnitManager = new DefaultPersistenceUnitManager();

	@Nullable
	private PersistenceUnitInfo persistenceUnitInfo;


	/**
	 * Set the PersistenceUnitManager to use for obtaining the JPA persistence unit
	 * that this FactoryBean is supposed to build an EntityManagerFactory for.
	 * <p>The default is to rely on the local settings specified on this FactoryBean,
	 * such as "persistenceXmlLocation", "dataSource" and "loadTimeWeaver".
	 * <p>For reuse of existing persistence unit configuration or more advanced forms
	 * of custom persistence unit handling, consider defining a separate
	 * PersistenceUnitManager bean (typically a DefaultPersistenceUnitManager instance)
	 * and linking it in here. {@code persistence.xml} location, DataSource
	 * configuration and LoadTimeWeaver will be defined on that separate
	 * DefaultPersistenceUnitManager bean in such a scenario.
	 * @see #setPersistenceXmlLocation
	 * @see #setDataSource
	 * @see #setLoadTimeWeaver
	 * @see org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager
	 */
	/**
	 * 设置PersistenceUnitManager以用于获取该FactoryBean应该为其构建EntityManagerFactory的JPA持久性单元。 
	 *  <p>默认设置是依赖于此FactoryBean上指定的本地设置，例如"persistenceXmlLocation"，"dataSource"和"loadTimeWeaver"。 
	 *  <p>要重用现有的持久性单元配置或自定义持久性单元处理的更高级形式，请考虑定义一个单独的PersistenceUnitManager bean（通常是DefaultPersistenceUnitManager实例）并将其链接到此处。 
	 * 在这种情况下，将在该单独的DefaultPersistenceUnitManager bean上定义{@code  persistence.xml}的位置，DataSource配置和LoadTimeWeaver。 
	 *  
	 * @see  #setPersistenceXmlLocation 
	 * @see  #setDataSource 
	 * @see  #setLoadTimeWeaver 
	 * @see  org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager
	 */
	public void setPersistenceUnitManager(PersistenceUnitManager persistenceUnitManager) {
		this.persistenceUnitManager = persistenceUnitManager;
	}

	/**
	 * Set the location of the {@code persistence.xml} file
	 * we want to use. This is a Spring resource location.
	 * <p>Default is "classpath:META-INF/persistence.xml".
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @param persistenceXmlLocation a Spring resource String
	 * identifying the location of the {@code persistence.xml} file
	 * that this LocalContainerEntityManagerFactoryBean should parse
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 设置我们要使用的{@code  persistence.xml}文件的位置。 
	 * 这是一个Spring资源位置。 
	 *  <p>默认为"classpath：META-INF / persistence.xml"。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @param  persistenceXmlLocation Spring资源字符串，标识此LocalContainerEntityManagerFactoryBean应该解析的{@code  persistence.xml}文件的位置
	 * @see  #setPersistenceUnitManager
	 */
	public void setPersistenceXmlLocation(String persistenceXmlLocation) {
		this.internalPersistenceUnitManager.setPersistenceXmlLocation(persistenceXmlLocation);
	}

	/**
	 * Uses the specified persistence unit name as the name of the default
	 * persistence unit, if applicable.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitName
	 */
	/**
	 * 如果适用，将指定的持久性单元名称用作默认持久性单元的名称。 
	 *  <p> <b>注意：仅在未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @see  DefaultPersistenceUnitManager＃setDefaultPersistenceUnitName
	 */
	@Override
	public void setPersistenceUnitName(@Nullable String persistenceUnitName) {
		super.setPersistenceUnitName(persistenceUnitName);
		if (persistenceUnitName != null) {
			this.internalPersistenceUnitManager.setDefaultPersistenceUnitName(persistenceUnitName);
		}
	}

	/**
	 * Set a persistence unit root location for the default persistence unit.
	 * <p>Default is "classpath:", that is, the root of the current classpath
	 * (nearest root directory). To be overridden if unit-specific resolution
	 * does not work and the classpath root is not appropriate either.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @since 4.3.3
	 * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitRootLocation
	 */
	/**
	 * 为默认持久性单元设置持久性单元的根位置。 
	 *  <p>默认值为"classpath："，即当前类路径的根（最近的根目录）。 
	 * 如果特定于单元的解析不起作用并且classpath根也不适合，则将其覆盖。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> @since 4.3.3 
	 * @see  DefaultPersistenceUnitManager＃setDefaultPersistenceUnitRootLocation
	 */
	public void setPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation) {
		this.internalPersistenceUnitManager.setDefaultPersistenceUnitRootLocation(defaultPersistenceUnitRootLocation);
	}

	/**
	 * Set whether to use Spring-based scanning for entity classes in the classpath
	 * instead of using JPA's standard scanning of jar files with {@code persistence.xml}
	 * markers in them. In case of Spring-based scanning, no {@code persistence.xml}
	 * is necessary; all you need to do is to specify base packages to search here.
	 * <p>Default is none. Specify packages to search for autodetection of your entity
	 * classes in the classpath. This is analogous to Spring's component-scan feature
	 * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).
	 * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>
	 * In particular, JPA providers may pick up annotated packages for provider-specific
	 * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's
	 * scan can detect annotated packages as well if supported by the given
	 * {@link JpaVendorAdapter} (e.g. for Hibernate).
	 * <p>If no explicit {@link #setMappingResources mapping resources} have been
	 * specified in addition to these packages, Spring's setup looks for a default
	 * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping
	 * resource for the default unit if the mapping file is not co-located with a
	 * {@code persistence.xml} file (in which case we assume it is only meant to be
	 * used with the persistence units defined there, like in standard JPA).
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @param packagesToScan one or more base packages to search, analogous to
	 * Spring's component-scan configuration for regular Spring components
	 * @see #setPersistenceUnitManager
	 * @see DefaultPersistenceUnitManager#setPackagesToScan
	 */
	/**
	 * 设置是否对类路径中的实体类使用基于Spring的扫描，而不是对其中带有{@code  persistence.xml}标记的jar文件使用JPA的标准扫描。 
	 * 如果是基于Spring的扫描，则不需要{@code  persistence.xml}。 
	 * 您需要做的就是指定要在此处搜索的基本软件包。 
	 *  <p>默认为无。 
	 * 指定包以在类路径中搜索对实体类的自动检测。 
	 * 这类似于Spring的组件扫描功能（{@link  org.springframework.context.annotation.ClassPathBeanDefinitionScanner}）。 
	 *  <p> <b>注意：与常规JPA扫描相比，可能会有一些限制。 
	 * </ b>特别是，JPA提供程序只有在受{@code  persistence.xml驱动时，才可以为提供程序特定的注释选择带注释的程序包。 
	 *  }。 
	 * 从4.1开始，如果给定的{@link  JpaVendorAdapter}支持（例如对于Hibernate），Spring的扫描也可以检测带注释的包。 
	 *  <p>如果除了这些软件包之外未指定任何明确的{@link  #setMappingResources映射资源}，Spring的安装程序会在类路径中查找默认的{@code  META-INF / orm.xml}文件，进行注册如果映射文件未与{@code  persistence.xml}文件位于同一位置，则将其作为默认单元的映射资源（在这种情况下，我们假定它仅与在那里定义的持久性单元一起使用，就像在标准JPA中一样）。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @param  packagesTo扫描一个或多个基本包以进行搜索，类似于常规Spring组件的Spring组件扫描配置。 
	 * <
	 * @see> #setPersistenceUnitManager 
	 * @see  DefaultPersistenceUnitManager＃setPackagesToScan
	 */
	public void setPackagesToScan(String... packagesToScan) {
		this.internalPersistenceUnitManager.setPackagesToScan(packagesToScan);
	}

	/**
	 * Specify one or more mapping resources (equivalent to {@code <mapping-file>}
	 * entries in {@code persistence.xml}) for the default persistence unit.
	 * Can be used on its own or in combination with entity scanning in the classpath,
	 * in both cases avoiding {@code persistence.xml}.
	 * <p>Note that mapping resources must be relative to the classpath root,
	 * e.g. "META-INF/mappings.xml" or "com/mycompany/repository/mappings.xml",
	 * so that they can be loaded through {@code ClassLoader.getResource}.
	 * <p>If no explicit mapping resources have been specified next to
	 * {@link #setPackagesToScan packages to scan}, Spring's setup looks for a default
	 * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping
	 * resource for the default unit if the mapping file is not co-located with a
	 * {@code persistence.xml} file (in which case we assume it is only meant to be
	 * used with the persistence units defined there, like in standard JPA).
	 * <p>Note that specifying an empty array/list here suppresses the default
	 * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying
	 * {@code META-INF/orm.xml} here will register that file even if it happens
	 * to be co-located with a {@code persistence.xml} file.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @see #setPersistenceUnitManager
	 * @see DefaultPersistenceUnitManager#setMappingResources
	 */
	/**
	 * 为默认持久性单元指定一个或多个映射资源（相当于{@code  persistence.xml}中的{@code  <mapping-file>}条目）。 
	 * 在两种情况下都可以避免使用{@code  persistence.xml}，可以单独使用或与类路径中的实体扫描结合使用。 
	 *  <p>请注意，映射资源必须相对于类路径根，例如"META-INF / mappings.xml"或"com / mycompany / repository / mappings.xml"，以便可以通过{@code  ClassLoader.getResource}加载它们。 
	 *  <p>如果在{@link  #setPackagesToScan要扫描的软件包}旁边未指定显式映射资源，Spring的安装程序将在类路径中查找默认的{@code  META-INF / orm.xml}文件，进行注册如果映射文件未与{@code  persistence.xml}文件位于同一位置，则将其作为默认单元的映射资源（在这种情况下，我们假定它仅与在那里定义的持久性单元一起使用，就像在标准JPA中一样）。 
	 *  <p>请注意，在此处指定一个空数组/列表将禁止默认的{@code  META-INF / orm.xml}检查。 
	 * 另一方面，在此处明确指定{@code  META-INF / orm.xml}将注册该文件，即使该文件恰巧与{@code  persistence.xml}文件位于同一位置。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @see  #setPersistenceUnitManager 
	 * @see  DefaultPersistenceUnitManager＃setMappingResources
	 */
	public void setMappingResources(String... mappingResources) {
		this.internalPersistenceUnitManager.setMappingResources(mappingResources);
	}

	/**
	 * Specify the JPA 2.0 shared cache mode for this persistence unit,
	 * overriding a value in {@code persistence.xml} if set.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @since 4.0
	 * @see javax.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 为此持久性单元指定JPA 2.0共享缓存模式，如果设置，则覆盖{@code  persistence.xml}中的值。 
	 *  <p> <b>注意：仅在未指定外部PersistenceUnitManager的情况下应用。 
	 * </ b> @since 4.0 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getSharedCacheMode（）
	 * @see  #setPersistenceUnitManager
	 */
	public void setSharedCacheMode(SharedCacheMode sharedCacheMode) {
		this.internalPersistenceUnitManager.setSharedCacheMode(sharedCacheMode);
	}

	/**
	 * Specify the JPA 2.0 validation mode for this persistence unit,
	 * overriding a value in {@code persistence.xml} if set.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @since 4.0
	 * @see javax.persistence.spi.PersistenceUnitInfo#getValidationMode()
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 为此持久性单元指定JPA 2.0验证模式，如果设置，则覆盖{@code  persistence.xml}中的值。 
	 *  <p> <b>注意：仅在未指定外部PersistenceUnitManager的情况下应用。 
	 * </ b> @since 4.0 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getValidationMode（）
	 * @see  #setPersistenceUnitManager
	 */
	public void setValidationMode(ValidationMode validationMode) {
		this.internalPersistenceUnitManager.setValidationMode(validationMode);
	}

	/**
	 * Specify the JDBC DataSource that the JPA persistence provider is supposed
	 * to use for accessing the database. This is an alternative to keeping the
	 * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed
	 * DataSource instead.
	 * <p>In JPA speak, a DataSource passed in here will be used as "nonJtaDataSource"
	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as
	 * overriding data source configuration in {@code persistence.xml} (if any).
	 * Note that this variant typically works for JTA transaction management as well;
	 * if it does not, consider using the explicit {@link #setJtaDataSource} instead.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @see javax.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 指定JPA持久性提供程序用于访问数据库的JDBC数据源。 
	 * 这是将JDBC配置保留在{@code  persistence.xml}中的替代方法，而是传入一个Spring管理的数据源。 
	 *  <p>在JPA中，此处传递的数据源将用作传递给PersistenceProvider的PersistenceUnitInfo上的"nonJtaDataSource"，并覆盖{@code  persistence.xml}中的数据源配置（如果有）。 
	 * 注意，该变体通常也适用于JTA事务管理。 
	 * 如果不是，请考虑使用显式的{@link  #setJtaDataSource}。 
	 *  <p> <b>注意：仅在未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getNonJtaDataSource（）
	 * @see  #setPersistenceUnitManager
	 */
	public void setDataSource(DataSource dataSource) {
		this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(dataSource));
		this.internalPersistenceUnitManager.setDefaultDataSource(dataSource);
	}

	/**
	 * Specify the JDBC DataSource that the JPA persistence provider is supposed
	 * to use for accessing the database. This is an alternative to keeping the
	 * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed
	 * DataSource instead.
	 * <p>In JPA speak, a DataSource passed in here will be used as "jtaDataSource"
	 * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as
	 * overriding data source configuration in {@code persistence.xml} (if any).
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource()
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 指定JPA持久性提供程序用于访问数据库的JDBC数据源。 
	 * 这是将JDBC配置保留在{@code  persistence.xml}中的替代方法，而是传入一个Spring管理的数据源。 
	 *  <p>在JPA中，此处传递的数据源将用作传递给PersistenceProvider的PersistenceUnitInfo上的"jtaDataSource"，并覆盖{@code  persistence.xml}中的数据源配置（如果有）。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @see  javax.persistence.spi.PersistenceUnitInfo＃getJtaDataSource（）
	 * @see  #setPersistenceUnitManager
	 */
	public void setJtaDataSource(DataSource jtaDataSource) {
		this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(jtaDataSource));
		this.internalPersistenceUnitManager.setDefaultJtaDataSource(jtaDataSource);
	}

	/**
	 * Set the PersistenceUnitPostProcessors to be applied to the
	 * PersistenceUnitInfo used for creating this EntityManagerFactory.
	 * <p>Such post-processors can, for example, register further entity
	 * classes and jar files, in addition to the metadata read from
	 * {@code persistence.xml}.
	 * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>
	 * @see #setPersistenceUnitManager
	 */
	/**
	 * 将PersistenceUnitPostProcessors设置为应用于创建该EntityManagerFactory的PersistenceUnitInfo。 
	 *  <p>除了从{@code  persistence.xml}读取的元数据外，此类后处理器还可以例如注册其他实体类和jar文件。 
	 *  <p> <b>注意：仅当未指定外部PersistenceUnitManager时应用。 
	 * </ b> 
	 * @see  #setPersistenceUnitManager
	 */
	public void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor... postProcessors) {
		this.internalPersistenceUnitManager.setPersistenceUnitPostProcessors(postProcessors);
	}

	/**
	 * Specify the Spring LoadTimeWeaver to use for class instrumentation according
	 * to the JPA class transformer contract.
	 * <p>It is a not required to specify a LoadTimeWeaver: Most providers will be
	 * able to provide a subset of their functionality without class instrumentation
	 * as well, or operate with their VM agent specified on JVM startup.
	 * <p>In terms of Spring-provided weaving options, the most important ones are
	 * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)
	 * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts
	 * with an underlying ClassLoader based on specific extended methods being available
	 * on it.
	 * <p><b>NOTE:</b> As of Spring 2.5, the context's default LoadTimeWeaver (defined
	 * as bean with name "loadTimeWeaver") will be picked up automatically, if available,
	 * removing the need for LoadTimeWeaver configuration on each affected target bean.
	 * Consider using the {@code context:load-time-weaver} XML tag for creating
	 * such a shared LoadTimeWeaver (autodetecting the environment by default).
	 * <p><b>NOTE:</b> Only applied if no external PersistenceUnitManager specified.
	 * Otherwise, the external {@link #setPersistenceUnitManager PersistenceUnitManager}
	 * is responsible for the weaving configuration.
	 * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver
	 * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver
	 */
	/**
	 * 根据JPA类转换器协定，指定要用于类检测的Spring LoadTimeWeaver。 
	 *  <p>不需要指定LoadTimeWeaver：大多数提供程序也将能够提供其功能的子集而无需类检测，也可以使用在JVM启动时指定的VM代理进行操作。 
	 *  <p>就Spring提供的编织选项而言，最重要的选择是InstrumentationLoadTimeWeaver，它需要在JVM启动时指定一个Spring特定（但非常通用）的VM代理； 
	 *  ReflectiveLoadTimeWeaver，它根据特定的扩展与底层的ClassLoader交互可用的方法。 
	 *  <p> <b>注意：</ b>从Spring 2.5开始，将自动获取上下文的默认LoadTimeWeaver（定义为名称为"loadTimeWeaver"的bean）（如果有的话），从而无需在每个受影响的目标上进行LoadTimeWeaver配置豆角，扁豆。 
	 * 考虑使用{@code  context：load-time-weaver} XML标签来创建这样的共享LoadTimeWeaver（默认情况下自动检测环境）。 
	 *  <p> <b>注意：</ b>仅在未指定外部PersistenceUnitManager的情况下应用。 
	 * 否则，外部{@link  #setPersistenceUnitManager PersistenceUnitManager}负责编织配置。 
	 *  
	 * @see  org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver 
	 * @see  org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver
	 */
	@Override
	public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {
		this.internalPersistenceUnitManager.setLoadTimeWeaver(loadTimeWeaver);
	}

	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.internalPersistenceUnitManager.setResourceLoader(resourceLoader);
	}


	@Override
	public void afterPropertiesSet() throws PersistenceException {
		PersistenceUnitManager managerToUse = this.persistenceUnitManager;
		if (this.persistenceUnitManager == null) {
			this.internalPersistenceUnitManager.afterPropertiesSet();
			managerToUse = this.internalPersistenceUnitManager;
		}

		this.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);
		JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();
		if (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof SmartPersistenceUnitInfo) {
			String rootPackage = jpaVendorAdapter.getPersistenceProviderRootPackage();
			if (rootPackage != null) {
				((SmartPersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(rootPackage);
			}
		}

		super.afterPropertiesSet();
	}

	@Override
	protected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {
		Assert.state(this.persistenceUnitInfo != null, "PersistenceUnitInfo not initialized");

		PersistenceProvider provider = getPersistenceProvider();
		if (provider == null) {
			String providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();
			if (providerClassName == null) {
				throw new IllegalArgumentException(
						"No PersistenceProvider specified in EntityManagerFactory configuration, " +
						"and chosen PersistenceUnitInfo does not specify a provider class name either");
			}
			Class<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());
			provider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);
		}

		if (logger.isDebugEnabled()) {
			logger.debug("Building JPA container EntityManagerFactory for persistence unit '" +
					this.persistenceUnitInfo.getPersistenceUnitName() + "'");
		}
		EntityManagerFactory emf =
				provider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());
		postProcessEntityManagerFactory(emf, this.persistenceUnitInfo);

		return emf;
	}


	/**
	 * Determine the PersistenceUnitInfo to use for the EntityManagerFactory
	 * created by this bean.
	 * <p>The default implementation reads in all persistence unit infos from
	 * {@code persistence.xml}, as defined in the JPA specification.
	 * If no entity manager name was specified, it takes the first info in the
	 * array as returned by the reader. Otherwise, it checks for a matching name.
	 * @param persistenceUnitManager the PersistenceUnitManager to obtain from
	 * @return the chosen PersistenceUnitInfo
	 */
	/**
	 * 确定要用于此bean创建的EntityManagerFactory的PersistenceUnitInfo。 
	 *  <p>根据JPA规范中的定义，默认实现从{@code  persistence.xml}中读取所有持久性单元信息。 
	 * 如果未指定实体管理器名称，则它将获取读取器返回的数组中的第一个信息。 
	 * 否则，它将检查匹配的名称。 
	 *  
	 * @param  persistenceUnitManager PersistenceUnitManager，可从
	 * @return 获取所选择的PersistenceUnitInfo
	 */
	protected PersistenceUnitInfo determinePersistenceUnitInfo(PersistenceUnitManager persistenceUnitManager) {
		if (getPersistenceUnitName() != null) {
			return persistenceUnitManager.obtainPersistenceUnitInfo(getPersistenceUnitName());
		}
		else {
			return persistenceUnitManager.obtainDefaultPersistenceUnitInfo();
		}
	}

	/**
	 * Hook method allowing subclasses to customize the EntityManagerFactory
	 * after its creation via the PersistenceProvider.
	 * <p>The default implementation is empty.
	 * @param emf the newly created EntityManagerFactory we are working with
	 * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory
	 * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory
	 */
	/**
	 * 允许子类在通过PersistenceProvider创建EntityManagerFactory后对其进行自定义的Hook方法。 
	 *  <p>默认实现为空。 
	 *  
	 * @param  emf与我们一起使用的新创建的EntityManagerFactory 
	 * @param  pui用于配置EntityManagerFactory的PersistenceUnitInfo 
	 * @see  javax.persistence.spi.PersistenceProvider＃createContainerEntityManagerFactory
	 */
	protected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui) {
	}


	@Override
	@Nullable
	public PersistenceUnitInfo getPersistenceUnitInfo() {
		return this.persistenceUnitInfo;
	}

	@Override
	@Nullable
	public String getPersistenceUnitName() {
		if (this.persistenceUnitInfo != null) {
			return this.persistenceUnitInfo.getPersistenceUnitName();
		}
		return super.getPersistenceUnitName();
	}

	@Override
	public DataSource getDataSource() {
		if (this.persistenceUnitInfo != null) {
			return (this.persistenceUnitInfo.getJtaDataSource() != null ?
					this.persistenceUnitInfo.getJtaDataSource() :
					this.persistenceUnitInfo.getNonJtaDataSource());
		}
		return (this.internalPersistenceUnitManager.getDefaultJtaDataSource() != null ?
				this.internalPersistenceUnitManager.getDefaultJtaDataSource() :
				this.internalPersistenceUnitManager.getDefaultDataSource());
	}

}
