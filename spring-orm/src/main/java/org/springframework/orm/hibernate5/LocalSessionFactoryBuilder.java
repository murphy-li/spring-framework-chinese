/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.orm.hibernate5;

import java.io.IOException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Collections;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import javax.persistence.AttributeConverter;
import javax.persistence.Converter;
import javax.persistence.Embeddable;
import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.sql.DataSource;
import javax.transaction.TransactionManager;

import org.hibernate.HibernateException;
import org.hibernate.MappingException;
import org.hibernate.SessionFactory;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
import org.hibernate.cache.spi.RegionFactory;
import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.Configuration;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.hibernate.engine.spi.SessionFactoryImplementor;

import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.core.InfrastructureProxy;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternUtils;
import org.springframework.core.task.AsyncTaskExecutor;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.core.type.filter.TypeFilter;
import org.springframework.lang.Nullable;
import org.springframework.transaction.jta.JtaTransactionManager;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;

/**
 * A Spring-provided extension of the standard Hibernate {@link Configuration} class,
 * adding {@link SpringSessionContext} as a default and providing convenient ways
 * to specify a JDBC {@link DataSource} and an application class loader.
 *
 * <p>This is designed for programmatic use, e.g. in {@code @Bean} factory methods;
 * consider using {@link LocalSessionFactoryBean} for XML bean definition files.
 * Typically combined with {@link HibernateTransactionManager} for declarative
 * transactions against the {@code SessionFactory} and its JDBC {@code DataSource}.
 *
 * <p>Compatible with Hibernate 5.0/5.1 as well as 5.2/5.3, as of Spring 5.1.
 * Set up with Hibernate 5.2/5.3, this builder is also a convenient way to set up
 * a JPA {@code EntityManagerFactory} since the Hibernate {@code SessionFactory}
 * natively exposes the JPA {@code EntityManagerFactory} interface as well now.
 *
 * <p>This builder supports Hibernate 5.3 {@code BeanContainer} integration,
 * {@link MetadataSources} from custom {@link BootstrapServiceRegistryBuilder}
 * setup, as well as other advanced Hibernate configuration options beyond the
 * standard JPA bootstrap contract.
 *
 * @author Juergen Hoeller
 * @since 4.2
 * @see HibernateTransactionManager
 * @see LocalSessionFactoryBean
 * @see #setBeanContainer
 * @see #LocalSessionFactoryBuilder(DataSource, ResourceLoader, MetadataSources)
 * @see BootstrapServiceRegistryBuilder
 */
/**
 * Spring提供的标准Hibernate {@link  Configuration}类的扩展，默认情况下添加{@link  SpringSessionContext}，并提供了方便的方法来指定JDBC {@link  DataSource}和应用程序类加载器。 
 *  <p>这是专为程序使用而设计的，例如在{@code  @Bean}工厂方法中； 
 * 考虑对XML Bean定义文件使用{@link  LocalSessionFactoryBean}。 
 * 通常与{@link  HibernateTransactionManager}结合使用，以针对{@code  SessionFactory}及其JDBC {@code  DataSource}进行声明式事务。 
 *  <p>从Spring 5.1开始与Hibernate 5.0 / 5.1和5.2 / 5.3兼容。 
 * 使用Hibernate 5.2 / 5.3进行设置，此构建器也是设置JPA {@code  EntityManagerFactory}的便捷方法，因为Hibernate {@code  SessionFactory}将JPA {@code  EntityManagerFactory}接口本地公开为现在好了。 
 *  <p>此构建器支持Hibernate 5.3 {@code  BeanContainer}集成，自定义{@link  BootstrapServiceRegistryBuilder}设置的{@link  MetadataSources}，以及标准JPA引导合同以外的其他高级Hibernate配置选项。 
 *  @author  Juergen Hoeller @since 4.2起
 * @see  HibernateTransactionManager 
 * @see  LocalSessionFactoryBean 
 * @see  #setBeanContainer 
 * @see  #LocalSessionFactoryBuilder（DataSource，ResourceLoader，MetadataSources）
 * @see  BootstrapServiceRegistryBuilder
 */
@SuppressWarnings("serial")
public class LocalSessionFactoryBuilder extends Configuration {

	private static final String RESOURCE_PATTERN = "/**/*.class";

	private static final String PACKAGE_INFO_SUFFIX = ".package-info";

	private static final TypeFilter[] DEFAULT_ENTITY_TYPE_FILTERS = new TypeFilter[] {
			new AnnotationTypeFilter(Entity.class, false),
			new AnnotationTypeFilter(Embeddable.class, false),
			new AnnotationTypeFilter(MappedSuperclass.class, false)};

	private static final TypeFilter CONVERTER_TYPE_FILTER = new AnnotationTypeFilter(Converter.class, false);


	private final ResourcePatternResolver resourcePatternResolver;

	@Nullable
	private TypeFilter[] entityTypeFilters = DEFAULT_ENTITY_TYPE_FILTERS;


	/**
	 * Create a new LocalSessionFactoryBuilder for the given DataSource.
	 * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using
	 * (may be {@code null})
	 */
	/**
	 * 为给定的数据源创建一个新的LocalSessionFactoryBuilder。 
	 *  
	 * @param  dataSource生成的Hibernate SessionFactory应该使用的JDBC DataSource（可以为{@code  null}）
	 */
	public LocalSessionFactoryBuilder(@Nullable DataSource dataSource) {
		this(dataSource, new PathMatchingResourcePatternResolver());
	}

	/**
	 * Create a new LocalSessionFactoryBuilder for the given DataSource.
	 * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using
	 * (may be {@code null})
	 * @param classLoader the ClassLoader to load application classes from
	 */
	/**
	 * 为给定的数据源创建一个新的LocalSessionFactoryBuilder。 
	 *  
	 * @param  dataSource生成的Hibernate SessionFactory应该使用的JDBC DataSource（可能为{@code  null}）
	 * @param  classLoader ClassLoader可以从中加载应用程序类
	 */
	public LocalSessionFactoryBuilder(@Nullable DataSource dataSource, ClassLoader classLoader) {
		this(dataSource, new PathMatchingResourcePatternResolver(classLoader));
	}

	/**
	 * Create a new LocalSessionFactoryBuilder for the given DataSource.
	 * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using
	 * (may be {@code null})
	 * @param resourceLoader the ResourceLoader to load application classes from
	 */
	/**
	 * 为给定的数据源创建一个新的LocalSessionFactoryBuilder。 
	 *  
	 * @param  dataSource生成的Hibernate SessionFactory应该使用的JDBC DataSource（可能为{@code  null}）
	 * @param  resourceLoader ResourceLoader可以从中加载应用程序类
	 */
	public LocalSessionFactoryBuilder(@Nullable DataSource dataSource, ResourceLoader resourceLoader) {
		this(dataSource, resourceLoader, new MetadataSources(
				new BootstrapServiceRegistryBuilder().applyClassLoader(resourceLoader.getClassLoader()).build()));
	}

	/**
	 * Create a new LocalSessionFactoryBuilder for the given DataSource.
	 * @param dataSource the JDBC DataSource that the resulting Hibernate SessionFactory should be using
	 * (may be {@code null})
	 * @param resourceLoader the ResourceLoader to load application classes from
	 * @param metadataSources the Hibernate MetadataSources service to use (e.g. reusing an existing one)
	 * @since 4.3
	 */
	/**
	 * 为给定的数据源创建一个新的LocalSessionFactoryBuilder。 
	 *  
	 * @param  dataSource生成的Hibernate SessionFactory应该使用的JDBC数据源（可能为{@code  null}）。 
	 *  （例如重用现有的）@4.3起
	 */
	public LocalSessionFactoryBuilder(
			@Nullable DataSource dataSource, ResourceLoader resourceLoader, MetadataSources metadataSources) {

		super(metadataSources);

		getProperties().put(AvailableSettings.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());
		if (dataSource != null) {
			getProperties().put(AvailableSettings.DATASOURCE, dataSource);
		}

		// Hibernate 5.1/5.2: manually enforce connection release mode ON_CLOSE (the former default)
		try {
			// Try Hibernate 5.2
			AvailableSettings.class.getField("CONNECTION_HANDLING");
			getProperties().put("hibernate.connection.handling_mode", "DELAYED_ACQUISITION_AND_HOLD");
		}
		catch (NoSuchFieldException ex) {
			// Try Hibernate 5.1
			try {
				AvailableSettings.class.getField("ACQUIRE_CONNECTIONS");
				getProperties().put("hibernate.connection.release_mode", "ON_CLOSE");
			}
			catch (NoSuchFieldException ex2) {
				// on Hibernate 5.0.x or lower - no need to change the default there
			}
		}

		getProperties().put(AvailableSettings.CLASSLOADERS, Collections.singleton(resourceLoader.getClassLoader()));
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
	}


	/**
	 * Set the Spring {@link JtaTransactionManager} or the JTA {@link TransactionManager}
	 * to be used with Hibernate, if any. Allows for using a Spring-managed transaction
	 * manager for Hibernate 5's session and cache synchronization, with the
	 * "hibernate.transaction.jta.platform" automatically set to it.
	 * <p>A passed-in Spring {@link JtaTransactionManager} needs to contain a JTA
	 * {@link TransactionManager} reference to be usable here, except for the WebSphere
	 * case where we'll automatically set {@code WebSphereExtendedJtaPlatform} accordingly.
	 * <p>Note: If this is set, the Hibernate settings should not contain a JTA platform
	 * setting to avoid meaningless double configuration.
	 */
	/**
	 * 设置要与Hibernate一起使用的Spring {@link  JtaTransactionManager}或JTA {@link  TransactionManager}。 
	 * 允许使用Spring管理的事务管理器进行Hibernate 5的会话和缓存同步，并自动将其设置为"hibernate.transaction.jta.platform"。 
	 *  <p>传入的Spring {@link  JtaTransactionManager}需要包含一个JTA {@link  TransactionManager}引用才能在此处使用，但在WebSphere情况下，我们将自动设置{@code  WebSphereExtendedJtaPlatform }。 
	 *  <p>注意：如果设置了该选项，则Hibernate设置不应包含JTA平台设置，以避免无意义的双重配置。 
	 * 
	 */
	public LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager) {
		Assert.notNull(jtaTransactionManager, "Transaction manager reference must not be null");

		if (jtaTransactionManager instanceof JtaTransactionManager) {
			boolean webspherePresent = ClassUtils.isPresent("com.ibm.wsspi.uow.UOWManager", getClass().getClassLoader());
			if (webspherePresent) {
				getProperties().put(AvailableSettings.JTA_PLATFORM,
						"org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform");
			}
			else {
				JtaTransactionManager jtaTm = (JtaTransactionManager) jtaTransactionManager;
				if (jtaTm.getTransactionManager() == null) {
					throw new IllegalArgumentException(
							"Can only apply JtaTransactionManager which has a TransactionManager reference set");
				}
				getProperties().put(AvailableSettings.JTA_PLATFORM,
						new ConfigurableJtaPlatform(jtaTm.getTransactionManager(), jtaTm.getUserTransaction(),
								jtaTm.getTransactionSynchronizationRegistry()));
			}
		}
		else if (jtaTransactionManager instanceof TransactionManager) {
			getProperties().put(AvailableSettings.JTA_PLATFORM,
					new ConfigurableJtaPlatform((TransactionManager) jtaTransactionManager, null, null));
		}
		else {
			throw new IllegalArgumentException(
					"Unknown transaction manager type: " + jtaTransactionManager.getClass().getName());
		}

		// Hibernate 5.1/5.2: manually enforce connection release mode AFTER_STATEMENT (the JTA default)
		try {
			// Try Hibernate 5.2
			AvailableSettings.class.getField("CONNECTION_HANDLING");
			getProperties().put("hibernate.connection.handling_mode", "DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT");
		}
		catch (NoSuchFieldException ex) {
			// Try Hibernate 5.1
			try {
				AvailableSettings.class.getField("ACQUIRE_CONNECTIONS");
				getProperties().put("hibernate.connection.release_mode", "AFTER_STATEMENT");
			}
			catch (NoSuchFieldException ex2) {
				// on Hibernate 5.0.x or lower - no need to change the default there
			}
		}

		return this;
	}

	/**
	 * Set a Hibernate {@link org.hibernate.resource.beans.container.spi.BeanContainer}
	 * for the given Spring {@link ConfigurableListableBeanFactory}.
	 * <p>Note: Bean container integration requires Hibernate 5.3 or higher.
	 * It enables autowiring of Hibernate attribute converters and entity listeners.
	 * @since 5.1
	 * @see SpringBeanContainer
	 * @see AvailableSettings#BEAN_CONTAINER
	 */
	/**
	 * 为给定的Spring {@link  ConfigurableListableBeanFactory}设置一个Hibernate {@link  org.hibernate.resource.beans.container.spi.BeanContainer}。 
	 *  <p>注意：Bean容器集成需要Hibernate 5.3或更高版本。 
	 * 它启用了Hibernate属性转换器和实体侦听器的自动装配。 
	 *  @since 5.1 
	 * @see  SpringBeanContainer 
	 * @see  AvailableSettings＃BEAN_CONTAINER
	 */
	public LocalSessionFactoryBuilder setBeanContainer(ConfigurableListableBeanFactory beanFactory) {
		getProperties().put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(beanFactory));
		return this;
	}

	/**
	 * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.
	 * Allows for using a Spring-managed {@code RegionFactory} instance.
	 * <p>Note: If this is set, the Hibernate settings should not define a
	 * cache provider to avoid meaningless double configuration.
	 * @since 5.1
	 * @see AvailableSettings#CACHE_REGION_FACTORY
	 */
	/**
	 * 设置休眠{@link  RegionFactory}以用于SessionFactory。 
	 * 允许使用Spring管理的{@code  RegionFactory}实例。 
	 *  <p>注意：如果设置了该设置，则Hibernate设置不应定义缓存提供程序，以避免无意义的双重配置。 
	 *  @始于5.1 
	 * @see  AvailableSettings＃CACHE_REGION_FACTORY
	 */
	public LocalSessionFactoryBuilder setCacheRegionFactory(RegionFactory cacheRegionFactory) {
		getProperties().put(AvailableSettings.CACHE_REGION_FACTORY, cacheRegionFactory);
		return this;
	}

	/**
	 * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.
	 * @since 4.3
	 * @see AvailableSettings#MULTI_TENANT_CONNECTION_PROVIDER
	 */
	/**
	 * 设置一个{@link  MultiTenantConnectionProvider}传递给SessionFactory。 
	 *  @始于4.3 
	 * @see  AvailableSettings＃MULTI_TENANT_CONNECTION_PROVIDER
	 */
	public LocalSessionFactoryBuilder setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {
		getProperties().put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider);
		return this;
	}

	/**
	 * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.
	 * @since 4.3.2
	 * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER
	 */
	/**
	 * 重写以可靠地将{@link  CurrentTenantIdentifierResolver}传递给SessionFactory。 
	 *  @since 4.3.2 
	 * @see  AvailableSettings＃MULTI_TENANT_IDENTIFIER_RESOLVER
	 */
	@Override
	public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {
		getProperties().put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver);
		super.setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver);
	}

	/**
	 * Specify custom type filters for Spring-based scanning for entity classes.
	 * <p>Default is to search all specified packages for classes annotated with
	 * {@code @javax.persistence.Entity}, {@code @javax.persistence.Embeddable}
	 * or {@code @javax.persistence.MappedSuperclass}.
	 * @see #scanPackages
	 */
	/**
	 * 为基于Spring的实体类扫描指定自定义类型过滤器。 
	 *  <p>默认是在所有指定的包中搜索以{@code  @javax.persistence.Entity}，{<@code> @javax.persistence.Embeddable}或{@code  @javax.persistence注释的类。 
	 *  MappedSuperclass}。 
	 *  
	 * @see  #scanPackages
	 */
	public LocalSessionFactoryBuilder setEntityTypeFilters(TypeFilter... entityTypeFilters) {
		this.entityTypeFilters = entityTypeFilters;
		return this;
	}

	/**
	 * Add the given annotated classes in a batch.
	 * @see #addAnnotatedClass
	 * @see #scanPackages
	 */
	/**
	 * 批量添加给定的带注释的类。 
	 *  
	 * @see  #addAnnotatedClass 
	 * @see  #scanPackages
	 */
	public LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses) {
		for (Class<?> annotatedClass : annotatedClasses) {
			addAnnotatedClass(annotatedClass);
		}
		return this;
	}

	/**
	 * Add the given annotated packages in a batch.
	 * @see #addPackage
	 * @see #scanPackages
	 */
	/**
	 * 批量添加给定的带注释的程序包。 
	 *  
	 * @see  #addPackage 
	 * @see  #scanPackages
	 */
	public LocalSessionFactoryBuilder addPackages(String... annotatedPackages) {
		for (String annotatedPackage : annotatedPackages) {
			addPackage(annotatedPackage);
		}
		return this;
	}

	/**
	 * Perform Spring-based scanning for entity classes, registering them
	 * as annotated classes with this {@code Configuration}.
	 * @param packagesToScan one or more Java package names
	 * @throws HibernateException if scanning fails for any reason
	 */
	/**
	 * 对实体类执行基于Spring的扫描，并使用此{@code  Configuration}将它们注册为带注释的类。 
	 *  
	 * @param  packagesToScan一个或多个Java包名称
	 * @throws 如果由于任何原因扫描失败，则抛出HibernateException
	 */
	@SuppressWarnings("unchecked")
	public LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws HibernateException {
		Set<String> entityClassNames = new TreeSet<>();
		Set<String> converterClassNames = new TreeSet<>();
		Set<String> packageNames = new TreeSet<>();
		try {
			for (String pkg : packagesToScan) {
				String pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
						ClassUtils.convertClassNameToResourcePath(pkg) + RESOURCE_PATTERN;
				Resource[] resources = this.resourcePatternResolver.getResources(pattern);
				MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory(this.resourcePatternResolver);
				for (Resource resource : resources) {
					if (resource.isReadable()) {
						MetadataReader reader = readerFactory.getMetadataReader(resource);
						String className = reader.getClassMetadata().getClassName();
						if (matchesEntityTypeFilter(reader, readerFactory)) {
							entityClassNames.add(className);
						}
						else if (CONVERTER_TYPE_FILTER.match(reader, readerFactory)) {
							converterClassNames.add(className);
						}
						else if (className.endsWith(PACKAGE_INFO_SUFFIX)) {
							packageNames.add(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));
						}
					}
				}
			}
		}
		catch (IOException ex) {
			throw new MappingException("Failed to scan classpath for unlisted classes", ex);
		}
		try {
			ClassLoader cl = this.resourcePatternResolver.getClassLoader();
			for (String className : entityClassNames) {
				addAnnotatedClass(ClassUtils.forName(className, cl));
			}
			for (String className : converterClassNames) {
				addAttributeConverter((Class<? extends AttributeConverter<?, ?>>) ClassUtils.forName(className, cl));
			}
			for (String packageName : packageNames) {
				addPackage(packageName);
			}
		}
		catch (ClassNotFoundException ex) {
			throw new MappingException("Failed to load annotated classes from classpath", ex);
		}
		return this;
	}

	/**
	 * Check whether any of the configured entity type filters matches
	 * the current class descriptor contained in the metadata reader.
	 */
	/**
	 * 检查是否有任何已配置的实体类型过滤器与元数据读取器中包含的当前类描述符匹配。 
	 * 
	 */
	private boolean matchesEntityTypeFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
		if (this.entityTypeFilters != null) {
			for (TypeFilter filter : this.entityTypeFilters) {
				if (filter.match(reader, readerFactory)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Build the Hibernate {@code SessionFactory} through background bootstrapping,
	 * using the given executor for a parallel initialization phase
	 * (e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}).
	 * <p>{@code SessionFactory} initialization will then switch into background
	 * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for
	 * injection purposes instead of waiting for Hibernate's bootstrapping to complete.
	 * However, note that the first actual call to a {@code SessionFactory} method will
	 * then block until Hibernate's bootstrapping completed, if not ready by then.
	 * For maximum benefit, make sure to avoid early {@code SessionFactory} calls
	 * in init methods of related beans, even for metadata introspection purposes.
	 * @since 4.3
	 * @see #buildSessionFactory()
	 */
	/**
	 * 使用给定的执行器进行并行初始化阶段（例如{@link  org.springframework.core.task.SimpleAsyncTaskExecutor}），通过后台引导程序构建Hibernate {@code  SessionFactory}。 
	 * 然后，<p> {<@code> SessionFactory}初始化将切换到后台引导程序模式，并立即返回一个{@code  SessionFactory}代理用于注入目的，而不是等待Hibernate的引导完成。 
	 * 但是，请注意，对{@code  SessionFactory}方法的第一个实际调用将阻塞，直到Hibernate的引导完成为止（如果那时还没有准备好）。 
	 * 为了获得最大利益，请确保避免在相关bean的init方法中进行早期的{@code  SessionFactory}调用，即使是出于元数据自省的目的。 
	 *  @since 4.3 
	 * @see  #buildSessionFactory（）
	 */
	public SessionFactory buildSessionFactory(AsyncTaskExecutor bootstrapExecutor) {
		Assert.notNull(bootstrapExecutor, "AsyncTaskExecutor must not be null");
		return (SessionFactory) Proxy.newProxyInstance(this.resourcePatternResolver.getClassLoader(),
				new Class<?>[] {SessionFactoryImplementor.class, InfrastructureProxy.class},
				new BootstrapSessionFactoryInvocationHandler(bootstrapExecutor));
	}


	/**
	 * Proxy invocation handler for background bootstrapping, only enforcing
	 * a fully initialized target {@code SessionFactory} when actually needed.
	 * @since 4.3
	 */
	/**
	 * 用于后台引导的代理调用处理程序，仅在实际需要时才强制执行完全初始化的目标{@code  SessionFactory}。 
	 *  @4.3起
	 */
	private class BootstrapSessionFactoryInvocationHandler implements InvocationHandler {

		private final Future<SessionFactory> sessionFactoryFuture;

		public BootstrapSessionFactoryInvocationHandler(AsyncTaskExecutor bootstrapExecutor) {
			this.sessionFactoryFuture = bootstrapExecutor.submit(
					(Callable<SessionFactory>) LocalSessionFactoryBuilder.this::buildSessionFactory);
		}

		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			try {
				if (method.getName().equals("equals")) {
					// Only consider equal when proxies are identical.
					return (proxy == args[0]);
				}
				else if (method.getName().equals("hashCode")) {
					// Use hashCode of EntityManagerFactory proxy.
					return System.identityHashCode(proxy);
				}
				else if (method.getName().equals("getProperties")) {
					return getProperties();
				}
				else if (method.getName().equals("getWrappedObject")) {
					// Call coming in through InfrastructureProxy interface...
					return getSessionFactory();
				}
				// Regular delegation to the target SessionFactory,
				// enforcing its full initialization...
				return method.invoke(getSessionFactory(), args);
			}
			catch (InvocationTargetException ex) {
				throw ex.getTargetException();
			}
		}

		private SessionFactory getSessionFactory() {
			try {
				return this.sessionFactoryFuture.get();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				throw new IllegalStateException("Interrupted during initialization of Hibernate SessionFactory", ex);
			}
			catch (ExecutionException ex) {
				Throwable cause = ex.getCause();
				if (cause instanceof HibernateException) {
					// Rethrow a provider configuration exception (possibly with a nested cause) directly
					throw (HibernateException) cause;
				}
				throw new IllegalStateException("Failed to asynchronously initialize Hibernate SessionFactory: " +
						ex.getMessage(), cause);
			}
		}
	}

}
