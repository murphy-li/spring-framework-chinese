/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.orm.hibernate5;

import java.sql.Connection;
import java.sql.ResultSet;

import javax.persistence.PersistenceException;
import javax.sql.DataSource;

import org.hibernate.ConnectionReleaseMode;
import org.hibernate.FlushMode;
import org.hibernate.HibernateException;
import org.hibernate.Interceptor;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.engine.spi.SessionImplementor;
import org.hibernate.resource.transaction.spi.TransactionStatus;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataAccessResourceFailureException;
import org.springframework.jdbc.datasource.ConnectionHolder;
import org.springframework.jdbc.datasource.DataSourceUtils;
import org.springframework.jdbc.datasource.JdbcTransactionObjectSupport;
import org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;
import org.springframework.lang.Nullable;
import org.springframework.transaction.CannotCreateTransactionException;
import org.springframework.transaction.IllegalTransactionStateException;
import org.springframework.transaction.InvalidIsolationLevelException;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionSystemException;
import org.springframework.transaction.support.AbstractPlatformTransactionManager;
import org.springframework.transaction.support.DefaultTransactionStatus;
import org.springframework.transaction.support.ResourceTransactionManager;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.Assert;

/**
 * {@link org.springframework.transaction.PlatformTransactionManager}
 * implementation for a single Hibernate {@link SessionFactory}.
 * Binds a Hibernate Session from the specified factory to the thread,
 * potentially allowing for one thread-bound Session per factory.
 * {@code SessionFactory.getCurrentSession()} is required for Hibernate
 * access code that needs to support this transaction handling mechanism,
 * with the SessionFactory being configured with {@link SpringSessionContext}.
 *
 * <p>Supports custom isolation levels, and timeouts that get applied as
 * Hibernate transaction timeouts.
 *
 * <p>This transaction manager is appropriate for applications that use a single
 * Hibernate SessionFactory for transactional data access, but it also supports
 * direct DataSource access within a transaction (i.e. plain JDBC code working
 * with the same DataSource). This allows for mixing services which access Hibernate
 * and services which use plain JDBC (without being aware of Hibernate)!
 * Application code needs to stick to the same simple Connection lookup pattern as
 * with {@link org.springframework.jdbc.datasource.DataSourceTransactionManager}
 * (i.e. {@link org.springframework.jdbc.datasource.DataSourceUtils#getConnection}
 * or going through a
 * {@link org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy}).
 *
 * <p>Note: To be able to register a DataSource's Connection for plain JDBC code,
 * this instance needs to be aware of the DataSource ({@link #setDataSource}).
 * The given DataSource should obviously match the one used by the given SessionFactory.
 *
 * <p>JTA (usually through {@link org.springframework.transaction.jta.JtaTransactionManager})
 * is necessary for accessing multiple transactional resources within the same
 * transaction. The DataSource that Hibernate uses needs to be JTA-enabled in
 * such a scenario (see container setup).
 *
 * <p>This transaction manager supports nested transactions via JDBC 3.0 Savepoints.
 * The {@link #setNestedTransactionAllowed} "nestedTransactionAllowed"} flag defaults
 * to "false", though, as nested transactions will just apply to the JDBC Connection,
 * not to the Hibernate Session and its cached entity objects and related context.
 * You can manually set the flag to "true" if you want to use nested transactions
 * for JDBC access code which participates in Hibernate transactions (provided that
 * your JDBC driver supports Savepoints). <i>Note that Hibernate itself does not
 * support nested transactions! Hence, do not expect Hibernate access code to
 * semantically participate in a nested transaction.</i>
 *
 * @author Juergen Hoeller
 * @since 4.2
 * @see #setSessionFactory
 * @see #setDataSource
 * @see SessionFactory#getCurrentSession()
 * @see DataSourceUtils#getConnection
 * @see DataSourceUtils#releaseConnection
 * @see org.springframework.jdbc.core.JdbcTemplate
 * @see org.springframework.jdbc.datasource.DataSourceTransactionManager
 * @see org.springframework.transaction.jta.JtaTransactionManager
 */
/**
 * 单个Hibernate {@link  SessionFactory}的{@link  org.springframework.transaction.PlatformTransactionManager}实现。 
 * 将Hibernate Session从指定的工厂绑定到线程，可能允许每个工厂一个线程绑定的Session。 
 * 对于需要支持此事务处理机制的Hibernate访问代码，需要{@code  SessionFactory.getCurrentSession（）}，而SessionFactory则使用{@link  SpringSessionContext}配置。 
 *  <p>支持自定义隔离级别和作为Hibernate事务超时应用的超时。 
 *  <p>此事务管理器适用于使用单个Hibernate SessionFactory进行事务数据访问的应用程序，但它还支持事务内的直接DataSource访问（即，与同一DataSource一起使用的纯JDBC代码）。 
 * 这允许混合访问Hibernate的服务和使用普通JDBC的服务（无需了解Hibernate）！ 
 * 应用程序代码需要遵循与{@link  org.springframework.jdbc.datasource.DataSourceTransactionManager}相同的简单连接查找模式（即{@link  org.springframework.jdbc.datasource.DataSourceUtils＃getConnection}通过{@link  org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy}）。 
 *  <p>注意：为了能够为纯JDBC代码注册数据源的连接，此实例需要注意数据源（{@link  #setDataSource}）。 
 * 给定的DataSource显然应该与给定的SessionFactory使用的数据源匹配。 
 *  <p> JTA（通常通过{@link  org.springframework.transaction.jta.JtaTransactionManager}）对于访问同一事务中的多个事务资源是必需的。 
 * 在这种情况下，Hibernate使用的DataSource必须启用JTA（请参阅容器设置）。 
 *  <p>此事务管理器通过JDBC 3.0保存点支持嵌套事务。 
 *  {{@link> #setNestedTransactionAllowed}"nestedTransactionAllowed"}标志默认为"false"，因为嵌套事务仅适用于JDBC连接，不适用于Hibernate Session及其缓存的实体对象和相关上下文。 
 * 如果要将嵌套事务用于参与Hibernate事务的JDBC访问代码，则可以手动将标志设置为"true"（前提是您的JDBC驱动程序支持Savepoints）。 
 *  <i>请注意，Hibernate本身不支持嵌套事务！ 
 * 因此，不要期望Hibernate访问代码在语义上参与嵌套事务。 
 * </ i> @author  Juergen Hoeller @since 4.2起
 * @see  #setSessionFactory 
 * @see  #setDataSource 
 * @see  SessionFactory＃getCurrentSession（） 
 * @see  DataSourceUtils＃getConnection 
 * @see  DataSourceUtils＃releaseConnection 
 * @see  org.springframework.jdbc.core.JdbcTemplate 
 * @see  org.springframework.jdbc.datasource.DataSourceTransactionManager 
 * @see  org.springframework.transaction。 
 *  jta.JtaTransactionManager
 */
@SuppressWarnings("serial")
public class HibernateTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {

	@Nullable
	private SessionFactory sessionFactory;

	@Nullable
	private DataSource dataSource;

	private boolean autodetectDataSource = true;

	private boolean prepareConnection = true;

	private boolean allowResultAccessAfterCompletion = false;

	private boolean hibernateManagedSession = false;

	@Nullable
	private Object entityInterceptor;

	/**
	 * Just needed for entityInterceptorBeanName.
	 * @see #setEntityInterceptorBeanName
	 */
	/**
	 * 只是需要EntityInterceptorBeanName。 
	 *  
	 * @see  #setEntityInterceptorBeanName
	 */
	@Nullable
	private BeanFactory beanFactory;


	/**
	 * Create a new HibernateTransactionManager instance.
	 * A SessionFactory has to be set to be able to use it.
	 * @see #setSessionFactory
	 */
	/**
	 * 创建一个新的HibernateTransactionManager实例。 
	 * 必须将SessionFactory设置为可以使用它。 
	 *  
	 * @see  #setSessionFactory
	 */
	public HibernateTransactionManager() {
	}

	/**
	 * Create a new HibernateTransactionManager instance.
	 * @param sessionFactory the SessionFactory to manage transactions for
	 */
	/**
	 * 创建一个新的HibernateTransactionManager实例。 
	 *  
	 * @param  sessionFactory用于管理事务的SessionFactory
	 */
	public HibernateTransactionManager(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
		afterPropertiesSet();
	}


	/**
	 * Set the SessionFactory that this instance should manage transactions for.
	 */
	/**
	 * 设置此实例应为其管理事务的SessionFactory。 
	 * 
	 */
	public void setSessionFactory(@Nullable SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}

	/**
	 * Return the SessionFactory that this instance should manage transactions for.
	 */
	/**
	 * 返回此实例应为其管理事务的SessionFactory。 
	 * 
	 */
	@Nullable
	public SessionFactory getSessionFactory() {
		return this.sessionFactory;
	}

	/**
	 * Obtain the SessionFactory for actual use.
	 * @return the SessionFactory (never {@code null})
	 * @throws IllegalStateException in case of no SessionFactory set
	 * @since 5.0
	 */
	/**
	 * 获取SessionFactory以便实际使用。 
	 *  
	 * @return  SessionFactory（从不{<@@code> null}）
	 * @throws 如果从5.0开始没有设置SessionFactory，则抛出IllegalStateException
	 */
	protected final SessionFactory obtainSessionFactory() {
		SessionFactory sessionFactory = getSessionFactory();
		Assert.state(sessionFactory != null, "No SessionFactory set");
		return sessionFactory;
	}

	/**
	 * Set the JDBC DataSource that this instance should manage transactions for.
	 * The DataSource should match the one used by the Hibernate SessionFactory:
	 * for example, you could specify the same JNDI DataSource for both.
	 * <p>If the SessionFactory was configured with LocalDataSourceConnectionProvider,
	 * i.e. by Spring's LocalSessionFactoryBean with a specified "dataSource",
	 * the DataSource will be auto-detected: You can still explicitly specify the
	 * DataSource, but you don't need to in this case.
	 * <p>A transactional JDBC Connection for this DataSource will be provided to
	 * application code accessing this DataSource directly via DataSourceUtils
	 * or JdbcTemplate. The Connection will be taken from the Hibernate Session.
	 * <p>The DataSource specified here should be the target DataSource to manage
	 * transactions for, not a TransactionAwareDataSourceProxy. Only data access
	 * code may work with TransactionAwareDataSourceProxy, while the transaction
	 * manager needs to work on the underlying target DataSource. If there's
	 * nevertheless a TransactionAwareDataSourceProxy passed in, it will be
	 * unwrapped to extract its target DataSource.
	 * <p><b>NOTE: For scenarios with many transactions that just read data from
	 * Hibernate's cache (and do not actually access the database), consider using
	 * a {@link org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy}
	 * for the actual target DataSource. Alternatively, consider switching
	 * {@link #setPrepareConnection "prepareConnection"} to {@code false}.</b>
	 * In both cases, this transaction manager will not eagerly acquire a
	 * JDBC Connection for each Hibernate Session anymore (as of Spring 5.1).
	 * @see #setAutodetectDataSource
	 * @see TransactionAwareDataSourceProxy
	 * @see org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy
	 * @see org.springframework.jdbc.core.JdbcTemplate
	 */
	/**
	 * 设置该实例应为其管理事务的JDBC DataSource。 
	 * 该数据源应与Hibernate SessionFactory使用的数据源匹配：例如，您可以为两个数据库指定相同的JNDI数据源。 
	 *  <p>如果SessionFactory是使用LocalDataSourceConnectionProvider配置的，即由Spring的LocalSessionFactoryBean使用指定的"dataSource"配置的，则将自动检测到DataSource：您仍然可以显式指定DataSource，但在这种情况下则不需要。 
	 *  <p>此DataSource的事务JDBC连接将提供给直接通过DataSourceUtils或JdbcTemplate访问此DataSource的应用程序代码。 
	 * 连接将从休眠会话中获取。 
	 *  <p>此处指定的数据源应该是管理事务的目标数据源，而不是TransactionAwareDataSourceProxy。 
	 * 只有数据访问代码才能与TransactionAwareDataSourceProxy一起使用，而事务管理器则需要在基础目标DataSource上工作。 
	 * 但是，如果仍然传递了TransactionAwareDataSourceProxy，它将被解包以提取其目标DataSource。 
	 *  <p> <b>注意：对于具有许多事务的示例，这些事务仅从Hibernate的缓存中读取数据（并且实际上不访问数据库），请考虑使用{{@link> org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy}实际目标数据源。 
	 * 或者，考虑将{@link  #setPrepareConnection"prepareConnection"}切换为{@code  false}。 
	 * </ b>在两种情况下，此事务管理器将不再急切地为每个Hibernate会话获取JDBC连接（自Spring 5.1）。 
	 *  
	 * @see  #setAutodetectDataSource 
	 * @see  TransactionAwareDataSourceProxy 
	 * @see  org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy 
	 * @see  org.springframework.jdbc.core.JdbcTemplate
	 */
	public void setDataSource(@Nullable DataSource dataSource) {
		if (dataSource instanceof TransactionAwareDataSourceProxy) {
			// If we got a TransactionAwareDataSourceProxy, we need to perform transactions
			// for its underlying target DataSource, else data access code won't see
			// properly exposed transactions (i.e. transactions for the target DataSource).
			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();
		}
		else {
			this.dataSource = dataSource;
		}
	}

	/**
	 * Return the JDBC DataSource that this instance manages transactions for.
	 */
	/**
	 * 返回此实例为其管理事务的JDBC DataSource。 
	 * 
	 */
	@Nullable
	public DataSource getDataSource() {
		return this.dataSource;
	}

	/**
	 * Set whether to autodetect a JDBC DataSource used by the Hibernate SessionFactory,
	 * if set via LocalSessionFactoryBean's {@code setDataSource}. Default is "true".
	 * <p>Can be turned off to deliberately ignore an available DataSource, in order
	 * to not expose Hibernate transactions as JDBC transactions for that DataSource.
	 * @see #setDataSource
	 */
	/**
	 * 设置是否通过LocalSessionFactoryBean的{@code  setDataSource}设置是否自动检测Hibernate SessionFactory使用的JDBC数据源。 
	 * 默认值为"true"。 
	 *  <p>可以关闭以故意忽略可用的数据源，以免将Hibernate事务公开为该数据源的JDBC事务。 
	 *  
	 * @see  #setDataSource
	 */
	public void setAutodetectDataSource(boolean autodetectDataSource) {
		this.autodetectDataSource = autodetectDataSource;
	}

	/**
	 * Set whether to prepare the underlying JDBC Connection of a transactional
	 * Hibernate Session, that is, whether to apply a transaction-specific
	 * isolation level and/or the transaction's read-only flag to the underlying
	 * JDBC Connection.
	 * <p>Default is "true". If you turn this flag off, the transaction manager
	 * will not support per-transaction isolation levels anymore. It will not
	 * call {@code Connection.setReadOnly(true)} for read-only transactions
	 * anymore either. If this flag is turned off, no cleanup of a JDBC Connection
	 * is required after a transaction, since no Connection settings will get modified.
	 * @see Connection#setTransactionIsolation
	 * @see Connection#setReadOnly
	 */
	/**
	 * 设置是否准备事务性Hibernate会话的基础JDBC连接，即是否将事务特定的隔离级别和/或事务的只读标志应用于基础JDBC连接。 
	 *  <p>默认为"true"。 
	 * 如果关闭此标志，则事务管理器将不再支持每个事务的隔离级别。 
	 * 它也不会再为只读事务调用{@code  Connection.setReadOnly（true）}。 
	 * 如果关闭此标志，则在事务处理后无需清理JDBC连接，因为不会修改任何连接设置。 
	 *  
	 * @see  Connection＃setTransactionIsolation 
	 * @see  Connection＃setReadOnly
	 */
	public void setPrepareConnection(boolean prepareConnection) {
		this.prepareConnection = prepareConnection;
	}

	/**
	 * Set whether to allow result access after completion, typically via Hibernate's
	 * ScrollableResults mechanism.
	 * <p>Default is "false". Turning this flag on enforces over-commit holdability on the
	 * underlying JDBC Connection (if {@link #prepareConnection "prepareConnection"} is on)
	 * and skips the disconnect-on-completion step.
	 * @see Connection#setHoldability
	 * @see ResultSet#HOLD_CURSORS_OVER_COMMIT
	 * @see #disconnectOnCompletion(Session)
	 */
	/**
	 * 设置是否允许在完成之后访问结果，通常是通过Hibernate的ScrollableResults机制进行的。 
	 *  <p>默认为"false"。 
	 * 启用此标志将对基础JDBC连接强制实施过量提交的保持性（如果{@link  #prepareConnection"prepareConnection"}处于启用状态），则跳过"完成时断开连接"步骤。 
	 *  
	 * @see  Connection＃setHoldability 
	 * @see  ResultSet＃HOLD_CURSORS_OVER_COMMIT 
	 * @see  #disconnectOnCompletion（Session）
	 */
	public void setAllowResultAccessAfterCompletion(boolean allowResultAccessAfterCompletion) {
		this.allowResultAccessAfterCompletion = allowResultAccessAfterCompletion;
	}

	/**
	 * Set whether to operate on a Hibernate-managed Session instead of a
	 * Spring-managed Session, that is, whether to obtain the Session through
	 * Hibernate's {@link SessionFactory#getCurrentSession()}
	 * instead of {@link SessionFactory#openSession()} (with a Spring
	 * {@link TransactionSynchronizationManager}
	 * check preceding it).
	 * <p>Default is "false", i.e. using a Spring-managed Session: taking the current
	 * thread-bound Session if available (e.g. in an Open-Session-in-View scenario),
	 * creating a new Session for the current transaction otherwise.
	 * <p>Switch this flag to "true" in order to enforce use of a Hibernate-managed Session.
	 * Note that this requires {@link SessionFactory#getCurrentSession()}
	 * to always return a proper Session when called for a Spring-managed transaction;
	 * transaction begin will fail if the {@code getCurrentSession()} call fails.
	 * <p>This mode will typically be used in combination with a custom Hibernate
	 * {@link org.hibernate.context.spi.CurrentSessionContext} implementation that stores
	 * Sessions in a place other than Spring's TransactionSynchronizationManager.
	 * It may also be used in combination with Spring's Open-Session-in-View support
	 * (using Spring's default {@link SpringSessionContext}), in which case it subtly
	 * differs from the Spring-managed Session mode: The pre-bound Session will <i>not</i>
	 * receive a {@code clear()} call (on rollback) or a {@code disconnect()}
	 * call (on transaction completion) in such a scenario; this is rather left up
	 * to a custom CurrentSessionContext implementation (if desired).
	 */
	/**
	 * 设置是否在Hibernate管理的Session而不是Spring管理的Session上进行操作，即是否通过Hibernate的{@link  SessionFactory＃getCurrentSession（）}而不是{@link  SessionFactory＃openSession（ ）}（在其前面进行Spring {@link  TransactionSynchronizationManager}检查）。 
	 *  <p>默认为"false"，即使用Spring管理的会话：如果有的话（例如，在Open-Session-in-View场景中）使用当前线程绑定的Session，否则为当前事务创建新的Session。 
	 *  <p>将此标志切换为"true"，以强制使用Hibernate管理的会话。 
	 * 请注意，这要求{@link  SessionFactory＃getCurrentSession（）}在调用Spring托管事务时始终返回正确的Session； 
	 * 如果{@code  getCurrentSession（）}调用失败，则事务开始将失败。 
	 *  <p>此模式通常将与自定义的Hibernate {@link  org.hibernate.context.spi.CurrentSessionContext}实现结合使用，该实现将Session存储在Spring的TransactionSynchronizationManager之外的其他位置。 
	 * 它也可以与Spring的Open-Session-in-View支持一起使用（使用Spring的默认{@link  SpringSessionContext}），在这种情况下，它与Spring托管的Session模式有细微的区别：在这种情况下，<i>不</ i>收到{@code  clear（）}调用（在回滚时）或{{@@code> disconnect（）}调用（在事务完成时）； 
	 * 而是将其留给自定义CurrentSessionContext实现（如果需要）。 
	 * 
	 */
	public void setHibernateManagedSession(boolean hibernateManagedSession) {
		this.hibernateManagedSession = hibernateManagedSession;
	}

	/**
	 * Set the bean name of a Hibernate entity interceptor that allows to inspect
	 * and change property values before writing to and reading from the database.
	 * Will get applied to any new Session created by this transaction manager.
	 * <p>Requires the bean factory to be known, to be able to resolve the bean
	 * name to an interceptor instance on session creation. Typically used for
	 * prototype interceptors, i.e. a new interceptor instance per session.
	 * <p>Can also be used for shared interceptor instances, but it is recommended
	 * to set the interceptor reference directly in such a scenario.
	 * @param entityInterceptorBeanName the name of the entity interceptor in
	 * the bean factory
	 * @see #setBeanFactory
	 * @see #setEntityInterceptor
	 */
	/**
	 * 设置Hibernate实体拦截器的bean名称，该拦截器允许在写入数据库和从数据库读取之前检查和更改属性值。 
	 * 将应用于该事务管理器创建的任何新会话。 
	 *  <p>要求知道bean工厂，以便能够在会话创建时将bean名称解析为拦截器实例。 
	 * 通常用于原型拦截器，即每个会话一个新的拦截器实例。 
	 *  <p>也可以用于共享的拦截器实例，但是建议在这种情况下直接设置拦截器引用。 
	 *  
	 * @param  entityInterceptorBeanName Bean工厂中实体拦截器的名称
	 * @see  #setBeanFactory 
	 * @see  #setEntityInterceptor
	 */
	public void setEntityInterceptorBeanName(String entityInterceptorBeanName) {
		this.entityInterceptor = entityInterceptorBeanName;
	}

	/**
	 * Set a Hibernate entity interceptor that allows to inspect and change
	 * property values before writing to and reading from the database.
	 * Will get applied to any new Session created by this transaction manager.
	 * <p>Such an interceptor can either be set at the SessionFactory level,
	 * i.e. on LocalSessionFactoryBean, or at the Session level, i.e. on
	 * HibernateTransactionManager.
	 * @see LocalSessionFactoryBean#setEntityInterceptor
	 */
	/**
	 * 设置一个Hibernate实体拦截器，该拦截器允许在写入数据库和从数据库读取之前检查和更改属性值。 
	 * 将应用于该事务管理器创建的任何新会话。 
	 *  <p>此类拦截器可以在SessionFactory级别（即LocalSessionFactoryBean）上设置，也可以在Session级别（即HibernateTransactionManager）上设置。 
	 *  
	 * @see  LocalSessionFactoryBean＃setEntityInterceptor
	 */
	public void setEntityInterceptor(@Nullable Interceptor entityInterceptor) {
		this.entityInterceptor = entityInterceptor;
	}

	/**
	 * Return the current Hibernate entity interceptor, or {@code null} if none.
	 * Resolves an entity interceptor bean name via the bean factory,
	 * if necessary.
	 * @throws IllegalStateException if bean name specified but no bean factory set
	 * @throws BeansException if bean name resolution via the bean factory failed
	 * @see #setEntityInterceptor
	 * @see #setEntityInterceptorBeanName
	 * @see #setBeanFactory
	 */
	/**
	 * 返回当前的Hibernate实体拦截器； 
	 * 如果没有，则返回{@code  null}。 
	 * 如有必要，通过bean工厂解析实体拦截器bean名称。 
	 *  
	 * @throws 如果指定了bean名称但未设置bean工厂，则为IllegalStateException 
	 * @throws 如果通过bean工厂解析bean名称失败的BeansException 
	 * @see  #setEntityInterceptor＃
	 */
	@Nullable
	public Interceptor getEntityInterceptor() throws IllegalStateException, BeansException {
		if (this.entityInterceptor instanceof Interceptor) {
			return (Interceptor) this.entityInterceptor;
		}
		else if (this.entityInterceptor instanceof String) {
			if (this.beanFactory == null) {
				throw new IllegalStateException("Cannot get entity interceptor via bean name if no bean factory set");
			}
			String beanName = (String) this.entityInterceptor;
			return this.beanFactory.getBean(beanName, Interceptor.class);
		}
		else {
			return null;
		}
	}

	/**
	 * The bean factory just needs to be known for resolving entity interceptor
	 * bean names. It does not need to be set for any other mode of operation.
	 * @see #setEntityInterceptorBeanName
	 */
	/**
	 * 只需知道bean工厂解析实体拦截器bean名称即可。 
	 * 无需将其设置为任何其他操作模式。 
	 *  
	 * @see  #setEntityInterceptorBeanName
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}

	@Override
	public void afterPropertiesSet() {
		if (getSessionFactory() == null) {
			throw new IllegalArgumentException("Property 'sessionFactory' is required");
		}
		if (this.entityInterceptor instanceof String && this.beanFactory == null) {
			throw new IllegalArgumentException("Property 'beanFactory' is required for 'entityInterceptorBeanName'");
		}

		// Check for SessionFactory's DataSource.
		if (this.autodetectDataSource && getDataSource() == null) {
			DataSource sfds = SessionFactoryUtils.getDataSource(getSessionFactory());
			if (sfds != null) {
				// Use the SessionFactory's DataSource for exposing transactions to JDBC code.
				if (logger.isDebugEnabled()) {
					logger.debug("Using DataSource [" + sfds +
							"] of Hibernate SessionFactory for HibernateTransactionManager");
				}
				setDataSource(sfds);
			}
		}
	}


	@Override
	public Object getResourceFactory() {
		return obtainSessionFactory();
	}

	@Override
	protected Object doGetTransaction() {
		HibernateTransactionObject txObject = new HibernateTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());

		SessionFactory sessionFactory = obtainSessionFactory();
		SessionHolder sessionHolder =
				(SessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
		if (sessionHolder != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Found thread-bound Session [" + sessionHolder.getSession() + "] for Hibernate transaction");
			}
			txObject.setSessionHolder(sessionHolder);
		}
		else if (this.hibernateManagedSession) {
			try {
				Session session = sessionFactory.getCurrentSession();
				if (logger.isDebugEnabled()) {
					logger.debug("Found Hibernate-managed Session [" + session + "] for Spring-managed transaction");
				}
				txObject.setExistingSession(session);
			}
			catch (HibernateException ex) {
				throw new DataAccessResourceFailureException(
						"Could not obtain Hibernate-managed Session for Spring-managed transaction", ex);
			}
		}

		if (getDataSource() != null) {
			ConnectionHolder conHolder = (ConnectionHolder)
					TransactionSynchronizationManager.getResource(getDataSource());
			txObject.setConnectionHolder(conHolder);
		}

		return txObject;
	}

	@Override
	protected boolean isExistingTransaction(Object transaction) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) transaction;
		return (txObject.hasSpringManagedTransaction() ||
				(this.hibernateManagedSession && txObject.hasHibernateManagedTransaction()));
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void doBegin(Object transaction, TransactionDefinition definition) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) transaction;

		if (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
			throw new IllegalTransactionStateException(
					"Pre-bound JDBC Connection found! HibernateTransactionManager does not support " +
					"running within DataSourceTransactionManager if told to manage the DataSource itself. " +
					"It is recommended to use a single HibernateTransactionManager for all transactions " +
					"on a single DataSource, no matter whether Hibernate or JDBC access.");
		}

		Session session = null;

		try {
			if (!txObject.hasSessionHolder() || txObject.getSessionHolder().isSynchronizedWithTransaction()) {
				Interceptor entityInterceptor = getEntityInterceptor();
				Session newSession = (entityInterceptor != null ?
						obtainSessionFactory().withOptions().interceptor(entityInterceptor).openSession() :
						obtainSessionFactory().openSession());
				if (logger.isDebugEnabled()) {
					logger.debug("Opened new Session [" + newSession + "] for Hibernate transaction");
				}
				txObject.setSession(newSession);
			}

			session = txObject.getSessionHolder().getSession();

			boolean holdabilityNeeded = this.allowResultAccessAfterCompletion && !txObject.isNewSession();
			boolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT);
			if (holdabilityNeeded || isolationLevelNeeded || definition.isReadOnly()) {
				if (this.prepareConnection && isSameConnectionForEntireSession(session)) {
					// We're allowed to change the transaction settings of the JDBC Connection.
					if (logger.isDebugEnabled()) {
						logger.debug("Preparing JDBC Connection of Hibernate Session [" + session + "]");
					}
					Connection con = ((SessionImplementor) session).connection();
					Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
					txObject.setPreviousIsolationLevel(previousIsolationLevel);
					txObject.setReadOnly(definition.isReadOnly());
					if (this.allowResultAccessAfterCompletion && !txObject.isNewSession()) {
						int currentHoldability = con.getHoldability();
						if (currentHoldability != ResultSet.HOLD_CURSORS_OVER_COMMIT) {
							txObject.setPreviousHoldability(currentHoldability);
							con.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
						}
					}
				}
				else {
					// Not allowed to change the transaction settings of the JDBC Connection.
					if (isolationLevelNeeded) {
						// We should set a specific isolation level but are not allowed to...
						throw new InvalidIsolationLevelException(
								"HibernateTransactionManager is not allowed to support custom isolation levels: " +
								"make sure that its 'prepareConnection' flag is on (the default) and that the " +
								"Hibernate connection release mode is set to 'on_close' (the default for JDBC).");
					}
					if (logger.isDebugEnabled()) {
						logger.debug("Not preparing JDBC Connection of Hibernate Session [" + session + "]");
					}
				}
			}

			if (definition.isReadOnly() && txObject.isNewSession()) {
				// Just set to MANUAL in case of a new Session for this transaction.
				session.setFlushMode(FlushMode.MANUAL);
				// As of 5.1, we're also setting Hibernate's read-only entity mode by default.
				session.setDefaultReadOnly(true);
			}

			if (!definition.isReadOnly() && !txObject.isNewSession()) {
				// We need AUTO or COMMIT for a non-read-only transaction.
				FlushMode flushMode = SessionFactoryUtils.getFlushMode(session);
				if (FlushMode.MANUAL.equals(flushMode)) {
					session.setFlushMode(FlushMode.AUTO);
					txObject.getSessionHolder().setPreviousFlushMode(flushMode);
				}
			}

			Transaction hibTx;

			// Register transaction timeout.
			int timeout = determineTimeout(definition);
			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
				// Use Hibernate's own transaction timeout mechanism on Hibernate 3.1+
				// Applies to all statements, also to inserts, updates and deletes!
				hibTx = session.getTransaction();
				hibTx.setTimeout(timeout);
				hibTx.begin();
			}
			else {
				// Open a plain Hibernate transaction without specified timeout.
				hibTx = session.beginTransaction();
			}

			// Add the Hibernate transaction to the session holder.
			txObject.getSessionHolder().setTransaction(hibTx);

			// Register the Hibernate Session's JDBC Connection for the DataSource, if set.
			if (getDataSource() != null) {
				SessionImplementor sessionImpl = (SessionImplementor) session;
				// The following needs to use a lambda expression instead of a method reference
				// for compatibility with Hibernate ORM <5.2 where connection() is defined on
				// SessionImplementor itself instead of on SharedSessionContractImplementor...
				ConnectionHolder conHolder = new ConnectionHolder(() -> sessionImpl.connection());
				if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
					conHolder.setTimeoutInSeconds(timeout);
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Exposing Hibernate transaction as JDBC [" + conHolder.getConnectionHandle() + "]");
				}
				TransactionSynchronizationManager.bindResource(getDataSource(), conHolder);
				txObject.setConnectionHolder(conHolder);
			}

			// Bind the session holder to the thread.
			if (txObject.isNewSessionHolder()) {
				TransactionSynchronizationManager.bindResource(obtainSessionFactory(), txObject.getSessionHolder());
			}
			txObject.getSessionHolder().setSynchronizedWithTransaction(true);
		}

		catch (Throwable ex) {
			if (txObject.isNewSession()) {
				try {
					if (session != null && session.getTransaction().getStatus() == TransactionStatus.ACTIVE) {
						session.getTransaction().rollback();
					}
				}
				catch (Throwable ex2) {
					logger.debug("Could not rollback Session after failed transaction begin", ex);
				}
				finally {
					SessionFactoryUtils.closeSession(session);
					txObject.setSessionHolder(null);
				}
			}
			throw new CannotCreateTransactionException("Could not open Hibernate Session for transaction", ex);
		}
	}

	@Override
	protected Object doSuspend(Object transaction) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) transaction;
		txObject.setSessionHolder(null);
		SessionHolder sessionHolder =
				(SessionHolder) TransactionSynchronizationManager.unbindResource(obtainSessionFactory());
		txObject.setConnectionHolder(null);
		ConnectionHolder connectionHolder = null;
		if (getDataSource() != null) {
			connectionHolder = (ConnectionHolder) TransactionSynchronizationManager.unbindResource(getDataSource());
		}
		return new SuspendedResourcesHolder(sessionHolder, connectionHolder);
	}

	@Override
	protected void doResume(@Nullable Object transaction, Object suspendedResources) {
		SessionFactory sessionFactory = obtainSessionFactory();

		SuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources;
		if (TransactionSynchronizationManager.hasResource(sessionFactory)) {
			// From non-transactional code running in active transaction synchronization
			// -> can be safely removed, will be closed on transaction completion.
			TransactionSynchronizationManager.unbindResource(sessionFactory);
		}
		TransactionSynchronizationManager.bindResource(sessionFactory, resourcesHolder.getSessionHolder());
		if (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {
			TransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder());
		}
	}

	@Override
	protected void doCommit(DefaultTransactionStatus status) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction();
		Transaction hibTx = txObject.getSessionHolder().getTransaction();
		Assert.state(hibTx != null, "No Hibernate transaction");
		if (status.isDebug()) {
			logger.debug("Committing Hibernate transaction on Session [" +
					txObject.getSessionHolder().getSession() + "]");
		}

		try {
			hibTx.commit();
		}
		catch (org.hibernate.TransactionException ex) {
			// assumably from commit call to the underlying JDBC connection
			throw new TransactionSystemException("Could not commit Hibernate transaction", ex);
		}
		catch (HibernateException ex) {
			// assumably failed to flush changes to database
			throw convertHibernateAccessException(ex);
		}
		catch (PersistenceException ex) {
			if (ex.getCause() instanceof HibernateException) {
				throw convertHibernateAccessException((HibernateException) ex.getCause());
			}
			throw ex;
		}
	}

	@Override
	protected void doRollback(DefaultTransactionStatus status) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction();
		Transaction hibTx = txObject.getSessionHolder().getTransaction();
		Assert.state(hibTx != null, "No Hibernate transaction");
		if (status.isDebug()) {
			logger.debug("Rolling back Hibernate transaction on Session [" +
					txObject.getSessionHolder().getSession() + "]");
		}

		try {
			hibTx.rollback();
		}
		catch (org.hibernate.TransactionException ex) {
			throw new TransactionSystemException("Could not roll back Hibernate transaction", ex);
		}
		catch (HibernateException ex) {
			// Shouldn't really happen, as a rollback doesn't cause a flush.
			throw convertHibernateAccessException(ex);
		}
		catch (PersistenceException ex) {
			if (ex.getCause() instanceof HibernateException) {
				throw convertHibernateAccessException((HibernateException) ex.getCause());
			}
			throw ex;
		}
		finally {
			if (!txObject.isNewSession() && !this.hibernateManagedSession) {
				// Clear all pending inserts/updates/deletes in the Session.
				// Necessary for pre-bound Sessions, to avoid inconsistent state.
				txObject.getSessionHolder().getSession().clear();
			}
		}
	}

	@Override
	protected void doSetRollbackOnly(DefaultTransactionStatus status) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction();
		if (status.isDebug()) {
			logger.debug("Setting Hibernate transaction on Session [" +
					txObject.getSessionHolder().getSession() + "] rollback-only");
		}
		txObject.setRollbackOnly();
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void doCleanupAfterCompletion(Object transaction) {
		HibernateTransactionObject txObject = (HibernateTransactionObject) transaction;

		// Remove the session holder from the thread.
		if (txObject.isNewSessionHolder()) {
			TransactionSynchronizationManager.unbindResource(obtainSessionFactory());
		}

		// Remove the JDBC connection holder from the thread, if exposed.
		if (getDataSource() != null) {
			TransactionSynchronizationManager.unbindResource(getDataSource());
		}

		Session session = txObject.getSessionHolder().getSession();
		if (this.prepareConnection && isPhysicallyConnected(session)) {
			// We're running with connection release mode "on_close": We're able to reset
			// the isolation level and/or read-only flag of the JDBC Connection here.
			// Else, we need to rely on the connection pool to perform proper cleanup.
			try {
				Connection con = ((SessionImplementor) session).connection();
				Integer previousHoldability = txObject.getPreviousHoldability();
				if (previousHoldability != null) {
					con.setHoldability(previousHoldability);
				}
				DataSourceUtils.resetConnectionAfterTransaction(
						con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());
			}
			catch (HibernateException ex) {
				logger.debug("Could not access JDBC Connection of Hibernate Session", ex);
			}
			catch (Throwable ex) {
				logger.debug("Could not reset JDBC Connection after transaction", ex);
			}
		}

		if (txObject.isNewSession()) {
			if (logger.isDebugEnabled()) {
				logger.debug("Closing Hibernate Session [" + session + "] after transaction");
			}
			SessionFactoryUtils.closeSession(session);
		}
		else {
			if (logger.isDebugEnabled()) {
				logger.debug("Not closing pre-bound Hibernate Session [" + session + "] after transaction");
			}
			if (txObject.getSessionHolder().getPreviousFlushMode() != null) {
				session.setFlushMode(txObject.getSessionHolder().getPreviousFlushMode());
			}
			if (!this.allowResultAccessAfterCompletion && !this.hibernateManagedSession) {
				disconnectOnCompletion(session);
			}
		}
		txObject.getSessionHolder().clear();
	}

	/**
	 * Disconnect a pre-existing Hibernate Session on transaction completion,
	 * returning its database connection but preserving its entity state.
	 * <p>The default implementation simply calls {@link Session#disconnect()}.
	 * Subclasses may override this with a no-op or with fine-tuned disconnection logic.
	 * @param session the Hibernate Session to disconnect
	 * @see Session#disconnect()
	 */
	/**
	 * 在事务完成时断开先前存在的Hibernate会话，返回其数据库连接但保留其实体状态。 
	 *  <p>默认实现只是调用{@link  Session＃disconnect（）}。 
	 * 子类可以使用无操作或经过微调的断开逻辑来覆盖它。 
	 *  
	 * @param 会话Hibernate会话断开连接
	 * @see  Session＃disconnect（）
	 */
	protected void disconnectOnCompletion(Session session) {
		session.disconnect();
	}

	/**
	 * Return whether the given Hibernate Session will always hold the same
	 * JDBC Connection. This is used to check whether the transaction manager
	 * can safely prepare and clean up the JDBC Connection used for a transaction.
	 * <p>The default implementation checks the Session's connection release mode
	 * to be "on_close".
	 * @param session the Hibernate Session to check
	 * @see ConnectionReleaseMode#ON_CLOSE
	 */
	/**
	 * 返回给定的Hibernate会话是否将始终保持相同的JDBC连接。 
	 * 这用于检查事务管理器是否可以安全地准备和清理用于事务的JDBC连接。 
	 *  <p>默认实现将会话的连接释放模式检查为"on_close"。 
	 *  
	 * @param 会话Hibernate会话以检查
	 * @see  ConnectionReleaseMode＃ON_CLOSE
	 */
	@SuppressWarnings("deprecation")
	protected boolean isSameConnectionForEntireSession(Session session) {
		if (!(session instanceof SessionImplementor)) {
			// The best we can do is to assume we're safe.
			return true;
		}
		ConnectionReleaseMode releaseMode =
				((SessionImplementor) session).getJdbcCoordinator().getConnectionReleaseMode();
		return ConnectionReleaseMode.ON_CLOSE.equals(releaseMode);
	}

	/**
	 * Determine whether the given Session is (still) physically connected
	 * to the database, that is, holds an active JDBC Connection internally.
	 * @param session the Hibernate Session to check
	 * @see #isSameConnectionForEntireSession(Session)
	 */
	/**
	 * 确定给定的Session是否（仍然）物理连接到数据库，也就是说，内部是否保持活动的JDBC Connection。 
	 *  
	 * @param 会话Hibernate会话以检查
	 * @see  #isSameConnectionForEntireSession（Session）
	 */
	protected boolean isPhysicallyConnected(Session session) {
		if (!(session instanceof SessionImplementor)) {
			// The best we can do is to check whether we're logically connected.
			return session.isConnected();
		}
		return ((SessionImplementor) session).getJdbcCoordinator().getLogicalConnection().isPhysicallyConnected();
	}


	/**
	 * Convert the given HibernateException to an appropriate exception
	 * from the {@code org.springframework.dao} hierarchy.
	 * <p>Will automatically apply a specified SQLExceptionTranslator to a
	 * Hibernate JDBCException, else rely on Hibernate's default translation.
	 * @param ex the HibernateException that occurred
	 * @return a corresponding DataAccessException
	 * @see SessionFactoryUtils#convertHibernateAccessException
	 */
	/**
	 * 将给定的HibernateException转换为{@code  org.springframework.dao}层次结构中的适当异常。 
	 *  <p>将自动将指定的SQLExceptionTranslator应用于Hibernate JDBCException，否则将依赖于Hibernate的默认翻译。 
	 *  
	 * @param 发生的HibernateException 
	 * @return 相应的DataAccessException 
	 * @see  SessionFactoryUtils＃convertHibernateAccessException
	 */
	protected DataAccessException convertHibernateAccessException(HibernateException ex) {
		return SessionFactoryUtils.convertHibernateAccessException(ex);
	}


	/**
	 * Hibernate transaction object, representing a SessionHolder.
	 * Used as transaction object by HibernateTransactionManager.
	 */
	/**
	 * 休眠事务对象，代表一个SessionHolder。 
	 * 由HibernateTransactionManager用作事务对象。 
	 * 
	 */
	private class HibernateTransactionObject extends JdbcTransactionObjectSupport {

		@Nullable
		private SessionHolder sessionHolder;

		private boolean newSessionHolder;

		private boolean newSession;

		@Nullable
		private Integer previousHoldability;

		public void setSession(Session session) {
			this.sessionHolder = new SessionHolder(session);
			this.newSessionHolder = true;
			this.newSession = true;
		}

		public void setExistingSession(Session session) {
			this.sessionHolder = new SessionHolder(session);
			this.newSessionHolder = true;
			this.newSession = false;
		}

		public void setSessionHolder(@Nullable SessionHolder sessionHolder) {
			this.sessionHolder = sessionHolder;
			this.newSessionHolder = false;
			this.newSession = false;
		}

		public SessionHolder getSessionHolder() {
			Assert.state(this.sessionHolder != null, "No SessionHolder available");
			return this.sessionHolder;
		}

		public boolean hasSessionHolder() {
			return (this.sessionHolder != null);
		}

		public boolean isNewSessionHolder() {
			return this.newSessionHolder;
		}

		public boolean isNewSession() {
			return this.newSession;
		}

		public void setPreviousHoldability(@Nullable Integer previousHoldability) {
			this.previousHoldability = previousHoldability;
		}

		@Nullable
		public Integer getPreviousHoldability() {
			return this.previousHoldability;
		}

		public boolean hasSpringManagedTransaction() {
			return (this.sessionHolder != null && this.sessionHolder.getTransaction() != null);
		}

		public boolean hasHibernateManagedTransaction() {
			return (this.sessionHolder != null &&
					this.sessionHolder.getSession().getTransaction().getStatus() == TransactionStatus.ACTIVE);
		}

		public void setRollbackOnly() {
			getSessionHolder().setRollbackOnly();
			if (hasConnectionHolder()) {
				getConnectionHolder().setRollbackOnly();
			}
		}

		@Override
		public boolean isRollbackOnly() {
			return getSessionHolder().isRollbackOnly() ||
					(hasConnectionHolder() && getConnectionHolder().isRollbackOnly());
		}

		@Override
		public void flush() {
			try {
				getSessionHolder().getSession().flush();
			}
			catch (HibernateException ex) {
				throw convertHibernateAccessException(ex);
			}
			catch (PersistenceException ex) {
				if (ex.getCause() instanceof HibernateException) {
					throw convertHibernateAccessException((HibernateException) ex.getCause());
				}
				throw ex;
			}
		}
	}


	/**
	 * Holder for suspended resources.
	 * Used internally by {@code doSuspend} and {@code doResume}.
	 */
	/**
	 * 暂挂资源的持有者。 
	 * 由{@code  doSuspend}和{@code  doResume}内部使用。 
	 * 
	 */
	private static final class SuspendedResourcesHolder {

		private final SessionHolder sessionHolder;

		@Nullable
		private final ConnectionHolder connectionHolder;

		private SuspendedResourcesHolder(SessionHolder sessionHolder, @Nullable ConnectionHolder conHolder) {
			this.sessionHolder = sessionHolder;
			this.connectionHolder = conHolder;
		}

		private SessionHolder getSessionHolder() {
			return this.sessionHolder;
		}

		@Nullable
		private ConnectionHolder getConnectionHolder() {
			return this.connectionHolder;
		}
	}

}
