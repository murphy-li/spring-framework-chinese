/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.orm.hibernate5;

import java.io.File;
import java.io.IOException;
import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.Interceptor;
import org.hibernate.SessionFactory;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
import org.hibernate.cache.spi.RegionFactory;
import org.hibernate.cfg.Configuration;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.hibernate.integrator.spi.Integrator;
import org.hibernate.service.ServiceRegistry;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternUtils;
import org.springframework.core.task.AsyncTaskExecutor;
import org.springframework.core.type.filter.TypeFilter;
import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;

/**
 * {@link FactoryBean} that creates a Hibernate {@link SessionFactory}. This is the usual
 * way to set up a shared Hibernate SessionFactory in a Spring application context; the
 * SessionFactory can then be passed to data access objects via dependency injection.
 *
 * <p>Compatible with Hibernate 5.0/5.1 as well as 5.2/5.3, as of Spring 5.1.
 * Set up with Hibernate 5.3, {@code LocalSessionFactoryBean} is an immediate alternative
 * to {@link org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean} for common
 * JPA purposes: In particular with Hibernate 5.3, the Hibernate {@code SessionFactory}
 * will natively expose the JPA {@code EntityManagerFactory} interface as well, and
 * Hibernate {@code BeanContainer} integration will be registered out of the box.
 * In combination with {@link HibernateTransactionManager}, this naturally allows for
 * mixing JPA access code with native Hibernate access code within the same transaction.
 *
 * @author Juergen Hoeller
 * @since 4.2
 * @see #setDataSource
 * @see #setPackagesToScan
 * @see HibernateTransactionManager
 * @see LocalSessionFactoryBuilder
 * @see org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean
 */
/**
 * {@link  FactoryBean}创建一个休眠{{@link> SessionFactory}。 
 * 这是在Spring应用程序上下文中建立共享的Hibernate SessionFactory的常用方法。 
 * 然后可以通过依赖注入将SessionFactory传递给数据访问对象。 
 *  <p>从Spring 5.1开始与Hibernate 5.0 / 5.1和5.2 / 5.3兼容。 
 * 使用Hibernate 5.3进行设置，{<@code> LocalSessionFactoryBean}是{@link  org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean}的直接替代品，用于常见的JPA：特别是在Hibernate 5.3中，Hibernate {<@code > SessionFactory}还将本机公开JPA {@code  EntityManagerFactory}接口，并且Hibernate {@code  BeanContainer}集成将直接注册。 
 * 与{@link  HibernateTransactionManager}结合使用，自然可以在同一事务中将JPA访问代码与本机Hibernate访问代码混合。 
 *  @author  Juergen Hoeller @始于4.2 
 * @see  #setDataSource 
 * @see  #setPackagesToScan 
 * @see  HibernateTransactionManager 
 * @see  LocalSessionFactoryBuilder 
 * @see  org.springframework.orm.jpa.LocalContainerEntityManagerManagerBean
 */
public class LocalSessionFactoryBean extends HibernateExceptionTranslator
		implements FactoryBean<SessionFactory>, ResourceLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean {

	@Nullable
	private DataSource dataSource;

	@Nullable
	private Resource[] configLocations;

	@Nullable
	private String[] mappingResources;

	@Nullable
	private Resource[] mappingLocations;

	@Nullable
	private Resource[] cacheableMappingLocations;

	@Nullable
	private Resource[] mappingJarLocations;

	@Nullable
	private Resource[] mappingDirectoryLocations;

	@Nullable
	private Interceptor entityInterceptor;

	@Nullable
	private ImplicitNamingStrategy implicitNamingStrategy;

	@Nullable
	private PhysicalNamingStrategy physicalNamingStrategy;

	@Nullable
	private Object jtaTransactionManager;

	@Nullable
	private RegionFactory cacheRegionFactory;

	@Nullable
	private MultiTenantConnectionProvider multiTenantConnectionProvider;

	@Nullable
	private CurrentTenantIdentifierResolver currentTenantIdentifierResolver;

	@Nullable
	private Properties hibernateProperties;

	@Nullable
	private TypeFilter[] entityTypeFilters;

	@Nullable
	private Class<?>[] annotatedClasses;

	@Nullable
	private String[] annotatedPackages;

	@Nullable
	private String[] packagesToScan;

	@Nullable
	private AsyncTaskExecutor bootstrapExecutor;

	@Nullable
	private Integrator[] hibernateIntegrators;

	private boolean metadataSourcesAccessed = false;

	@Nullable
	private MetadataSources metadataSources;

	@Nullable
	private ResourcePatternResolver resourcePatternResolver;

	@Nullable
	private ConfigurableListableBeanFactory beanFactory;

	@Nullable
	private Configuration configuration;

	@Nullable
	private SessionFactory sessionFactory;


	/**
	 * Set the DataSource to be used by the SessionFactory.
	 * If set, this will override corresponding settings in Hibernate properties.
	 * <p>If this is set, the Hibernate settings should not define
	 * a connection provider to avoid meaningless double configuration.
	 */
	/**
	 * 设置要由SessionFactory使用的数据源。 
	 * 如果设置，它将覆盖休眠属性中的相应设置。 
	 *  <p>如果设置了该选项，则休眠设置不应定义连接提供程序，以避免无意义的双重配置。 
	 * 
	 */
	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	/**
	 * Set the location of a single Hibernate XML config file, for example as
	 * classpath resource "classpath:hibernate.cfg.xml".
	 * <p>Note: Can be omitted when all necessary properties and mapping
	 * resources are specified locally via this bean.
	 * @see Configuration#configure(java.net.URL)
	 */
	/**
	 * 设置单个Hibernate XML配置文件的位置，例如，作为类路径资源"classpath：hibernate.cfg.xml"。 
	 *  <p>注意：当通过此bean在本地指定所有必要的属性和映射资源时，可以省略。 
	 *  
	 * @see 配置#configure（java.net.URL）
	 */
	public void setConfigLocation(Resource configLocation) {
		this.configLocations = new Resource[] {configLocation};
	}

	/**
	 * Set the locations of multiple Hibernate XML config files, for example as
	 * classpath resources "classpath:hibernate.cfg.xml,classpath:extension.cfg.xml".
	 * <p>Note: Can be omitted when all necessary properties and mapping
	 * resources are specified locally via this bean.
	 * @see Configuration#configure(java.net.URL)
	 */
	/**
	 * 设置多个Hibernate XML配置文件的位置，例如作为类路径资源"classpath：hibernate.cfg.xml，classpath：extension.cfg.xml"。 
	 *  <p>注意：当通过此bean在本地指定所有必要的属性和映射资源时，可以省略。 
	 *  
	 * @see 配置#configure（java.net.URL）
	 */
	public void setConfigLocations(Resource... configLocations) {
		this.configLocations = configLocations;
	}

	/**
	 * Set Hibernate mapping resources to be found in the class path,
	 * like "example.hbm.xml" or "mypackage/example.hbm.xml".
	 * Analogous to mapping entries in a Hibernate XML config file.
	 * Alternative to the more generic setMappingLocations method.
	 * <p>Can be used to add to mappings from a Hibernate XML config file,
	 * or to specify all mappings locally.
	 * @see #setMappingLocations
	 * @see Configuration#addResource
	 */
	/**
	 * 设置要在类路径中找到的Hibernate映射资源，例如"example.hbm.xml"或"mypackage / example.hbm.xml"。 
	 * 类似于Hibernate XML配置文件中的映射条目。 
	 * 替代更通用的setMappingLocations方法。 
	 *  <p>可用于从Hibernate XML配置文件添加到映射，或在本地指定所有映射。 
	 *  
	 * @see  #setMappingLocations 
	 * @see 配置#addResource
	 */
	public void setMappingResources(String... mappingResources) {
		this.mappingResources = mappingResources;
	}

	/**
	 * Set locations of Hibernate mapping files, for example as classpath
	 * resource "classpath:example.hbm.xml". Supports any resource location
	 * via Spring's resource abstraction, for example relative paths like
	 * "WEB-INF/mappings/example.hbm.xml" when running in an application context.
	 * <p>Can be used to add to mappings from a Hibernate XML config file,
	 * or to specify all mappings locally.
	 * @see Configuration#addInputStream
	 */
	/**
	 * 设置Hibernate映射文件的位置，例如作为类路径资源"classpath：example.hbm.xml"。 
	 * 通过Spring的资源抽象支持任何资源位置，例如在应用程序上下文中运行时的相对路径，例如"WEB-INF / mappings / example.hbm.xml"。 
	 *  <p>可用于从Hibernate XML配置文件添加到映射，或在本地指定所有映射。 
	 *  
	 * @see 配置#addInputStream
	 */
	public void setMappingLocations(Resource... mappingLocations) {
		this.mappingLocations = mappingLocations;
	}

	/**
	 * Set locations of cacheable Hibernate mapping files, for example as web app
	 * resource "/WEB-INF/mapping/example.hbm.xml". Supports any resource location
	 * via Spring's resource abstraction, as long as the resource can be resolved
	 * in the file system.
	 * <p>Can be used to add to mappings from a Hibernate XML config file,
	 * or to specify all mappings locally.
	 * @see Configuration#addCacheableFile(File)
	 */
	/**
	 * 设置可缓存的Hibernate映射文件的位置，例如作为Web应用程序资源"/WEB-INF/mapping/example.hbm.xml"。 
	 * 只要可以在文件系统中解析资源，就可以通过Spring的资源抽象支持任何资源位置。 
	 *  <p>可用于从Hibernate XML配置文件添加到映射，或在本地指定所有映射。 
	 *  
	 * @see 配置#addCacheableFile（文件）
	 */
	public void setCacheableMappingLocations(Resource... cacheableMappingLocations) {
		this.cacheableMappingLocations = cacheableMappingLocations;
	}

	/**
	 * Set locations of jar files that contain Hibernate mapping resources,
	 * like "WEB-INF/lib/example.hbm.jar".
	 * <p>Can be used to add to mappings from a Hibernate XML config file,
	 * or to specify all mappings locally.
	 * @see Configuration#addJar(File)
	 */
	/**
	 * 设置包含Hibernate映射资源的jar文件的位置，例如"WEB-INF / lib / example.hbm.jar"。 
	 *  <p>可用于从Hibernate XML配置文件添加到映射，或在本地指定所有映射。 
	 *  
	 * @see 配置#addJar（文件）
	 */
	public void setMappingJarLocations(Resource... mappingJarLocations) {
		this.mappingJarLocations = mappingJarLocations;
	}

	/**
	 * Set locations of directories that contain Hibernate mapping resources,
	 * like "WEB-INF/mappings".
	 * <p>Can be used to add to mappings from a Hibernate XML config file,
	 * or to specify all mappings locally.
	 * @see Configuration#addDirectory(File)
	 */
	/**
	 * 设置包含Hibernate映射资源的目录的位置，例如"WEB-INF / mappings"。 
	 *  <p>可用于从Hibernate XML配置文件添加到映射，或在本地指定所有映射。 
	 *  
	 * @see 配置#addDirectory（文件）
	 */
	public void setMappingDirectoryLocations(Resource... mappingDirectoryLocations) {
		this.mappingDirectoryLocations = mappingDirectoryLocations;
	}

	/**
	 * Set a Hibernate entity interceptor that allows to inspect and change
	 * property values before writing to and reading from the database.
	 * Will get applied to any new Session created by this factory.
	 * @see Configuration#setInterceptor
	 */
	/**
	 * 设置一个Hibernate实体拦截器，该拦截器允许在写入数据库和从数据库读取之前检查和更改属性值。 
	 * 将应用于该工厂创建的任何新会话。 
	 *  
	 * @see 配置#setInterceptor
	 */
	public void setEntityInterceptor(Interceptor entityInterceptor) {
		this.entityInterceptor = entityInterceptor;
	}

	/**
	 * Set a Hibernate 5 {@link ImplicitNamingStrategy} for the SessionFactory.
	 * @see Configuration#setImplicitNamingStrategy
	 */
	/**
	 * 为SessionFactory设置一个Hibernate 5 {@link  ImplicitNamingStrategy}。 
	 *  
	 * @see 配置#setImplicitNamingStrategy
	 */
	public void setImplicitNamingStrategy(ImplicitNamingStrategy implicitNamingStrategy) {
		this.implicitNamingStrategy = implicitNamingStrategy;
	}

	/**
	 * Set a Hibernate 5 {@link PhysicalNamingStrategy} for the SessionFactory.
	 * @see Configuration#setPhysicalNamingStrategy
	 */
	/**
	 * 为SessionFactory设置一个Hibernate 5 {@link  PhysicalNamingStrategy}。 
	 *  
	 * @see 配置#setPhysicalNamingStrategy
	 */
	public void setPhysicalNamingStrategy(PhysicalNamingStrategy physicalNamingStrategy) {
		this.physicalNamingStrategy = physicalNamingStrategy;
	}

	/**
	 * Set the Spring {@link org.springframework.transaction.jta.JtaTransactionManager}
	 * or the JTA {@link javax.transaction.TransactionManager} to be used with Hibernate,
	 * if any. Implicitly sets up {@code JtaPlatform}.
	 * @see LocalSessionFactoryBuilder#setJtaTransactionManager
	 */
	/**
	 * 设置要与Hibernate一起使用的Spring {@link  org.springframework.transaction.jta.JtaTransactionManager}或JTA {@link  javax.transaction.TransactionManager}以与Hibernate一起使用。 
	 * 隐式设置{@code  JtaPlatform}。 
	 *  
	 * @see  LocalSessionFactoryBuilder＃setJtaTransactionManager
	 */
	public void setJtaTransactionManager(Object jtaTransactionManager) {
		this.jtaTransactionManager = jtaTransactionManager;
	}

	/**
	 * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.
	 * Allows for using a Spring-managed {@code RegionFactory} instance.
	 * <p>Note: If this is set, the Hibernate settings should not define a
	 * cache provider to avoid meaningless double configuration.
	 * @since 5.1
	 * @see LocalSessionFactoryBuilder#setCacheRegionFactory
	 */
	/**
	 * 设置休眠{@link  RegionFactory}以用于SessionFactory。 
	 * 允许使用Spring管理的{@code  RegionFactory}实例。 
	 *  <p>注意：如果设置了该设置，则Hibernate设置不应定义缓存提供程序，以避免无意义的双重配置。 
	 *  @since 5.1 
	 * @see  LocalSessionFactoryBuilder＃setCacheRegionFactory
	 */
	public void setCacheRegionFactory(RegionFactory cacheRegionFactory) {
		this.cacheRegionFactory = cacheRegionFactory;
	}

	/**
	 * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.
	 * @since 4.3
	 * @see LocalSessionFactoryBuilder#setMultiTenantConnectionProvider
	 */
	/**
	 * 设置一个{@link  MultiTenantConnectionProvider}传递给SessionFactory。 
	 *  @since 4.3 
	 * @see  LocalSessionFactoryBuilder＃setMultiTenantConnectionProvider
	 */
	public void setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {
		this.multiTenantConnectionProvider = multiTenantConnectionProvider;
	}

	/**
	 * Set a {@link CurrentTenantIdentifierResolver} to be passed on to the SessionFactory.
	 * @see LocalSessionFactoryBuilder#setCurrentTenantIdentifierResolver
	 */
	/**
	 * 设置一个{@link  CurrentTenantIdentifierResolver}传递给SessionFactory。 
	 *  
	 * @see  LocalSessionFactoryBuilder＃setCurrentTenantIdentifierResolver
	 */
	public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {
		this.currentTenantIdentifierResolver = currentTenantIdentifierResolver;
	}

	/**
	 * Set Hibernate properties, such as "hibernate.dialect".
	 * <p>Note: Do not specify a transaction provider here when using
	 * Spring-driven transactions. It is also advisable to omit connection
	 * provider settings and use a Spring-set DataSource instead.
	 * @see #setDataSource
	 */
	/**
	 * 设置休眠属性，例如"hibernate.dialect"。 
	 *  <p>注意：使用Spring驱动的事务时，请不要在此处指定事务提供程序。 
	 * 还建议忽略连接提供程序设置，而改用Spring-set DataSource。 
	 *  
	 * @see  #setDataSource
	 */
	public void setHibernateProperties(Properties hibernateProperties) {
		this.hibernateProperties = hibernateProperties;
	}

	/**
	 * Return the Hibernate properties, if any. Mainly available for
	 * configuration through property paths that specify individual keys.
	 */
	/**
	 * 返回Hibernate属性（如果有）。 
	 * 主要用于通过指定单个键的属性路径进行配置。 
	 * 
	 */
	public Properties getHibernateProperties() {
		if (this.hibernateProperties == null) {
			this.hibernateProperties = new Properties();
		}
		return this.hibernateProperties;
	}

	/**
	 * Specify custom type filters for Spring-based scanning for entity classes.
	 * <p>Default is to search all specified packages for classes annotated with
	 * {@code @javax.persistence.Entity}, {@code @javax.persistence.Embeddable}
	 * or {@code @javax.persistence.MappedSuperclass}.
	 * @see #setPackagesToScan
	 */
	/**
	 * 为基于Spring的实体类扫描指定自定义类型过滤器。 
	 *  <p>默认是在所有指定的包中搜索以{@code  @javax.persistence.Entity}，{<@code> @javax.persistence.Embeddable}或{@code  @javax.persistence注释的类。 
	 *  MappedSuperclass}。 
	 *  
	 * @see  #setPackagesToScan
	 */
	public void setEntityTypeFilters(TypeFilter... entityTypeFilters) {
		this.entityTypeFilters = entityTypeFilters;
	}

	/**
	 * Specify annotated entity classes to register with this Hibernate SessionFactory.
	 * @see Configuration#addAnnotatedClass(Class)
	 */
	/**
	 * 指定带注释的实体类以向此Hibernate SessionFactory注册。 
	 *  
	 * @see  Configuration＃addAnnotatedClass（Class）
	 */
	public void setAnnotatedClasses(Class<?>... annotatedClasses) {
		this.annotatedClasses = annotatedClasses;
	}

	/**
	 * Specify the names of annotated packages, for which package-level
	 * annotation metadata will be read.
	 * @see Configuration#addPackage(String)
	 */
	/**
	 * 指定带注释的程序包的名称，将为其读取程序包级别的注释元数据。 
	 *  
	 * @see 配置#addPackage（字符串）
	 */
	public void setAnnotatedPackages(String... annotatedPackages) {
		this.annotatedPackages = annotatedPackages;
	}

	/**
	 * Specify packages to search for autodetection of your entity classes in the
	 * classpath. This is analogous to Spring's component-scan feature
	 * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).
	 */
	/**
	 * 指定包以在类路径中搜索对实体类的自动检测。 
	 * 这类似于Spring的组件扫描功能（{@link  org.springframework.context.annotation.ClassPathBeanDefinitionScanner}）。 
	 * 
	 */
	public void setPackagesToScan(String... packagesToScan) {
		this.packagesToScan = packagesToScan;
	}

	/**
	 * Specify an asynchronous executor for background bootstrapping,
	 * e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.
	 * <p>{@code SessionFactory} initialization will then switch into background
	 * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for
	 * injection purposes instead of waiting for Hibernate's bootstrapping to complete.
	 * However, note that the first actual call to a {@code SessionFactory} method will
	 * then block until Hibernate's bootstrapping completed, if not ready by then.
	 * For maximum benefit, make sure to avoid early {@code SessionFactory} calls
	 * in init methods of related beans, even for metadata introspection purposes.
	 * @since 4.3
	 * @see LocalSessionFactoryBuilder#buildSessionFactory(AsyncTaskExecutor)
	 */
	/**
	 * 指定用于后台引导的异步执行程序，例如{@link  org.springframework.core.task.SimpleAsyncTaskExecutor}。 
	 * 然后，<p> {<@code> SessionFactory}初始化将切换到后台引导程序模式，并立即返回一个{@code  SessionFactory}代理用于注入目的，而不是等待Hibernate的引导完成。 
	 * 但是，请注意，对{@code  SessionFactory}方法的第一个实际调用将阻塞，直到Hibernate的引导完成为止（如果那时还没有准备好）。 
	 * 为了获得最大利益，请确保避免在相关bean的init方法中进行早期的{@code  SessionFactory}调用，即使是出于元数据自省的目的。 
	 *  @since 4.3 
	 * @see  LocalSessionFactoryBuilder＃buildSessionFactory（AsyncTaskExecutor）
	 */
	public void setBootstrapExecutor(AsyncTaskExecutor bootstrapExecutor) {
		this.bootstrapExecutor = bootstrapExecutor;
	}

	/**
	 * Specify one or more Hibernate {@link Integrator} implementations to apply.
	 * <p>This will only be applied for an internally built {@link MetadataSources}
	 * instance. {@link #setMetadataSources} effectively overrides such settings,
	 * with integrators to be applied to the externally built {@link MetadataSources}.
	 * @since 5.1
	 * @see #setMetadataSources
	 * @see BootstrapServiceRegistryBuilder#applyIntegrator
	 */
	/**
	 * 指定一个或多个要应用的Hibernate {@link  Integrator}实现。 
	 *  <p>这仅适用于内部构建的{@link  MetadataSources}实例。 
	 *  {@link  #setMetadataSources}有效地覆盖了此类设置，并将积分器应用于外部构建的{@link  MetadataSources}。 
	 *  @since 5.1 
	 * @see  #setMetadataSources 
	 * @see  BootstrapServiceRegistryBuilder＃applyIntegrator
	 */
	public void setHibernateIntegrators(Integrator... hibernateIntegrators) {
		this.hibernateIntegrators = hibernateIntegrators;
	}

	/**
	 * Specify a Hibernate {@link MetadataSources} service to use (e.g. reusing an
	 * existing one), potentially populated with a custom Hibernate bootstrap
	 * {@link org.hibernate.service.ServiceRegistry} as well.
	 * @since 4.3
	 * @see MetadataSources#MetadataSources(ServiceRegistry)
	 * @see BootstrapServiceRegistryBuilder#build()
	 */
	/**
	 * 指定要使用的Hibernate {@link  MetadataSources}服务（例如，重用现有服务），并可能使用自定义的Hibernate引导程序{@link  org.hibernate.service.ServiceRegistry}进行填充。 
	 *  @since 4.3 
	 * @see  MetadataSources＃MetadataSources（ServiceRegistry）
	 * @see  BootstrapServiceRegistryBuilder＃build（）
	 */
	public void setMetadataSources(MetadataSources metadataSources) {
		this.metadataSourcesAccessed = true;
		this.metadataSources = metadataSources;
	}

	/**
	 * Determine the Hibernate {@link MetadataSources} to use.
	 * <p>Can also be externally called to initialize and pre-populate a {@link MetadataSources}
	 * instance which is then going to be used for {@link SessionFactory} building.
	 * @return the MetadataSources to use (never {@code null})
	 * @since 4.3
	 * @see LocalSessionFactoryBuilder#LocalSessionFactoryBuilder(DataSource, ResourceLoader, MetadataSources)
	 */
	/**
	 * 确定要使用的休眠{@link  MetadataSources}。 
	 * 也可以从外部调用<p>来初始化和预填充{@link  MetadataSources}实例，然后将其用于{@link  SessionFactory}构建。 
	 *  
	 * @return 要使用的MetadataSources（从{<@@code> null}开始）@4.3起@
	 * @see> LocalSessionFactoryBuilder＃LocalSessionFactoryBuilder（DataSource，ResourceLoader，MetadataSources）
	 */
	public MetadataSources getMetadataSources() {
		this.metadataSourcesAccessed = true;
		if (this.metadataSources == null) {
			BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();
			if (this.resourcePatternResolver != null) {
				builder = builder.applyClassLoader(this.resourcePatternResolver.getClassLoader());
			}
			if (this.hibernateIntegrators != null) {
				for (Integrator integrator : this.hibernateIntegrators) {
					builder = builder.applyIntegrator(integrator);
				}
			}
			this.metadataSources = new MetadataSources(builder.build());
		}
		return this.metadataSources;
	}

	/**
	 * Specify a Spring {@link ResourceLoader} to use for Hibernate metadata.
	 * @param resourceLoader the ResourceLoader to use (never {@code null})
	 */
	/**
	 * 指定一个Spring {@link  ResourceLoader}用于Hibernate元数据。 
	 *  
	 * @param  resourceLoader要使用的ResourceLoader（切勿使用{<@@code> null}）
	 */
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
	}

	/**
	 * Determine the Spring {@link ResourceLoader} to use for Hibernate metadata.
	 * @return the ResourceLoader to use (never {@code null})
	 * @since 4.3
	 */
	/**
	 * 确定要用于Hibernate元数据的Spring {@link  ResourceLoader}。 
	 *  
	 * @return 要使用的ResourceLoader（从{<@@code> null}开始）@4.3
	 */
	public ResourceLoader getResourceLoader() {
		if (this.resourcePatternResolver == null) {
			this.resourcePatternResolver = new PathMatchingResourcePatternResolver();
		}
		return this.resourcePatternResolver;
	}

	/**
	 * Accept the containing {@link BeanFactory}, registering corresponding Hibernate
	 * {@link org.hibernate.resource.beans.container.spi.BeanContainer} integration for
	 * it if possible. This requires a Spring {@link ConfigurableListableBeanFactory}
	 * and Hibernate 5.3 or higher on the classpath.
	 * @since 5.1
	 * @see SpringBeanContainer
	 * @see LocalSessionFactoryBuilder#setBeanContainer
	 */
	/**
	 * 接受包含的{@link  BeanFactory}，并尽可能注册相应的Hibernate {@link  org.hibernate.resource.beans.container.spi.BeanContainer}集成。 
	 * 这需要Spring {@link  ConfigurableListableBeanFactory}和Hibernate 5.3或更高版本的类路径。 
	 *  @since 5.1 
	 * @see  SpringBeanContainer 
	 * @see  LocalSessionFactoryBuilder＃setBeanContainer
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		if (beanFactory instanceof ConfigurableListableBeanFactory &&
				ClassUtils.isPresent("org.hibernate.resource.beans.container.spi.BeanContainer",
						getClass().getClassLoader())) {
			this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
		}
	}


	@Override
	public void afterPropertiesSet() throws IOException {
		if (this.metadataSources != null && !this.metadataSourcesAccessed) {
			// Repeated initialization with no user-customized MetadataSources -> clear it.
			this.metadataSources = null;
		}

		LocalSessionFactoryBuilder sfb = new LocalSessionFactoryBuilder(
				this.dataSource, getResourceLoader(), getMetadataSources());

		if (this.configLocations != null) {
			for (Resource resource : this.configLocations) {
				// Load Hibernate configuration from given location.
				sfb.configure(resource.getURL());
			}
		}

		if (this.mappingResources != null) {
			// Register given Hibernate mapping definitions, contained in resource files.
			for (String mapping : this.mappingResources) {
				Resource mr = new ClassPathResource(mapping.trim(), getResourceLoader().getClassLoader());
				sfb.addInputStream(mr.getInputStream());
			}
		}

		if (this.mappingLocations != null) {
			// Register given Hibernate mapping definitions, contained in resource files.
			for (Resource resource : this.mappingLocations) {
				sfb.addInputStream(resource.getInputStream());
			}
		}

		if (this.cacheableMappingLocations != null) {
			// Register given cacheable Hibernate mapping definitions, read from the file system.
			for (Resource resource : this.cacheableMappingLocations) {
				sfb.addCacheableFile(resource.getFile());
			}
		}

		if (this.mappingJarLocations != null) {
			// Register given Hibernate mapping definitions, contained in jar files.
			for (Resource resource : this.mappingJarLocations) {
				sfb.addJar(resource.getFile());
			}
		}

		if (this.mappingDirectoryLocations != null) {
			// Register all Hibernate mapping definitions in the given directories.
			for (Resource resource : this.mappingDirectoryLocations) {
				File file = resource.getFile();
				if (!file.isDirectory()) {
					throw new IllegalArgumentException(
							"Mapping directory location [" + resource + "] does not denote a directory");
				}
				sfb.addDirectory(file);
			}
		}

		if (this.entityInterceptor != null) {
			sfb.setInterceptor(this.entityInterceptor);
		}

		if (this.implicitNamingStrategy != null) {
			sfb.setImplicitNamingStrategy(this.implicitNamingStrategy);
		}

		if (this.physicalNamingStrategy != null) {
			sfb.setPhysicalNamingStrategy(this.physicalNamingStrategy);
		}

		if (this.jtaTransactionManager != null) {
			sfb.setJtaTransactionManager(this.jtaTransactionManager);
		}

		if (this.beanFactory != null) {
			sfb.setBeanContainer(this.beanFactory);
		}

		if (this.cacheRegionFactory != null) {
			sfb.setCacheRegionFactory(this.cacheRegionFactory);
		}

		if (this.multiTenantConnectionProvider != null) {
			sfb.setMultiTenantConnectionProvider(this.multiTenantConnectionProvider);
		}

		if (this.currentTenantIdentifierResolver != null) {
			sfb.setCurrentTenantIdentifierResolver(this.currentTenantIdentifierResolver);
		}

		if (this.hibernateProperties != null) {
			sfb.addProperties(this.hibernateProperties);
		}

		if (this.entityTypeFilters != null) {
			sfb.setEntityTypeFilters(this.entityTypeFilters);
		}

		if (this.annotatedClasses != null) {
			sfb.addAnnotatedClasses(this.annotatedClasses);
		}

		if (this.annotatedPackages != null) {
			sfb.addPackages(this.annotatedPackages);
		}

		if (this.packagesToScan != null) {
			sfb.scanPackages(this.packagesToScan);
		}

		// Build SessionFactory instance.
		this.configuration = sfb;
		this.sessionFactory = buildSessionFactory(sfb);
	}

	/**
	 * Subclasses can override this method to perform custom initialization
	 * of the SessionFactory instance, creating it via the given Configuration
	 * object that got prepared by this LocalSessionFactoryBean.
	 * <p>The default implementation invokes LocalSessionFactoryBuilder's buildSessionFactory.
	 * A custom implementation could prepare the instance in a specific way (e.g. applying
	 * a custom ServiceRegistry) or use a custom SessionFactoryImpl subclass.
	 * @param sfb a LocalSessionFactoryBuilder prepared by this LocalSessionFactoryBean
	 * @return the SessionFactory instance
	 * @see LocalSessionFactoryBuilder#buildSessionFactory
	 */
	/**
	 * 子类可以重写此方法以执行SessionFactory实例的自定义初始化，通过此LocalSessionFactoryBean准备的给定Configuration对象创建它。 
	 *  <p>默认实现调用LocalSessionFactoryBuilder的buildSessionFactory。 
	 * 定制实现可以以特定方式准备实例（例如，应用定制ServiceRegistry）或使用定制SessionFactoryImpl子类。 
	 *  
	 * @param  sfb由此LocalSessionFactoryBean准备的LocalSessionFactoryBuilder 
	 * @return  SessionFactory实例
	 * @see  LocalSessionFactoryBuilder＃buildSessionFactory
	 */
	protected SessionFactory buildSessionFactory(LocalSessionFactoryBuilder sfb) {
		return (this.bootstrapExecutor != null ? sfb.buildSessionFactory(this.bootstrapExecutor) :
				sfb.buildSessionFactory());
	}

	/**
	 * Return the Hibernate Configuration object used to build the SessionFactory.
	 * Allows for access to configuration metadata stored there (rarely needed).
	 * @throws IllegalStateException if the Configuration object has not been initialized yet
	 */
	/**
	 * 返回用于构建SessionFactory的Hibernate Configuration对象。 
	 * 允许访问存储在此的配置元数据（非常需要）。 
	 *  
	 * @throws  IllegalStateException如果尚未初始化Configuration对象
	 */
	public final Configuration getConfiguration() {
		if (this.configuration == null) {
			throw new IllegalStateException("Configuration not initialized yet");
		}
		return this.configuration;
	}


	@Override
	@Nullable
	public SessionFactory getObject() {
		return this.sessionFactory;
	}

	@Override
	public Class<?> getObjectType() {
		return (this.sessionFactory != null ? this.sessionFactory.getClass() : SessionFactory.class);
	}

	@Override
	public boolean isSingleton() {
		return true;
	}


	@Override
	public void destroy() {
		if (this.sessionFactory != null) {
			this.sessionFactory.close();
		}
	}

}
