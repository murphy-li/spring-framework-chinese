/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.http.codec;

import java.util.List;
import java.util.function.Consumer;

import org.springframework.core.codec.Decoder;
import org.springframework.core.codec.Encoder;
import org.springframework.lang.Nullable;

/**
 * Defines a common interface for configuring either client or server HTTP
 * message readers and writers. This is used as follows:
 * <ul>
 * <li>Use {@link ClientCodecConfigurer#create()} or
 * {@link ServerCodecConfigurer#create()} to create an instance.
 * <li>Use {@link #defaultCodecs()} to customize HTTP message readers or writers
 * registered by default.
 * <li>Use {@link #customCodecs()} to add custom HTTP message readers or writers.
 * <li>Use {@link #getReaders()} and {@link #getWriters()} to obtain the list of
 * configured HTTP message readers and writers.
 * </ul>
 *
 * <p>HTTP message readers and writers are divided into 3 categories that are
 * ordered as follows:
 * <ol>
 * <li>Typed readers and writers that support specific types, e.g. byte[], String.
 * <li>Object readers and writers, e.g. JSON, XML.
 * <li>Catch-all readers or writers, e.g. String with any media type.
 * </ol>
 *
 * <p>Typed and object readers are further sub-divided and ordered as follows:
 * <ol>
 * <li>Default HTTP reader and writer registrations.
 * <li>Custom readers and writers.
 * </ol>
 *
 * @author Rossen Stoyanchev
 * @since 5.0
 */
/**
 * 定义用于配置客户端或服务器HTTP消息读取器和写入器的通用接口。 
 * 它的用法如下：<ul> <li>使用{@link  ClientCodecConfigurer＃create（）}或{@link  ServerCodecConfigurer＃create（）}创建实例。 
 *  <li>使用{@link  #defaultCodecs（）}自定义默认注册的HTTP消息读取器或写入器。 
 *  <li>使用{@link  #customCodecs（）}添加自定义HTTP消息读取器或写入器。 
 *  <li>使用{@link  #getReaders（）}和{@link  #getWriters（）}获取已配置的HTTP消息读取器和写入器的列表。 
 *  </ ul> <p> HTTP消息读取器和写入器分为3类，按以下顺序排序：<ol> <li>支持特定类型（例如， byte []，字符串。 
 *  <li>对象读取器和写入器，例如JSON，XML。 
 *  <li>吸引所有读者或作家，例如具有任何媒体类型的字符串。 
 *  </ ol> <p>类型和对象读取器进一步细分和排序，如下所示：<ol> <li>默认的HTTP读取器和写入器注册。 
 *  <li>自定义读者和作家。 
 *  </ ol> @author  Rossen Stoyanchev @从5.0开始
 */
public interface CodecConfigurer {

	/**
	 * Provides a way to customize or replace HTTP message readers and writers
	 * registered by default.
	 * @see #registerDefaults(boolean)
	 */
	/**
	 * 提供一种自定义或替换默认注册的HTTP消息读取器和写入器的方法。 
	 *  
	 * @see  #registerDefaults（布尔值）
	 */
	DefaultCodecs defaultCodecs();

	/**
	 * Register custom HTTP message readers or writers in addition to the ones
	 * registered by default.
	 */
	/**
	 * 除了默认注册的自定义HTTP消息读取器或写入器之外，还请注册。 
	 * 
	 */
	CustomCodecs customCodecs();

	/**
	 * Provides a way to completely turn off registration of default HTTP message
	 * readers and writers, and instead rely only on the ones provided via
	 * {@link #customCodecs()}.
	 * <p>By default this is set to {@code "true"} in which case default
	 * registrations are made; setting this to {@code false} disables default
	 * registrations.
	 */
	/**
	 * 提供一种方法来完全关闭默认HTTP消息读取器和写入器的注册，而仅依靠通过{@link  #customCodecs（）}提供的注册。 
	 *  <p>默认情况下，此设置为{@code "true"}，在这种情况下会进行默认注册。 
	 * 将此设置为{@code  false}将禁用默认注册。 
	 * 
	 */
	void registerDefaults(boolean registerDefaults);


	/**
	 * Obtain the configured HTTP message readers.
	 */
	/**
	 * 获取配置的HTTP消息阅读器。 
	 * 
	 */
	List<HttpMessageReader<?>> getReaders();

	/**
	 * Obtain the configured HTTP message writers.
	 */
	/**
	 * 获取配置的HTTP消息编写器。 
	 * 
	 */
	List<HttpMessageWriter<?>> getWriters();

	/**
	 * Create a copy of this {@link CodecConfigurer}. The returned clone has its
	 * own lists of default and custom codecs and generally can be configured
	 * independently. Keep in mind however that codec instances (if any are
	 * configured) are themselves not cloned.
	 * @since 5.1.12
	 */
	/**
	 * 创建此{@link  CodecConfigurer}的副本。 
	 * 返回的克隆具有自己的默认和自定义编解码器列表，通常可以独立配置。 
	 * 但是请记住，编解码器实例（如果已配置）本身不会被克隆。 
	 *  @自5.1.12起
	 */
	CodecConfigurer clone();


	/**
	 * Customize or replace the HTTP message readers and writers registered by
	 * default. The options are further extended by
	 * {@link ClientCodecConfigurer.ClientDefaultCodecs ClientDefaultCodecs} and
	 * {@link ServerCodecConfigurer.ServerDefaultCodecs ServerDefaultCodecs}.
	 */
	/**
	 * 自定义或替换默认注册的HTTP消息读取器和写入器。 
	 *  {@link  ClientCodecConfigurer.ClientDefaultCodecs ClientDefaultCodecs}和{@link  ServerCodecConfigurer.ServerDefaultCodecs ServerDefaultCodecs}进一步扩展了这些选项。 
	 * 
	 */
	interface DefaultCodecs {

		/**
		 * Override the default Jackson JSON {@code Decoder}.
		 * <p>Note that {@link #maxInMemorySize(int)}, if configured, will be
		 * applied to the given decoder.
		 * @param decoder the decoder instance to use
		 * @see org.springframework.http.codec.json.Jackson2JsonDecoder
		 */
		/**
		 * 覆盖默认的Jackson JSON {@code  Decoder}。 
		 *  <p>请注意，{<@link> #maxInMemorySize（int）}（如果已配置）将应用于给定的解码器。 
		 *  
		 * @param 解码器解码器实例使用
		 * @see  org.springframework.http.codec.json.Jackson2JsonDecoder
		 */
		void jackson2JsonDecoder(Decoder<?> decoder);

		/**
		 * Override the default Jackson JSON {@code Encoder}.
		 * @param encoder the encoder instance to use
		 * @see org.springframework.http.codec.json.Jackson2JsonEncoder
		 */
		/**
		 * 覆盖默认的Jackson JSON {@code 编码器}。 
		 *  
		 * @param 编码器编码器实例以使用
		 * @see  org.springframework.http.codec.json.Jackson2JsonEncoder
		 */
		void jackson2JsonEncoder(Encoder<?> encoder);

		/**
		 * Override the default Jackson Smile {@code Decoder}.
		 * <p>Note that {@link #maxInMemorySize(int)}, if configured, will be
		 * applied to the given decoder.
		 * @param decoder the decoder instance to use
		 * @see org.springframework.http.codec.json.Jackson2SmileDecoder
		 */
		/**
		 * 覆盖默认的Jackson Jackson {@code  Decoder}。 
		 *  <p>请注意，{<@link> #maxInMemorySize（int）}（如果已配置）将应用于给定的解码器。 
		 *  
		 * @param 解码器解码器实例使用
		 * @see  org.springframework.http.codec.json.Jackson2SmileDecoder
		 */
		void jackson2SmileDecoder(Decoder<?> decoder);

		/**
		 * Override the default Jackson Smile {@code Encoder}.
		 * @param encoder the encoder instance to use
		 * @see org.springframework.http.codec.json.Jackson2SmileEncoder
		 */
		/**
		 * 覆盖默认的Jackson笑容{@code 编码器}。 
		 *  
		 * @param 编码器编码器实例以使用
		 * @see  org.springframework.http.codec.json.Jackson2SmileEncoder
		 */
		void jackson2SmileEncoder(Encoder<?> encoder);

		/**
		 * Override the default Protobuf {@code Decoder}.
		 * <p>Note that {@link #maxInMemorySize(int)}, if configured, will be
		 * applied to the given decoder.
		 * @param decoder the decoder instance to use
		 * @since 5.1
		 * @see org.springframework.http.codec.protobuf.ProtobufDecoder
		 */
		/**
		 * 覆盖默认的Protobuf {@code  Decoder}。 
		 *  <p>请注意，{<@link> #maxInMemorySize（int）}（如果已配置）将应用于给定的解码器。 
		 *  
		 * @param 解码器解码器实例从@since 5.1开始使用
		 * @see  org.springframework.http.codec.protobuf.ProtobufDecoder
		 */
		void protobufDecoder(Decoder<?> decoder);

		/**
		 * Override the default Protobuf {@code Encoder}.
		 * @param encoder the encoder instance to use
		 * @since 5.1
		 * @see org.springframework.http.codec.protobuf.ProtobufEncoder
		 * @see org.springframework.http.codec.protobuf.ProtobufHttpMessageWriter
		 */
		/**
		 * 覆盖默认的Protobuf {@code 编码器}。 
		 *  
		 * @param 编码器编码器实例从@since 5.1开始使用。 
		 * 
		 */
		void protobufEncoder(Encoder<?> encoder);

		/**
		 * Override the default JAXB2 {@code Decoder}.
		 * <p>Note that {@link #maxInMemorySize(int)}, if configured, will be
		 * applied to the given decoder.
		 * @param decoder the decoder instance to use
		 * @since 5.1.3
		 * @see org.springframework.http.codec.xml.Jaxb2XmlDecoder
		 */
		/**
		 * 覆盖默认的JAXB2 {@code  Decoder}。 
		 *  <p>请注意，{<@link> #maxInMemorySize（int）}（如果已配置）将应用于给定的解码器。 
		 *  
		 * @param 解码器解码器实例从@5.1.3开始使用
		 * @see  org.springframework.http.codec.xml.Jaxb2XmlDecoder
		 */
		void jaxb2Decoder(Decoder<?> decoder);

		/**
		 * Override the default JABX2 {@code Encoder}.
		 * @param encoder the encoder instance to use
		 * @since 5.1.3
		 * @see org.springframework.http.codec.xml.Jaxb2XmlEncoder
		 */
		/**
		 * 覆盖默认的JABX2 {@code 编码器}。 
		 *  
		 * @param 编码器编码器实例从@5.1.3开始使用
		 * @see  org.springframework.http.codec.xml.Jaxb2XmlEncoder
		 */
		void jaxb2Encoder(Encoder<?> encoder);

		/**
		 * Configure a limit on the number of bytes that can be buffered whenever
		 * the input stream needs to be aggregated. This can be a result of
		 * decoding to a single {@code DataBuffer},
		 * {@link java.nio.ByteBuffer ByteBuffer}, {@code byte[]},
		 * {@link org.springframework.core.io.Resource Resource}, {@code String}, etc.
		 * It can also occur when splitting the input stream, e.g. delimited text,
		 * in which case the limit applies to data buffered between delimiters.
		 * <p>By default this is not set, in which case individual codec defaults
		 * apply. All codecs are limited to 256K by default.
		 * @param byteCount the max number of bytes to buffer, or -1 for unlimited
		 * @since 5.1.11
		 */
		/**
		 * 配置每当需要聚合输入流时可以缓冲的字节数的限制。 
		 * 这可能是由于解码为单个{@code  DataBuffer}，{<@link> java.nio.ByteBuffer ByteBuffer}，{<@code> byte []}，{<@link> org.springframework。 
		 *  core.io.Resource Resource}，{<@code> String}等。 
		 * 拆分输入流时也可能发生，例如分隔文本，在这种情况下，该限制适用于分隔符之间缓冲的数据。 
		 *  <p>默认情况下未设置，在这种情况下将应用各个编解码器默认值。 
		 * 默认情况下，所有编解码器均限制为256K。 
		 *  
		 * @param  byteCount要缓冲的最大字节数，从5.1.11开始为-1表示无限制@
		 */
		void maxInMemorySize(int byteCount);

		/**
		 * Whether to log form data at DEBUG level, and headers at TRACE level.
		 * Both may contain sensitive information.
		 * <p>By default set to {@code false} so that request details are not shown.
		 * @param enable whether to enable or not
		 * @since 5.1
		 */
		/**
		 * 是否在DEBUG级别记录表单数据，在TRACE级别记录标题。 
		 * 两者都可能包含敏感信息。 
		 *  <p>默认情况下设置为{@code  false}，因此不会显示请求详细信息。 
		 *  
		 * @param 启用是否启用@since 5.1
		 */
		void enableLoggingRequestDetails(boolean enable);
	}


	/**
	 * Registry for custom HTTP message readers and writers.
	 */
	/**
	 * 自定义HTTP消息读取器和写入器的注册表。 
	 * 
	 */
	interface CustomCodecs {

		/**
		 * Register a custom codec. This is expected to be one of the following:
		 * <ul>
		 * <li>{@link HttpMessageReader}
		 * <li>{@link HttpMessageWriter}
		 * <li>{@link Encoder} (wrapped internally with {@link EncoderHttpMessageWriter})
		 * <li>{@link Decoder} (wrapped internally with {@link DecoderHttpMessageReader})
		 * </ul>
		 * @param codec the codec to register
		 * @since 5.1.13
		 */
		/**
		 * 注册自定义编解码器。 
		 * 这应该是以下之一：<ul> <li> {<@link> HttpMessageReader} <li> {<@link> HttpMessageWriter} <li> {<@link> Encoder}（内部用{<@link> EncoderHttpMessageWriter}）<li> {<@link> Decoder}（内部包装有{@link  DecoderHttpMessageReader}）</ ul> 
		 * @param 编解码器，自5.1.13起注册@
		 */
		void register(Object codec);

		/**
		 * Variant of {@link #register(Object)} that also applies the below
		 * properties, if configured, via {@link #defaultCodecs()}:
		 * <ul>
		 * <li>{@link CodecConfigurer.DefaultCodecs#maxInMemorySize(int) maxInMemorySize}
		 * <li>{@link CodecConfigurer.DefaultCodecs#enableLoggingRequestDetails(boolean) enableLoggingRequestDetails}
		 * </ul>
		 * <p>The properties are applied every time {@link #getReaders()} or
		 * {@link #getWriters()} are used to obtain the list of configured
		 * readers or writers.
		 * @param codec the codec to register and apply default config to
		 * @since 5.1.13
		 */
		/**
		 * {@link  #register（Object）}的变体，也通过{@link  #defaultCodecs（）}应用以下属性（如果已配置）：<ul> <li> {<@link> CodecConfigurer.DefaultCodecs＃ maxInMemorySize（int）maxInMemorySize} <li> {<@link> CodecConfigurer.DefaultCodecs＃enableLoggingRequestDetails（boolean）enableLoggingRequestDetails} </ ul> <p>每次{@link  #getReaders（）}或{@link  #getWriters（）}用于获取已配置的读取器或写入器的列表。 
		 *  
		 * @param 编解码器用于注册编解码器并将默认配置应用于@since 5.1.13
		 */
		void registerWithDefaultConfig(Object codec);

		/**
		 * Variant of {@link #register(Object)} that also allows the caller to
		 * apply the properties from {@link DefaultCodecConfig} to the given
		 * codec. If you want to apply all the properties, prefer using
		 * {@link #registerWithDefaultConfig(Object)}.
		 * <p>The consumer is called every time {@link #getReaders()} or
		 * {@link #getWriters()} are used to obtain the list of configured
		 * readers or writers.
		 * @param codec the codec to register
		 * @param configConsumer consumer of the default config
		 * @since 5.1.13
		 */
		/**
		 * {@link  #register（Object）}的变体，它也允许调用者将{@link  DefaultCodecConfig}中的属性应用于给定的编解码器。 
		 * 如果要应用所有属性，请首选使用{@link  #registerWithDefaultConfig（Object）}。 
		 *  <p>每次使用{@link  #getReaders（）}或{@link  #getWriters（）}获取已配置的读取器或写入器的列表时，都会调用使用者。 
		 *  
		 * @param 编解码器用于注册
		 * @param  config的编解码器消费默认配置的用户（自5.1.13起）
		 */
		void registerWithDefaultConfig(Object codec, Consumer<DefaultCodecConfig> configConsumer);

		/**
		 * Add a custom {@code Decoder} internally wrapped with
		 * {@link DecoderHttpMessageReader}).
		 * @param decoder the decoder to add
		 * @deprecated as of 5.1.13, use {@link #register(Object)} or
		 * {@link #registerWithDefaultConfig(Object)} instead.
		 */
		/**
		 * 添加一个内部包装有{@link  DecoderHttpMessageReader}的自定义{@code  Decoder}。 
		 *  
		 * @param 解码器解码器从5.1.13开始添加@deprecated，改为使用{@link  #register（Object）}或{@link  #registerWithDefaultConfig（Object）}。 
		 * 
		 */
		@Deprecated
		void decoder(Decoder<?> decoder);

		/**
		 * Add a custom {@code Encoder}, internally wrapped with
		 * {@link EncoderHttpMessageWriter}.
		 * @param encoder the encoder to add
		 * @deprecated as of 5.1.13, use {@link #register(Object)} or
		 * {@link #registerWithDefaultConfig(Object)} instead.
		 */
		/**
		 * 添加一个自定义的{@code  Encoder}，内部用{@link  EncoderHttpMessageWriter}包装。 
		 *  
		 * @param 编码器编码器要添加自5.1.13起已弃用的@，请改用{@link  #register（Object）}或{@link  #registerWithDefaultConfig（Object）}。 
		 * 
		 */
		@Deprecated
		void encoder(Encoder<?> encoder);

		/**
		 * Add a custom {@link HttpMessageReader}. For readers of type
		 * {@link DecoderHttpMessageReader} consider using the shortcut
		 * {@link #decoder(Decoder)} instead.
		 * @param reader the reader to add
		 * @deprecated as of 5.1.13, use {@link #register(Object)} or
		 * {@link #registerWithDefaultConfig(Object)} instead.
		 */
		/**
		 * 添加自定义{@link  HttpMessageReader}。 
		 * 对于类型为{@link  DecoderHttpMessageReader}的阅读器，请考虑使用快捷方式{@link  #decoder（Decoder）}。 
		 *  
		 * @param 读者读者从5.1.13开始添加@deprecated，请改用{@link  #register（Object）}或{@link  #registerWithDefaultConfig（Object）}。 
		 * 
		 */
		@Deprecated
		void reader(HttpMessageReader<?> reader);

		/**
		 * Add a custom {@link HttpMessageWriter}. For writers of type
		 * {@link EncoderHttpMessageWriter} consider using the shortcut
		 * {@link #encoder(Encoder)} instead.
		 * @param writer the writer to add
		 * @deprecated as of 5.1.13, use {@link #register(Object)} or
		 * {@link #registerWithDefaultConfig(Object)} instead.
		 */
		/**
		 * 添加自定义{@link  HttpMessageWriter}。 
		 * 对于类型为{@link  EncoderHttpMessageWriter}的编写者，可以考虑使用快捷方式{@link  #encoder（Encoder）}。 
		 *  
		 * @param 编写者编写者要添加自5.1.13起已弃用的@，请改用{@link  #register（Object）}或{@link  #registerWithDefaultConfig（Object）}。 
		 * 
		 */
		@Deprecated
		void writer(HttpMessageWriter<?> writer);

		/**
		 * Register a callback for the {@link DefaultCodecConfig configuration}
		 * applied to default codecs. This allows custom codecs to follow general
		 * guidelines applied to default ones, such as logging details and limiting
		 * the amount of buffered data.
		 * @param codecsConfigConsumer the default codecs configuration callback
		 * @deprecated as of 5.1.13, use {@link #registerWithDefaultConfig(Object)}
		 * or {@link #registerWithDefaultConfig(Object, Consumer)} instead.
		 */
		/**
		 * 注册适用于默认编解码器的{@link  DefaultCodecConfig配置}的回调。 
		 * 这使自定义编解码器可以遵循适用于默认编解码器的一般准则，例如记录详细信息和限制缓冲数据量。 
		 *  
		 * @param  codecsConfig消费自5.1.13起已弃用的默认编解码器配置回调，请改用{@link  #registerWithDefaultConfig（Object）}或{@link  #registerWithDefaultConfig（Object，Consumer）}。 
		 * 
		 */
		@Deprecated
		void withDefaultCodecConfig(Consumer<DefaultCodecConfig> codecsConfigConsumer);
	}


	/**
	 * Exposes the values of properties configured through
	 * {@link #defaultCodecs()} that are applied to default codecs.
	 * The main purpose of this interface is to provide access to them so they
	 * can also be applied to custom codecs if needed.
	 * @since 5.1.12
	 * @see CustomCodecs#registerWithDefaultConfig(Object, Consumer)
	 */
	/**
	 * 公开通过{@link  #defaultCodecs（）}配置的应用于默认编解码器的属性的值。 
	 * 该接口的主要目的是提供对它们的访问，因此如果需要，它们也可以应用于自定义编解码器。 
	 *  @since 5.1.12 
	 * @see  CustomCodecs＃registerWithDefaultConfig（Object，Consumer）
	 */
	interface DefaultCodecConfig {

		/**
		 * Get the configured limit on the number of bytes that can be buffered whenever
		 * the input stream needs to be aggregated.
		 */
		/**
		 * 获取每当需要聚合输入流时就可以缓冲的字节数的已配置限制。 
		 * 
		 */
		@Nullable
		Integer maxInMemorySize();

		/**
		 * Whether to log form data at DEBUG level, and headers at TRACE level.
		 * Both may contain sensitive information.
		 */
		/**
		 * 是否在DEBUG级别记录表单数据，在TRACE级别记录标题。 
		 * 两者都可能包含敏感信息。 
		 * 
		 */
		@Nullable
		Boolean isEnableLoggingRequestDetails();
	}

}
