/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2016的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.context.request;

import org.springframework.lang.Nullable;
import org.springframework.ui.ModelMap;

/**
 * Interface for general web request interception. Allows for being applied
 * to Servlet request by building on the {@link WebRequest} abstraction.
 *
 * <p>This interface assumes MVC-style request processing: A handler gets executed,
 * exposes a set of model objects, then a view gets rendered based on that model.
 * Alternatively, a handler may also process the request completely, with no
 * view to be rendered.
 *
 * <p>In an async processing scenario, the handler may be executed in a separate
 * thread while the main thread exits without rendering or invoking the
 * {@code postHandle} and {@code afterCompletion} callbacks. When concurrent
 * handler execution completes, the request is dispatched back in order to
 * proceed with rendering the model and all methods of this contract are invoked
 * again. For further options and comments see
 * {@code org.springframework.web.context.request.async.AsyncWebRequestInterceptor}
 *
 * <p>This interface is deliberately minimalistic to keep the dependencies of
 * generic request interceptors as minimal as feasible.
 *
 * @author Juergen Hoeller
 * @since 2.0
 * @see ServletWebRequest
 * @see org.springframework.web.servlet.DispatcherServlet
 * @see org.springframework.web.servlet.handler.AbstractHandlerMapping#setInterceptors
 * @see org.springframework.web.servlet.HandlerInterceptor
 */
/**
 * 通用Web请求拦截的接口。 
 * 通过构建{@link  WebRequest}抽象，允许将其应用于Servlet请求。 
 *  <p>此接口假定采用MVC样式的请求处理：执行处理程序，公开一组模型对象，然后根据该模型呈现视图。 
 * 或者，处理程序也可以完全处理请求，而无需渲染视图。 
 *  <p>在异步处理方案中，处理程序可以在主线程退出时在单独的线程中执行，而无需呈现或调用{@code  postHandle}和{@code  afterCompletion}回调。 
 * 当并发处理程序执行完成时，将发回该请求以继续呈现模型，并再次调用该协定的所有方法。 
 * 有关更多选项和注释，请参见{@code  org.springframework.web.context.request.async.AsyncWebRequestInterceptor} <p>此接口是故意最小化的，以使通用请求拦截器的依赖性保持最小。 
 *  @author  Juergen Hoeller @since 2.0起
 * @see  ServletWebRequest 
 * @see  org.springframework.web.servlet.DispatcherServlet 
 * @see  org.springframework.web.servlet.handler.AbstractHandlerMapping＃setInterceptors 
 * @see  org。 
 *  springframework.web.servlet.HandlerInterceptor
 */
public interface WebRequestInterceptor {

	/**
	 * Intercept the execution of a request handler <i>before</i> its invocation.
	 * <p>Allows for preparing context resources (such as a Hibernate Session)
	 * and expose them as request attributes or as thread-local objects.
	 * @param request the current web request
	 * @throws Exception in case of errors
	 */
	/**
	 * 在请求处理器<i> </ i>调用之前拦截执行。 
	 *  <p>允许准备上下文资源（例如Hibernate Session）并将它们公开为请求属性或线程本地对象。 
	 *  
	 * @param 请求当前的Web请求
	 * @throws 发生错误时发生异常
	 */
	void preHandle(WebRequest request) throws Exception;

	/**
	 * Intercept the execution of a request handler <i>after</i> its successful
	 * invocation, right before view rendering (if any).
	 * <p>Allows for modifying context resources after successful handler
	 * execution (for example, flushing a Hibernate Session).
	 * @param request the current web request
	 * @param model the map of model objects that will be exposed to the view
	 * (may be {@code null}). Can be used to analyze the exposed model
	 * and/or to add further model attributes, if desired.
	 * @throws Exception in case of errors
	 */
	/**
	 * 在成功渲染视图之后（如果有），在成功调用之后拦截请求处理程序的执行。 
	 *  <p>允许在成功执行处理程序后修改上下文资源（例如，刷新休眠会话）。 
	 *  
	 * @param 请求当前的Web请求
	 * @param 建模将公开给视图的模型对象的地图（可以为{@code  null}）。 
	 * 如果需要，可用于分析暴露的模型和/或添加其他模型属性。 
	 *  
	 * @throws 错误时发生异常
	 */
	void postHandle(WebRequest request, @Nullable ModelMap model) throws Exception;

	/**
	 * Callback after completion of request processing, that is, after rendering
	 * the view. Will be called on any outcome of handler execution, thus allows
	 * for proper resource cleanup.
	 * <p>Note: Will only be called if this interceptor's {@code preHandle}
	 * method has successfully completed!
	 * @param request the current web request
	 * @param ex exception thrown on handler execution, if any
	 * @throws Exception in case of errors
	 */
	/**
	 * 完成请求处理后（即渲染视图之后）的回调。 
	 * 处理程序执行的任何结果都将被调用，从而可以进行适当的资源清理。 
	 *  <p>注意：仅当此拦截器的{@code  preHandle}方法成功完成时才会调用！ 
	 *  
	 * @param 请求当前的Web请求
	 * @param 处理程序执行时抛出的异常（如果有）
	 * @throws 发生错误时的异常
	 */
	void afterCompletion(WebRequest request, @Nullable Exception ex) throws Exception;

}
