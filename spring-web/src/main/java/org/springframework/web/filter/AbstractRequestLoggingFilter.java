/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.filter;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.function.Predicate;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.http.HttpHeaders;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.WebUtils;

/**
 * Base class for {@code Filter}s that perform logging operations before and after a request
 * is processed.
 *
 * <p>Subclasses should override the {@code beforeRequest(HttpServletRequest, String)} and
 * {@code afterRequest(HttpServletRequest, String)} methods to perform the actual logging
 * around the request.
 *
 * <p>Subclasses are passed the message to write to the log in the {@code beforeRequest} and
 * {@code afterRequest} methods. By default, only the URI of the request is logged. However,
 * setting the {@code includeQueryString} property to {@code true} will cause the query string of
 * the request to be included also; this can be further extended through {@code includeClientInfo}
 * and {@code includeHeaders}. The payload (body content) of the request can be logged via the
 * {@code includePayload} flag: Note that this will only log the part of the payload which has
 * actually been read, not necessarily the entire body of the request.
 *
 * <p>Prefixes and suffixes for the before and after messages can be configured using the
 * {@code beforeMessagePrefix}, {@code afterMessagePrefix}, {@code beforeMessageSuffix} and
 * {@code afterMessageSuffix} properties.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rossen Stoyanchev
 * @since 1.2.5
 * @see #beforeRequest
 * @see #afterRequest
 */
/**
 * {@code 筛选器}的基类，它们在处理请求之前和之后执行日志记录操作。 
 *  <p>子类应该重写{@code  beforeRequest（HttpServletRequest，String）}和{@code  afterRequest（HttpServletRequest，String）}方法，以围绕请求执行实际的日志记录。 
 *  <p>子类通过{@code  beforeRequest}和{@code  afterRequest}方法传递消息以写入日志。 
 * 默认情况下，仅记录请求的URI。 
 * 但是，将{@code  includeQueryString}属性设置为{@code  true}将导致也包含请求的查询字符串。 
 * 可以通过{@code  includeClientInfo}和{@code  includeHeaders}进一步扩展。 
 * 可以通过{@code  includePayload}标志记录请求的有效负载（正文内容）：请注意，这只会记录实际读取的有效负载部分，而不必记录整个请求正文。 
 * 可以使用{@code  beforeMessagePrefix}，{<@code> afterMessagePrefix}，{<@code> beforeMessageSuffix}和{@code  afterMessageSuffix}属性配置<p>之前和之后消息的前缀和后缀。 
 *  @author  Rob Harrop @author  Juergen Hoeller @author  Rossen Stoyanchev @1.2.5起
 * @see  #beforeRequest 
 * @see  #afterRequest
 */
public abstract class AbstractRequestLoggingFilter extends OncePerRequestFilter {

	/**
	 * The default value prepended to the log message written <i>before</i> a request is
	 * processed.
	 */
	/**
	 * 在处理请求之前<i> </ i>之前写入日志消息的默认值。 
	 * 
	 */
	public static final String DEFAULT_BEFORE_MESSAGE_PREFIX = "Before request [";

	/**
	 * The default value appended to the log message written <i>before</i> a request is
	 * processed.
	 */
	/**
	 * 在请求处理之前<i> </ i>写入日志消息后附加的默认值。 
	 * 
	 */
	public static final String DEFAULT_BEFORE_MESSAGE_SUFFIX = "]";

	/**
	 * The default value prepended to the log message written <i>after</i> a request is
	 * processed.
	 */
	/**
	 * 在处理请求后<i> </ i>之前写在日志消息上的默认值。 
	 * 
	 */
	public static final String DEFAULT_AFTER_MESSAGE_PREFIX = "After request [";

	/**
	 * The default value appended to the log message written <i>after</i> a request is
	 * processed.
	 */
	/**
	 * 处理请求后，在<i> </ i>后写在日志消息上的默认值。 
	 * 
	 */
	public static final String DEFAULT_AFTER_MESSAGE_SUFFIX = "]";

	private static final int DEFAULT_MAX_PAYLOAD_LENGTH = 50;


	private boolean includeQueryString = false;

	private boolean includeClientInfo = false;

	private boolean includeHeaders = false;

	private boolean includePayload = false;

	@Nullable
	private Predicate<String> headerPredicate;

	private int maxPayloadLength = DEFAULT_MAX_PAYLOAD_LENGTH;

	private String beforeMessagePrefix = DEFAULT_BEFORE_MESSAGE_PREFIX;

	private String beforeMessageSuffix = DEFAULT_BEFORE_MESSAGE_SUFFIX;

	private String afterMessagePrefix = DEFAULT_AFTER_MESSAGE_PREFIX;

	private String afterMessageSuffix = DEFAULT_AFTER_MESSAGE_SUFFIX;


	/**
	 * Set whether the query string should be included in the log message.
	 * <p>Should be configured using an {@code <init-param>} for parameter name
	 * "includeQueryString" in the filter definition in {@code web.xml}.
	 */
	/**
	 * 设置查询字符串是否应包括在查询消息中。 
	 *  <p>应使用{@code  web.xml}中过滤器定义中的参数名称"includeQueryString"使用{@code  <init-param>}进行配置。 
	 * 
	 */
	public void setIncludeQueryString(boolean includeQueryString) {
		this.includeQueryString = includeQueryString;
	}

	/**
	 * Return whether the query string should be included in the log message.
	 */
	/**
	 * 返回查询字符串是否应包含在日志消息中。 
	 * 
	 */
	protected boolean isIncludeQueryString() {
		return this.includeQueryString;
	}

	/**
	 * Set whether the client address and session id should be included in the
	 * log message.
	 * <p>Should be configured using an {@code <init-param>} for parameter name
	 * "includeClientInfo" in the filter definition in {@code web.xml}.
	 */
	/**
	 * 设置是否在日志消息中包括客户端地址和会话ID。 
	 *  <p>应使用{@code  web.xml}中过滤器定义中的参数名称"includeClientInfo"使用{@code  <init-param>}进行配置。 
	 * 
	 */
	public void setIncludeClientInfo(boolean includeClientInfo) {
		this.includeClientInfo = includeClientInfo;
	}

	/**
	 * Return whether the client address and session id should be included in the
	 * log message.
	 */
	/**
	 * 返回是否在日志消息中包括客户端地址和会话ID。 
	 * 
	 */
	protected boolean isIncludeClientInfo() {
		return this.includeClientInfo;
	}

	/**
	 * Set whether the request headers should be included in the log message.
	 * <p>Should be configured using an {@code <init-param>} for parameter name
	 * "includeHeaders" in the filter definition in {@code web.xml}.
	 * @since 4.3
	 */
	/**
	 * 设置是否在日志消息中包含请求标头。 
	 *  <p>应使用{@code  web.xml}的过滤器定义中的参数名称"includeHeaders"使用{@code  <init-param>}进行配置。 
	 *  @4.3起
	 */
	public void setIncludeHeaders(boolean includeHeaders) {
		this.includeHeaders = includeHeaders;
	}

	/**
	 * Return whether the request headers should be included in the log message.
	 * @since 4.3
	 */
	/**
	 * 返回请求标头是否应包含在日志消息中。 
	 *  @4.3起
	 */
	protected boolean isIncludeHeaders() {
		return this.includeHeaders;
	}

	/**
	 * Set whether the request payload (body) should be included in the log message.
	 * <p>Should be configured using an {@code <init-param>} for parameter name
	 * "includePayload" in the filter definition in {@code web.xml}.
	 * @since 3.0
	 */
	/**
	 * 设置是否在日志消息中包括请求有效负载（正文）。 
	 *  <p>应使用{@code  web.xml}的过滤器定义中的参数名称"includePayload"使用{@code  <init-param>}进行配置。 
	 *  @从3.0起
	 */
	public void setIncludePayload(boolean includePayload) {
		this.includePayload = includePayload;
	}

	/**
	 * Return whether the request payload (body) should be included in the log message.
	 * @since 3.0
	 */
	/**
	 * 返回是否在日志消息中包括请求有效负载（正文）。 
	 *  @从3.0起
	 */
	protected boolean isIncludePayload() {
		return this.includePayload;
	}

	/**
	 * Configure a predicate for selecting which headers should be logged if
	 * {@link #setIncludeHeaders(boolean)} is set to {@code true}.
	 * <p>By default this is not set in which case all headers are logged.
	 * @param headerPredicate the predicate to use
	 * @since 5.2
	 */
	/**
	 * 如果{@link  #setIncludeHeaders（boolean）}设置为{@code  true}，则配置谓词以选择应记录的标头。 
	 *  <p>在没有记录所有标题的情况下，默认情况下未设置。 
	 *  
	 * @param  headerPredicate谓词以使用@since 5.2
	 */
	public void setHeaderPredicate(@Nullable Predicate<String> headerPredicate) {
		this.headerPredicate = headerPredicate;
	}

	/**
	 * The configured {@link #setHeaderPredicate(Predicate) headerPredicate}.
	 * @since 5.2
	 */
	/**
	 * 配置的{@link  #setHeaderPredicate（Predicate）headerPredicate}。 
	 *  @5.2起
	 */
	@Nullable
	protected Predicate<String> getHeaderPredicate() {
		return this.headerPredicate;
	}

	/**
	 * Set the maximum length of the payload body to be included in the log message.
	 * Default is 50 characters.
	 * @since 3.0
	 */
	/**
	 * 设置要包含在日志消息中的有效负载主体的最大长度。 
	 * 默认值为50个字符。 
	 *  @从3.0起
	 */
	public void setMaxPayloadLength(int maxPayloadLength) {
		Assert.isTrue(maxPayloadLength >= 0, "'maxPayloadLength' should be larger than or equal to 0");
		this.maxPayloadLength = maxPayloadLength;
	}

	/**
	 * Return the maximum length of the payload body to be included in the log message.
	 * @since 3.0
	 */
	/**
	 * 返回要包含在日志消息中的有效负载主体的最大长度。 
	 *  @从3.0起
	 */
	protected int getMaxPayloadLength() {
		return this.maxPayloadLength;
	}

	/**
	 * Set the value that should be prepended to the log message written
	 * <i>before</i> a request is processed.
	 */
	/**
	 * 设置在处理请求之前<i> </ i>之前写在日志消息中的值。 
	 * 
	 */
	public void setBeforeMessagePrefix(String beforeMessagePrefix) {
		this.beforeMessagePrefix = beforeMessagePrefix;
	}

	/**
	 * Set the value that should be appended to the log message written
	 * <i>before</i> a request is processed.
	 */
	/**
	 * 设置应在处理请求之前<i> </ i>附加到写入日志消息的值。 
	 * 
	 */
	public void setBeforeMessageSuffix(String beforeMessageSuffix) {
		this.beforeMessageSuffix = beforeMessageSuffix;
	}

	/**
	 * Set the value that should be prepended to the log message written
	 * <i>after</i> a request is processed.
	 */
	/**
	 * 设置在处理请求后<i> </ i>之前写在日志消息中的值。 
	 * 
	 */
	public void setAfterMessagePrefix(String afterMessagePrefix) {
		this.afterMessagePrefix = afterMessagePrefix;
	}

	/**
	 * Set the value that should be appended to the log message written
	 * <i>after</i> a request is processed.
	 */
	/**
	 * 设置应在请求处理后<i> </ i>后写入日志消息的值。 
	 * 
	 */
	public void setAfterMessageSuffix(String afterMessageSuffix) {
		this.afterMessageSuffix = afterMessageSuffix;
	}


	/**
	 * The default value is "false" so that the filter may log a "before" message
	 * at the start of request processing and an "after" message at the end from
	 * when the last asynchronously dispatched thread is exiting.
	 */
	/**
	 * 默认值为"false"，以便过滤器可以在请求处理开始时记录"before"消息，而从最后一个异步调度的线程退出时，在结束时记录"after"消息。 
	 * 
	 */
	@Override
	protected boolean shouldNotFilterAsyncDispatch() {
		return false;
	}

	/**
	 * Forwards the request to the next filter in the chain and delegates down to the subclasses
	 * to perform the actual request logging both before and after the request is processed.
	 * @see #beforeRequest
	 * @see #afterRequest
	 */
	/**
	 * 将请求转发到链中的下一个过滤器，并委托给子类以在处理请求之前和之后执行实际的请求日志记录。 
	 *  
	 * @see  #beforeRequest 
	 * @see  #afterRequest
	 */
	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		boolean isFirstRequest = !isAsyncDispatch(request);
		HttpServletRequest requestToUse = request;

		if (isIncludePayload() && isFirstRequest && !(request instanceof ContentCachingRequestWrapper)) {
			requestToUse = new ContentCachingRequestWrapper(request, getMaxPayloadLength());
		}

		boolean shouldLog = shouldLog(requestToUse);
		if (shouldLog && isFirstRequest) {
			beforeRequest(requestToUse, getBeforeMessage(requestToUse));
		}
		try {
			filterChain.doFilter(requestToUse, response);
		}
		finally {
			if (shouldLog && !isAsyncStarted(requestToUse)) {
				afterRequest(requestToUse, getAfterMessage(requestToUse));
			}
		}
	}

	/**
	 * Get the message to write to the log before the request.
	 * @see #createMessage
	 */
	/**
	 * 获取消息以在请求之前将其写入日志。 
	 *  
	 * @see  #createMessage
	 */
	private String getBeforeMessage(HttpServletRequest request) {
		return createMessage(request, this.beforeMessagePrefix, this.beforeMessageSuffix);
	}

	/**
	 * Get the message to write to the log after the request.
	 * @see #createMessage
	 */
	/**
	 * 请求后获取消息以写入日志。 
	 *  
	 * @see  #createMessage
	 */
	private String getAfterMessage(HttpServletRequest request) {
		return createMessage(request, this.afterMessagePrefix, this.afterMessageSuffix);
	}

	/**
	 * Create a log message for the given request, prefix and suffix.
	 * <p>If {@code includeQueryString} is {@code true}, then the inner part
	 * of the log message will take the form {@code request_uri?query_string};
	 * otherwise the message will simply be of the form {@code request_uri}.
	 * <p>The final message is composed of the inner part as described and
	 * the supplied prefix and suffix.
	 */
	/**
	 * 为给定的请求，前缀和后缀创建一条日志消息。 
	 *  <p>如果{@code  includeQueryString}为{@code  true}，则日志消息的内部将采用{@code  request_uri？query_string}的形式； 
	 * 否则，该消息将简单地为{@code  request_uri}的形式。 
	 *  <p>最终消息由所描述的内部部分以及所提供的前缀和后缀组成。 
	 * 
	 */
	protected String createMessage(HttpServletRequest request, String prefix, String suffix) {
		StringBuilder msg = new StringBuilder();
		msg.append(prefix);
		msg.append(request.getMethod()).append(" ");
		msg.append(request.getRequestURI());

		if (isIncludeQueryString()) {
			String queryString = request.getQueryString();
			if (queryString != null) {
				msg.append('?').append(queryString);
			}
		}

		if (isIncludeClientInfo()) {
			String client = request.getRemoteAddr();
			if (StringUtils.hasLength(client)) {
				msg.append(", client=").append(client);
			}
			HttpSession session = request.getSession(false);
			if (session != null) {
				msg.append(", session=").append(session.getId());
			}
			String user = request.getRemoteUser();
			if (user != null) {
				msg.append(", user=").append(user);
			}
		}

		if (isIncludeHeaders()) {
			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders();
			if (getHeaderPredicate() != null) {
				Enumeration<String> names = request.getHeaderNames();
				while (names.hasMoreElements()) {
					String header = names.nextElement();
					if (!getHeaderPredicate().test(header)) {
						headers.set(header, "masked");
					}
				}
			}
			msg.append(", headers=").append(headers);
		}

		if (isIncludePayload()) {
			String payload = getMessagePayload(request);
			if (payload != null) {
				msg.append(", payload=").append(payload);
			}
		}

		msg.append(suffix);
		return msg.toString();
	}

	/**
	 * Extracts the message payload portion of the message created by
	 * {@link #createMessage(HttpServletRequest, String, String)} when
	 * {@link #isIncludePayload()} returns true.
	 * @since 5.0.3
	 */
	/**
	 * 当{@link  #isIncludePayload（）}返回true时，提取由{@link  #createMessage（HttpServletRequest，String，String）}创建的消息的消息有效负载部分。 
	 *  @5.0.3起
	 */
	@Nullable
	protected String getMessagePayload(HttpServletRequest request) {
		ContentCachingRequestWrapper wrapper =
				WebUtils.getNativeRequest(request, ContentCachingRequestWrapper.class);
		if (wrapper != null) {
			byte[] buf = wrapper.getContentAsByteArray();
			if (buf.length > 0) {
				int length = Math.min(buf.length, getMaxPayloadLength());
				try {
					return new String(buf, 0, length, wrapper.getCharacterEncoding());
				}
				catch (UnsupportedEncodingException ex) {
					return "[unknown]";
				}
			}
		}
		return null;
	}


	/**
	 * Determine whether to call the {@link #beforeRequest}/{@link #afterRequest}
	 * methods for the current request, i.e. whether logging is currently active
	 * (and the log message is worth building).
	 * <p>The default implementation always returns {@code true}. Subclasses may
	 * override this with a log level check.
	 * @param request current HTTP request
	 * @return {@code true} if the before/after method should get called;
	 * {@code false} otherwise
	 * @since 4.1.5
	 */
	/**
	 * 确定是否为当前请求调用{@link  #beforeRequest} / {<@link> #afterRequest}方法，即日志记录当前是否处于活动状态（并且日志消息值得构建）。 
	 *  <p>默认实现始终返回{@code  true}。 
	 * 子类可以通过日志级别检查来覆盖它。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @return  {@code  true}，如果应调用before / after方法； 
	 *  {@code  false}否则@始于4.1.5
	 */
	protected boolean shouldLog(HttpServletRequest request) {
		return true;
	}

	/**
	 * Concrete subclasses should implement this method to write a log message
	 * <i>before</i> the request is processed.
	 * @param request current HTTP request
	 * @param message the message to log
	 */
	/**
	 * 具体的子类应实现此方法，以便在处理请求之前<i> </ i>写入日志消息。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 消息要记录的消息
	 */
	protected abstract void beforeRequest(HttpServletRequest request, String message);

	/**
	 * Concrete subclasses should implement this method to write a log message
	 * <i>after</i> the request is processed.
	 * @param request current HTTP request
	 * @param message the message to log
	 */
	/**
	 * 具体的子类应实现此方法，以便在处理请求后<i> </ i>写入日志消息。 
	 *  
	 * @param 请求当前HTTP请求
	 * @param 消息要记录的消息
	 */
	protected abstract void afterRequest(HttpServletRequest request, String message);

}
