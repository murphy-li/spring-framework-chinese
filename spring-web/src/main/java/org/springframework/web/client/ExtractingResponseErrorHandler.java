/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.client;

import java.io.IOException;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;

/**
 * Implementation of {@link ResponseErrorHandler} that uses {@link HttpMessageConverter
 * HttpMessageConverters} to convert HTTP error responses to {@link RestClientException
 * RestClientExceptions}.
 *
 * <p>To use this error handler, you must specify a
 * {@linkplain #setStatusMapping(Map) status mapping} and/or a
 * {@linkplain #setSeriesMapping(Map) series mapping}. If either of these mappings has a match
 * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given
 * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return
 * {@code true}, and {@link #handleError(ClientHttpResponse)} will attempt to use the
 * {@linkplain #setMessageConverters(List) configured message converters} to convert the response
 * into the mapped subclass of {@link RestClientException}. Note that the
 * {@linkplain #setStatusMapping(Map) status mapping} takes precedence over
 * {@linkplain #setSeriesMapping(Map) series mapping}.
 *
 * <p>If there is no match, this error handler will default to the behavior of
 * {@link DefaultResponseErrorHandler}. Note that you can override this default behavior
 * by specifying a {@linkplain #setSeriesMapping(Map) series mapping} from
 * {@code HttpStatus.Series#CLIENT_ERROR} and/or {@code HttpStatus.Series#SERVER_ERROR}
 * to {@code null}.
 *
 * @author Simon Galperin
 * @author Arjen Poutsma
 * @since 5.0
 * @see RestTemplate#setErrorHandler(ResponseErrorHandler)
 */
/**
 * 使用{@link  HttpMessageConverter HttpMessageConverters}将HTTP错误响应转换为{@link  RestClientException RestClientExceptions}的{@link  ResponseErrorHandler}的实现。 
 *  <p>要使用此错误处理程序，必须指定{@link  plain #setStatusMapping（Map）状态映射}和/或{{@@link> plain #setSeriesMapping（Map）系列映射}。 
 * 如果这些映射中的任何一个都与给定{@code  ClientHttpResponse}的{@link  plain ClientHttpResponse＃getStatusCode（）状态代码}匹配，则{@link  #hasError（ClientHttpResponse）}将返回{@code  true}和{@link  #handleError（ClientHttpResponse）}将尝试使用{@link  plain #setMessageConverters（List）配置的消息转换器}将响应转换为{<@链接> RestClientException}。 
 * 请注意，{<@link> plain #setStatusMapping（Map）状态映射}优先于{@link  plain #setSeriesMapping（Map）系列映射}。 
 *  <p>如果没有匹配项，则此错误处理程序将默认为{@link  DefaultResponseErrorHandler}的行为。 
 * 请注意，您可以通过从{@code  HttpStatus.Series＃CLIENT_ERROR}和/或{@code  HttpStatus.Series＃SERVER_ERROR}指定一个{@link  plain #setSeriesMapping（Map）系列映射}来覆盖此默认行为。 
 *  }到{@code  null}。 
 *  @author  Simon Galperin @author  Arjen Poutsma @从5.0起
 * @see  RestTemplate＃setErrorHandler（ResponseErrorHandler）
 */
public class ExtractingResponseErrorHandler extends DefaultResponseErrorHandler {

	private List<HttpMessageConverter<?>> messageConverters = Collections.emptyList();

	private final Map<HttpStatus, Class<? extends RestClientException>> statusMapping = new LinkedHashMap<>();

	private final Map<HttpStatus.Series, Class<? extends RestClientException>> seriesMapping = new LinkedHashMap<>();


	/**
	 * Create a new, empty {@code ExtractingResponseErrorHandler}.
	 * <p>Note that {@link #setMessageConverters(List)} must be called when using this constructor.
	 */
	/**
	 * 创建一个新的空{@code  ExtractingResponseErrorHandler}。 
	 *  <p>请注意，使用此构造函数时必须调用{@link  #setMessageConverters（List）}。 
	 * 
	 */
	public ExtractingResponseErrorHandler() {
	}

	/**
	 * Create a new {@code ExtractingResponseErrorHandler} with the given
	 * {@link HttpMessageConverter} instances.
	 * @param messageConverters the message converters to use
	 */
	/**
	 * 使用给定的{@link  HttpMessageConverter}实例创建一个新的{@code  ExtractingResponseErrorHandler}。 
	 *  
	 * @param  message转换要使用的消息转换器
	 */
	public ExtractingResponseErrorHandler(List<HttpMessageConverter<?>> messageConverters) {
		this.messageConverters = messageConverters;
	}


	/**
	 * Set the message converters to use by this extractor.
	 */
	/**
	 * 设置此提取程序要使用的消息转换器。 
	 * 
	 */
	public void setMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
		this.messageConverters = messageConverters;
	}

	/**
	 * Set the mapping from HTTP status code to {@code RestClientException} subclass.
	 * If this mapping has a match
	 * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given
	 * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return
	 * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the
	 * {@linkplain #setMessageConverters(List) configured message converters} to convert the
	 * response into the mapped subclass of {@link RestClientException}.
	 */
	/**
	 * 设置从HTTP状态代码到{@code  RestClientException}子类的映射。 
	 * 如果此映射与给定{@code  ClientHttpResponse}的{@link  plain ClientHttpResponse＃getStatusCode（）状态代码}匹配，则{@link  #hasError（ClientHttpResponse）}将返回{<@code > true}和{@link  #handleError（ClientHttpResponse）}将尝试使用{@link  plain #setMessageConverters（List）配置的消息转换器}将响应转换为{@link  RestClientException的映射子类}。 
	 * 
	 */
	public void setStatusMapping(Map<HttpStatus, Class<? extends RestClientException>> statusMapping) {
		if (!CollectionUtils.isEmpty(statusMapping)) {
			this.statusMapping.putAll(statusMapping);
		}
	}

	/**
	 * Set the mapping from HTTP status series to {@code RestClientException} subclass.
	 * If this mapping has a match
	 * for the {@linkplain ClientHttpResponse#getStatusCode() status code} of a given
	 * {@code ClientHttpResponse}, {@link #hasError(ClientHttpResponse)} will return
	 * {@code true} and {@link #handleError(ClientHttpResponse)} will attempt to use the
	 * {@linkplain #setMessageConverters(List) configured message converters} to convert the
	 * response into the mapped subclass of {@link RestClientException}.
	 */
	/**
	 * 设置从HTTP状态系列到{@code  RestClientException}子类的映射。 
	 * 如果此映射与给定{@code  ClientHttpResponse}的{@link  plain ClientHttpResponse＃getStatusCode（）状态代码}匹配，则{@link  #hasError（ClientHttpResponse）}将返回{<@code > true}和{@link  #handleError（ClientHttpResponse）}将尝试使用{@link  plain #setMessageConverters（List）配置的消息转换器}将响应转换为{@link  RestClientException的映射子类}。 
	 * 
	 */
	public void setSeriesMapping(Map<HttpStatus.Series, Class<? extends RestClientException>> seriesMapping) {
		if (!CollectionUtils.isEmpty(seriesMapping)) {
			this.seriesMapping.putAll(seriesMapping);
		}
	}


	@Override
	protected boolean hasError(HttpStatus statusCode) {
		if (this.statusMapping.containsKey(statusCode)) {
			return this.statusMapping.get(statusCode) != null;
		}
		else if (this.seriesMapping.containsKey(statusCode.series())) {
			return this.seriesMapping.get(statusCode.series()) != null;
		}
		else {
			return super.hasError(statusCode);
		}
	}

	@Override
	public void handleError(ClientHttpResponse response, HttpStatus statusCode) throws IOException {
		if (this.statusMapping.containsKey(statusCode)) {
			extract(this.statusMapping.get(statusCode), response);
		}
		else if (this.seriesMapping.containsKey(statusCode.series())) {
			extract(this.seriesMapping.get(statusCode.series()), response);
		}
		else {
			super.handleError(response, statusCode);
		}
	}

	private void extract(@Nullable Class<? extends RestClientException> exceptionClass,
			ClientHttpResponse response) throws IOException {

		if (exceptionClass == null) {
			return;
		}

		HttpMessageConverterExtractor<? extends RestClientException> extractor =
				new HttpMessageConverterExtractor<>(exceptionClass, this.messageConverters);
		RestClientException exception = extractor.extractData(response);
		if (exception != null) {
			throw exception;
		}
	}

}
