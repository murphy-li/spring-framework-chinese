/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.util;

import java.io.Serializable;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.UnaryOperator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.MultiValueMap;

/**
 * Represents an immutable collection of URI components, mapping component type to
 * String values. Contains convenience getters for all components. Effectively similar
 * to {@link java.net.URI}, but with more powerful encoding options and support for
 * URI template variables.
 *
 * @author Arjen Poutsma
 * @author Juergen Hoeller
 * @author Rossen Stoyanchev
 * @since 3.1
 * @see UriComponentsBuilder
 */
/**
 * 表示URI组件的不可变集合，将组件类型映射到String值。 
 * 包含所有组件的便捷吸气剂。 
 * 与{@link  java.net.URI}有效相似，但具有更强大的编码选项并支持URI模板变量。 
 *  @author  Arjen Poutsma @author  Juergen Hoeller @author  Rossen Stoyanchev @自3.1起
 * @see  UriComponentsBuilder
 */
@SuppressWarnings("serial")
public abstract class UriComponents implements Serializable {

	/** Captures URI template variable names. */
	/**
	 * 捕获URI模板变量名称。 
	 * 
	 */
	private static final Pattern NAMES_PATTERN = Pattern.compile("\\{([^/]+?)}");


	@Nullable
	private final String scheme;

	@Nullable
	private final String fragment;


	protected UriComponents(@Nullable String scheme, @Nullable String fragment) {
		this.scheme = scheme;
		this.fragment = fragment;
	}


	// Component getters

	/**
	 * Return the scheme. Can be {@code null}.
	 */
	/**
	 * 返回计划。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public final String getScheme() {
		return this.scheme;
	}

	/**
	 * Return the fragment. Can be {@code null}.
	 */
	/**
	 * 返回片段。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public final String getFragment() {
		return this.fragment;
	}

	/**
	 * Return the scheme specific part. Can be {@code null}.
	 */
	/**
	 * 返回方案的特定部分。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public abstract String getSchemeSpecificPart();

	/**
	 * Return the user info. Can be {@code null}.
	 */
	/**
	 * 返回用户信息。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public abstract String getUserInfo();

	/**
	 * Return the host. Can be {@code null}.
	 */
	/**
	 * 返回主机。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public abstract String getHost();

	/**
	 * Return the port. {@code -1} if no port has been set.
	 */
	/**
	 * 返回端口。 
	 *  {@code  -1}（如果未设置任何端口）。 
	 * 
	 */
	public abstract int getPort();

	/**
	 * Return the path. Can be {@code null}.
	 */
	/**
	 * 返回路径。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public abstract String getPath();

	/**
	 * Return the list of path segments. Empty if no path has been set.
	 */
	/**
	 * 返回路径段列表。 
	 * 如果未设置路径，则为空。 
	 * 
	 */
	public abstract List<String> getPathSegments();

	/**
	 * Return the query. Can be {@code null}.
	 */
	/**
	 * 返回查询。 
	 * 可以为{@code  null}。 
	 * 
	 */
	@Nullable
	public abstract String getQuery();

	/**
	 * Return the map of query parameters. Empty if no query has been set.
	 */
	/**
	 * 返回查询参数图。 
	 * 如果未设置查询，则为空。 
	 * 
	 */
	public abstract MultiValueMap<String, String> getQueryParams();


	/**
	 * Invoke this <em>after</em> expanding URI variables to encode the
	 * resulting URI component values.
	 * <p>In comparison to {@link UriComponentsBuilder#encode()}, this method
	 * <em>only</em> replaces non-ASCII and illegal (within a given URI
	 * component type) characters, but not characters with reserved meaning.
	 * For most cases, {@link UriComponentsBuilder#encode()} is more likely
	 * to give the expected result.
	 * @see UriComponentsBuilder#encode()
	 */
	/**
	 * 在扩展URI变量后调用<em> </ em>来对所得的URI组件值进行编码。 
	 *  <p>与{@link  UriComponentsBuilder＃encode（）}相比，此方法<em>仅</ em>替换非ASCII和非法（在给定URI组件类型内）字符，但不替换具有保留含义的字符。 
	 * 在大多数情况下，{@link  UriComponentsBuilder＃encode（）}更可能给出预期的结果。 
	 *  
	 * @see  UriComponentsBuilder＃encode（）
	 */
	public final UriComponents encode() {
		return encode(StandardCharsets.UTF_8);
	}

	/**
	 * A variant of {@link #encode()} with a charset other than "UTF-8".
	 * @param charset the charset to use for encoding
	 * @see UriComponentsBuilder#encode(Charset)
	 */
	/**
	 * {@link  #encode（）}的变体，其字符集不是"UTF-8"。 
	 *  
	 * @param 字符集用于编码的字符集
	 * @see  UriComponentsBuilder＃encode（Charset）
	 */
	public abstract UriComponents encode(Charset charset);

	/**
	 * Replace all URI template variables with the values from a given map.
	 * <p>The given map keys represent variable names; the corresponding values
	 * represent variable values. The order of variables is not significant.
	 * @param uriVariables the map of URI variables
	 * @return the expanded URI components
	 */
	/**
	 * 将所有URI模板变量替换为给定映射中的值。 
	 *  <p>给定的映射键代表变量名； 
	 * 相应的值表示变量值。 
	 * 变量的顺序并不重要。 
	 *  
	 * @param  uri可变URI变量的映射
	 * @return 扩展的URI组件
	 */
	public final UriComponents expand(Map<String, ?> uriVariables) {
		Assert.notNull(uriVariables, "'uriVariables' must not be null");
		return expandInternal(new MapTemplateVariables(uriVariables));
	}

	/**
	 * Replace all URI template variables with the values from a given array.
	 * <p>The given array represents variable values. The order of variables is significant.
	 * @param uriVariableValues the URI variable values
	 * @return the expanded URI components
	 */
	/**
	 * 将所有URI模板变量替换为给定数组中的值。 
	 *  <p>给定的数组表示变量值。 
	 * 变量的顺序很重要。 
	 *  
	 * @param  uriVariableValues URI变量值
	 * @return 扩展的URI组件
	 */
	public final UriComponents expand(Object... uriVariableValues) {
		Assert.notNull(uriVariableValues, "'uriVariableValues' must not be null");
		return expandInternal(new VarArgsTemplateVariables(uriVariableValues));
	}

	/**
	 * Replace all URI template variables with the values from the given
	 * {@link UriTemplateVariables}.
	 * @param uriVariables the URI template values
	 * @return the expanded URI components
	 */
	/**
	 * 将所有URI模板变量替换为给定{@link  UriTemplateVariables}中的值。 
	 *  
	 * @param  uri可变URI模板值
	 * @return 扩展的URI组件
	 */
	public final UriComponents expand(UriTemplateVariables uriVariables) {
		Assert.notNull(uriVariables, "'uriVariables' must not be null");
		return expandInternal(uriVariables);
	}

	/**
	 * Replace all URI template variables with the values from the given {@link
	 * UriTemplateVariables}.
	 * @param uriVariables the URI template values
	 * @return the expanded URI components
	 */
	/**
	 * 将所有URI模板变量替换为给定{@link  UriTemplateVariables}中的值。 
	 *  
	 * @param  uri可变URI模板值
	 * @return 扩展的URI组件
	 */
	abstract UriComponents expandInternal(UriTemplateVariables uriVariables);

	/**
	 * Normalize the path removing sequences like "path/..". Note that
	 * normalization is applied to the full path, and not to individual path
	 * segments.
	 * @see org.springframework.util.StringUtils#cleanPath(String)
	 */
	/**
	 * 标准化路径删除序列，例如"path / .."。 
	 * 请注意，归一化应用于完整路径，而不是单个路径段。 
	 *  
	 * @see  org.springframework.util.StringUtils＃cleanPath（String）
	 */
	public abstract UriComponents normalize();

	/**
	 * Concatenate all URI components to return the fully formed URI String.
	 * <p>This method does nothing more than a simple concatenation based on
	 * current values. That means it could produce different results if invoked
	 * before vs after methods that can change individual values such as
	 * {@code encode}, {@code expand}, or {@code normalize}.
	 */
	/**
	 * 连接所有URI组件以返回完整的URI字符串。 
	 *  <p>此方法只不过基于当前值进行简单串联而已。 
	 * 这意味着，如果在可以更改单个值（例如{@code 编码}，{<@code>扩展}或{@code 规范化）的方法之前或之后调用它，则可能会产生不同的结果。 
	 * 
	 */
	public abstract String toUriString();

	/**
	 * Create a {@link URI} from this instance as follows:
	 * <p>If the current instance is {@link #encode() encoded}, form the full
	 * URI String via {@link #toUriString()}, and then pass it to the single
	 * argument {@link URI} constructor which preserves percent encoding.
	 * <p>If not yet encoded, pass individual URI component values to the
	 * multi-argument {@link URI} constructor which quotes illegal characters
	 * that cannot appear in their respective URI component.
	 */
	/**
	 * 从此实例创建一个{@link  URI}，如下所示：<p>如果当前实例是{@link  #encode（）编码}，则通过{@link  #toUriString（）形成完整的URI字符串。 
	 *  }，然后将其传递给保留百分比编码的单个参数{@link  URI}构造函数。 
	 *  <p>如果尚未编码，则将各个URI组件值传递给多参数{@link  URI}构造函数，该构造函数引用不能出现在其各自URI组件中的非法字符。 
	 * 
	 */
	public abstract URI toUri();

	/**
	 * A simple pass-through to {@link #toUriString()}.
	 */
	/**
	 * 向{@link  #toUriString（）}的简单传递。 
	 * 
	 */
	@Override
	public final String toString() {
		return toUriString();
	}

	/**
	 * Set all components of the given UriComponentsBuilder.
	 * @since 4.2
	 */
	/**
	 * 设置给定UriComponentsBuilder的所有组件。 
	 *  @4.2起
	 */
	protected abstract void copyToUriComponentsBuilder(UriComponentsBuilder builder);


	// Static expansion helpers

	@Nullable
	static String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables) {
		return expandUriComponent(source, uriVariables, null);
	}

	@Nullable
	static String expandUriComponent(@Nullable String source, UriTemplateVariables uriVariables,
			@Nullable UnaryOperator<String> encoder) {

		if (source == null) {
			return null;
		}
		if (source.indexOf('{') == -1) {
			return source;
		}
		if (source.indexOf(':') != -1) {
			source = sanitizeSource(source);
		}
		Matcher matcher = NAMES_PATTERN.matcher(source);
		StringBuffer sb = new StringBuffer();
		while (matcher.find()) {
			String match = matcher.group(1);
			String varName = getVariableName(match);
			Object varValue = uriVariables.getValue(varName);
			if (UriTemplateVariables.SKIP_VALUE.equals(varValue)) {
				continue;
			}
			String formatted = getVariableValueAsString(varValue);
			formatted = encoder != null ? encoder.apply(formatted) : Matcher.quoteReplacement(formatted);
			matcher.appendReplacement(sb, formatted);
		}
		matcher.appendTail(sb);
		return sb.toString();
	}

	/**
	 * Remove nested "{}" such as in URI vars with regular expressions.
	 */
	/**
	 * 使用正则表达式删除嵌套的"{}"，例如在URI vars中。 
	 * 
	 */
	private static String sanitizeSource(String source) {
		int level = 0;
		StringBuilder sb = new StringBuilder();
		for (char c : source.toCharArray()) {
			if (c == '{') {
				level++;
			}
			if (c == '}') {
				level--;
			}
			if (level > 1 || (level == 1 && c == '}')) {
				continue;
			}
			sb.append(c);
		}
		return sb.toString();
	}

	private static String getVariableName(String match) {
		int colonIdx = match.indexOf(':');
		return (colonIdx != -1 ? match.substring(0, colonIdx) : match);
	}

	private static String getVariableValueAsString(@Nullable Object variableValue) {
		return (variableValue != null ? variableValue.toString() : "");
	}


	/**
	 * Defines the contract for URI Template variables.
	 * @see HierarchicalUriComponents#expand
	 */
	/**
	 * 定义URI模板变量的协定。 
	 *  
	 * @see  HierarchicalUriComponents＃expand
	 */
	public interface UriTemplateVariables {

		/**
		 * Constant for a value that indicates a URI variable name should be
		 * ignored and left as is. This is useful for partial expanding of some
		 * but not all URI variables.
		 */
		/**
		 * 指示URI变量名称的值的常量应忽略并保持原样。 
		 * 这对于部分但不是全部URI变量的部分扩展很有用。 
		 * 
		 */
		Object SKIP_VALUE = UriTemplateVariables.class;

		/**
		 * Get the value for the given URI variable name.
		 * If the value is {@code null}, an empty String is expanded.
		 * If the value is {@link #SKIP_VALUE}, the URI variable is not expanded.
		 * @param name the variable name
		 * @return the variable value, possibly {@code null} or {@link #SKIP_VALUE}
		 */
		/**
		 * 获取给定URI变量名称的值。 
		 * 如果值为{@code  null}，则将扩展一个空的String。 
		 * 如果值为{@link  #SKIP_VALUE}，则不会扩展URI变量。 
		 *  
		 * @param 命名变量名称
		 * @return 变量值，可能为{@code  null}或{@link  #SKIP_VALUE}
		 */
		@Nullable
		Object getValue(@Nullable String name);
	}


	/**
	 * URI template variables backed by a map.
	 */
	/**
	 * 映射支持的URI模板变量。 
	 * 
	 */
	private static class MapTemplateVariables implements UriTemplateVariables {

		private final Map<String, ?> uriVariables;

		public MapTemplateVariables(Map<String, ?> uriVariables) {
			this.uriVariables = uriVariables;
		}

		@Override
		@Nullable
		public Object getValue(@Nullable String name) {
			if (!this.uriVariables.containsKey(name)) {
				throw new IllegalArgumentException("Map has no value for '" + name + "'");
			}
			return this.uriVariables.get(name);
		}
	}


	/**
	 * URI template variables backed by a variable argument array.
	 */
	/**
	 * 由变量参数数组支持的URI模板变量。 
	 * 
	 */
	private static class VarArgsTemplateVariables implements UriTemplateVariables {

		private final Iterator<Object> valueIterator;

		public VarArgsTemplateVariables(Object... uriVariableValues) {
			this.valueIterator = Arrays.asList(uriVariableValues).iterator();
		}

		@Override
		@Nullable
		public Object getValue(@Nullable String name) {
			if (!this.valueIterator.hasNext()) {
				throw new IllegalArgumentException("Not enough variable values available to expand '" + name + "'");
			}
			return this.valueIterator.next();
		}
	}

}
