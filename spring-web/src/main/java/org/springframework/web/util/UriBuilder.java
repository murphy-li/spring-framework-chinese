/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.util;

import java.net.URI;
import java.util.Collection;
import java.util.Map;

import org.springframework.lang.Nullable;
import org.springframework.util.MultiValueMap;

/**
 * Builder-style methods to prepare and expand a URI template with variables.
 *
 * <p>Effectively a generalization of {@link UriComponentsBuilder} but with
 * shortcuts to expand directly into {@link URI} rather than
 * {@link UriComponents} and also leaving common concerns such as encoding
 * preferences, a base URI, and others as implementation concerns.
 *
 * <p>Typically obtained via {@link UriBuilderFactory} which serves as a central
 * component configured once and used to create many URLs.
 *
 * @author Rossen Stoyanchev
 * @since 5.0
 * @see UriBuilderFactory
 * @see UriComponentsBuilder
 */
/**
 * 生成器样式的方法，用于准备和扩展带有变量的URI模板。 
 *  <p>有效地概括了{@link  UriComponentsBuilder}，但具有直接扩展到{@link  URI}而不是{@link  UriComponents}的快捷方式，并且还存在诸如编码首选项，基本URI等常见问题以及其他实施方面的问题。 
 *  <p>通常通过{@link  UriBuilderFactory}获得，它用作一次配置的中央组件，用于创建许多URL。 
 *  @author  Rossen Stoyanchev @从5.0开始
 * @see  UriBuilderFactory 
 * @see  UriComponentsBuilder
 */
public interface UriBuilder {

	/**
	 * Set the URI scheme which may contain URI template variables,
	 * and may also be {@code null} to clear the scheme of this builder.
	 * @param scheme the URI scheme
	 */
	/**
	 * 设置URI方案，该方案可以包含URI模板变量，也可以为{@code  null}以清除此构建器的方案。 
	 *  
	 * @param 方案URI方案
	 */
	UriBuilder scheme(@Nullable String scheme);

	/**
	 * Set the URI user info which may contain URI template variables, and
	 * may also be {@code null} to clear the user info of this builder.
	 * @param userInfo the URI user info
	 */
	/**
	 * 设置URI用户信息，该用户信息可能包含URI模板变量，也可以为{@code  null}以清除此构建器的用户信息。 
	 *  
	 * @param  userInfo URI用户信息
	 */
	UriBuilder userInfo(@Nullable String userInfo);

	/**
	 * Set the URI host which may contain URI template variables, and may also
	 * be {@code null} to clear the host of this builder.
	 * @param host the URI host
	 */
	/**
	 * 设置URI主机，该主机可能包含URI模板变量，也可以为{@code  null}以清除此构建器的主机。 
	 *  
	 * @param 托管URI主机
	 */
	UriBuilder host(@Nullable String host);

	/**
	 * Set the URI port. Passing {@code -1} will clear the port of this builder.
	 * @param port the URI port
	 */
	/**
	 * 设置URI端口。 
	 * 传递{@code  -1}将清除此构建器的端口。 
	 *  
	 * @param 端口URI端口
	 */
	UriBuilder port(int port);

	/**
	 * Set the URI port . Use this method only when the port needs to be
	 * parameterized with a URI variable. Otherwise use {@link #port(int)}.
	 * Passing {@code null} will clear the port of this builder.
	 * @param port the URI port
	 */
	/**
	 * 设置URI端口。 
	 * 仅当需要使用URI变量对端口进行参数化时，才使用此方法。 
	 * 否则，请使用{@link  #port（int）}。 
	 * 传递{@code  null}将清除此构建器的端口。 
	 *  
	 * @param 端口URI端口
	 */
	UriBuilder port(@Nullable String port);

	/**
	 * Append the given path to the existing path of this builder.
	 * The given path may contain URI template variables.
	 * @param path the URI path
	 */
	/**
	 * 将给定路径追加到此构建器的现有路径。 
	 * 给定的路径可能包含URI模板变量。 
	 *  
	 * @param  path URI路径
	 */
	UriBuilder path(String path);

	/**
	 * Set the path of this builder overriding the existing path values.
	 * @param path the URI path, or {@code null} for an empty path
	 */
	/**
	 * 设置此构建器的路径以覆盖现有路径值。 
	 *  
	 * @param 路径URI路径，或{@code  null}表示空路径
	 */
	UriBuilder replacePath(@Nullable String path);

	/**
	 * Append path segments to the existing path. Each path segment may contain
	 * URI template variables and should not contain any slashes.
	 * Use {@code path("/")} subsequently to ensure a trailing slash.
	 * @param pathSegments the URI path segments
	 */
	/**
	 * 将路径段追加到现有路径。 
	 * 每个路径段都可以包含URI模板变量，并且不应包含任何斜杠。 
	 * 随后使用{@code  path（"/"）}来确保后跟斜杠。 
	 *  
	 * @param  pathSegments URI路径段
	 */
	UriBuilder pathSegment(String... pathSegments) throws IllegalArgumentException;

	/**
	 * Parse the given query string into query parameters where parameters are
	 * separated with {@code '&'} and their values, if any, with {@code '='}.
	 * The query may contain URI template variables.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param query the query string
	 */
	/**
	 * 将给定的查询字符串解析为查询参数，其中参数之间用{@code '＆'}分隔，其值（如果有）用{@code '='}分隔。 
	 * 该查询可能包含URI模板变量。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 查询查询字符串
	 */
	UriBuilder query(String query);

	/**
	 * Clear existing query parameters and then delegate to {@link #query(String)}.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param query the query string; a {@code null} value removes all query parameters.
	 */
	/**
	 * 清除现有查询参数，然后委托给{@link  #query（String）}。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 查询查询字符串； 
	 *  {@code  null}值将删除所有查询参数。 
	 * 
	 */
	UriBuilder replaceQuery(@Nullable String query);

	/**
	 * Append the given query parameter. Both the parameter name and values may
	 * contain URI template variables to be expanded later from values. If no
	 * values are given, the resulting URI will contain the query parameter name
	 * only, e.g. {@code "?foo"} instead of {@code "?foo=bar"}.
	 * <p><strong>Note:</strong> encoding, if applied, will only encode characters
	 * that are illegal in a query parameter name or value such as {@code "="}
	 * or {@code "&"}. All others that are legal as per syntax rules in
	 * <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a> are not
	 * encoded. This includes {@code "+"} which sometimes needs to be encoded
	 * to avoid its interpretation as an encoded space. Stricter encoding may
	 * be applied by using a URI template variable along with stricter encoding
	 * on variable values. For more details please read the
	 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#web-uri-encoding">"URI Encoding"</a>
	 * section of the Spring Framework reference.
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @see #queryParam(String, Collection)
	 */
	/**
	 * 附加给定的查询参数。 
	 * 参数名称和值都可以包含URI模板变量，以便以后从值中进行扩展。 
	 * 如果未提供任何值，则结果URI将仅包含查询参数名称，例如{@code "？foo"}代替{@code "？foo = bar"}。 
	 *  <p> <strong>注意：</ strong>编码（如果应用）将仅对查询参数名称或值中的非法字符进行编码，例如{@code "="}或{@code "＆ "}。 
	 * 根据<a href="https://tools.ietf.org/html/rfc3986"> RFC 3986 </a>中的语法规则合法的所有其他文件均未进行编码。 
	 * 这包括{@code "+"}，有时需要进行编码以避免将其解释为编码空间。 
	 * 可以通过使用URI模板变量以及对变量值进行更严格的编码来应用更严格的编码。 
	 * 有关更多详细信息，请阅读<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#web-uri-encoding">"URI编码"</ </ Spring框架参考的a>部分。 
	 *  
	 * @param 命名查询参数名称
	 * @param 值查询参数值
	 * @see  #queryParam（String，Collection）
	 */
	UriBuilder queryParam(String name, Object... values);

	/**
	 * Variant of {@link #queryParam(String, Object...)} with a Collection.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @since 5.2
	 * @see #queryParam(String, Object...)
	 */
	/**
	 * {@link  #queryParam（String，Object ...）}与集合的变体。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 命名查询参数名称
	 * @param 值查询参数值@since 5.2 
	 * @see  #queryParam（String，Object ...）
	 */
	UriBuilder queryParam(String name, @Nullable Collection<?> values);

	/**
	 * Add multiple query parameters and values.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param params the params
	 */
	/**
	 * 添加多个查询参数和值。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 参数params
	 */
	UriBuilder queryParams(MultiValueMap<String, String> params);

	/**
	 * Set the query parameter values replacing existing values, or if no
	 * values are given, the query parameter is removed.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @see #replaceQueryParam(String, Collection)
	 */
	/**
	 * 设置查询参数值以替换现有值，或者如果未提供任何值，则删除查询参数。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 命名查询参数名称
	 * @param 值查询参数值
	 * @see  #replaceQueryParam（String，Collection）
	 */
	UriBuilder replaceQueryParam(String name, Object... values);

	/**
	 * Variant of {@link #replaceQueryParam(String, Object...)} with a Collection.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param name the query parameter name
	 * @param values the query parameter values
	 * @since 5.2
	 * @see #replaceQueryParam(String, Object...)
	 */
	/**
	 * {@link  #replaceQueryParam（String，Object ...）}与集合的变体。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 为查询参数名称命名
	 * @param 为查询参数值@5.2起@
	 * @see> #replaceQueryParam（String，Object ...）
	 */
	UriBuilder replaceQueryParam(String name, @Nullable Collection<?> values);

	/**
	 * Set the query parameter values after removing all existing ones.
	 * <p><strong>Note: </strong> please, review the Javadoc of
	 * {@link #queryParam(String, Object...)} for further notes on the treatment
	 * and encoding of individual query parameters.
	 * @param params the query parameter name
	 */
	/**
	 * 删除所有现有参数后，设置查询参数值。 
	 *  <p> <strong>注意：</ strong>，请查阅{@link  #queryParam（String，Object ...）}的Javadoc，以获取有关各个查询参数的处理和编码的进一步说明。 
	 *  
	 * @param 设置查询参数名称
	 */
	UriBuilder replaceQueryParams(MultiValueMap<String, String> params);

	/**
	 * Set the URI fragment. The given fragment may contain URI template variables,
	 * and may also be {@code null} to clear the fragment of this builder.
	 * @param fragment the URI fragment
	 */
	/**
	 * 设置URI片段。 
	 * 给定的片段可能包含URI模板变量，也可能是{@code  null}以清除此构建器的片段。 
	 *  
	 * @param 片段化URI片段
	 */
	UriBuilder fragment(@Nullable String fragment);

	/**
	 * Build a {@link URI} instance and replaces URI template variables
	 * with the values from an array.
	 * @param uriVariables the map of URI variables
	 * @return the URI
	 */
	/**
	 * 构建一个{@link  URI}实例，并将URI模板变量替换为数组中的值。 
	 *  
	 * @param  uri对URI变量的映射进行变量
	 * @return  URI
	 */
	URI build(Object... uriVariables);

	/**
	 * Build a {@link URI} instance and replaces URI template variables
	 * with the values from a map.
	 * @param uriVariables the map of URI variables
	 * @return the URI
	 */
	/**
	 * 构建{@link  URI}实例，并用映射中的值替换URI模板变量。 
	 *  
	 * @param  uri对URI变量的映射进行变量
	 * @return  URI
	 */
	URI build(Map<String, ?> uriVariables);

}
