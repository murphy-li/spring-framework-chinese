/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.util;

import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.Tag;

import org.springframework.util.Assert;

/**
 * Utility class for tag library related code, exposing functionality
 * such as translating {@link String Strings} to web scopes.
 *
 * <p>
 * <ul>
 * <li>{@code page} will be transformed to
 * {@link javax.servlet.jsp.PageContext#PAGE_SCOPE PageContext.PAGE_SCOPE}
 * <li>{@code request} will be transformed to
 * {@link javax.servlet.jsp.PageContext#REQUEST_SCOPE PageContext.REQUEST_SCOPE}
 * <li>{@code session} will be transformed to
 * {@link javax.servlet.jsp.PageContext#SESSION_SCOPE PageContext.SESSION_SCOPE}
 * <li>{@code application} will be transformed to
 * {@link javax.servlet.jsp.PageContext#APPLICATION_SCOPE PageContext.APPLICATION_SCOPE}
 * </ul>
 *
 * @author Alef Arendsen
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Rick Evans
 */
/**
 * 标记库相关代码的实用程序类，提供了将{@link  String Strings}转换为Web作用域的功能。 
 *  <p> <ul> <li> {<@code>页面}将转换为{@link  javax.servlet.jsp.PageContext＃PAGE_SCOPE PageContext.PAGE_SCOPE} <li> {<@code> request}将转换为{@link  javax.servlet.jsp.PageContext＃REQUEST_SCOPE PageContext.REQUEST_SCOPE} <li> {<@code>会话}将转换为{@link  javax.servlet.jsp.PageContext＃SESSION_SCOPE PageContext。 
 *  SESSION_SCOPE} <li> {<@code>应用程序}将转换为{@link  javax.servlet.jsp.PageContext＃APPLICATION_SCOPE PageContext.APPLICATION_SCOPE} </ ul> @author  Alef Arendsen @author  Rob Harrop @author  Juergen Hoeller @author 里克·埃文斯（Rick Evans）
 */
public abstract class TagUtils {

	/** Constant identifying the page scope. */
	/**
	 * 标识页面范围的常量。 
	 * 
	 */
	public static final String SCOPE_PAGE = "page";

	/** Constant identifying the request scope. */
	/**
	 * 标识请求范围的常量。 
	 * 
	 */
	public static final String SCOPE_REQUEST = "request";

	/** Constant identifying the session scope. */
	/**
	 * 标识会话范围的常量。 
	 * 
	 */
	public static final String SCOPE_SESSION = "session";

	/** Constant identifying the application scope. */
	/**
	 * 常数标识应用范围。 
	 * 
	 */
	public static final String SCOPE_APPLICATION = "application";


	/**
	 * Determines the scope for a given input {@code String}.
	 * <p>If the {@code String} does not match 'request', 'session',
	 * 'page' or 'application', the method will return {@link PageContext#PAGE_SCOPE}.
	 * @param scope the {@code String} to inspect
	 * @return the scope found, or {@link PageContext#PAGE_SCOPE} if no scope matched
	 * @throws IllegalArgumentException if the supplied {@code scope} is {@code null}
	 */
	/**
	 * 确定给定输入{@code  String}的范围。 
	 *  <p>如果{@code 字符串}与'request'，'session'，'page'或'application'不匹配，则该方法将返回{@link  PageContext＃PAGE_SCOPE}。 
	 *  
	 * @param 作用域{@code 字符串}检查
	 * @return 找到的作用域，如果没有作用域匹配，则{@link  PageContext＃PAGE_SCOPE} 
	 * @throws  IllegalArgumentException如果提供的{@code  scope}为{@code  null}
	 */
	public static int getScope(String scope) {
		Assert.notNull(scope, "Scope to search for cannot be null");
		if (scope.equals(SCOPE_REQUEST)) {
			return PageContext.REQUEST_SCOPE;
		}
		else if (scope.equals(SCOPE_SESSION)) {
			return PageContext.SESSION_SCOPE;
		}
		else if (scope.equals(SCOPE_APPLICATION)) {
			return PageContext.APPLICATION_SCOPE;
		}
		else {
			return PageContext.PAGE_SCOPE;
		}
	}

	/**
	 * Determine whether the supplied {@link Tag} has any ancestor tag
	 * of the supplied type.
	 * @param tag the tag whose ancestors are to be checked
	 * @param ancestorTagClass the ancestor {@link Class} being searched for
	 * @return {@code true} if the supplied {@link Tag} has any ancestor tag
	 * of the supplied type
	 * @throws IllegalArgumentException if either of the supplied arguments is {@code null};
	 * or if the supplied {@code ancestorTagClass} is not type-assignable to
	 * the {@link Tag} class
	 */
	/**
	 * 确定所提供的{@link 标签}是否具有所提供类型的任何祖先标签。 
	 *  
	 * @param 标记要检查其祖先的标记
	 * @param  ancestorTagClass正在搜索祖先{@link  Class}的标记
	 * @return  {@code  true}（如果提供的{@link 标记） }如果提供的任何一个参数为{@code  null}，则具有提供的类型
	 * @throws  IllegalArgumentException的任何祖先标记； 
	 * 或提供的{@code  ancestorTagClass}不可类型分配给{@link  Tag}类
	 */
	public static boolean hasAncestorOfType(Tag tag, Class<?> ancestorTagClass) {
		Assert.notNull(tag, "Tag cannot be null");
		Assert.notNull(ancestorTagClass, "Ancestor tag class cannot be null");
		if (!Tag.class.isAssignableFrom(ancestorTagClass)) {
			throw new IllegalArgumentException(
					"Class '" + ancestorTagClass.getName() + "' is not a valid Tag type");
		}
		Tag ancestor = tag.getParent();
		while (ancestor != null) {
			if (ancestorTagClass.isAssignableFrom(ancestor.getClass())) {
				return true;
			}
			ancestor = ancestor.getParent();
		}
		return false;
	}

	/**
	 * Determine whether the supplied {@link Tag} has any ancestor tag
	 * of the supplied type, throwing an {@link IllegalStateException}
	 * if not.
	 * @param tag the tag whose ancestors are to be checked
	 * @param ancestorTagClass the ancestor {@link Class} being searched for
	 * @param tagName the name of the {@code tag}; for example '{@code option}'
	 * @param ancestorTagName the name of the ancestor {@code tag}; for example '{@code select}'
	 * @throws IllegalStateException if the supplied {@code tag} does not
	 * have a tag of the supplied {@code parentTagClass} as an ancestor
	 * @throws IllegalArgumentException if any of the supplied arguments is {@code null},
	 * or in the case of the {@link String}-typed arguments, is composed wholly
	 * of whitespace; or if the supplied {@code ancestorTagClass} is not
	 * type-assignable to the {@link Tag} class
	 * @see #hasAncestorOfType(javax.servlet.jsp.tagext.Tag, Class)
	 */
	/**
	 * 确定所提供的{@link 标签}是否具有所提供类型的任何祖先标签，如果没有，则抛出一个{@link  IllegalStateException}。 
	 *  
	 * @param 标记要检查其祖先的标记
	 * @param  ancestorTagClass正在搜索祖先{@link  Class}的标记
	 * @param 标记名称{@code 标记的名称}； 
	 * 例如'{@code 选项}'
	 * @param  ancestorTagName祖先的名称{@code 标签}； 
	 * 例如，如果提供的{@code 标签}没有作为父项
	 * @throws  IllegalArgumentException的提供的{@code  parentTagClass}的标签，则为'{@code  select}'
	 * @throws  IllegalStateException提供的任何参数为{@code  null}，或者对于{@link  String}类型的参数，完全由空格组成； 
	 * 或提供的{@code  ancestorTagClass}不是类型可分配给{@link  Tag}类
	 * @see  #hasAncestorOfType（javax.servlet.jsp.tagext.Tag，Class）的类型
	 */
	public static void assertHasAncestorOfType(Tag tag, Class<?> ancestorTagClass, String tagName,
			String ancestorTagName) {

		Assert.hasText(tagName, "'tagName' must not be empty");
		Assert.hasText(ancestorTagName, "'ancestorTagName' must not be empty");
		if (!TagUtils.hasAncestorOfType(tag, ancestorTagClass)) {
			throw new IllegalStateException("The '" + tagName +
					"' tag can only be used inside a valid '" + ancestorTagName + "' tag.");
		}
	}

}
