/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URI;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;

import javax.servlet.ServletContext;
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestWrapper;
import javax.servlet.ServletResponse;
import javax.servlet.ServletResponseWrapper;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpRequest;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
 * Miscellaneous utilities for web applications.
 * Used by various framework classes.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sebastien Deleuze
 */
/**
 * Web应用程序的杂项实用程序。 
 * 由各种框架类使用。 
 *  @author 罗德·约翰逊@author  Juergen Hoeller @author 塞巴斯蒂安·德勒兹（Sebastien Deleuze）
 */
public abstract class WebUtils {

	/**
	 * Standard Servlet 2.3+ spec request attribute for include request URI.
	 * <p>If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating request. Its own request URI is exposed as a request attribute.
	 */
	/**
	 * 用于包含请求URI的标准Servlet 2.3+规范请求属性。 
	 *  <p>如果通过{@code  RequestDispatcher}包含在内，则当前资源将看到原始请求。 
	 * 它自己的请求URI作为请求属性公开。 
	 * 
	 */
	public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = "javax.servlet.include.request_uri";

	/**
	 * Standard Servlet 2.3+ spec request attribute for include context path.
	 * <p>If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating context path. Its own context path is exposed as a request attribute.
	 */
	/**
	 * 用于包含上下文路径的标准Servlet 2.3+规范请求属性。 
	 *  <p>如果通过{@code  RequestDispatcher}包含在内，则当前资源将看到原始上下文路径。 
	 * 它自己的上下文路径作为请求属性公开。 
	 * 
	 */
	public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = "javax.servlet.include.context_path";

	/**
	 * Standard Servlet 2.3+ spec request attribute for include servlet path.
	 * <p>If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating servlet path. Its own servlet path is exposed as a request attribute.
	 */
	/**
	 * 包含Servlet路径的标准Servlet 2.3+规范请求属性。 
	 *  <p>如果通过{@code  RequestDispatcher}包含在内，则当前资源将看到原始servlet路径。 
	 * 它自己的servlet路径作为请求属性公开。 
	 * 
	 */
	public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = "javax.servlet.include.servlet_path";

	/**
	 * Standard Servlet 2.3+ spec request attribute for include path info.
	 * <p>If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating path info. Its own path info is exposed as a request attribute.
	 */
	/**
	 * 用于包含路径信息的标准Servlet 2.3+规范请求属性。 
	 *  <p>如果通过{@code  RequestDispatcher}包含在内，则当前资源将看到原始路径信息。 
	 * 它自己的路径信息作为请求属性公开。 
	 * 
	 */
	public static final String INCLUDE_PATH_INFO_ATTRIBUTE = "javax.servlet.include.path_info";

	/**
	 * Standard Servlet 2.3+ spec request attribute for include query string.
	 * <p>If included via a {@code RequestDispatcher}, the current resource will see the
	 * originating query string. Its own query string is exposed as a request attribute.
	 */
	/**
	 * 用于包含查询字符串的标准Servlet 2.3+规范请求属性。 
	 *  <p>如果通过{@code  RequestDispatcher}包含在内，当前资源将看到原始查询字符串。 
	 * 它自己的查询字符串作为请求属性公开。 
	 * 
	 */
	public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = "javax.servlet.include.query_string";

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward request URI.
	 * <p>If forwarded to via a RequestDispatcher, the current resource will see its
	 * own request URI. The originating request URI is exposed as a request attribute.
	 */
	/**
	 * 用于转发请求URI的标准Servlet 2.4+ spec请求属性。 
	 *  <p>如果通过RequestDispatcher转发到，则当前资源将看到其自己的请求URI。 
	 * 原始请求URI作为请求属性公开。 
	 * 
	 */
	public static final String FORWARD_REQUEST_URI_ATTRIBUTE = "javax.servlet.forward.request_uri";

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward context path.
	 * <p>If forwarded to via a RequestDispatcher, the current resource will see its
	 * own context path. The originating context path is exposed as a request attribute.
	 */
	/**
	 * 用于前向上下文路径的标准Servlet 2.4+ spec请求属性。 
	 *  <p>如果通过RequestDispatcher转发到，则当前资源将看到其自己的上下文路径。 
	 * 原始上下文路径作为请求属性公开。 
	 * 
	 */
	public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = "javax.servlet.forward.context_path";

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward servlet path.
	 * <p>If forwarded to via a RequestDispatcher, the current resource will see its
	 * own servlet path. The originating servlet path is exposed as a request attribute.
	 */
	/**
	 * 正向Servlet路径的标准Servlet 2.4+ spec请求属性。 
	 *  <p>如果通过RequestDispatcher转发到，则当前资源将看到其自己的servlet路径。 
	 * 原始Servlet路径作为请求属性公开。 
	 * 
	 */
	public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = "javax.servlet.forward.servlet_path";

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward path info.
	 * <p>If forwarded to via a RequestDispatcher, the current resource will see its
	 * own path ingo. The originating path info is exposed as a request attribute.
	 */
	/**
	 * 用于前进路径信息的标准Servlet 2.4+规范请求属性。 
	 *  <p>如果通过RequestDispatcher转发到，则当前资源将看到其自己的路径。 
	 * 原始路径信息作为请求属性公开。 
	 * 
	 */
	public static final String FORWARD_PATH_INFO_ATTRIBUTE = "javax.servlet.forward.path_info";

	/**
	 * Standard Servlet 2.4+ spec request attribute for forward query string.
	 * <p>If forwarded to via a RequestDispatcher, the current resource will see its
	 * own query string. The originating query string is exposed as a request attribute.
	 */
	/**
	 * 用于向前查询字符串的标准Servlet 2.4+ spec请求属性。 
	 *  <p>如果通过RequestDispatcher转发到，则当前资源将看到其自己的查询字符串。 
	 * 原始查询字符串作为请求属性公开。 
	 * 
	 */
	public static final String FORWARD_QUERY_STRING_ATTRIBUTE = "javax.servlet.forward.query_string";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page status code.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面状态代码的标准Servlet 2.3+规范请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_STATUS_CODE_ATTRIBUTE = "javax.servlet.error.status_code";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page exception type.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面异常类型的标准Servlet 2.3+ spec请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_EXCEPTION_TYPE_ATTRIBUTE = "javax.servlet.error.exception_type";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page message.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面消息的标准Servlet 2.3+规范请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_MESSAGE_ATTRIBUTE = "javax.servlet.error.message";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page exception.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面异常的标准Servlet 2.3+ spec请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_EXCEPTION_ATTRIBUTE = "javax.servlet.error.exception";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page request URI.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面请求URI的标准Servlet 2.3+ spec请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_REQUEST_URI_ATTRIBUTE = "javax.servlet.error.request_uri";

	/**
	 * Standard Servlet 2.3+ spec request attribute for error page servlet name.
	 * <p>To be exposed to JSPs that are marked as error pages, when forwarding
	 * to them directly rather than through the servlet container's error page
	 * resolution mechanism.
	 */
	/**
	 * 错误页面Servlet名称的标准Servlet 2.3+ spec请求属性。 
	 *  <p>当直接转发到标记为错误页面的JSP而不是通过servlet容器的错误页面解析机制将其暴露给它们时。 
	 * 
	 */
	public static final String ERROR_SERVLET_NAME_ATTRIBUTE = "javax.servlet.error.servlet_name";

	/**
	 * Prefix of the charset clause in a content type String: ";charset=".
	 */
	/**
	 * charset子句在内容类型字符串中的前缀："; charset ="。 
	 * 
	 */
	public static final String CONTENT_TYPE_CHARSET_PREFIX = ";charset=";

	/**
	 * Default character encoding to use when {@code request.getCharacterEncoding}
	 * returns {@code null}, according to the Servlet spec.
	 * @see ServletRequest#getCharacterEncoding
	 */
	/**
	 * 根据Servlet规范，当{@code  request.getCharacterEncoding}返回{@code  null}时使用的默认字符编码。 
	 *  
	 * @see  ServletRequest＃getCharacterEncoding
	 */
	public static final String DEFAULT_CHARACTER_ENCODING = "ISO-8859-1";

	/**
	 * Standard Servlet spec context attribute that specifies a temporary
	 * directory for the current web application, of type {@code java.io.File}.
	 */
	/**
	 * 标准Servlet规范上下文属性，用于指定当前Web应用程序的临时目录，类型为{@code  java.io.File}。 
	 * 
	 */
	public static final String TEMP_DIR_CONTEXT_ATTRIBUTE = "javax.servlet.context.tempdir";

	/**
	 * HTML escape parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): "defaultHtmlEscape".
	 */
	/**
	 * Servlet上下文级别的HTML转义参数（即{@code  web.xml}中的context-param）："defaultHtmlEscape"。 
	 * 
	 */
	public static final String HTML_ESCAPE_CONTEXT_PARAM = "defaultHtmlEscape";

	/**
	 * Use of response encoding for HTML escaping parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): "responseEncodedHtmlEscape".
	 * @since 4.1.2
	 */
	/**
	 * 在Servlet上下文级别（即{@code  web.xml}中的context-param）中对HTML转义参数使用响应编码："responseEncodedHtmlEscape"。 
	 *  @从4.1.2开始
	 */
	public static final String RESPONSE_ENCODED_HTML_ESCAPE_CONTEXT_PARAM = "responseEncodedHtmlEscape";

	/**
	 * Web app root key parameter at the servlet context level
	 * (i.e. a context-param in {@code web.xml}): "webAppRootKey".
	 */
	/**
	 * Servlet上下文级别（即{@code  web.xml}中的上下文参数）的Web应用程序根密钥参数："webAppRootKey"。 
	 * 
	 */
	public static final String WEB_APP_ROOT_KEY_PARAM = "webAppRootKey";

	/** Default web app root key: "webapp.root". */
	/**
	 * 默认的Web应用程序根密钥："webapp.root"。 
	 * 
	 */
	public static final String DEFAULT_WEB_APP_ROOT_KEY = "webapp.root";

	/** Name suffixes in case of image buttons. */
	/**
	 * 如果有图像按钮，则后缀。 
	 * 
	 */
	public static final String[] SUBMIT_IMAGE_SUFFIXES = {".x", ".y"};

	/** Key for the mutex session attribute. */
	/**
	 * 互斥会话属性的键。 
	 * 
	 */
	public static final String SESSION_MUTEX_ATTRIBUTE = WebUtils.class.getName() + ".MUTEX";


	/**
	 * Set a system property to the web application root directory.
	 * The key of the system property can be defined with the "webAppRootKey"
	 * context-param in {@code web.xml}. Default is "webapp.root".
	 * <p>Can be used for tools that support substitution with {@code System.getProperty}
	 * values, like log4j's "${key}" syntax within log file locations.
	 * @param servletContext the servlet context of the web application
	 * @throws IllegalStateException if the system property is already set,
	 * or if the WAR file is not expanded
	 * @see #WEB_APP_ROOT_KEY_PARAM
	 * @see #DEFAULT_WEB_APP_ROOT_KEY
	 * @see WebAppRootListener
	 */
	/**
	 * 将系统属性设置为Web应用程序的根目录。 
	 * 可以使用{@code  web.xml}中的"webAppRootKey"上下文参数定义系统属性的键。 
	 * 默认值为"webapp.root"。 
	 *  <p>可用于支持用{@code  System.getProperty}值替代的工具，例如日志文件位置中log4j的"$ {key}"语法。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文
	 * @throws  IllegalStateException如果已设置系统属性，或者未扩展WAR文件
	 * @see  #WEB_APP_ROOT_KEY_PARAM 
	 * @see  #DEFAULT_WEB_APP_ROOT_KEY 
	 * @see  WebAppRootListener
	 */
	public static void setWebAppRootSystemProperty(ServletContext servletContext) throws IllegalStateException {
		Assert.notNull(servletContext, "ServletContext must not be null");
		String root = servletContext.getRealPath("/");
		if (root == null) {
			throw new IllegalStateException(
					"Cannot set web app root system property when WAR file is not expanded");
		}
		String param = servletContext.getInitParameter(WEB_APP_ROOT_KEY_PARAM);
		String key = (param != null ? param : DEFAULT_WEB_APP_ROOT_KEY);
		String oldValue = System.getProperty(key);
		if (oldValue != null && !StringUtils.pathEquals(oldValue, root)) {
			throw new IllegalStateException("Web app root system property already set to different value: '" +
					key + "' = [" + oldValue + "] instead of [" + root + "] - " +
					"Choose unique values for the 'webAppRootKey' context-param in your web.xml files!");
		}
		System.setProperty(key, root);
		servletContext.log("Set web app root system property: '" + key + "' = [" + root + "]");
	}

	/**
	 * Remove the system property that points to the web app root directory.
	 * To be called on shutdown of the web application.
	 * @param servletContext the servlet context of the web application
	 * @see #setWebAppRootSystemProperty
	 */
	/**
	 * 删除指向Web应用程序根目录的系统属性。 
	 * 在关闭Web应用程序时被调用。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文
	 * @see  #setWebAppRootSystemProperty
	 */
	public static void removeWebAppRootSystemProperty(ServletContext servletContext) {
		Assert.notNull(servletContext, "ServletContext must not be null");
		String param = servletContext.getInitParameter(WEB_APP_ROOT_KEY_PARAM);
		String key = (param != null ? param : DEFAULT_WEB_APP_ROOT_KEY);
		System.getProperties().remove(key);
	}

	/**
	 * Return whether default HTML escaping is enabled for the web application,
	 * i.e. the value of the "defaultHtmlEscape" context-param in {@code web.xml}
	 * (if any).
	 * <p>This method differentiates between no param specified at all and
	 * an actual boolean value specified, allowing to have a context-specific
	 * default in case of no setting at the global level.
	 * @param servletContext the servlet context of the web application
	 * @return whether default HTML escaping is enabled for the given application
	 * ({@code null} = no explicit default)
	 */
	/**
	 * 返回是否为Web应用程序启用了默认的HTML转义，即{@code  web.xml}中"defaultHtmlEscape"上下文参数的值（如果有）。 
	 *  <p>此方法区分完全没有指定的参数和实际指定的布尔值，从而允许在全局级别未设置的情况下具有特定于上下文的默认值。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文<@r​​eturn>是否为给定应用程序启用了默认HTML转义（{@code  null} =没有明确的默认值）
	 */
	@Nullable
	public static Boolean getDefaultHtmlEscape(@Nullable ServletContext servletContext) {
		if (servletContext == null) {
			return null;
		}
		String param = servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
		return (StringUtils.hasText(param) ? Boolean.valueOf(param) : null);
	}

	/**
	 * Return whether response encoding should be used when HTML escaping characters,
	 * thus only escaping XML markup significant characters with UTF-* encodings.
	 * This option is enabled for the web application with a ServletContext param,
	 * i.e. the value of the "responseEncodedHtmlEscape" context-param in {@code web.xml}
	 * (if any).
	 * <p>This method differentiates between no param specified at all and
	 * an actual boolean value specified, allowing to have a context-specific
	 * default in case of no setting at the global level.
	 * @param servletContext the servlet context of the web application
	 * @return whether response encoding is to be used for HTML escaping
	 * ({@code null} = no explicit default)
	 * @since 4.1.2
	 */
	/**
	 * 返回在HTML转义字符时是否应使用响应编码，从而仅使用UTF编码转义XML标记有效字符。 
	 * 对于具有ServletContext参数的Web应用程序启用了此选项，即{@code  web.xml}中"responseEncodedHtmlEscape"上下文参数的值（如果有）。 
	 *  <p>此方法区分完全没有指定的参数和实际指定的布尔值，从而允许在全局级别未设置的情况下具有特定于上下文的默认值。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文<@r​​eturn>是否将响应编码用于HTML转义（{@code  null} =无显式默认值）@4.1.2起
	 */
	@Nullable
	public static Boolean getResponseEncodedHtmlEscape(@Nullable ServletContext servletContext) {
		if (servletContext == null) {
			return null;
		}
		String param = servletContext.getInitParameter(RESPONSE_ENCODED_HTML_ESCAPE_CONTEXT_PARAM);
		return (StringUtils.hasText(param) ? Boolean.valueOf(param) : null);
	}

	/**
	 * Return the temporary directory for the current web application,
	 * as provided by the servlet container.
	 * @param servletContext the servlet context of the web application
	 * @return the File representing the temporary directory
	 */
	/**
	 * 返回servlet容器提供的当前Web应用程序的临时目录。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文<@r​​eturn>代表临时目录的文件
	 */
	public static File getTempDir(ServletContext servletContext) {
		Assert.notNull(servletContext, "ServletContext must not be null");
		return (File) servletContext.getAttribute(TEMP_DIR_CONTEXT_ATTRIBUTE);
	}

	/**
	 * Return the real path of the given path within the web application,
	 * as provided by the servlet container.
	 * <p>Prepends a slash if the path does not already start with a slash,
	 * and throws a FileNotFoundException if the path cannot be resolved to
	 * a resource (in contrast to ServletContext's {@code getRealPath},
	 * which returns null).
	 * @param servletContext the servlet context of the web application
	 * @param path the path within the web application
	 * @return the corresponding real path
	 * @throws FileNotFoundException if the path cannot be resolved to a resource
	 * @see javax.servlet.ServletContext#getRealPath
	 */
	/**
	 * 返回servlet容器提供的Web应用程序中给定路径的真实路径。 
	 *  <p>如果路径尚未以斜杠开始，则前一个斜杠，如果路径无法解析为资源，则抛出FileNotFoundException（与ServletContext的{@code  getRealPath}相比，后者返回null）。 
	 *  
	 * @param  servletContext Web应用程序的servlet上下文
	 * @param 路径Web应用程序内的路径
	 * @return 对应的真实路径
	 * @throws  FileNotFoundException如果该路径无法解析为资源
	 * @see  javax .servlet.ServletContext＃getRealPath
	 */
	public static String getRealPath(ServletContext servletContext, String path) throws FileNotFoundException {
		Assert.notNull(servletContext, "ServletContext must not be null");
		// Interpret location as relative to the web application root directory.
		if (!path.startsWith("/")) {
			path = "/" + path;
		}
		String realPath = servletContext.getRealPath(path);
		if (realPath == null) {
			throw new FileNotFoundException(
					"ServletContext resource [" + path + "] cannot be resolved to absolute file path - " +
					"web application archive not expanded?");
		}
		return realPath;
	}

	/**
	 * Determine the session id of the given request, if any.
	 * @param request current HTTP request
	 * @return the session id, or {@code null} if none
	 */
	/**
	 * 确定给定请求的会话ID（如果有）。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @return 会话ID，如果没有，则返回{@code  null}
	 */
	@Nullable
	public static String getSessionId(HttpServletRequest request) {
		Assert.notNull(request, "Request must not be null");
		HttpSession session = request.getSession(false);
		return (session != null ? session.getId() : null);
	}

	/**
	 * Check the given request for a session attribute of the given name.
	 * Returns null if there is no session or if the session has no such attribute.
	 * Does not create a new session if none has existed before!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @return the value of the session attribute, or {@code null} if not found
	 */
	/**
	 * 在给定的请求中检查给定名称的会话属性。 
	 * 如果没有会话或会话没有此类属性，则返回null。 
	 * 如果以前不存在，则不创建新会话！ 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param 命名会话属性的名称
	 * @return 会话属性的值，如果找不到，则为{@code  null}
	 */
	@Nullable
	public static Object getSessionAttribute(HttpServletRequest request, String name) {
		Assert.notNull(request, "Request must not be null");
		HttpSession session = request.getSession(false);
		return (session != null ? session.getAttribute(name) : null);
	}

	/**
	 * Check the given request for a session attribute of the given name.
	 * Throws an exception if there is no session or if the session has no such
	 * attribute. Does not create a new session if none has existed before!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @return the value of the session attribute, or {@code null} if not found
	 * @throws IllegalStateException if the session attribute could not be found
	 */
	/**
	 * 在给定的请求中检查给定名称的会话属性。 
	 * 如果没有会话或会话没有此类属性，则引发异常。 
	 * 如果以前不存在，则不创建新会话！ 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param 命名会话属性的名称
	 * @return 会话属性的值，如果找不到，则为{@code  null} 
	 * @throws 如果会话属性为IllegalStateException找不到
	 */
	public static Object getRequiredSessionAttribute(HttpServletRequest request, String name)
			throws IllegalStateException {

		Object attr = getSessionAttribute(request, name);
		if (attr == null) {
			throw new IllegalStateException("No session attribute '" + name + "' found");
		}
		return attr;
	}

	/**
	 * Set the session attribute with the given name to the given value.
	 * Removes the session attribute if value is null, if a session existed at all.
	 * Does not create a new session if not necessary!
	 * @param request current HTTP request
	 * @param name the name of the session attribute
	 * @param value the value of the session attribute
	 */
	/**
	 * 将具有给定名称的会话属性设置为给定值。 
	 * 如果值根本为空，则删除会话属性。 
	 * 如有必要，请勿创建新会话！ 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param 名称会话属性的名称
	 * @param 值会话属性的值
	 */
	public static void setSessionAttribute(HttpServletRequest request, String name, @Nullable Object value) {
		Assert.notNull(request, "Request must not be null");
		if (value != null) {
			request.getSession().setAttribute(name, value);
		}
		else {
			HttpSession session = request.getSession(false);
			if (session != null) {
				session.removeAttribute(name);
			}
		}
	}

	/**
	 * Return the best available mutex for the given session:
	 * that is, an object to synchronize on for the given session.
	 * <p>Returns the session mutex attribute if available; usually,
	 * this means that the HttpSessionMutexListener needs to be defined
	 * in {@code web.xml}. Falls back to the HttpSession itself
	 * if no mutex attribute found.
	 * <p>The session mutex is guaranteed to be the same object during
	 * the entire lifetime of the session, available under the key defined
	 * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a
	 * safe reference to synchronize on for locking on the current session.
	 * <p>In many cases, the HttpSession reference itself is a safe mutex
	 * as well, since it will always be the same object reference for the
	 * same active logical session. However, this is not guaranteed across
	 * different servlet containers; the only 100% safe way is a session mutex.
	 * @param session the HttpSession to find a mutex for
	 * @return the mutex object (never {@code null})
	 * @see #SESSION_MUTEX_ATTRIBUTE
	 * @see HttpSessionMutexListener
	 */
	/**
	 * 返回给定会话的最佳可用互斥量：即，要在给定会话上进行同步的对象。 
	 *  <p>返回会话互斥属性（如果有）； 
	 * 通常，这意味着需要在{@code  web.xml}中定义HttpSessionMutexListener。 
	 * 如果未找到互斥锁属性，则退回到HttpSession本身。 
	 *  <p>在会话的整个生命周期中，保证会话互斥体是同一对象，可以在{@code  SESSION_MUTEX_ATTRIBUTE}常量定义的键下使用。 
	 * 它用作同步以锁定当前会话的安全参考。 
	 *  <p>在许多情况下，HttpSession引用本身也是安全的互斥体，因为对于同一活动的逻辑会话，它始终是相同的对象引用。 
	 * 但是，不能保证在不同的servlet容器之间都能做到这一点。 
	 * 唯一的100％安全方法是会话互斥。 
	 *  
	 * @param 对HttpSession进行会话，以找到
	 * @return 互斥对象的互斥对象（从不{<@@code> null}）
	 * @see  #SESSION_MUTEX_ATTRIBUTE 
	 * @see  HttpSessionMutexListener
	 */
	public static Object getSessionMutex(HttpSession session) {
		Assert.notNull(session, "Session must not be null");
		Object mutex = session.getAttribute(SESSION_MUTEX_ATTRIBUTE);
		if (mutex == null) {
			mutex = session;
		}
		return mutex;
	}


	/**
	 * Return an appropriate request object of the specified type, if available,
	 * unwrapping the given request as far as necessary.
	 * @param request the servlet request to introspect
	 * @param requiredType the desired type of request object
	 * @return the matching request object, or {@code null} if none
	 * of that type is available
	 */
	/**
	 * 返回指定类型的适当请求对象（如果有），并在必要时展开给定请求。 
	 *  
	 * @param 请求servlet请求进行内省
	 * @param  requiredType所需类型的请求对象
	 * @return 匹配的请求对象，或者{@code  null}（如果没有可用的类型）
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <T> T getNativeRequest(ServletRequest request, @Nullable Class<T> requiredType) {
		if (requiredType != null) {
			if (requiredType.isInstance(request)) {
				return (T) request;
			}
			else if (request instanceof ServletRequestWrapper) {
				return getNativeRequest(((ServletRequestWrapper) request).getRequest(), requiredType);
			}
		}
		return null;
	}

	/**
	 * Return an appropriate response object of the specified type, if available,
	 * unwrapping the given response as far as necessary.
	 * @param response the servlet response to introspect
	 * @param requiredType the desired type of response object
	 * @return the matching response object, or {@code null} if none
	 * of that type is available
	 */
	/**
	 * 返回指定类型的适当响应对象（如果有），并在必要时展开给定响应。 
	 *  
	 * @param 响应servlet对自省的响应
	 * @param  requiredType所需类型的响应对象
	 * @return 匹配的响应对象； 
	 * 如果没有可用的类型，则为{@code  null}
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <T> T getNativeResponse(ServletResponse response, @Nullable Class<T> requiredType) {
		if (requiredType != null) {
			if (requiredType.isInstance(response)) {
				return (T) response;
			}
			else if (response instanceof ServletResponseWrapper) {
				return getNativeResponse(((ServletResponseWrapper) response).getResponse(), requiredType);
			}
		}
		return null;
	}

	/**
	 * Determine whether the given request is an include request,
	 * that is, not a top-level HTTP request coming in from the outside.
	 * <p>Checks the presence of the "javax.servlet.include.request_uri"
	 * request attribute. Could check any request attribute that is only
	 * present in an include request.
	 * @param request current servlet request
	 * @return whether the given request is an include request
	 */
	/**
	 * 确定给定的请求是否是包含请求，即不是从外部传入的顶级HTTP请求。 
	 *  <p>检查"javax.servlet.include.request_uri"请求属性的存在。 
	 * 可以检查仅包含请求中包含的任何请求属性。 
	 *  
	 * @param 请求当前servlet请求
	 * @return 给定请求是否为包含请求
	 */
	public static boolean isIncludeRequest(ServletRequest request) {
		return (request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE) != null);
	}

	/**
	 * Expose the Servlet spec's error attributes as {@link javax.servlet.http.HttpServletRequest}
	 * attributes under the keys defined in the Servlet 2.3 specification, for error pages that
	 * are rendered directly rather than through the Servlet container's error page resolution:
	 * {@code javax.servlet.error.status_code},
	 * {@code javax.servlet.error.exception_type},
	 * {@code javax.servlet.error.message},
	 * {@code javax.servlet.error.exception},
	 * {@code javax.servlet.error.request_uri},
	 * {@code javax.servlet.error.servlet_name}.
	 * <p>Does not override values if already present, to respect attribute values
	 * that have been exposed explicitly before.
	 * <p>Exposes status code 200 by default. Set the "javax.servlet.error.status_code"
	 * attribute explicitly (before or after) in order to expose a different status code.
	 * @param request current servlet request
	 * @param ex the exception encountered
	 * @param servletName the name of the offending servlet
	 */
	/**
	 * 在Servlet 2.3规范中定义的键下，将Servlet规范的错误属性公开为{@link  javax.servlet.http.HttpServletRequest}属性，用于直接呈现而不是通过Servlet容器的错误页面分辨率呈现的错误页面：{@code  javax.servlet.error.status_code}，{<@code> javax.servlet.error.exception_type}，{<@code> javax.servlet.error.message}，{<@code> javax.servlet.error .exception}，{<@code> javax.servlet.error.request_uri}，{<@code> javax.servlet.error.servlet_name}。 
	 *  <p>如果已经存在，则不覆盖值，以尊重之前已明确公开的属性值。 
	 *  <p>默认情况下公开状态码200。 
	 * 显式地（在此之前或之后）设置"javax.servlet.error.status_code"属性，以便公开其他状态代码。 
	 *  
	 * @param 请求当前的servlet请求
	 * @param 遇到异常
	 * @param  servletName有问题的servlet的名称
	 */
	public static void exposeErrorRequestAttributes(HttpServletRequest request, Throwable ex,
			@Nullable String servletName) {

		exposeRequestAttributeIfNotPresent(request, ERROR_STATUS_CODE_ATTRIBUTE, HttpServletResponse.SC_OK);
		exposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_TYPE_ATTRIBUTE, ex.getClass());
		exposeRequestAttributeIfNotPresent(request, ERROR_MESSAGE_ATTRIBUTE, ex.getMessage());
		exposeRequestAttributeIfNotPresent(request, ERROR_EXCEPTION_ATTRIBUTE, ex);
		exposeRequestAttributeIfNotPresent(request, ERROR_REQUEST_URI_ATTRIBUTE, request.getRequestURI());
		if (servletName != null) {
			exposeRequestAttributeIfNotPresent(request, ERROR_SERVLET_NAME_ATTRIBUTE, servletName);
		}
	}

	/**
	 * Expose the specified request attribute if not already present.
	 * @param request current servlet request
	 * @param name the name of the attribute
	 * @param value the suggested value of the attribute
	 */
	/**
	 * 公开指定的请求属性（如果尚不存在）。 
	 *  
	 * @param 请求当前的servlet请求
	 * @param 名称属性的名称
	 * @param 值属性的建议值
	 */
	private static void exposeRequestAttributeIfNotPresent(ServletRequest request, String name, Object value) {
		if (request.getAttribute(name) == null) {
			request.setAttribute(name, value);
		}
	}

	/**
	 * Clear the Servlet spec's error attributes as {@link javax.servlet.http.HttpServletRequest}
	 * attributes under the keys defined in the Servlet 2.3 specification:
	 * {@code javax.servlet.error.status_code},
	 * {@code javax.servlet.error.exception_type},
	 * {@code javax.servlet.error.message},
	 * {@code javax.servlet.error.exception},
	 * {@code javax.servlet.error.request_uri},
	 * {@code javax.servlet.error.servlet_name}.
	 * @param request current servlet request
	 */
	/**
	 * 在Servlet 2.3规范中定义的键下，将Servlet规范的错误属性清除为{@link  javax.servlet.http.HttpServletRequest}属性：{@code  javax.servlet.error.status_code}，{<@code> javax.servlet.error.exception_type}，{<@code> javax.servlet.error.message}，{<@code> javax.servlet.error.exception}，{<@code> javax.servlet.error.request_uri} ，{<@code> javax.servlet.error.servlet_name}。 
	 *  
	 * @param 请求当前的servlet请求
	 */
	public static void clearErrorRequestAttributes(HttpServletRequest request) {
		request.removeAttribute(ERROR_STATUS_CODE_ATTRIBUTE);
		request.removeAttribute(ERROR_EXCEPTION_TYPE_ATTRIBUTE);
		request.removeAttribute(ERROR_MESSAGE_ATTRIBUTE);
		request.removeAttribute(ERROR_EXCEPTION_ATTRIBUTE);
		request.removeAttribute(ERROR_REQUEST_URI_ATTRIBUTE);
		request.removeAttribute(ERROR_SERVLET_NAME_ATTRIBUTE);
	}

	/**
	 * Retrieve the first cookie with the given name. Note that multiple
	 * cookies can have the same name but different paths or domains.
	 * @param request current servlet request
	 * @param name cookie name
	 * @return the first cookie with the given name, or {@code null} if none is found
	 */
	/**
	 * 检索具有给定名称的第一个cookie。 
	 * 请注意，多个Cookie可以具有相同的名称，但可以具有不同的路径或域。 
	 *  
	 * @param 请求当前的servlet请求
	 * @param 名称cookie名称
	 * @return 具有给定名称的第一个cookie； 
	 * 如果找不到，则为{@code  null}
	 */
	@Nullable
	public static Cookie getCookie(HttpServletRequest request, String name) {
		Assert.notNull(request, "Request must not be null");
		Cookie[] cookies = request.getCookies();
		if (cookies != null) {
			for (Cookie cookie : cookies) {
				if (name.equals(cookie.getName())) {
					return cookie;
				}
			}
		}
		return null;
	}

	/**
	 * Check if a specific input type="submit" parameter was sent in the request,
	 * either via a button (directly with name) or via an image (name + ".x" or
	 * name + ".y").
	 * @param request current HTTP request
	 * @param name name of the parameter
	 * @return if the parameter was sent
	 * @see #SUBMIT_IMAGE_SUFFIXES
	 */
	/**
	 * 检查请求中是否通过按钮（直接带有名称）或图像（名称+".x"或名称+".y"）发送了特定的输入type ="submit"参数。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param 名称参数的名称
	 * @return 如果已发送参数
	 * @see  #SUBMIT_IMAGE_SUFFIXES
	 */
	public static boolean hasSubmitParameter(ServletRequest request, String name) {
		Assert.notNull(request, "Request must not be null");
		if (request.getParameter(name) != null) {
			return true;
		}
		for (String suffix : SUBMIT_IMAGE_SUFFIXES) {
			if (request.getParameter(name + suffix) != null) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Obtain a named parameter from the given request parameters.
	 * <p>See {@link #findParameterValue(java.util.Map, String)}
	 * for a description of the lookup algorithm.
	 * @param request current HTTP request
	 * @param name the <i>logical</i> name of the request parameter
	 * @return the value of the parameter, or {@code null}
	 * if the parameter does not exist in given request
	 */
	/**
	 * 从给定的请求参数中获取命名参数。 
	 *  <p>有关查找算法的说明，请参见{@link  #findParameterValue（java.util.Map，String）}。 
	 *  
	 * @param 请求当前的HTTP请求
	 * @param 命名请求参数的<i>逻辑</ i>名称
	 * @return 参数的值，如果参数不存在，则为{@code  null}存在于给定的请求中
	 */
	@Nullable
	public static String findParameterValue(ServletRequest request, String name) {
		return findParameterValue(request.getParameterMap(), name);
	}

	/**
	 * Obtain a named parameter from the given request parameters.
	 * <p>This method will try to obtain a parameter value using the
	 * following algorithm:
	 * <ol>
	 * <li>Try to get the parameter value using just the given <i>logical</i> name.
	 * This handles parameters of the form <tt>logicalName = value</tt>. For normal
	 * parameters, e.g. submitted using a hidden HTML form field, this will return
	 * the requested value.</li>
	 * <li>Try to obtain the parameter value from the parameter name, where the
	 * parameter name in the request is of the form <tt>logicalName_value = xyz</tt>
	 * with "_" being the configured delimiter. This deals with parameter values
	 * submitted using an HTML form submit button.</li>
	 * <li>If the value obtained in the previous step has a ".x" or ".y" suffix,
	 * remove that. This handles cases where the value was submitted using an
	 * HTML form image button. In this case the parameter in the request would
	 * actually be of the form <tt>logicalName_value.x = 123</tt>. </li>
	 * </ol>
	 * @param parameters the available parameter map
	 * @param name the <i>logical</i> name of the request parameter
	 * @return the value of the parameter, or {@code null}
	 * if the parameter does not exist in given request
	 */
	/**
	 * 从给定的请求参数中获取命名参数。 
	 *  <p>此方法将尝试使用以下算法获取参数值：<ol> <li>仅使用给定的<i>逻辑</ i>名称尝试获取参数值。 
	 * 这将处理格式为<tt> logicalName = value </ tt>的参数。 
	 * 对于正常参数，例如使用隐藏的HTML表单字段提交，这将返回请求的值。 
	 * </ li> <li>尝试从参数名称中获取参数值，其中请求中的参数名称的格式为<tt> logicalName_value = xyz </ tt>，其中"_"是配置的分隔符。 
	 * 这处理使用HTML表单提交按钮提交的参数值。 
	 * </ li> <li>如果在上一步中获得的值后缀为".x"或".y"，则将其删除。 
	 * 这可以处理使用HTML表单图像按钮提交值的情况。 
	 * 在这种情况下，请求中的参数实际上将采用<tt> logicalName_value.x = 123 </ tt>的形式。 
	 *  </ li> </ ol> 
	 * @param 参数可用参数映射
	 * @param 名称请求参数的<i>逻辑</ i>名称
	 * @return 参数的值，或{<@code> null}如果给定请求中不存在参数
	 */
	@Nullable
	public static String findParameterValue(Map<String, ?> parameters, String name) {
		// First try to get it as a normal name=value parameter
		Object value = parameters.get(name);
		if (value instanceof String[]) {
			String[] values = (String[]) value;
			return (values.length > 0 ? values[0] : null);
		}
		else if (value != null) {
			return value.toString();
		}
		// If no value yet, try to get it as a name_value=xyz parameter
		String prefix = name + "_";
		for (String paramName : parameters.keySet()) {
			if (paramName.startsWith(prefix)) {
				// Support images buttons, which would submit parameters as name_value.x=123
				for (String suffix : SUBMIT_IMAGE_SUFFIXES) {
					if (paramName.endsWith(suffix)) {
						return paramName.substring(prefix.length(), paramName.length() - suffix.length());
					}
				}
				return paramName.substring(prefix.length());
			}
		}
		// We couldn't find the parameter value...
		return null;
	}

	/**
	 * Return a map containing all parameters with the given prefix.
	 * Maps single values to String and multiple values to String array.
	 * <p>For example, with a prefix of "spring_", "spring_param1" and
	 * "spring_param2" result in a Map with "param1" and "param2" as keys.
	 * @param request the HTTP request in which to look for parameters
	 * @param prefix the beginning of parameter names
	 * (if this is null or the empty string, all parameters will match)
	 * @return map containing request parameters <b>without the prefix</b>,
	 * containing either a String or a String array as values
	 * @see javax.servlet.ServletRequest#getParameterNames
	 * @see javax.servlet.ServletRequest#getParameterValues
	 * @see javax.servlet.ServletRequest#getParameterMap
	 */
	/**
	 * 返回包含所有具有给定前缀的参数的映射。 
	 * 将单个值映射到String，将多个值映射到String数组。 
	 *  <p>例如，使用前缀"spring _"，"spring_param1"和"spring_param2"会导致以"param1"和"param2"作为键的Map。 
	 *  
	 * @param 请求在其中查找参数的HTTP请求
	 * @param 在参数名称的开头添加前缀（如果为null或空字符串，则所有参数都将匹配）
	 * @return 包含请求参数的映射<b>不带前缀</ b>，包含一个String或一个String数组作为值
	 * @see  javax.servlet.ServletRequest＃getParameterNames 
	 * @see  javax.servlet.ServletRequest＃getParameterValues 
	 * @see  javax.servlet.ServletRequest＃ getParameterMap
	 */
	public static Map<String, Object> getParametersStartingWith(ServletRequest request, @Nullable String prefix) {
		Assert.notNull(request, "Request must not be null");
		Enumeration<String> paramNames = request.getParameterNames();
		Map<String, Object> params = new TreeMap<>();
		if (prefix == null) {
			prefix = "";
		}
		while (paramNames != null && paramNames.hasMoreElements()) {
			String paramName = paramNames.nextElement();
			if (prefix.isEmpty() || paramName.startsWith(prefix)) {
				String unprefixed = paramName.substring(prefix.length());
				String[] values = request.getParameterValues(paramName);
				if (values == null || values.length == 0) {
					// Do nothing, no values found at all.
				}
				else if (values.length > 1) {
					params.put(unprefixed, values);
				}
				else {
					params.put(unprefixed, values[0]);
				}
			}
		}
		return params;
	}

	/**
	 * Parse the given string with matrix variables. An example string would look
	 * like this {@code "q1=a;q1=b;q2=a,b,c"}. The resulting map would contain
	 * keys {@code "q1"} and {@code "q2"} with values {@code ["a","b"]} and
	 * {@code ["a","b","c"]} respectively.
	 * @param matrixVariables the unparsed matrix variables string
	 * @return a map with matrix variable names and values (never {@code null})
	 * @since 3.2
	 */
	/**
	 * 用矩阵变量解析给定的字符串。 
	 * 示例字符串如下所示：{@code "q1 = a; q1 = b; q2 = a，b，c"}。 
	 * 结果映射将包含键{@code "q1"}和{@code "q2"}，其值分别为{@code  ["a"，"b"]}和{@code  ["a"，"b"，"c"]}。 
	 *  
	 * @param  matrixVariables未解析的矩阵变量字符串
	 * @return 具有矩阵变量名称和值的映射（从{<@@code> null}开始）@3.2
	 */
	public static MultiValueMap<String, String> parseMatrixVariables(String matrixVariables) {
		MultiValueMap<String, String> result = new LinkedMultiValueMap<>();
		if (!StringUtils.hasText(matrixVariables)) {
			return result;
		}
		StringTokenizer pairs = new StringTokenizer(matrixVariables, ";");
		while (pairs.hasMoreTokens()) {
			String pair = pairs.nextToken();
			int index = pair.indexOf('=');
			if (index != -1) {
				String name = pair.substring(0, index);
				String rawValue = pair.substring(index + 1);
				for (String value : StringUtils.commaDelimitedListToStringArray(rawValue)) {
					result.add(name, value);
				}
			}
			else {
				result.add(pair, "");
			}
		}
		return result;
	}

	/**
	 * Check the given request origin against a list of allowed origins.
	 * A list containing "*" means that all origins are allowed.
	 * An empty list means only same origin is allowed.
	 *
	 * <p><strong>Note:</strong> as of 5.1 this method ignores
	 * {@code "Forwarded"} and {@code "X-Forwarded-*"} headers that specify the
	 * client-originated address. Consider using the {@code ForwardedHeaderFilter}
	 * to extract and use, or to discard such headers.
	 *
	 * @return {@code true} if the request origin is valid, {@code false} otherwise
	 * @since 4.1.5
	 * @see <a href="https://tools.ietf.org/html/rfc6454">RFC 6454: The Web Origin Concept</a>
	 */
	/**
	 * 根据允许的来源列表检查给定的请求来源。 
	 * 包含""的列表表示允许所有来源。 
	 * 空列表意味着仅允许相同的原点。 
	 *  <p> <strong>注意</ strong>：从5.1版本开始，此方法将忽略{@code "Forwarded"}和{@code "X-Forwarded-"}标头，这些标头指定了客户端起源的地址。 
	 * 考虑使用{@code  ForwardedHeaderFilter}提取和使用或丢弃此类标头。 
	 *  
	 * @return  {@code  true}，如果请求来源有效，则{@code  false}，否则，@since 4.1.5起
	 * @see  <a href ="https://tools.ietf.org/ html / rfc6454"> RFC 6454：网络起源概念</a>
	 */
	public static boolean isValidOrigin(HttpRequest request, Collection<String> allowedOrigins) {
		Assert.notNull(request, "Request must not be null");
		Assert.notNull(allowedOrigins, "Allowed origins must not be null");

		String origin = request.getHeaders().getOrigin();
		if (origin == null || allowedOrigins.contains("*")) {
			return true;
		}
		else if (CollectionUtils.isEmpty(allowedOrigins)) {
			return isSameOrigin(request);
		}
		else {
			return allowedOrigins.contains(origin);
		}
	}

	/**
	 * Check if the request is a same-origin one, based on {@code Origin}, {@code Host},
	 * {@code Forwarded}, {@code X-Forwarded-Proto}, {@code X-Forwarded-Host} and
	 * {@code X-Forwarded-Port} headers.
	 *
	 * <p><strong>Note:</strong> as of 5.1 this method ignores
	 * {@code "Forwarded"} and {@code "X-Forwarded-*"} headers that specify the
	 * client-originated address. Consider using the {@code ForwardedHeaderFilter}
	 * to extract and use, or to discard such headers.

	 * @return {@code true} if the request is a same-origin one, {@code false} in case
	 * of cross-origin request
	 * @since 4.2
	 */
	/**
	 * 根据{@code  Origin}，{<@code> Host}，{<@code> Forwarded}，{<@code> X-Forwarded-Proto}，{ @code  X-Forwarded-Host}和{@code  X-Forwarded-Port}标头。 
	 *  <p> <strong>注意</ strong>：从5.1版本开始，此方法将忽略{@code "Forwarded"}和{@code "X-Forwarded-"}标头，这些标头指定了客户端起源的地址。 
	 * 考虑使用{@code  ForwardedHeaderFilter}提取和使用或丢弃此类标头。 
	 *  
	 * @return  {@code  true}（如果请求是相同来源的请求，则为{@code  false}，如果是跨源请求，则从4.2开始）
	 */
	public static boolean isSameOrigin(HttpRequest request) {
		HttpHeaders headers = request.getHeaders();
		String origin = headers.getOrigin();
		if (origin == null) {
			return true;
		}

		String scheme;
		String host;
		int port;
		if (request instanceof ServletServerHttpRequest) {
			// Build more efficiently if we can: we only need scheme, host, port for origin comparison
			HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();
			scheme = servletRequest.getScheme();
			host = servletRequest.getServerName();
			port = servletRequest.getServerPort();
		}
		else {
			URI uri = request.getURI();
			scheme = uri.getScheme();
			host = uri.getHost();
			port = uri.getPort();
		}

		UriComponents originUrl = UriComponentsBuilder.fromOriginHeader(origin).build();
		return (ObjectUtils.nullSafeEquals(scheme, originUrl.getScheme()) &&
				ObjectUtils.nullSafeEquals(host, originUrl.getHost()) &&
				getPort(scheme, port) == getPort(originUrl.getScheme(), originUrl.getPort()));
	}

	private static int getPort(@Nullable String scheme, int port) {
		if (port == -1) {
			if ("http".equals(scheme) || "ws".equals(scheme)) {
				port = 80;
			}
			else if ("https".equals(scheme) || "wss".equals(scheme)) {
				port = 443;
			}
		}
		return port;
	}

}
