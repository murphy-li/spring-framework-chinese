/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.util.pattern;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import org.springframework.http.server.PathContainer;
import org.springframework.http.server.PathContainer.Element;
import org.springframework.http.server.PathContainer.Separator;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;

/**
 * Representation of a parsed path pattern. Includes a chain of path elements
 * for fast matching and accumulates computed state for quick comparison of
 * patterns.
 *
 * <p>{@code PathPattern} matches URL paths using the following rules:<br>
 * <ul>
 * <li>{@code ?} matches one character</li>
 * <li>{@code *} matches zero or more characters within a path segment</li>
 * <li>{@code **} matches zero or more <em>path segments</em> until the end of the path</li>
 * <li><code>{spring}</code> matches a <em>path segment</em> and captures it as a variable named "spring"</li>
 * <li><code>{spring:[a-z]+}</code> matches the regexp {@code [a-z]+} as a path variable named "spring"</li>
 * <li><code>{*spring}</code> matches zero or more <em>path segments</em> until the end of the path
 * and captures it as a variable named "spring"</li>
 * </ul>
 *
 * <h3>Examples</h3>
 * <ul>
 * <li>{@code /pages/t?st.html} &mdash; matches {@code /pages/test.html} as well as
 * {@code /pages/tXst.html} but not {@code /pages/toast.html}</li>
 * <li>{@code /resources/*.png} &mdash; matches all {@code .png} files in the
 * {@code resources} directory</li>
 * <li><code>/resources/&#42;&#42;</code> &mdash; matches all files
 * underneath the {@code /resources/} path, including {@code /resources/image.png}
 * and {@code /resources/css/spring.css}</li>
 * <li><code>/resources/{&#42;path}</code> &mdash; matches all files
 * underneath the {@code /resources/} path and captures their relative path in
 * a variable named "path"; {@code /resources/image.png} will match with
 * "spring" &rarr; "/image.png", and {@code /resources/css/spring.css} will match
 * with "spring" &rarr; "/css/spring.css"</li>
 * <li><code>/resources/{filename:\\w+}.dat</code> will match {@code /resources/spring.dat}
 * and assign the value {@code "spring"} to the {@code filename} variable</li>
 * </ul>
 *
 * @author Andy Clement
 * @author Rossen Stoyanchev
 * @since 5.0
 * @see PathContainer
 */
/**
 * 解析路径模式的表示。 
 * 包括用于快速匹配的路径元素链，并累积计算状态以快速比较模式。 
 *  <p> {<@code> PathPattern}使用以下规则匹配URL路径：<br> <ul> <li> {<@code>？}匹配一个字符</ li> <li> {<@code>}匹配路径段中的零个或多个字符</ li> <li> {<@code>}匹配零个或多个<em>路径段</ em>直到路径结束</ li> <li> <code > {spring} </ code>匹配<em>路径段</ em>，并将其捕获为名为"spring"的变量</ li> <li> <code> {spring：[az] +} </ code >匹配正则表达式{@code  [az] +}，因为路径变量名为"spring"</ li> <li> <code> {spring} </ code>匹配零个或多个<em>路径段</ em>直到路径的结尾并将其捕获为名为"spring"的变量</ li> </ ul> <h3>示例</ h3> <ul> <li> {<@code> / pages / t？ st.html} —匹配{@code  /pages/test.html}和{@code  /pages/tXst.html}，但不匹配{@code  /pages/toast.html}</li > <li> {<@code> / resources .png}-匹配{@code  resources}目录中的所有{@code  .png}文件</ li> <li> <code> / resources / * * </ code>-匹配下面的所有文件h {{@code> / resources /}路径，包括{@code  /resources/image.png}和{@code  /resources/css/spring.css} </ li> <li> <code > / resources / {* path} </ code> —匹配{@code  / resources /}路径下的所有文件，并在名为"path"的变量中捕获其相对路径； 
 *  {@code  /resources/image.png}将与"spring"→"/image.png"匹配，而{@code  /resources/css/spring.css}将与"spring"→"// css / spring.css"</ li> <li> <code> / resources / {文件名：\\ w +}。 
 * dat </ code>将与{@code  /resources/spring.dat}匹配并分配值{@code "spring"}到{@code  filename}变量</ li> </ ul> @author  Andy Clement @author  Rossen Stoyanchev @since 5.0 
 * @see  PathContainer
 */
public class PathPattern implements Comparable<PathPattern> {

	private static final PathContainer EMPTY_PATH = PathContainer.parsePath("");

	/**
	 * Comparator that sorts patterns by specificity as follows:
	 * <ol>
	 * <li>Null instances are last.
	 * <li>Catch-all patterns are last.
	 * <li>If both patterns are catch-all, consider the length (longer wins).
	 * <li>Compare wildcard and captured variable count (lower wins).
	 * <li>Consider length (longer wins)
	 * </ol>
	 */
	/**
	 * 比较器按特异性对模式进行排序，如下所示：<ol> <li>空实例是最后一个。 
	 *  <li>包罗万象的模式是最后的。 
	 *  <li>如果两种模式都是通吃的，请考虑长度（较长的获胜者）。 
	 *  <li>比较通配符和捕获的变量计数（较低的获胜率）。 
	 *  <li>考虑长度（越长越好）</ ol>
	 */
	public static final Comparator<PathPattern> SPECIFICITY_COMPARATOR =
			Comparator.nullsLast(
					Comparator.<PathPattern>
							comparingInt(p -> p.isCatchAll() ? 1 : 0)
							.thenComparingInt(p -> p.isCatchAll() ? scoreByNormalizedLength(p) : 0)
							.thenComparingInt(PathPattern::getScore)
							.thenComparingInt(PathPattern::scoreByNormalizedLength)
			);


	/** The text of the parsed pattern. */
	/**
	 * 解析模式的文本。 
	 * 
	 */
	private final String patternString;

	/** The parser used to construct this pattern. */
	/**
	 * 解析器用于构造此模式。 
	 * 
	 */
	private final PathPatternParser parser;

	/** The options to use to parse a pattern. */
	/**
	 * 用于解析模式的选项。 
	 * 
	 */
	private final PathContainer.Options pathOptions;

	/** If this pattern has no trailing slash, allow candidates to include one and still match successfully. */
	/**
	 * 如果此模式没有尾部斜杠，则允许候选者包括一个并且仍然成功匹配。 
	 * 
	 */
	private final boolean matchOptionalTrailingSeparator;

	/** Will this match candidates in a case sensitive way? (case sensitivity  at parse time). */
	/**
	 * 这会以区分大小写的方式匹配候选人吗？ （在分析时区分大小写）。 
	 * 
	 */
	private final boolean caseSensitive;

	/** First path element in the parsed chain of path elements for this pattern. */
	/**
	 * 此模式的解析路径元素链中的第一个路径元素。 
	 * 
	 */
	@Nullable
	private final PathElement head;

	/** How many variables are captured in this pattern. */
	/**
	 * 在此模式下捕获了多少个变量。 
	 * 
	 */
	private int capturedVariableCount;

	/**
	 * The normalized length is trying to measure the 'active' part of the pattern. It is computed
	 * by assuming all captured variables have a normalized length of 1. Effectively this means changing
	 * your variable name lengths isn't going to change the length of the active part of the pattern.
	 * Useful when comparing two patterns.
	 */
	/**
	 * 标准化长度正在尝试测量模式的"活动"部分。 
	 * 它是通过假设所有捕获的变量的标准化长度为1来计算的。 
	 * 实际上，这意味着更改变量名的长度不会更改模式的活动部分的长度。 
	 * 比较两个模式时很有用。 
	 * 
	 */
	private int normalizedLength;

	/**
	 * Does the pattern end with '&lt;separator&gt;'.
	 */
	/**
	 * 模式是否以'<separator>'结尾。 
	 * 
	 */
	private boolean endsWithSeparatorWildcard = false;

	/**
	 * Score is used to quickly compare patterns. Different pattern components are given different
	 * weights. A 'lower score' is more specific. Current weights:
	 * <ul>
	 * <li>Captured variables are worth 1
	 * <li>Wildcard is worth 100
	 * </ul>
	 */
	/**
	 * 分数用于快速比较模式。 
	 * 不同的图案成分被赋予不同的权重。 
	 *  "较低的分数"更为具体。 
	 * 当前权重：<ul> <li>捕获的变量值1 <li>通配符值100 </ ul>
	 */
	private int score;

	/** Does the pattern end with {*...}. */
	/**
	 * 模式是否以{...}结尾。 
	 * 
	 */
	private boolean catchAll = false;


	PathPattern(String patternText, PathPatternParser parser, @Nullable PathElement head) {
		this.patternString = patternText;
		this.parser = parser;
		this.pathOptions = parser.getPathOptions();
		this.matchOptionalTrailingSeparator = parser.isMatchOptionalTrailingSeparator();
		this.caseSensitive = parser.isCaseSensitive();
		this.head = head;

		// Compute fields for fast comparison
		PathElement elem = head;
		while (elem != null) {
			this.capturedVariableCount += elem.getCaptureCount();
			this.normalizedLength += elem.getNormalizedLength();
			this.score += elem.getScore();
			if (elem instanceof CaptureTheRestPathElement || elem instanceof WildcardTheRestPathElement) {
				this.catchAll = true;
			}
			if (elem instanceof SeparatorPathElement && elem.next != null &&
					elem.next instanceof WildcardPathElement && elem.next.next == null) {
				this.endsWithSeparatorWildcard = true;
			}
			elem = elem.next;
		}
	}


	/**
	 * Return the original String that was parsed to create this PathPattern.
	 */
	/**
	 * 返回解析为创建此PathPattern的原始String。 
	 * 
	 */
	public String getPatternString() {
		return this.patternString;
	}

	/**
	 * Whether the pattern string contains pattern syntax that would require
	 * use of {@link #matches(PathContainer)}, or if it is a regular String that
	 * could be compared directly to others.
	 * @since 5.2
	 */
	/**
	 * 模式字符串是否包含需要使用{@link  #matches（PathContainer）}的模式语法，还是它是可以直接与其他字符串进行比较的常规字符串。 
	 *  @5.2起
	 */
	public boolean hasPatternSyntax() {
		return (this.score > 0 || this.patternString.indexOf('?') != -1);
	}

	/**
	 * Whether this pattern matches the given path.
	 * @param pathContainer the candidate path to attempt to match against
	 * @return {@code true} if the path matches this pattern
	 */
	/**
	 * 此模式是否与给定路径匹配。 
	 *  
	 * @param  pathContainer尝试与
	 * @return  {@code  true}匹配的候选路径
	 */
	public boolean matches(PathContainer pathContainer) {
		if (this.head == null) {
			return !hasLength(pathContainer) ||
				(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer));
		}
		else if (!hasLength(pathContainer)) {
			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {
				pathContainer = EMPTY_PATH; // Will allow CaptureTheRest to bind the variable to empty
			}
			else {
				return false;
			}
		}
		MatchingContext matchingContext = new MatchingContext(pathContainer, false);
		return this.head.matches(0, matchingContext);
	}

	/**
	 * Match this pattern to the given URI path and return extracted URI template
	 * variables as well as path parameters (matrix variables).
	 * @param pathContainer the candidate path to attempt to match against
	 * @return info object with the extracted variables, or {@code null} for no match
	 */
	/**
	 * 将此模式匹配到给定的URI路径，并返回提取的URI模板变量以及路径参数（矩阵变量）。 
	 *  
	 * @param  pathContainer尝试与提取的变量与
	 * @return  info对象匹配的候选路径，或者为{@code  null}表示不匹配
	 */
	@Nullable
	public PathMatchInfo matchAndExtract(PathContainer pathContainer) {
		if (this.head == null) {
			return (hasLength(pathContainer) &&
					!(this.matchOptionalTrailingSeparator && pathContainerIsJustSeparator(pathContainer)) ?
					null : PathMatchInfo.EMPTY);
		}
		else if (!hasLength(pathContainer)) {
			if (this.head instanceof WildcardTheRestPathElement || this.head instanceof CaptureTheRestPathElement) {
				pathContainer = EMPTY_PATH; // Will allow CaptureTheRest to bind the variable to empty
			}
			else {
				return null;
			}
		}
		MatchingContext matchingContext = new MatchingContext(pathContainer, true);
		return this.head.matches(0, matchingContext) ? matchingContext.getPathMatchResult() : null;
	}

	/**
	 * Match the beginning of the given path and return the remaining portion
	 * not covered by this pattern. This is useful for matching nested routes
	 * where the path is matched incrementally at each level.
	 * @param pathContainer the candidate path to attempt to match against
	 * @return info object with the match result or {@code null} for no match
	 */
	/**
	 * 匹配给定路径的开头，并返回该模式未覆盖的其余部分。 
	 * 这对于匹配嵌套路由很有用，在嵌套路由中，路径在每个级别上都递增匹配。 
	 *  
	 * @param  pathContainer尝试与具有匹配结果的
	 * @return  info对象进行匹配的候选路径，或者为{@code  null}进行不匹配的尝试
	 */
	@Nullable
	public PathRemainingMatchInfo matchStartOfPath(PathContainer pathContainer) {
		if (this.head == null) {
			return new PathRemainingMatchInfo(pathContainer);
		}
		else if (!hasLength(pathContainer)) {
			return null;
		}

		MatchingContext matchingContext = new MatchingContext(pathContainer, true);
		matchingContext.setMatchAllowExtraPath();
		boolean matches = this.head.matches(0, matchingContext);
		if (!matches) {
			return null;
		}
		else {
			PathRemainingMatchInfo info;
			if (matchingContext.remainingPathIndex == pathContainer.elements().size()) {
				info = new PathRemainingMatchInfo(EMPTY_PATH, matchingContext.getPathMatchResult());
			}
			else {
				info = new PathRemainingMatchInfo(pathContainer.subPath(matchingContext.remainingPathIndex),
						matchingContext.getPathMatchResult());
			}
			return info;
		}
	}

	/**
	 * Determine the pattern-mapped part for the given path.
	 * <p>For example: <ul>
	 * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} &rarr; ''</li>
	 * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit}' &rarr; '{@code cvs/commit}'</li>
	 * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code commit.html}'</li>
	 * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>
	 * </ul>
	 * <p><b>Notes:</b>
	 * <ul>
	 * <li>Assumes that {@link #matches} returns {@code true} for
	 * the same path but does <strong>not</strong> enforce this.
	 * <li>Duplicate occurrences of separators within the returned result are removed
	 * <li>Leading and trailing separators are removed from the returned result
	 * </ul>
	 * @param path a path that matches this pattern
	 * @return the subset of the path that is matched by pattern or "" if none
	 * of it is matched by pattern elements
	 */
	/**
	 * 确定给定路径的图案映射零件。 
	 *  <p>例如：<ul> <li>'{<@code> /docs/cvs/commit.html}'和'{@code  /docs/cvs/commit.html}→''</ li > <li>'{<@code> / docs}'和'{@code  / docs / cvs / commit}'→'{@code  cvs / commit}'</ li> <li>'{ @code  / docs / cvs .html}"和'{@code  /docs/cvs/commit.html}→'{@code  commit.html}'</ li> <li>'{@code  / docs}'和'{@code  / docs / cvs / commit}→'{@code  cvs / commit}'</ li> </ ul> <p> <b>注意：< / b> <ul> <li>假定{@link  #matches}对于同一路径返回{@code  true}，但<strong>不</ strong>强制执行此操作。 
	 *  <li>删除了返回结果中重复出现的分隔符<li>从返回结果中删除了领先的分隔符和尾随的分隔符</ ul> 
	 * @param  path与此模式匹配的路径
	 * @return 该路径的子集由模式或""匹配的模式（如果没有与模式元素匹配的模式）
	 */
	public PathContainer extractPathWithinPattern(PathContainer path) {
		List<Element> pathElements = path.elements();
		int pathElementsCount = pathElements.size();

		int startIndex = 0;
		// Find first path element that is not a separator or a literal (i.e. the first pattern based element)
		PathElement elem = this.head;
		while (elem != null) {
			if (elem.getWildcardCount() != 0 || elem.getCaptureCount() != 0) {
				break;
			}
			elem = elem.next;
			startIndex++;
		}
		if (elem == null) {
			// There is no pattern piece
			return PathContainer.parsePath("");
		}

		// Skip leading separators that would be in the result
		while (startIndex < pathElementsCount && (pathElements.get(startIndex) instanceof Separator)) {
			startIndex++;
		}

		int endIndex = pathElements.size();
		// Skip trailing separators that would be in the result
		while (endIndex > 0 && (pathElements.get(endIndex - 1) instanceof Separator)) {
			endIndex--;
		}

		boolean multipleAdjacentSeparators = false;
		for (int i = startIndex; i < (endIndex - 1); i++) {
			if ((pathElements.get(i) instanceof Separator) && (pathElements.get(i+1) instanceof Separator)) {
				multipleAdjacentSeparators=true;
				break;
			}
		}

		PathContainer resultPath = null;
		if (multipleAdjacentSeparators) {
			// Need to rebuild the path without the duplicate adjacent separators
			StringBuilder buf = new StringBuilder();
			int i = startIndex;
			while (i < endIndex) {
				Element e = pathElements.get(i++);
				buf.append(e.value());
				if (e instanceof Separator) {
					while (i < endIndex && (pathElements.get(i) instanceof Separator)) {
						i++;
					}
				}
			}
			resultPath = PathContainer.parsePath(buf.toString(), this.pathOptions);
		}
		else if (startIndex >= endIndex) {
			resultPath = PathContainer.parsePath("");
		}
		else {
			resultPath = path.subPath(startIndex, endIndex);
		}
		return resultPath;
	}

	/**
	 * Compare this pattern with a supplied pattern: return -1,0,+1 if this pattern
	 * is more specific, the same or less specific than the supplied pattern.
	 * The aim is to sort more specific patterns first.
	 */
	/**
	 * 将此模式与提供的模式进行比较：如果此模式比提供的模式更具体，相同或更少，则返回-1,0，+ 1。 
	 * 目的是首先对更具体的模式进行排序。 
	 * 
	 */
	@Override
	public int compareTo(@Nullable PathPattern otherPattern) {
		int result = SPECIFICITY_COMPARATOR.compare(this, otherPattern);
		return (result == 0 && otherPattern != null ?
				this.patternString.compareTo(otherPattern.patternString) : result);
	}

	/**
	 * Combine this pattern with another.
	 */
	/**
	 * 将此模式与另一个模式结合。 
	 * 
	 */
	public PathPattern combine(PathPattern pattern2string) {
		// If one of them is empty the result is the other. If both empty the result is ""
		if (!StringUtils.hasLength(this.patternString)) {
			if (!StringUtils.hasLength(pattern2string.patternString)) {
				return this.parser.parse("");
			}
			else {
				return pattern2string;
			}
		}
		else if (!StringUtils.hasLength(pattern2string.patternString)) {
			return this;
		}

		// /* + /hotel => /hotel
		// /*.* + /*.html => /*.html
		// However:
		// /usr + /user => /usr/user
		// /{foo} + /bar => /{foo}/bar
		if (!this.patternString.equals(pattern2string.patternString) && this.capturedVariableCount == 0 &&
				matches(PathContainer.parsePath(pattern2string.patternString))) {
			return pattern2string;
		}

		// /hotels/* + /booking => /hotels/booking
		// /hotels/* + booking => /hotels/booking
		if (this.endsWithSeparatorWildcard) {
			return this.parser.parse(concat(
					this.patternString.substring(0, this.patternString.length() - 2),
					pattern2string.patternString));
		}

		// /hotels + /booking => /hotels/booking
		// /hotels + booking => /hotels/booking
		int starDotPos1 = this.patternString.indexOf("*.");  // Are there any file prefix/suffix things to consider?
		if (this.capturedVariableCount != 0 || starDotPos1 == -1 || getSeparator() == '.') {
			return this.parser.parse(concat(this.patternString, pattern2string.patternString));
		}

		// /*.html + /hotel => /hotel.html
		// /*.html + /hotel.* => /hotel.html
		String firstExtension = this.patternString.substring(starDotPos1 + 1);  // looking for the first extension
		String p2string = pattern2string.patternString;
		int dotPos2 = p2string.indexOf('.');
		String file2 = (dotPos2 == -1 ? p2string : p2string.substring(0, dotPos2));
		String secondExtension = (dotPos2 == -1 ? "" : p2string.substring(dotPos2));
		boolean firstExtensionWild = (firstExtension.equals(".*") || firstExtension.isEmpty());
		boolean secondExtensionWild = (secondExtension.equals(".*") || secondExtension.isEmpty());
		if (!firstExtensionWild && !secondExtensionWild) {
			throw new IllegalArgumentException(
					"Cannot combine patterns: " + this.patternString + " and " + pattern2string);
		}
		return this.parser.parse(file2 + (firstExtensionWild ? secondExtension : firstExtension));
	}

	@Override
	public boolean equals(@Nullable Object other) {
		if (!(other instanceof PathPattern)) {
			return false;
		}
		PathPattern otherPattern = (PathPattern) other;
		return (this.patternString.equals(otherPattern.getPatternString()) &&
				getSeparator() == otherPattern.getSeparator() &&
				this.caseSensitive == otherPattern.caseSensitive);
	}

	@Override
	public int hashCode() {
		return (this.patternString.hashCode() + getSeparator()) * 17 + (this.caseSensitive ? 1 : 0);
	}

	@Override
	public String toString() {
		return this.patternString;
	}


	int getScore() {
		return this.score;
	}

	boolean isCatchAll() {
		return this.catchAll;
	}

	/**
	 * The normalized length is trying to measure the 'active' part of the pattern. It is computed
	 * by assuming all capture variables have a normalized length of 1. Effectively this means changing
	 * your variable name lengths isn't going to change the length of the active part of the pattern.
	 * Useful when comparing two patterns.
	 */
 /**
  * + /酒店=> /酒店//。 
  *  + .html => .html //但是：// / usr + / user => / usr / user // / {foo} + / bar => / {foo} / bar if（！ 
  * this.patternString.equals（ pattern2string.patternString）&& this.capturedVariableCount == 0 && match（PathContainer.parsePath（pattern2string.patternString）））{返回pattern2string; } // / hotels + / booking => / hotels / booking // / hotels + booking => / hotels / booking if（this.endsWithSeparatorWildcard）{返回this.parser.parse（concat（this.patternString.substring（0， this.patternString.length（）-2），pattern2string.patternString））; } // / hotels + / booking => / hotels / booking // / hotels + booking => / hotels / booking int starDotPos1 = this.patternString.indexOf（"。 
  * "）; //是否要考虑文件前缀/后缀？如果（this.capturedVariableCount！ 
  * = 0 || starDotPos1 == -1 || getSeparator（）=='。 
  * '）{返回this.parser.parse（concat（this.patternString，pattern2string.patternString）））; } // .html + / hotel => /hotel.html // .html + / hotel。 
  *  => /hotel.html字符串firstExtension = this.patternString.substring（starDotPos1 + 1）; //寻找第一个扩展字符串String p2string = pattern2string.patternString; int dotPos2 = p2string.indexOf（'。 
  * '）;字符串file2 =（dotPos2 == -1？p2string：p2string.substring（0，dotPos2））;字符串secondExtension =（dotPos2 == -1？""：p2string.substring（dotPos2））; boolean firstExtensionWild =（firstExtension.equals（"。 
  * "）|| firstExtension.isEmpty（））; boolean secondExtensionWild =（secondExtension.equals（"。 
  * "）|| secondExtension.isEmpty（））;如果（！ 
  * firstExtensionWild &&！ 
  * secondExtensionWild）{抛出新的IllegalArgumentException（"不能组合模式："+ this.patternString +"和"+ pattern2string）; }返回this.parser.parse（file2 +（firstExtensionWild？secondExtension：firstExtension））; } @Override public boolean equals（@Nullable Object other）{if（！ 
  * （PathPattern的另一个实例））{返回false； 
  *  } PathPattern otherPattern =（PathPattern）other;返回（this.patternString.equals（otherPattern.getPatternString（））&& getSeparator（）== otherPattern.getSeparator（）&& this.caseSensitive == otherPattern.caseSensitive）; } @Override public int hashCode（）{return（this.patternString.hashCode（）+ getSeparator（））17 +（this.caseSensitive？1：0）; } @Override public String toString（）{返回this.patternString; } int getScore（）{返回this.score; } boolean isCatchAll（）{返回this.catchAll;规范化的长度试图测量模式的"活动"部分。 
  * 它是通过假设所有捕获变量的标准化长度为1来计算的。 
  * 实际上，这意味着更改变量名的长度不会更改模式的活动部分的长度。 
  * 比较两个模式时很有用。 
  * 
  */
	int getNormalizedLength() {
		return this.normalizedLength;
	}

	char getSeparator() {
		return this.pathOptions.separator();
	}

	int getCapturedVariableCount() {
		return this.capturedVariableCount;
	}

	String toChainString() {
		StringJoiner stringJoiner = new StringJoiner(" ");
		PathElement pe = this.head;
		while (pe != null) {
			stringJoiner.add(pe.toString());
			pe = pe.next;
		}
		return stringJoiner.toString();
	}

	/**
	 * Return the string form of the pattern built from walking the path element chain.
	 * @return the string form of the pattern
	 */
	/**
	 * 返回通过遍历路径元素链构建的模式的字符串形式。 
	 *  
	 * @return 模式的字符串形式
	 */
	String computePatternString() {
		StringBuilder buf = new StringBuilder();
		PathElement pe = this.head;
		while (pe != null) {
			buf.append(pe.getChars());
			pe = pe.next;
		}
		return buf.toString();
	}

	@Nullable
	PathElement getHeadSection() {
		return this.head;
	}

	/**
	 * Join two paths together including a separator if necessary.
	 * Extraneous separators are removed (if the first path
	 * ends with one and the second path starts with one).
	 * @param path1 first path
	 * @param path2 second path
	 * @return joined path that may include separator if necessary
	 */
	/**
	 * 将两个路径连接在一起，如有必要，包括分隔符。 
	 * 除去无关的分隔符（如果第一路径以一个结束，第二路径以一个开始）。 
	 *  
	 * @param  path1第一路径
	 * @param  path2第二路径
	 * @return 必要时可能包含分隔符的连接路径
	 */
	private String concat(String path1, String path2) {
		boolean path1EndsWithSeparator = (path1.charAt(path1.length() - 1) == getSeparator());
		boolean path2StartsWithSeparator = (path2.charAt(0) == getSeparator());
		if (path1EndsWithSeparator && path2StartsWithSeparator) {
			return path1 + path2.substring(1);
		}
		else if (path1EndsWithSeparator || path2StartsWithSeparator) {
			return path1 + path2;
		}
		else {
			return path1 + getSeparator() + path2;
		}
	}

	/**
	 * Return if the container is not null and has more than zero elements.
	 * @param container a path container
	 * @return {@code true} has more than zero elements
	 */
	/**
	 * 如果容器不为null并且具有多个元素，则返回。 
	 *  
	 * @param 容器路径容器
	 * @return  {@code  true}具有不止零个元素
	 */
	private boolean hasLength(@Nullable PathContainer container) {
		return container != null && container.elements().size() > 0;
	}

	private static int scoreByNormalizedLength(PathPattern pattern) {
		return -pattern.getNormalizedLength();
	}

	private boolean pathContainerIsJustSeparator(PathContainer pathContainer) {
		return pathContainer.value().length() == 1 &&
				pathContainer.value().charAt(0) == getSeparator();
	}


	/**
	 * Holder for URI variables and path parameters (matrix variables) extracted
	 * based on the pattern for a given matched path.
	 */
	/**
	 * 基于给定匹配路径的模式提取的URI变量和路径参数（矩阵变量）的持有者。 
	 * 
	 */
	public static class PathMatchInfo {

		private static final PathMatchInfo EMPTY = new PathMatchInfo(Collections.emptyMap(), Collections.emptyMap());

		private final Map<String, String> uriVariables;

		private final Map<String, MultiValueMap<String, String>> matrixVariables;

		PathMatchInfo(Map<String, String> uriVars, @Nullable Map<String, MultiValueMap<String, String>> matrixVars) {
			this.uriVariables = Collections.unmodifiableMap(uriVars);
			this.matrixVariables = (matrixVars != null ?
					Collections.unmodifiableMap(matrixVars) : Collections.emptyMap());
		}

		/**
		 * Return the extracted URI variables.
		 */
		/**
		 * 返回提取的URI变量。 
		 * 
		 */
		public Map<String, String> getUriVariables() {
			return this.uriVariables;
		}

		/**
		 * Return maps of matrix variables per path segment, keyed off by URI
		 * variable name.
		 */
		/**
		 * 返回每个路径段的矩阵变量的映射，以URI变量名称为键。 
		 * 
		 */
		public Map<String, MultiValueMap<String, String>> getMatrixVariables() {
			return this.matrixVariables;
		}

		@Override
		public String toString() {
			return "PathMatchInfo[uriVariables=" + this.uriVariables + ", " +
					"matrixVariables=" + this.matrixVariables + "]";
		}
	}


	/**
	 * Holder for the result of a match on the start of a pattern.
	 * Provides access to the remaining path not matched to the pattern as well
	 * as any variables bound in that first part that was matched.
	 */
	/**
	 * 模式开始处匹配结果的持有人。 
	 * 提供对与模式不匹配的剩余路径以及在匹配的第一部分中绑定的任何变量的访问。 
	 * 
	 */
	public static class PathRemainingMatchInfo {

		private final PathContainer pathRemaining;

		private final PathMatchInfo pathMatchInfo;


		PathRemainingMatchInfo(PathContainer pathRemaining) {
			this(pathRemaining, PathMatchInfo.EMPTY);
		}

		PathRemainingMatchInfo(PathContainer pathRemaining, PathMatchInfo pathMatchInfo) {
			this.pathRemaining = pathRemaining;
			this.pathMatchInfo = pathMatchInfo;
		}

		/**
		 * Return the part of a path that was not matched by a pattern.
		 */
		/**
		 * 返回路径中与模式不匹配的部分。 
		 * 
		 */
		public PathContainer getPathRemaining() {
			return this.pathRemaining;
		}

		/**
		 * Return variables that were bound in the part of the path that was
		 * successfully matched or an empty map.
		 */
		/**
		 * 返回绑定在成功匹配的路径部分或空映射中的变量。 
		 * 
		 */
		public Map<String, String> getUriVariables() {
			return this.pathMatchInfo.getUriVariables();
		}

		/**
		 * Return the path parameters for each bound variable.
		 */
		/**
		 * 返回每个绑定变量的路径参数。 
		 * 
		 */
		public Map<String, MultiValueMap<String, String>> getMatrixVariables() {
			return this.pathMatchInfo.getMatrixVariables();
		}
	}


	/**
	 * Encapsulates context when attempting a match. Includes some fixed state like the
	 * candidate currently being considered for a match but also some accumulators for
	 * extracted variables.
	 */
	/**
	 * 尝试匹配时封装上下文。 
	 * 包括一些固定状态，例如当前正在考虑进行匹配的候选对象，还包括一些用于提取变量的累加器。 
	 * 
	 */
	class MatchingContext {

		final PathContainer candidate;

		final List<Element> pathElements;

		final int pathLength;

		@Nullable
		private Map<String, String> extractedUriVariables;

		@Nullable
		private Map<String, MultiValueMap<String, String>> extractedMatrixVariables;

		boolean extractingVariables;

		boolean determineRemainingPath = false;

		// if determineRemaining is true, this is set to the position in
		// the candidate where the pattern finished matching - i.e. it
		// points to the remaining path that wasn't consumed
		int remainingPathIndex;

		public MatchingContext(PathContainer pathContainer, boolean extractVariables) {
			this.candidate = pathContainer;
			this.pathElements = pathContainer.elements();
			this.pathLength = this.pathElements.size();
			this.extractingVariables = extractVariables;
		}

		public void setMatchAllowExtraPath() {
			this.determineRemainingPath = true;
		}

		public boolean isMatchOptionalTrailingSeparator() {
			return matchOptionalTrailingSeparator;
		}

		public void set(String key, String value, MultiValueMap<String,String> parameters) {
			if (this.extractedUriVariables == null) {
				this.extractedUriVariables = new HashMap<>();
			}
			this.extractedUriVariables.put(key, value);

			if (!parameters.isEmpty()) {
				if (this.extractedMatrixVariables == null) {
					this.extractedMatrixVariables = new HashMap<>();
				}
				this.extractedMatrixVariables.put(key, CollectionUtils.unmodifiableMultiValueMap(parameters));
			}
		}

		public PathMatchInfo getPathMatchResult() {
			if (this.extractedUriVariables == null) {
				return PathMatchInfo.EMPTY;
			}
			else {
				return new PathMatchInfo(this.extractedUriVariables, this.extractedMatrixVariables);
			}
		}

		/**
		 * Return if element at specified index is a separator.
		 * @param pathIndex possible index of a separator
		 * @return {@code true} if element is a separator
		 */
		/**
		 * 如果指定索引处的元素是分隔符，则返回。 
		 *  
		 * @param  pathIndex分隔符的可能索引
		 * @return  {@code  true}如果element是分隔符
		 */
		boolean isSeparator(int pathIndex) {
			return this.pathElements.get(pathIndex) instanceof Separator;
		}

		/**
		 * Return the decoded value of the specified element.
		 * @param pathIndex path element index
		 * @return the decoded value
		 */
		/**
		 * 返回指定元素的解码值。 
		 *  
		 * @param  pathIndex路径元素索引
		 * @return 解码值
		 */
		String pathElementValue(int pathIndex) {
			Element element = (pathIndex < this.pathLength) ? this.pathElements.get(pathIndex) : null;
			if (element instanceof PathContainer.PathSegment) {
				return ((PathContainer.PathSegment)element).valueToMatch();
			}
			return "";
		}
	}

}
