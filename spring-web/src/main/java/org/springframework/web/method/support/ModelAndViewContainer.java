/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.method.support;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.springframework.http.HttpStatus;
import org.springframework.lang.Nullable;
import org.springframework.ui.Model;
import org.springframework.ui.ModelMap;
import org.springframework.validation.support.BindingAwareModelMap;
import org.springframework.web.bind.support.SessionStatus;
import org.springframework.web.bind.support.SimpleSessionStatus;

/**
 * Records model and view related decisions made by
 * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers} and
 * {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} during the course of invocation of
 * a controller method.
 *
 * <p>The {@link #setRequestHandled} flag can be used to indicate the request
 * has been handled directly and view resolution is not required.
 *
 * <p>A default {@link Model} is automatically created at instantiation.
 * An alternate model instance may be provided via {@link #setRedirectModel}
 * for use in a redirect scenario. When {@link #setRedirectModelScenario} is set
 * to {@code true} signalling a redirect scenario, the {@link #getModel()}
 * returns the redirect model instead of the default model.
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @since 3.1
 */
/**
 * 记录模型并查看由{@link  HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}和{@link  HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}做出的决策。 
 *  <p> {<@link> #setRequestHandled}标志可用于指示请求已直接处理，并且不需要视图分辨率。 
 *  <p>实例化时自动创建默认的{@link 模型}。 
 * 可以通过{@link  #setRedirectModel}提供备用模型实例，以用于重定向方案。 
 * 当{@link  #setRedirectModelScenario}设置为{@code  true}表示重定向方案时，{<@link> #getModel（）}返回重定向模型，而不是默认模型。 
 *  @author  Rossen Stoyanchev @author 于尔根·霍勒（Juergen Hoeller）@从3.1开始
 */
public class ModelAndViewContainer {

	private boolean ignoreDefaultModelOnRedirect = false;

	@Nullable
	private Object view;

	private final ModelMap defaultModel = new BindingAwareModelMap();

	@Nullable
	private ModelMap redirectModel;

	private boolean redirectModelScenario = false;

	@Nullable
	private HttpStatus status;

	private final Set<String> noBinding = new HashSet<>(4);

	private final Set<String> bindingDisabled = new HashSet<>(4);

	private final SessionStatus sessionStatus = new SimpleSessionStatus();

	private boolean requestHandled = false;


	/**
	 * By default the content of the "default" model is used both during
	 * rendering and redirect scenarios. Alternatively controller methods
	 * can declare an argument of type {@code RedirectAttributes} and use
	 * it to provide attributes to prepare the redirect URL.
	 * <p>Setting this flag to {@code true} guarantees the "default" model is
	 * never used in a redirect scenario even if a RedirectAttributes argument
	 * is not declared. Setting it to {@code false} means the "default" model
	 * may be used in a redirect if the controller method doesn't declare a
	 * RedirectAttributes argument.
	 * <p>The default setting is {@code false}.
	 */
	/**
	 * 默认情况下，在渲染和重定向方案中都使用"默认"模型的内容。 
	 * 另外，控制器方法可以声明{@code  RedirectAttributes}类型的参数，并使用它提供属性以准备重定向URL。 
	 *  <p>将此标志设置为{@code  true}可以确保即使未声明RedirectAttributes参数，也不会在重定向方案中使用"默认"模型。 
	 * 将其设置为{@code  false}意味着如果控制器方法未声明RedirectAttributes参数，则可以在重定向中使用"默认"模型。 
	 *  <p>默认设置为{@code  false}。 
	 * 
	 */
	public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {
		this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;
	}

	/**
	 * Set a view name to be resolved by the DispatcherServlet via a ViewResolver.
	 * Will override any pre-existing view name or View.
	 */
	/**
	 * 设置要由DispatcherServlet通过ViewResolver解析的视图名称。 
	 * 将覆盖任何先前存在的视图名称或视图。 
	 * 
	 */
	public void setViewName(@Nullable String viewName) {
		this.view = viewName;
	}

	/**
	 * Return the view name to be resolved by the DispatcherServlet via a
	 * ViewResolver, or {@code null} if a View object is set.
	 */
	/**
	 * 返回要由DispatcherServlet通过ViewResolver解析的视图名称，如果设置了View对象，则返回{@code  null}。 
	 * 
	 */
	@Nullable
	public String getViewName() {
		return (this.view instanceof String ? (String) this.view : null);
	}

	/**
	 * Set a View object to be used by the DispatcherServlet.
	 * Will override any pre-existing view name or View.
	 */
	/**
	 * 设置一个由DispatcherServlet使用的View对象。 
	 * 将覆盖任何先前存在的视图名称或视图。 
	 * 
	 */
	public void setView(@Nullable Object view) {
		this.view = view;
	}

	/**
	 * Return the View object, or {@code null} if we using a view name
	 * to be resolved by the DispatcherServlet via a ViewResolver.
	 */
	/**
	 * 返回View对象，或者如果我们使用视图名称由DispatcherServlet通过ViewResolver解析，则返回{@code  null}。 
	 * 
	 */
	@Nullable
	public Object getView() {
		return this.view;
	}

	/**
	 * Whether the view is a view reference specified via a name to be
	 * resolved by the DispatcherServlet via a ViewResolver.
	 */
	/**
	 * 该视图是否为通过名称指定的视图引用，该名称由DispatcherServlet通过ViewResolver解析。 
	 * 
	 */
	public boolean isViewReference() {
		return (this.view instanceof String);
	}

	/**
	 * Return the model to use -- either the "default" or the "redirect" model.
	 * The default model is used if {@code redirectModelScenario=false} or
	 * there is no redirect model (i.e. RedirectAttributes was not declared as
	 * a method argument) and {@code ignoreDefaultModelOnRedirect=false}.
	 */
	/**
	 * 返回要使用的模型-"默认"模型或"重定向"模型。 
	 * 如果{@code  redirectModelScenario = false}或没有重定向模型（即未将RedirectAttributes声明为方法参数）且{@code  ignoreDefaultModelOnRedirect = false}，则使用默认模型。 
	 * 
	 */
	public ModelMap getModel() {
		if (useDefaultModel()) {
			return this.defaultModel;
		}
		else {
			if (this.redirectModel == null) {
				this.redirectModel = new ModelMap();
			}
			return this.redirectModel;
		}
	}

	/**
	 * Whether to use the default model or the redirect model.
	 */
	/**
	 * 是使用默认模型还是重定向模型。 
	 * 
	 */
	private boolean useDefaultModel() {
		return (!this.redirectModelScenario || (this.redirectModel == null && !this.ignoreDefaultModelOnRedirect));
	}

	/**
	 * Return the "default" model created at instantiation.
	 * <p>In general it is recommended to use {@link #getModel()} instead which
	 * returns either the "default" model (template rendering) or the "redirect"
	 * model (redirect URL preparation). Use of this method may be needed for
	 * advanced cases when access to the "default" model is needed regardless,
	 * e.g. to save model attributes specified via {@code @SessionAttributes}.
	 * @return the default model (never {@code null})
	 * @since 4.1.4
	 */
	/**
	 * 返回实例化时创建的"默认"模型。 
	 *  <p>通常，建议使用{@link  #getModel（）}代替它返回"默认"模型（模板呈现）或"重定向"模型（重定向URL准备）。 
	 * 在某些情况下，无论是否需要访问"默认"模型，都可能需要使用此方法。 
	 * 保存通过{@code  @SessionAttributes}指定的模型属性。 
	 *  
	 * @return 默认模型（永不{<@@code> null}）@从4.1.4开始
	 */
	public ModelMap getDefaultModel() {
		return this.defaultModel;
	}

	/**
	 * Provide a separate model instance to use in a redirect scenario.
	 * <p>The provided additional model however is not used unless
	 * {@link #setRedirectModelScenario} gets set to {@code true}
	 * to signal an actual redirect scenario.
	 */
	/**
	 * 提供一个单独的模型实例以在重定向方案中使用。 
	 *  <p>但是，除非将{@link  #setRedirectModelScenario}设置为{@code  true}来表示实际的重定向方案，否则不会使用提供的附加模型。 
	 * 
	 */
	public void setRedirectModel(ModelMap redirectModel) {
		this.redirectModel = redirectModel;
	}

	/**
	 * Whether the controller has returned a redirect instruction, e.g. a
	 * "redirect:" prefixed view name, a RedirectView instance, etc.
	 */
	/**
	 * 控制器是否已返回重定向指令，例如视图名称的前缀"redirect："，RedirectView实例等。 
	 * 
	 */
	public void setRedirectModelScenario(boolean redirectModelScenario) {
		this.redirectModelScenario = redirectModelScenario;
	}

	/**
	 * Provide an HTTP status that will be passed on to with the
	 * {@code ModelAndView} used for view rendering purposes.
	 * @since 4.3
	 */
	/**
	 * 提供一个HTTP状态，该状态将通过{@code  ModelAndView}传递给视图渲染。 
	 *  @4.3起
	 */
	public void setStatus(@Nullable HttpStatus status) {
		this.status = status;
	}

	/**
	 * Return the configured HTTP status, if any.
	 * @since 4.3
	 */
	/**
	 * 返回已配置的HTTP状态（如果有）。 
	 *  @4.3起
	 */
	@Nullable
	public HttpStatus getStatus() {
		return this.status;
	}

	/**
	 * Programmatically register an attribute for which data binding should not occur,
	 * not even for a subsequent {@code @ModelAttribute} declaration.
	 * @param attributeName the name of the attribute
	 * @since 4.3
	 */
	/**
	 * 以编程方式注册不应发生数据绑定的属性，即使随后的{@code  @ModelAttribute}声明也是如此。 
	 *  
	 * @param  attributeName属性名称，自4.3起
	 */
	public void setBindingDisabled(String attributeName) {
		this.bindingDisabled.add(attributeName);
	}

	/**
	 * Whether binding is disabled for the given model attribute.
	 * @since 4.3
	 */
	/**
	 * 给定的模型属性是否禁用绑定。 
	 *  @4.3起
	 */
	public boolean isBindingDisabled(String name) {
		return (this.bindingDisabled.contains(name) || this.noBinding.contains(name));
	}

	/**
	 * Register whether data binding should occur for a corresponding model attribute,
	 * corresponding to an {@code @ModelAttribute(binding=true/false)} declaration.
	 * <p>Note: While this flag will be taken into account by {@link #isBindingDisabled},
	 * a hard {@link #setBindingDisabled} declaration will always override it.
	 * @param attributeName the name of the attribute
	 * @since 4.3.13
	 */
	/**
	 * 注册是否对与{@code  @ModelAttribute（binding = true / false）}声明相对应的相应模型属性进行数据绑定。 
	 *  <p>注意：尽管{@link  #isBindingDisabled}将考虑此标志，但硬{{@@link> #setBindingDisabled}声明将始终覆盖它。 
	 *  
	 * @param  attributeName属性名称@自4.3.13起
	 */
	public void setBinding(String attributeName, boolean enabled) {
		if (!enabled) {
			this.noBinding.add(attributeName);
		}
		else {
			this.noBinding.remove(attributeName);
		}
	}

	/**
	 * Return the {@link SessionStatus} instance to use that can be used to
	 * signal that session processing is complete.
	 */
	/**
	 * 返回要使用的{@link  SessionStatus}实例，该实例可用于指示会话处理已完成。 
	 * 
	 */
	public SessionStatus getSessionStatus() {
		return this.sessionStatus;
	}

	/**
	 * Whether the request has been handled fully within the handler, e.g.
	 * {@code @ResponseBody} method, and therefore view resolution is not
	 * necessary. This flag can also be set when controller methods declare an
	 * argument of type {@code ServletResponse} or {@code OutputStream}).
	 * <p>The default value is {@code false}.
	 */
	/**
	 * 该请求是否已在处理程序中完全处理，例如{@code  @ResponseBody}方法，因此不需要视图分辨率。 
	 * 当控制器方法声明类型为{@code  ServletResponse}或{@code  OutputStream}的参数时，也可以设置此标志。 
	 *  <p>默认值为{@code  false}。 
	 * 
	 */
	public void setRequestHandled(boolean requestHandled) {
		this.requestHandled = requestHandled;
	}

	/**
	 * Whether the request has been handled fully within the handler.
	 */
	/**
	 * 请求是否已在处理程序中完全处理。 
	 * 
	 */
	public boolean isRequestHandled() {
		return this.requestHandled;
	}

	/**
	 * Add the supplied attribute to the underlying model.
	 * A shortcut for {@code getModel().addAttribute(String, Object)}.
	 */
	/**
	 * 将提供的属性添加到基础模型。 
	 *  {@code  getModel（）。 
	 * addAttribute（String，Object）}的快捷方式。 
	 * 
	 */
	public ModelAndViewContainer addAttribute(String name, @Nullable Object value) {
		getModel().addAttribute(name, value);
		return this;
	}

	/**
	 * Add the supplied attribute to the underlying model.
	 * A shortcut for {@code getModel().addAttribute(Object)}.
	 */
	/**
	 * 将提供的属性添加到基础模型。 
	 *  {@code  getModel（）。 
	 * addAttribute（Object）}的快捷方式。 
	 * 
	 */
	public ModelAndViewContainer addAttribute(Object value) {
		getModel().addAttribute(value);
		return this;
	}

	/**
	 * Copy all attributes to the underlying model.
	 * A shortcut for {@code getModel().addAllAttributes(Map)}.
	 */
	/**
	 * 将所有属性复制到基础模型。 
	 *  {@code  getModel（）。 
	 * addAllAttributes（Map）}的快捷方式。 
	 * 
	 */
	public ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {
		getModel().addAllAttributes(attributes);
		return this;
	}

	/**
	 * Copy attributes in the supplied {@code Map} with existing objects of
	 * the same name taking precedence (i.e. not getting replaced).
	 * A shortcut for {@code getModel().mergeAttributes(Map<String, ?>)}.
	 */
	/**
	 * 将提供的{@code 映射}中的属性复制为具有相同名称的现有对象（即不被替换）。 
	 *  {@code  getModel（）。 
	 * mergeAttributes（Map <String，？>）}的快捷方式。 
	 * 
	 */
	public ModelAndViewContainer mergeAttributes(@Nullable Map<String, ?> attributes) {
		getModel().mergeAttributes(attributes);
		return this;
	}

	/**
	 * Remove the given attributes from the model.
	 */
	/**
	 * 从模型中删除给定的属性。 
	 * 
	 */
	public ModelAndViewContainer removeAttributes(@Nullable Map<String, ?> attributes) {
		if (attributes != null) {
			for (String key : attributes.keySet()) {
				getModel().remove(key);
			}
		}
		return this;
	}

	/**
	 * Whether the underlying model contains the given attribute name.
	 * A shortcut for {@code getModel().containsAttribute(String)}.
	 */
	/**
	 * 基础模型是否包含给定的属性名称。 
	 *  {@code  getModel（）。 
	 * containsAttribute（String）}的快捷方式。 
	 * 
	 */
	public boolean containsAttribute(String name) {
		return getModel().containsAttribute(name);
	}


	/**
	 * Return diagnostic information.
	 */
	/**
	 * 返回诊断信息。 
	 * 
	 */
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder("ModelAndViewContainer: ");
		if (!isRequestHandled()) {
			if (isViewReference()) {
				sb.append("reference to view with name '").append(this.view).append("'");
			}
			else {
				sb.append("View is [").append(this.view).append(']');
			}
			if (useDefaultModel()) {
				sb.append("; default model ");
			}
			else {
				sb.append("; redirect model ");
			}
			sb.append(getModel());
		}
		else {
			sb.append("Request handled directly");
		}
		return sb.toString();
	}

}
