/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.bind.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.core.annotation.AliasFor;

/**
 * Annotation for mapping web requests onto methods in request-handling classes
 * with flexible method signatures.
 *
 * <p>Both Spring MVC and Spring WebFlux support this annotation through a
 * {@code RequestMappingHandlerMapping} and {@code RequestMappingHandlerAdapter}
 * in their respective modules and package structure. For the exact list of
 * supported handler method arguments and return types in each, please use the
 * reference documentation links below:
 * <ul>
 * <li>Spring MVC
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments">Method Arguments</a>
 * and
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-return-types">Return Values</a>
 * </li>
 * <li>Spring WebFlux
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-arguments">Method Arguments</a>
 * and
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-ann-return-types">Return Values</a>
 * </li>
 * </ul>
 *
 * <p><strong>Note:</strong> This annotation can be used both at the class and
 * at the method level. In most cases, at the method level applications will
 * prefer to use one of the HTTP method specific variants
 * {@link GetMapping @GetMapping}, {@link PostMapping @PostMapping},
 * {@link PutMapping @PutMapping}, {@link DeleteMapping @DeleteMapping}, or
 * {@link PatchMapping @PatchMapping}.</p>
 *
 * <p><b>NOTE:</b> When using controller interfaces (e.g. for AOP proxying),
 * make sure to consistently put <i>all</i> your mapping annotations - such as
 * {@code @RequestMapping} and {@code @SessionAttributes} - on
 * the controller <i>interface</i> rather than on the implementation class.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @author Sam Brannen
 * @since 2.5
 * @see GetMapping
 * @see PostMapping
 * @see PutMapping
 * @see DeleteMapping
 * @see PatchMapping
 * @see org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
 * @see org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter
 */
/**
 * 用于将Web请求映射到具有灵活方法签名的请求处理类中的方法的注释。 
 *  <p> Spring MVC和Spring WebFlux都通过各自模块和包结构中的{@code  RequestMappingHandlerMapping}和{@code  RequestMappingHandlerAdapter}来支持此注释。 
 * 有关每个中支持的处理程序方法参数和返回类型的确切列表，请使用下面的参考文档链接：<ul> <li> Spring MVC <a href ="https://docs.spring.io/spring/docs/ current / spring-framework-reference / web.html＃mvc-ann-arguments">方法参数</a>和<a href ="https://docs.spring.io/spring/docs/current/spring-framework -reference / web.html＃mvc-ann-return-types">返回值</a> </ li> <li> Spring WebFlux <a href ="https://docs.spring.io/spring/docs/ current / spring-framework-reference / web-reactive.html＃webflux-ann-arguments">方法参数</a>和<a href ="https://docs.spring.io/spring/docs/current/spring -framework-reference / web-reactive.html＃webflux-ann-return-types">返回值</a> </ li> </ ul> <p> <strong>注意：</ strong>在类和方法级别都使用。 
 * 在大多数情况下，在方法级别，应用程序会更喜欢使用HTTP方法特定的变体之一{{@link> GetMapping @GetMapping}，{<@link> PostMapping @PostMapping}，{<@link> PutMapping @PutMapping}， {@link  DeleteMapping @DeleteMapping}或{@link  PatchMapping @PatchMapping}。 
 * </ p> <p> <b>注意：</ b>使用控制器接口（例如用于AOP代理）时，请确保始终将<i>所有</ i>您的映射注释（例如{@code  @RequestMapping}和{@code  @SessionAttributes}）放置在控制器<i>接口</ i>上，而不是实现类。 
 *  @author  Juergen Hoeller @author  Arjen Poutsma @author  Sam Brannen @since 2.5 
 * @see  GetMapping 
 * @see  PostMapping 
 * @see  PutMapping 
 * @see  DeleteMapping 
 * @see  PatchMapping 
 * @see  org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 
 * @see  org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface RequestMapping {

	/**
	 * Assign a name to this mapping.
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used on both levels, a combined name is derived by concatenation
	 * with "#" as separator.
	 * @see org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder
	 * @see org.springframework.web.servlet.handler.HandlerMethodMappingNamingStrategy
	 */
	/**
	 * 为该映射分配名称。 
	 *  <p> <b>在类型级别和方法级别上都受支持！ 
	 * </ b>在两个级别上都使用时，组合名称是通过以"＃"作为分隔符的连接而派生的。 
	 *  
	 * @see  org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder 
	 * @see  org.springframework.web.servlet.handler.HandlerMethodMappingNamingStrategy
	 */
	String name() default "";

	/**
	 * The primary mapping expressed by this annotation.
	 * <p>This is an alias for {@link #path}. For example,
	 * {@code @RequestMapping("/foo")} is equivalent to
	 * {@code @RequestMapping(path="/foo")}.
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used at the type level, all method-level mappings inherit
	 * this primary mapping, narrowing it for a specific handler method.
	 * <p><strong>NOTE</strong>: A handler method that is not mapped to any path
	 * explicitly is effectively mapped to an empty path.
	 */
	/**
	 * 此注释表示的主要映射。 
	 *  <p>这是{@link  #path}的别名。 
	 * 例如，{@code  @RequestMapping（"/ foo"）}等效于{@code  @RequestMapping（path ="/ foo"）}。 
	 *  <p> <b>在类型级别以及方法级别都受支持！ 
	 * </ b>在类型级别使用时，所有方法级别的映射都继承该主映射，从而将其缩小为特定的处理程序方法。 
	 *  <p> <strong>注意</ strong>：未显式映射到任何路径的处理程序方法将有效地映射到空路径。 
	 * 
	 */
	@AliasFor("path")
	String[] value() default {};

	/**
	 * The path mapping URIs (e.g. {@code "/profile"}).
	 * <p>Ant-style path patterns are also supported (e.g. {@code "/profile/**"}).
	 * At the method level, relative paths (e.g. {@code "edit"}) are supported
	 * within the primary mapping expressed at the type level.
	 * Path mapping URIs may contain placeholders (e.g. <code>"/${profile_path}"</code>).
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used at the type level, all method-level mappings inherit
	 * this primary mapping, narrowing it for a specific handler method.
	 * <p><strong>NOTE</strong>: A handler method that is not mapped to any path
	 * explicitly is effectively mapped to an empty path.
	 * @since 4.2
	 */
	/**
	 * 路径映射URI（例如{@code "/ profile"}）。 
	 * 还支持<p>蚂蚁风格的路径模式（例如{@code "/ profile"}）。 
	 * 在方法级别，在类型级别表示的主映射中支持相对路径（例如{@code "edit"}）。 
	 * 路径映射URI可能包含占位符（例如<code>"/ $ {profile_path}"</ code>）。 
	 *  <p> <b>在类型级别以及方法级别都受支持！ 
	 * </ b>在类型级别使用时，所有方法级别的映射都继承该主映射，从而将其缩小为特定的处理程序方法。 
	 *  <p> <strong>注意</ strong>：未显式映射到任何路径的处理程序方法将有效地映射到空路径。 
	 *  @4.2起
	 */
	@AliasFor("value")
	String[] path() default {};

	/**
	 * The HTTP request methods to map to, narrowing the primary mapping:
	 * GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used at the type level, all method-level mappings inherit
	 * this HTTP method restriction (i.e. the type-level restriction
	 * gets checked before the handler method is even resolved).
	 */
	/**
	 * 要映射到的HTTP请求方法，从而缩小了主要映射：GET，POST，HEAD，OPTIONS，PUT，PATCH，DELETE，TRACE。 
	 *  <p> <b>在类型级别以及方法级别均受支持！ 
	 * </ b>在类型级别使用时，所有方法级别的映射都继承此HTTP方法限制（即，在执行之前检查类型级别的限制）处理程序方法甚至可以解决）。 
	 * 
	 */
	RequestMethod[] method() default {};

	/**
	 * The parameters of the mapped request, narrowing the primary mapping.
	 * <p>Same format for any environment: a sequence of "myParam=myValue" style
	 * expressions, with a request only mapped if each such parameter is found
	 * to have the given value. Expressions can be negated by using the "!=" operator,
	 * as in "myParam!=myValue". "myParam" style expressions are also supported,
	 * with such parameters having to be present in the request (allowed to have
	 * any value). Finally, "!myParam" style expressions indicate that the
	 * specified parameter is <i>not</i> supposed to be present in the request.
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used at the type level, all method-level mappings inherit
	 * this parameter restriction (i.e. the type-level restriction
	 * gets checked before the handler method is even resolved).
	 * <p>Parameter mappings are considered as restrictions that are enforced at
	 * the type level. The primary path mapping (i.e. the specified URI value)
	 * still has to uniquely identify the target handler, with parameter mappings
	 * simply expressing preconditions for invoking the handler.
	 */
	/**
	 * 映射请求的参数，从而缩小了主映射的范围。 
	 *  <p>任何环境的格式相同：一系列"myParam = myValue"样式表达式，仅当发现每个这样的参数都具有给定值时，才会映射请求。 
	 * 可以使用"！ 
	 * ="运算符来否定表达式，如"myParam！ 
	 * = myValue"。 
	 * 还支持"myParam"样式表达式，此类参数必须存在于请求中（允许具有任何值）。 
	 * 最后，"！ 
	 * myParam"样式表达式表示指定的参数不应该出现在请求中。 
	 *  <p> <b>在类型级别和方法级别都受支持！ 
	 * </ b>在类型级别使用时，所有方法级别的映射都继承此参数限制（即，类型级别的限制会在处理程序方法甚至可以解决）。 
	 *  <p>参数映射被视为在类型级别上强制执行的限制。 
	 * 主路径映射（即指定的URI值）仍必须唯一标识目标处理程序，而参数映射仅表示调用处理程序的前提条件。 
	 * 
	 */
	String[] params() default {};

	/**
	 * The headers of the mapped request, narrowing the primary mapping.
	 * <p>Same format for any environment: a sequence of "My-Header=myValue" style
	 * expressions, with a request only mapped if each such header is found
	 * to have the given value. Expressions can be negated by using the "!=" operator,
	 * as in "My-Header!=myValue". "My-Header" style expressions are also supported,
	 * with such headers having to be present in the request (allowed to have
	 * any value). Finally, "!My-Header" style expressions indicate that the
	 * specified header is <i>not</i> supposed to be present in the request.
	 * <p>Also supports media type wildcards (*), for headers such as Accept
	 * and Content-Type. For instance,
	 * <pre class="code">
	 * &#064;RequestMapping(value = "/something", headers = "content-type=text/*")
	 * </pre>
	 * will match requests with a Content-Type of "text/html", "text/plain", etc.
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * When used at the type level, all method-level mappings inherit
	 * this header restriction (i.e. the type-level restriction
	 * gets checked before the handler method is even resolved).
	 * @see org.springframework.http.MediaType
	 */
	/**
	 * 映射请求的标头，缩小了主映射的范围。 
	 *  <p>任何环境的相同格式："My-Header = myValue"样式表达式的序列，仅当发现每个此类标头具有给定值时才映射请求。 
	 * 可以使用"！ 
	 * ="运算符来否定表达式，如"My-Header！ 
	 * = myValue"中所示。 
	 * 还支持"My-Header"样式表达式，此类首部必须出现在请求中（允许具有任何值）。 
	 * 最后，"！ 
	 * My-Header"样式表达式指示请求中不应存在指定的标头。 
	 *  <p>还支持媒体类型通配符（），用于标题（例如Accept和Content-Type）。 
	 * 例如，<pre class ="code"> @RequestMapping（value ="/ something"，headers ="content-type = text"）</ pre>将匹配Content-Type为"text / html"的请求， "text / plain"等。 
	 * <p> <b>在类型级别以及方法级别都受支持！ 
	 * </ b>在类型级别使用时，所有方法级别的映射都继承此标头限制（即，甚至在解析处理程序方法之前检查类型级别的限制）。 
	 *  
	 * @see  org.springframework.http.MediaType
	 */
	String[] headers() default {};

	/**
	 * Narrows the primary mapping by media types that can be consumed by the
	 * mapped handler. Consists of one or more media types one of which must
	 * match to the request {@code Content-Type} header. Examples:
	 * <pre class="code">
	 * consumes = "text/plain"
	 * consumes = {"text/plain", "application/*"}
	 * consumes = MediaType.TEXT_PLAIN_VALUE
	 * </pre>
	 * Expressions can be negated by using the "!" operator, as in
	 * "!text/plain", which matches all requests with a {@code Content-Type}
	 * other than "text/plain".
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * If specified at both levels, the method level consumes condition overrides
	 * the type level condition.
	 * @see org.springframework.http.MediaType
	 * @see javax.servlet.http.HttpServletRequest#getContentType()
	 */
	/**
	 * 通过可以由映射的处理程序使用的媒体类型来缩小主映射。 
	 * 由一种或多种媒体类型组成，其中一种必须与请求{@code  Content-Type}标头匹配。 
	 * 示例：<pre class ="code">消耗="文本/纯文本"消耗= {"文本/纯文本"，"应用程序"}消耗= MediaType.TEXT_PLAIN_VALUE </ pre>可以使用"！ 
	 * "否定表达式。 
	 * 运算符，如"！ 
	 * text / plain"中一样，该标识符与除"text / plain"以外的所有带有{@code  Content-Type}的请求匹配。 
	 *  <p> <b>在类型级别和方法级别都受支持！ 
	 * </ b>如果在两个级别上都指定了方法级别，则使用条件级别将覆盖条件级别。 
	 *  
	 * @see  org.springframework.http.MediaType 
	 * @see  javax.servlet.http.HttpServletRequest＃getContentType（）
	 */
	String[] consumes() default {};

	/**
	 * Narrows the primary mapping by media types that can be produced by the
	 * mapped handler. Consists of one or more media types one of which must
	 * be chosen via content negotiation against the "acceptable" media types
	 * of the request. Typically those are extracted from the {@code "Accept"}
	 * header but may be derived from query parameters, or other. Examples:
	 * <pre class="code">
	 * produces = "text/plain"
	 * produces = {"text/plain", "application/*"}
	 * produces = MediaType.TEXT_PLAIN_VALUE
	 * produces = "text/plain;charset=UTF-8"
	 * </pre>
	 * <p>If a declared media type contains a parameter (e.g. "charset=UTF-8",
	 * "type=feed", type="entry") and if a compatible media type from the request
	 * has that parameter too, then the parameter values must match. Otherwise
	 * if the media type from the request does not contain the parameter, it is
	 * assumed the client accepts any value.
	 * <p>Expressions can be negated by using the "!" operator, as in "!text/plain",
	 * which matches all requests with a {@code Accept} other than "text/plain".
	 * <p><b>Supported at the type level as well as at the method level!</b>
	 * If specified at both levels, the method level produces condition overrides
	 * the type level condition.
	 * @see org.springframework.http.MediaType
	 * @see org.springframework.http.MediaType
	 */
	/**
	 * 通过可以由映射处理程序生成的媒体类型来缩小主映射。 
	 * 由一种或多种媒体类型组成，其中一种必须通过针对请求的"可接受"媒体类型的内容协商来选择。 
	 * 通常，这些是从{@code "Accept"}标头中提取的，但也可以从查询参数或其他参数中得出。 
	 * 示例：<pre class ="code"> Produces ="text / plain"produces = {"text / plain"，"application"}产生= MediaType.TEXT_PLAIN_VALUE产生="text / plain; charset = UTF-8"</ pre> <p>如果声明的媒体类型包含参数（例如"charset = UTF-8"，"type = feed"，type ="entry"），并且请求中的兼容媒体类型也具有该参数，则参数值必须匹配。 
	 * 否则，如果请求中的媒体类型不包含参数，则假定客户端接受任何值。 
	 *  <p>可以使用"！ 
	 * "取反表达式。 
	 * 运算符，如"！ 
	 * text / plain"中所示，该操作符将所有请求与除"text / plain"之外的所有其他请求都用{@code  Accept}匹配。 
	 *  <p> <b>在类型级别和方法级别均受支持！ 
	 * </ b>如果在两个级别上均指定，则方法级别产生的条件将覆盖类型级别的条件。 
	 *  
	 * @see  org.springframework.http.MediaType 
	 * @see  org.springframework.http.MediaType
	 */
	String[] produces() default {};

}
