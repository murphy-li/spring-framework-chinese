/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;

/**
 * Interface to be implemented in Servlet 3.0+ environments in order to configure the
 * {@link ServletContext} programmatically -- as opposed to (or possibly in conjunction
 * with) the traditional {@code web.xml}-based approach.
 *
 * <p>Implementations of this SPI will be detected automatically by {@link
 * SpringServletContainerInitializer}, which itself is bootstrapped automatically
 * by any Servlet 3.0 container. See {@linkplain SpringServletContainerInitializer its
 * Javadoc} for details on this bootstrapping mechanism.
 *
 * <h2>Example</h2>
 * <h3>The traditional, XML-based approach</h3>
 * Most Spring users building a web application will need to register Spring's {@code
 * DispatcherServlet}. For reference, in WEB-INF/web.xml, this would typically be done as
 * follows:
 * <pre class="code">
 * &lt;servlet&gt;
 *   &lt;servlet-name>dispatcher&lt;/servlet-name&gt;
 *   &lt;servlet-class&gt;
 *     org.springframework.web.servlet.DispatcherServlet
 *   &lt;/servlet-class&gt;
 *   &lt;init-param>
 *     &lt;param-name>contextConfigLocation&lt;/param-name&gt;
 *     &lt;param-value>/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;
 *   &lt;/init-param&gt;
 *   &lt;load-on-startup>1&lt;/load-on-startup&gt;
 * &lt;/servlet&gt;
 *
 * &lt;servlet-mapping&gt;
 *   &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
 *   &lt;url-pattern&gt;/&lt;/url-pattern&gt;
 * &lt;/servlet-mapping&gt;</pre>
 *
 * <h3>The code-based approach with {@code WebApplicationInitializer}</h3>
 * Here is the equivalent {@code DispatcherServlet} registration logic,
 * {@code WebApplicationInitializer}-style:
 * <pre class="code">
 * public class MyWebAppInitializer implements WebApplicationInitializer {
 *
 *    &#064;Override
 *    public void onStartup(ServletContext container) {
 *      XmlWebApplicationContext appContext = new XmlWebApplicationContext();
 *      appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
 *
 *      ServletRegistration.Dynamic dispatcher =
 *        container.addServlet("dispatcher", new DispatcherServlet(appContext));
 *      dispatcher.setLoadOnStartup(1);
 *      dispatcher.addMapping("/");
 *    }
 *
 * }</pre>
 *
 * As an alternative to the above, you can also extend from {@link
 * org.springframework.web.servlet.support.AbstractDispatcherServletInitializer}.
 *
 * As you can see, thanks to Servlet 3.0's new {@link ServletContext#addServlet} method
 * we're actually registering an <em>instance</em> of the {@code DispatcherServlet}, and
 * this means that the {@code DispatcherServlet} can now be treated like any other object
 * -- receiving constructor injection of its application context in this case.
 *
 * <p>This style is both simpler and more concise. There is no concern for dealing with
 * init-params, etc, just normal JavaBean-style properties and constructor arguments. You
 * are free to create and work with your Spring application contexts as necessary before
 * injecting them into the {@code DispatcherServlet}.
 *
 * <p>Most major Spring Web components have been updated to support this style of
 * registration.  You'll find that {@code DispatcherServlet}, {@code FrameworkServlet},
 * {@code ContextLoaderListener} and {@code DelegatingFilterProxy} all now support
 * constructor arguments. Even if a component (e.g. non-Spring, other third party) has not
 * been specifically updated for use within {@code WebApplicationInitializers}, they still
 * may be used in any case. The Servlet 3.0 {@code ServletContext} API allows for setting
 * init-params, context-params, etc programmatically.
 *
 * <h2>A 100% code-based approach to configuration</h2>
 * In the example above, {@code WEB-INF/web.xml} was successfully replaced with code in
 * the form of a {@code WebApplicationInitializer}, but the actual
 * {@code dispatcher-config.xml} Spring configuration remained XML-based.
 * {@code WebApplicationInitializer} is a perfect fit for use with Spring's code-based
 * {@code @Configuration} classes. See @{@link
 * org.springframework.context.annotation.Configuration Configuration} Javadoc for
 * complete details, but the following example demonstrates refactoring to use Spring's
 * {@link org.springframework.web.context.support.AnnotationConfigWebApplicationContext
 * AnnotationConfigWebApplicationContext} in lieu of {@code XmlWebApplicationContext}, and
 * user-defined {@code @Configuration} classes {@code AppConfig} and
 * {@code DispatcherConfig} instead of Spring XML files. This example also goes a bit
 * beyond those above to demonstrate typical configuration of the 'root' application
 * context and registration of the {@code ContextLoaderListener}:
 * <pre class="code">
 * public class MyWebAppInitializer implements WebApplicationInitializer {
 *
 *    &#064;Override
 *    public void onStartup(ServletContext container) {
 *      // Create the 'root' Spring application context
 *      AnnotationConfigWebApplicationContext rootContext =
 *        new AnnotationConfigWebApplicationContext();
 *      rootContext.register(AppConfig.class);
 *
 *      // Manage the lifecycle of the root application context
 *      container.addListener(new ContextLoaderListener(rootContext));
 *
 *      // Create the dispatcher servlet's Spring application context
 *      AnnotationConfigWebApplicationContext dispatcherContext =
 *        new AnnotationConfigWebApplicationContext();
 *      dispatcherContext.register(DispatcherConfig.class);
 *
 *      // Register and map the dispatcher servlet
 *      ServletRegistration.Dynamic dispatcher =
 *        container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
 *      dispatcher.setLoadOnStartup(1);
 *      dispatcher.addMapping("/");
 *    }
 *
 * }</pre>
 *
 * As an alternative to the above, you can also extend from {@link
 * org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer}.
 *
 * Remember that {@code WebApplicationInitializer} implementations are <em>detected
 * automatically</em> -- so you are free to package them within your application as you
 * see fit.
 *
 * <h2>Ordering {@code WebApplicationInitializer} execution</h2>
 * {@code WebApplicationInitializer} implementations may optionally be annotated at the
 * class level with Spring's @{@link org.springframework.core.annotation.Order Order}
 * annotation or may implement Spring's {@link org.springframework.core.Ordered Ordered}
 * interface. If so, the initializers will be ordered prior to invocation. This provides
 * a mechanism for users to ensure the order in which servlet container initialization
 * occurs. Use of this feature is expected to be rare, as typical applications will likely
 * centralize all container initialization within a single {@code WebApplicationInitializer}.
 *
 * <h2>Caveats</h2>
 *
 * <h3>web.xml versioning</h3>
 * <p>{@code WEB-INF/web.xml} and {@code WebApplicationInitializer} use are not mutually
 * exclusive; for example, web.xml can register one servlet, and a {@code
 * WebApplicationInitializer} can register another. An initializer can even
 * <em>modify</em> registrations performed in {@code web.xml} through methods such as
 * {@link ServletContext#getServletRegistration(String)}. <strong>However, if
 * {@code WEB-INF/web.xml} is present in the application, its {@code version} attribute
 * must be set to "3.0" or greater, otherwise {@code ServletContainerInitializer}
 * bootstrapping will be ignored by the servlet container.</strong>
 *
 * <h3>Mapping to '/' under Tomcat</h3>
 * <p>Apache Tomcat maps its internal {@code DefaultServlet} to "/", and on Tomcat versions
 * &lt;= 7.0.14, this servlet mapping <em>cannot be overridden programmatically</em>.
 * 7.0.15 fixes this issue. Overriding the "/" servlet mapping has also been tested
 * successfully under GlassFish 3.1.<p>
 *
 * @author Chris Beams
 * @since 3.1
 * @see SpringServletContainerInitializer
 * @see org.springframework.web.context.AbstractContextLoaderInitializer
 * @see org.springframework.web.servlet.support.AbstractDispatcherServletInitializer
 * @see org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer
 */
/**
 * 在Servlet 3.0+环境中实现的接口，以便以编程方式配置{<< @link >> ServletContext}-与传统的{<< @code >> web.xml}（或可能与之结合）-基于方法。 
 *  <p>此SPI的实现将由{<< @link >> SpringServletContainerInitializer}自动检测，它本身可以由任何Servlet 3.0容器自动引导。 
 * 有关此自举机制的详细信息，请参见{<< @link >>纯SpringServletContainerInitializer及其Javadoc}。 
 *  <h2>示例</ h2> <h3>基于XML的传统方法</ h3>大多数构建Web应用程序的Spring用户将需要注册Spring的{<< @code >> DispatcherServlet}。 
 * 作为参考，在WEB-INF / web.xml中，通常按以下步骤进行操作：<pre class ="code"> <servlet> <servlet-name> dispatcher </ servlet-name> <servlet-class> org。 
 *  springframework.web.servlet.DispatcherServlet </ servlet-class> <init-param> <param-name> contextConfigLocation </ param-name> <param-value> /WEB-INF/spring/dispatcher-config.xml </ param -value> </ init-param> <load-on-startup> 1 </ load-on-startup> </ servlet> <servlet-mapping> <servlet-name> dispatcher </ servlet-name> <url-pattern > / </ url-pattern> </ servlet-mapping> </ pre> <h3>使用{<< @code >> WebApplicationInitializer}的基于代码的方法</ h3>这是等效的{<< @code> > DispatcherServlet}注册逻辑，{<< @code >> WebApplicationInitializer}样式：<pre class ="code">公共类MyWebAppInitializer实现WebApplicationInitializer {@Override public void onStartup（ServletContext container）{XmlWebApplicationContext appContext = new XmlWebApplicationContext（）; appContext.setConfigLocation（"/ WEB-INF / spring / dispatcher-config.xml"）; ServletRegistration.Dynamic调度程序= container.addServlet（"dispatcher"，新的DispatcherServlet（appContext））; dispatcher.setLoadOnStartup（1）; dispatcher.addMapping（"/"）; }} </ pre>作为上述替代方法，您还可以从{<< @link >> org.springframework.web.servlet.support.AbstractDispatcherServletInitializer}扩展。 
 * 如您所见，多亏了Servlet 3.0的新{<< @link >> ServletContext＃addServlet}方法，我们实际上正在注册{<< @code >> DispatcherServlet}的<em> instance </ em>，这意味着{<< @code >> DispatcherServlet}现在可以像其他任何对象一样对待-在这种情况下，接收其应用程序上下文的构造方法注入。 
 *  <p>此样式既简单又简洁。 
 * 不用担心处理init-params等问题，只需要处理普通的JavaBean样式的属性和构造函数参数即可。 
 * 在将它们注入到{<< @code >> DispatcherServlet}中之前，您可以根据需要自由创建和使用Spring应用程序上下文。 
 *  <p>大多数主要的Spring Web组件都已更新，以支持这种注册样式。 
 * 您会发现{<< @code >> DispatcherServlet}，{<< @code >> FrameworkServlet}，{<< @code >> ContextLoaderListener}和{<< @code >> DelegatingFilterProxy}现在都支持构造函数参数。 
 * 即使未专门针对{<< @code >> WebApplicationInitializers}中使用的组件（例如非Spring，其他第三方）进行更新，也可以在任何情况下使用它们。 
 *  Servlet 3.0 {<< @code >> ServletContext} API允许以编程方式设置init-params，context-params等。 
 *  <h2>一种基于代码的100％配置方法</ h2>在上面的示例中，{<< @code >> WEB-INF / web.xml}已成功替换为{<< @@code >> WebApplicationInitializer}，但实际的{<< @code >> dispatcher-config.xml} Spring配置仍然基于XML。 
 *  {<< @code >> WebApplicationInitializer}非常适合与Spring的基于代码的{<< @code >> @Configuration}类一起使用。 
 * 有关完整的详细信息，请参见@{<< @link >> org.springframework.context.annotation.Configuration配置} Javadoc，但是以下示例演示了重构以使用Spring的{<< @link >> org.springframework.web.context.support .AnnotationConfigWebApplicationContext AnnotationConfigWebApplicationContext}代替{<< @code >> XmlWebApplicationContext}，以及用户定义的{<< @code >> @Configuration}类{<< @code >> AppConfig}和{<< @code >> DispatcherConfig }代替Spring XML文件
 */
/**
 * 此示例还超出了上面的示例，以演示"根"应用程序上下文的典型配置和{<< @code >> ContextLoaderListener}的注册：<pre class ="code">公共类MyWebAppInitializer实现WebApplicationInitializer {@Override public void onStartup（ServletContext container）{//创建"根"Spring应用程序上下文AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext（）; rootContext.register（AppConfig.class）; //管理根应用程序上下文容器的生命周期。 
 * addListener（new ContextLoaderListener（rootContext））; //创建调度程序Servlet的Spring应用程序上下文AnnotationConfigWebApplicationContext dispatcherContext = new AnnotationConfigWebApplicationContext（）; dispatcherContext.register（DispatcherConfig.class）; //注册并映射调度程序Servlet ServletRegistration.Dynamic dispatcher = container.addServlet（"dispatcher"，new DispatcherServlet（dispatcherContext））; dispatcher.setLoadOnStartup（1）; dispatcher.addMapping（"/"）; }} </ pre>作为上述替代方法，您还可以从{<< @link >> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer}扩展。 
 * 请记住，{<< @code >> WebApplicationInitializer}实现是自动<em>检测到的</ em>，因此您可以随意将其打包到应用程序中。 
 *  <h2>订购{<< @code >> WebApplicationInitializer}执行</ h2> {<< @code >> WebApplicationInitializer}实现可以选择在类级别用Spring的@{<< @link >> org.springframework进行注释。 
 *  core.annotation.Order Order}注释或可以实现Spring的{<< @link >> org.springframework.core.Ordered Ordered}接口。 
 * 如果是这样，将在调用之前对初始化程序进行排序。 
 * 这为用户提供了一种机制，以确保servlet容器初始化发生的顺序。 
 * 预计很少使用此功能，因为典型的应用程序可能会将所有容器初始化集中在单个{<< @code >> WebApplicationInitializer}中。 
 *  <h2>注意事项</ h2> <h3> web.xml版本控制</ h3> <p> {<< @code >> WEB-INF / web.xml}和{<< @code >> WebApplicationInitializer}的使用不是互斥例如，web.xml可以注册一个servlet，而{<< @code >> WebApplicationInitializer}可以注册另一个。 
 * 初始化程序甚至可以通过{<< @link >> ServletContext＃getServletRegistration（String）}之类的方法，在{<< @code >> web.xml}中进行<em>修改</ em>注册。 
 *  <strong>但是，如果应用程序中存在{<< @code >> WEB-INF / web.xml}，则其{<< @code >> version}属性必须设置为"3.0"或更高，否则{ Servlet容器将忽略<< @code >> ServletContainerInitializer}自举。 
 * </ strong> <h3>在Tomcat下映射到'/'</ h3> <p> Apache Tomcat映射其内部{<< @code >> DefaultServlet}设置为"/"，并且在Tomcat版本7.0.14以下，无法以编程方式覆盖此servlet映射<em>。 
 *  7.0.15解决了此问题。 
 * 覆盖"/"servlet映射也已在GlassFish 3.1下成功测试。 
 * <p> << @author >> Chris Beams @since 3.1 << 
 * @see >> SpringServletContainerInitializer << 
 * @see >> org.springframework.web.context .AbstractContextLoaderInitializer << 
 * @see >> org.springframework.web.servlet.support.AbstractDispatcherServletInitializer << 
 * @see >> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer
 */
public interface WebApplicationInitializer {

	/**
	 * Configure the given {@link ServletContext} with any servlets, filters, listeners
	 * context-params and attributes necessary for initializing this web application. See
	 * examples {@linkplain WebApplicationInitializer above}.
	 * @param servletContext the {@code ServletContext} to initialize
	 * @throws ServletException if any call against the given {@code ServletContext}
	 * throws a {@code ServletException}
	 */
	/**
	 * 使用初始化此Web应用程序所需的所有Servlet，过滤器，侦听器上下文参数和属性配置给定的{@link  ServletContext}。 
	 * 请参阅示例{上面的<< link>普通WebApplicationInitializer}。 
	 *  
	 * @param  ServletContext如果对给定{@code  ServletContext}的任何调用抛出{@code  ServletException}，则{@code  ServletContext}初始化
	 * @throws  ServletException
	 */
	void onStartup(ServletContext servletContext) throws ServletException;

}
