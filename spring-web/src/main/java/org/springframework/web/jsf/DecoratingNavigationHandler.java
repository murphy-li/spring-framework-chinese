/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2012的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.jsf;

import javax.faces.application.NavigationHandler;
import javax.faces.context.FacesContext;

import org.springframework.lang.Nullable;

/**
 * Base class for JSF NavigationHandler implementations that want
 * to be capable of decorating an original NavigationHandler.
 *
 * <p>Supports the standard JSF style of decoration (through a constructor argument)
 * as well as an overloaded {@code handleNavigation} method with explicit
 * NavigationHandler argument (passing in the original NavigationHandler). Subclasses
 * are forced to implement this overloaded {@code handleNavigation} method.
 * Standard JSF invocations will automatically delegate to the overloaded method,
 * with the constructor-injected NavigationHandler as argument.
 *
 * @author Juergen Hoeller
 * @since 1.2.7
 * @see #handleNavigation(javax.faces.context.FacesContext, String, String, NavigationHandler)
 * @see DelegatingNavigationHandlerProxy
 */
/**
 * 希望能够装饰原始NavigationHandler的JSF NavigationHandler实现的基类。 
 *  <p>支持标准的JSF修饰样式（通过构造函数参数）以及带有显式NavigationHandler参数（传入原始NavigationHandler）的重载{@code  handleNavigation}方法。 
 * 子类被强制实现此重载的{@code  handleNavigation}方法。 
 * 标准的JSF调用将自动委托给重载的方法，并以构造函数注入的NavigationHandler作为参数。 
 *  @author  Juergen Hoeller @since 1.2.7 
 * @see  #handleNavigation（javax.faces.context.FacesContext，String，String，NavigationHandler）
 * @see  DelegatingNavigationHandlerProxy
 */
public abstract class DecoratingNavigationHandler extends NavigationHandler {

	@Nullable
	private NavigationHandler decoratedNavigationHandler;


	/**
	 * Create a DecoratingNavigationHandler without fixed original NavigationHandler.
	 */
	/**
	 * 创建一个没有固定原始NavigationHandler的DecoratingNavigationHandler。 
	 * 
	 */
	protected DecoratingNavigationHandler() {
	}

	/**
	 * Create a DecoratingNavigationHandler with fixed original NavigationHandler.
	 * @param originalNavigationHandler the original NavigationHandler to decorate
	 */
	/**
	 * 使用固定的原始NavigationHandler创建一个DecoratingNavigationHandler。 
	 *  
	 * @param  originalNavigationHandler要装饰的原始NavigationHandler
	 */
	protected DecoratingNavigationHandler(NavigationHandler originalNavigationHandler) {
		this.decoratedNavigationHandler = originalNavigationHandler;
	}

	/**
	 * Return the fixed original NavigationHandler decorated by this handler, if any
	 * (that is, if passed in through the constructor).
	 */
	/**
	 * 返回由该处理程序装饰的固定的原始NavigationHandler（如果有）（即，如果通过构造函数传递的话）。 
	 * 
	 */
	@Nullable
	public final NavigationHandler getDecoratedNavigationHandler() {
		return this.decoratedNavigationHandler;
	}


	/**
	 * This implementation of the standard JSF {@code handleNavigation} method
	 * delegates to the overloaded variant, passing in constructor-injected
	 * NavigationHandler as argument.
	 * @see #handleNavigation(javax.faces.context.FacesContext, String, String, javax.faces.application.NavigationHandler)
	 */
	/**
	 * 标准JSF {@code  handleNavigation}方法的此实现委托给重载的变量，将构造函数注入的NavigationHandler作为参数传入。 
	 *  
	 * @see  #handleNavigation（javax.faces.context.FacesContext，String，String，javax.faces.application.NavigationHandler）
	 */
	@Override
	public final void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {
		handleNavigation(facesContext, fromAction, outcome, this.decoratedNavigationHandler);
	}

	/**
	 * Special {@code handleNavigation} variant with explicit NavigationHandler
	 * argument. Either called directly, by code with an explicit original handler,
	 * or called from the standard {@code handleNavigation} method, as
	 * plain JSF-defined NavigationHandler.
	 * <p>Implementations should invoke {@code callNextHandlerInChain} to
	 * delegate to the next handler in the chain. This will always call the most
	 * appropriate next handler (see {@code callNextHandlerInChain} javadoc).
	 * Alternatively, the decorated NavigationHandler or the passed-in original
	 * NavigationHandler can also be called directly; however, this is not as
	 * flexible in terms of reacting to potential positions in the chain.
	 * @param facesContext the current JSF context
	 * @param fromAction the action binding expression that was evaluated to retrieve the
	 * specified outcome, or {@code null} if the outcome was acquired by some other means
	 * @param outcome the logical outcome returned by a previous invoked application action
	 * (which may be {@code null})
	 * @param originalNavigationHandler the original NavigationHandler,
	 * or {@code null} if none
	 * @see #callNextHandlerInChain
	 */
	/**
	 * 带有显式NavigationHandler参数的特殊{@code  handleNavigation}变体。 
	 * 通过具有显式原始处理程序的代码直接调用，或者从标准{@code  handleNavigation}方法（作为普通的JSF定义的NavigationHandler）调用。 
	 *  <p>实现应调用{@code  callNextHandlerInChain}委托给链中的下一个处理程序。 
	 * 这将始终调用最合适的下一个处理程序（请参阅{@code  callNextHandlerInChain} javadoc）。 
	 * 另外，装饰的NavigationHandler或传入的原始NavigationHandler也可以直接调用。 
	 * 然而，就对链中潜在位置的反应而言，这并不灵活。 
	 *  
	 * @param  facesContext当前JSF上下文
	 * @param  fromAction被评估为检索指定结果的动作绑定表达式，如果结果是通过其他方式获取的，则返回{@code  null}先前调用的应用程序操作返回的逻辑结果（可能为{@code  null}）
	 * @param  originalNavigationHandler原始NavigationHandler，如果没有，则为{@code  null} 
	 * @see  #callNextHandlerInChain
	 */
	public abstract void handleNavigation(FacesContext facesContext, @Nullable String fromAction,
			@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler);


	/**
	 * Method to be called by subclasses when intending to delegate to the next
	 * handler in the NavigationHandler chain. Will always call the most
	 * appropriate next handler, either the decorated NavigationHandler passed
	 * in as constructor argument or the original NavigationHandler as passed
	 * into this method - according to the position of this instance in the chain.
	 * <p>Will call the decorated NavigationHandler specified as constructor
	 * argument, if any. In case of a DecoratingNavigationHandler as target, the
	 * original NavigationHandler as passed into this method will be passed on to
	 * the next element in the chain: This ensures propagation of the original
	 * handler that the last element in the handler chain might delegate back to.
	 * In case of a standard NavigationHandler as target, the original handler
	 * will simply not get passed on; no delegating back to the original is
	 * possible further down the chain in that scenario.
	 * <p>If no decorated NavigationHandler specified as constructor argument,
	 * this instance is the last element in the chain. Hence, this method will
	 * call the original NavigationHandler as passed into this method. If no
	 * original NavigationHandler has been passed in (for example if this
	 * instance is the last element in a chain with standard NavigationHandlers
	 * as earlier elements), this method corresponds to a no-op.
	 * @param facesContext the current JSF context
	 * @param fromAction the action binding expression that was evaluated to retrieve the
	 * specified outcome, or {@code null} if the outcome was acquired by some other means
	 * @param outcome the logical outcome returned by a previous invoked application action
	 * (which may be {@code null})
	 * @param originalNavigationHandler the original NavigationHandler,
	 * or {@code null} if none
	 */
	/**
	 * 打算委托给NavigationHandler链中的下一个处理程序时，子类将调用的方法。 
	 * 将始终调用最合适的下一个处理程序，根据该实例在链中的位置，将其作为构造函数参数传入的经过修饰的NavigationHandler或作为该方法传入的原始NavigationHandler进行调用。 
	 *  <p>将调用指定为构造函数参数的修饰的NavigationHandler（如果有）。 
	 * 如果以DecoratingNavigationHandler作为目标，传递给此方法的原始NavigationHandler将被传递到链中的下一个元素：这样可确保传播原始处理程序，以使处理程序链中的最后一个元素可以委派回该原始处理程序。 
	 * 在将标准NavigationHandler作为目标的情况下，原始处理程序将不会继续传递； 
	 * 在这种情况下，不可能再回到原始位置。 
	 *  <p>如果未将修饰的NavigationHandler指定为构造函数参数，则此实例为链中的最后一个元素。 
	 * 因此，此方法将调用传递给此方法的原始NavigationHandler。 
	 * 如果未传入任何原始NavigationHandler（例如，如果此实例是链中的最后一个元素，且标准NavigationHandlers作为早期元素），则此方法对应于no-op。 
	 *  
	 * @param  facesContext当前JSF上下文
	 * @param  fromAction被评估为检索指定结果的动作绑定表达式，如果结果是通过其他方式获取的，则返回{@code  null}先前调用的应用程序操作返回的逻辑结果（可能为{@code  null}）
	 * @param  originalNavigationHandler原始NavigationHandler，如果没有，则为{@code  null}
	 */
	protected final void callNextHandlerInChain(FacesContext facesContext, @Nullable String fromAction,
			@Nullable String outcome, @Nullable NavigationHandler originalNavigationHandler) {

		NavigationHandler decoratedNavigationHandler = getDecoratedNavigationHandler();

		if (decoratedNavigationHandler instanceof DecoratingNavigationHandler) {
			// DecoratingNavigationHandler specified through constructor argument:
			// Call it with original NavigationHandler passed in.
			DecoratingNavigationHandler decHandler = (DecoratingNavigationHandler) decoratedNavigationHandler;
			decHandler.handleNavigation(facesContext, fromAction, outcome, originalNavigationHandler);
		}
		else if (decoratedNavigationHandler != null) {
			// Standard NavigationHandler specified through constructor argument:
			// Call it through standard API, without original NavigationHandler passed in.
			// The called handler will not be able to redirect to the original handler.
			decoratedNavigationHandler.handleNavigation(facesContext, fromAction, outcome);
		}
		else if (originalNavigationHandler != null) {
			// No NavigationHandler specified through constructor argument:
			// Call original handler, marking the end of this chain.
			originalNavigationHandler.handleNavigation(facesContext, fromAction, outcome);
		}
	}

}
