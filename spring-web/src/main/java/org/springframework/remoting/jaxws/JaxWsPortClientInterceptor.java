/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.remoting.jaxws;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.ProtocolException;
import javax.xml.ws.Service;
import javax.xml.ws.WebServiceException;
import javax.xml.ws.WebServiceFeature;
import javax.xml.ws.soap.SOAPFaultException;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;
import org.springframework.remoting.RemoteAccessException;
import org.springframework.remoting.RemoteConnectFailureException;
import org.springframework.remoting.RemoteLookupFailureException;
import org.springframework.remoting.RemoteProxyFailureException;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * {@link org.aopalliance.intercept.MethodInterceptor} for accessing a
 * specific port of a JAX-WS service.
 *
 * <p>Uses either {@link LocalJaxWsServiceFactory}'s facilities underneath,
 * or takes an explicit reference to an existing JAX-WS Service instance
 * (e.g. obtained via {@link org.springframework.jndi.JndiObjectFactoryBean}).
 *
 * @author Juergen Hoeller
 * @since 2.5
 * @see #setPortName
 * @see #setServiceInterface
 * @see javax.xml.ws.Service#getPort
 * @see org.springframework.remoting.RemoteAccessException
 * @see org.springframework.jndi.JndiObjectFactoryBean
 */
/**
 * {@link  org.aopalliance.intercept.MethodInterceptor}用于访问JAX-WS服务的特定端口。 
 *  <p>使用下面的{@link  LocalJaxWsServiceFactory}的设施，或显式引用现有的JAX-WS Service实例（例如，通过{@link  org.springframework.jndi.JndiObjectFactoryBean获得）。 
 *  @author  Juergen Hoeller @since 2.5起
 * @see  #setPortName 
 * @see  #setServiceInterface 
 * @see  javax.xml.ws.Service＃getPort 
 * @see  org.springframework.remoting.RemoteAccessException 
 * @see  org .springframework.jndi.JndiObjectFactoryBean
 */
public class JaxWsPortClientInterceptor extends LocalJaxWsServiceFactory
		implements MethodInterceptor, BeanClassLoaderAware, InitializingBean {

	@Nullable
	private Service jaxWsService;

	@Nullable
	private String portName;

	@Nullable
	private String username;

	@Nullable
	private String password;

	@Nullable
	private String endpointAddress;

	private boolean maintainSession;

	private boolean useSoapAction;

	@Nullable
	private String soapActionUri;

	@Nullable
	private Map<String, Object> customProperties;

	@Nullable
	private WebServiceFeature[] portFeatures;

	@Nullable
	private Class<?> serviceInterface;

	private boolean lookupServiceOnStartup = true;

	@Nullable
	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();

	@Nullable
	private QName portQName;

	@Nullable
	private Object portStub;

	private final Object preparationMonitor = new Object();


	/**
	 * Set a reference to an existing JAX-WS Service instance,
	 * for example obtained via {@link org.springframework.jndi.JndiObjectFactoryBean}.
	 * If not set, {@link LocalJaxWsServiceFactory}'s properties have to be specified.
	 * @see #setWsdlDocumentUrl
	 * @see #setNamespaceUri
	 * @see #setServiceName
	 * @see org.springframework.jndi.JndiObjectFactoryBean
	 */
	/**
	 * 设置对现有JAX-WS服务实例的引用，例如通过{@link  org.springframework.jndi.JndiObjectFactoryBean}获得的引用。 
	 * 如果未设置，则必须指定{@link  LocalJaxWsServiceFactory}的属性。 
	 *  
	 * @see  #setWsdlDocumentUrl 
	 * @see  #setNamespaceUri 
	 * @see  #setServiceName 
	 * @see  org.springframework.jndi.JndiObjectFactoryBean
	 */
	public void setJaxWsService(@Nullable Service jaxWsService) {
		this.jaxWsService = jaxWsService;
	}

	/**
	 * Return a reference to an existing JAX-WS Service instance, if any.
	 */
	/**
	 * 返回对现有JAX-WS Service实例的引用（如果有）。 
	 * 
	 */
	@Nullable
	public Service getJaxWsService() {
		return this.jaxWsService;
	}

	/**
	 * Set the name of the port.
	 * Corresponds to the "wsdl:port" name.
	 */
	/**
	 * 设置端口名称。 
	 * 对应于"wsdl：port"名称。 
	 * 
	 */
	public void setPortName(@Nullable String portName) {
		this.portName = portName;
	}

	/**
	 * Return the name of the port.
	 */
	/**
	 * 返回端口名称。 
	 * 
	 */
	@Nullable
	public String getPortName() {
		return this.portName;
	}

	/**
	 * Set the username to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#USERNAME_PROPERTY
	 */
	/**
	 * 设置用户名以在存根上指定。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃USERNAME_PROPERTY
	 */
	public void setUsername(@Nullable String username) {
		this.username = username;
	}

	/**
	 * Return the username to specify on the stub.
	 */
	/**
	 * 返回用户名以在存根上指定。 
	 * 
	 */
	@Nullable
	public String getUsername() {
		return this.username;
	}

	/**
	 * Set the password to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#PASSWORD_PROPERTY
	 */
	/**
	 * 设置密码以在存根上指定。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃PASSWORD_PROPERTY
	 */
	public void setPassword(@Nullable String password) {
		this.password = password;
	}

	/**
	 * Return the password to specify on the stub.
	 */
	/**
	 * 返回密码以在存根上指定。 
	 * 
	 */
	@Nullable
	public String getPassword() {
		return this.password;
	}

	/**
	 * Set the endpoint address to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#ENDPOINT_ADDRESS_PROPERTY
	 */
	/**
	 * 设置端点地址以在存根上指定。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃ENDPOINT_ADDRESS_PROPERTY
	 */
	public void setEndpointAddress(@Nullable String endpointAddress) {
		this.endpointAddress = endpointAddress;
	}

	/**
	 * Return the endpoint address to specify on the stub.
	 */
	/**
	 * 返回端点地址以在存根上指定。 
	 * 
	 */
	@Nullable
	public String getEndpointAddress() {
		return this.endpointAddress;
	}

	/**
	 * Set the "session.maintain" flag to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#SESSION_MAINTAIN_PROPERTY
	 */
	/**
	 * 设置"session.maintain"标志以在存根上指定。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃SESSION_MAINTAIN_PROPERTY
	 */
	public void setMaintainSession(boolean maintainSession) {
		this.maintainSession = maintainSession;
	}

	/**
	 * Return the "session.maintain" flag to specify on the stub.
	 */
	/**
	 * 返回"session.maintain"标志以在存根上指定。 
	 * 
	 */
	public boolean isMaintainSession() {
		return this.maintainSession;
	}

	/**
	 * Set the "soapaction.use" flag to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#SOAPACTION_USE_PROPERTY
	 */
	/**
	 * 设置"soapaction.use"标志以在存根上指定。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃SOAPACTION_USE_PROPERTY
	 */
	public void setUseSoapAction(boolean useSoapAction) {
		this.useSoapAction = useSoapAction;
	}

	/**
	 * Return the "soapaction.use" flag to specify on the stub.
	 */
	/**
	 * 返回"soapaction.use"标志以在存根上指定。 
	 * 
	 */
	public boolean isUseSoapAction() {
		return this.useSoapAction;
	}

	/**
	 * Set the SOAP action URI to specify on the stub.
	 * @see javax.xml.ws.BindingProvider#SOAPACTION_URI_PROPERTY
	 */
	/**
	 * 设置要在存根上指定的SOAP操作URI。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃SOAPACTION_URI_PROPERTY
	 */
	public void setSoapActionUri(@Nullable String soapActionUri) {
		this.soapActionUri = soapActionUri;
	}

	/**
	 * Return the SOAP action URI to specify on the stub.
	 */
	/**
	 * 返回SOAP操作URI，以在存根上指定。 
	 * 
	 */
	@Nullable
	public String getSoapActionUri() {
		return this.soapActionUri;
	}

	/**
	 * Set custom properties to be set on the stub.
	 * <p>Can be populated with a String "value" (parsed via PropertiesEditor)
	 * or a "props" element in XML bean definitions.
	 * @see javax.xml.ws.BindingProvider#getRequestContext()
	 */
	/**
	 * 设置要在存根上设置的自定义属性。 
	 *  <p>可以用XML bean定义中的字符串"值"（通过PropertiesEditor解析）或"props"元素填充。 
	 *  
	 * @see  javax.xml.ws.BindingProvider＃getRequestContext（）
	 */
	public void setCustomProperties(Map<String, Object> customProperties) {
		this.customProperties = customProperties;
	}

	/**
	 * Allow Map access to the custom properties to be set on the stub,
	 * with the option to add or override specific entries.
	 * <p>Useful for specifying entries directly, for example via
	 * "customProperties[myKey]". This is particularly useful for
	 * adding or overriding entries in child bean definitions.
	 */
	/**
	 * 允许地图访问在存根上设置的自定义属性，并带有添加或覆盖特定条目的选项。 
	 *  <p>用于直接指定条目，例如通过"customProperties [myKey]"。 
	 * 这对于在子bean定义中添加或覆盖条目特别有用。 
	 * 
	 */
	public Map<String, Object> getCustomProperties() {
		if (this.customProperties == null) {
			this.customProperties = new HashMap<>();
		}
		return this.customProperties;
	}

	/**
	 * Add a custom property to this JAX-WS BindingProvider.
	 * @param name the name of the attribute to expose
	 * @param value the attribute value to expose
	 * @see javax.xml.ws.BindingProvider#getRequestContext()
	 */
	/**
	 * 将自定义属性添加到此JAX-WS BindingProvider。 
	 *  
	 * @param 命名要公开的属性的名称
	 * @param 值公开要公开的属性的值
	 * @see  javax.xml.ws.BindingProvider＃getRequestContext（）
	 */
	public void addCustomProperty(String name, Object value) {
		getCustomProperties().put(name, value);
	}

	/**
	 * Specify WebServiceFeature objects (e.g. as inner bean definitions)
	 * to apply to JAX-WS port stub creation.
	 * @since 4.0
	 * @see Service#getPort(Class, javax.xml.ws.WebServiceFeature...)
	 * @see #setServiceFeatures
	 */
	/**
	 * 指定WebServiceFeature对象（例如，作为内部bean定义）以应用于JAX-WS端口存根创建。 
	 *  @since 4.0 
	 * @see  Service＃getPort（Class，javax.xml.ws.WebServiceFeature ...）
	 * @see  #setServiceFeatures
	 */
	public void setPortFeatures(WebServiceFeature... features) {
		this.portFeatures = features;
	}

	/**
	 * Set the interface of the service that this factory should create a proxy for.
	 */
	/**
	 * 设置该工厂应为其创建代理的服务的接口。 
	 * 
	 */
	public void setServiceInterface(@Nullable Class<?> serviceInterface) {
		if (serviceInterface != null) {
			Assert.isTrue(serviceInterface.isInterface(), "'serviceInterface' must be an interface");
		}
		this.serviceInterface = serviceInterface;
	}

	/**
	 * Return the interface of the service that this factory should create a proxy for.
	 */
	/**
	 * 返回该工厂应为其创建代理的服务的接口。 
	 * 
	 */
	@Nullable
	public Class<?> getServiceInterface() {
		return this.serviceInterface;
	}

	/**
	 * Set whether to look up the JAX-WS service on startup.
	 * <p>Default is "true". Turn this flag off to allow for late start
	 * of the target server. In this case, the JAX-WS service will be
	 * lazily fetched on first access.
	 */
	/**
	 * 设置是否在启动时查找JAX-WS服务。 
	 *  <p>默认为"true"。 
	 * 关闭此标志以允许延迟启动目标服务器。 
	 * 在这种情况下，JAX-WS服务将在第一次访问时被延迟获取。 
	 * 
	 */
	public void setLookupServiceOnStartup(boolean lookupServiceOnStartup) {
		this.lookupServiceOnStartup = lookupServiceOnStartup;
	}

	/**
	 * Set the bean ClassLoader to use for this interceptor: primarily for
	 * building a client proxy in the {@link JaxWsPortProxyFactoryBean} subclass.
	 */
	/**
	 * 将bean ClassLoader设置为用于此拦截器：主要用于在{@link  JaxWsPortProxyFactoryBean}子类中构建客户端代理。 
	 * 
	 */
	@Override
	public void setBeanClassLoader(@Nullable ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}

	/**
	 * Return the bean ClassLoader to use for this interceptor.
	 */
	/**
	 * 返回用于此拦截器的bean ClassLoader。 
	 * 
	 */
	@Nullable
	protected ClassLoader getBeanClassLoader() {
		return this.beanClassLoader;
	}


	@Override
	public void afterPropertiesSet() {
		if (this.lookupServiceOnStartup) {
			prepare();
		}
	}

	/**
	 * Initialize the JAX-WS port for this interceptor.
	 */
	/**
	 * 初始化此拦截器的JAX-WS端口。 
	 * 
	 */
	public void prepare() {
		Class<?> ifc = getServiceInterface();
		Assert.notNull(ifc, "Property 'serviceInterface' is required");

		WebService ann = ifc.getAnnotation(WebService.class);
		if (ann != null) {
			applyDefaultsFromAnnotation(ann);
		}

		Service serviceToUse = getJaxWsService();
		if (serviceToUse == null) {
			serviceToUse = createJaxWsService();
		}

		this.portQName = getQName(getPortName() != null ? getPortName() : ifc.getName());
		Object stub = getPortStub(serviceToUse, (getPortName() != null ? this.portQName : null));
		preparePortStub(stub);
		this.portStub = stub;
	}

	/**
	 * Initialize this client interceptor's properties from the given WebService annotation,
	 * if necessary and possible (i.e. if "wsdlDocumentUrl", "namespaceUri", "serviceName"
	 * and "portName" haven't been set but corresponding values are declared at the
	 * annotation level of the specified service interface).
	 * @param ann the WebService annotation found on the specified service interface
	 */
	/**
	 * 如果有必要且可能的话，从给定的WebService注释初始化此客户端拦截器的属性（即，如果尚未设置"wsdlDocumentUrl"，"namespaceUri"，"serviceName"和"portName"，但在指定的注释级别声明了相应的值）服务界面）。 
	 *  
	 * @param 和在指定服务界面上找到的WebService注解
	 */
	protected void applyDefaultsFromAnnotation(WebService ann) {
		if (getWsdlDocumentUrl() == null) {
			String wsdl = ann.wsdlLocation();
			if (StringUtils.hasText(wsdl)) {
				try {
					setWsdlDocumentUrl(new URL(wsdl));
				}
				catch (MalformedURLException ex) {
					throw new IllegalStateException(
							"Encountered invalid @Service wsdlLocation value [" + wsdl + "]", ex);
				}
			}
		}
		if (getNamespaceUri() == null) {
			String ns = ann.targetNamespace();
			if (StringUtils.hasText(ns)) {
				setNamespaceUri(ns);
			}
		}
		if (getServiceName() == null) {
			String sn = ann.serviceName();
			if (StringUtils.hasText(sn)) {
				setServiceName(sn);
			}
		}
		if (getPortName() == null) {
			String pn = ann.portName();
			if (StringUtils.hasText(pn)) {
				setPortName(pn);
			}
		}
	}

	/**
	 * Return whether this client interceptor has already been prepared,
	 * i.e. has already looked up the JAX-WS service and port.
	 */
	/**
	 * 返回此客户端拦截器是否已经准备好，即是否已经查找了JAX-WS服务和端口。 
	 * 
	 */
	protected boolean isPrepared() {
		synchronized (this.preparationMonitor) {
			return (this.portStub != null);
		}
	}

	/**
	 * Return the prepared QName for the port.
	 * @see #setPortName
	 * @see #getQName
	 */
	/**
	 * 返回端口的准备好的QName。 
	 *  
	 * @see  #setPortName 
	 * @see  #getQName
	 */
	@Nullable
	protected final QName getPortQName() {
		return this.portQName;
	}

	/**
	 * Obtain the port stub from the given JAX-WS Service.
	 * @param service the Service object to obtain the port from
	 * @param portQName the name of the desired port, if specified
	 * @return the corresponding port object as returned from
	 * {@code Service.getPort(...)}
	 */
	/**
	 * 从给定的JAX-WS服务获取端口存根。 
	 *  
	 * @param 服务Service对象以从
	 * @param  portQName获得所需端口的名称的端口，如果已指定
	 * @return 从{@code  Service.getPort（... ）}
	 */
	protected Object getPortStub(Service service, @Nullable QName portQName) {
		if (this.portFeatures != null) {
			return (portQName != null ? service.getPort(portQName, getServiceInterface(), this.portFeatures) :
					service.getPort(getServiceInterface(), this.portFeatures));
		}
		else {
			return (portQName != null ? service.getPort(portQName, getServiceInterface()) :
					service.getPort(getServiceInterface()));
		}
	}

	/**
	 * Prepare the given JAX-WS port stub, applying properties to it.
	 * Called by {@link #prepare}.
	 * @param stub the current JAX-WS port stub
	 * @see #setUsername
	 * @see #setPassword
	 * @see #setEndpointAddress
	 * @see #setMaintainSession
	 * @see #setCustomProperties
	 */
	/**
	 * 准备给定的JAX-WS端口存根，并对其应用属性。 
	 * 由{@link  #prepare}调用。 
	 *  
	 * @param 对当前JAX-WS端口存根进行存根
	 * @see  #setUsername 
	 * @see  #setPassword 
	 * @see  #setEndpointAddress 
	 * @see  #setMaintainSession 
	 * @see  #setCustomProperties
	 */
	protected void preparePortStub(Object stub) {
		Map<String, Object> stubProperties = new HashMap<>();
		String username = getUsername();
		if (username != null) {
			stubProperties.put(BindingProvider.USERNAME_PROPERTY, username);
		}
		String password = getPassword();
		if (password != null) {
			stubProperties.put(BindingProvider.PASSWORD_PROPERTY, password);
		}
		String endpointAddress = getEndpointAddress();
		if (endpointAddress != null) {
			stubProperties.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointAddress);
		}
		if (isMaintainSession()) {
			stubProperties.put(BindingProvider.SESSION_MAINTAIN_PROPERTY, Boolean.TRUE);
		}
		if (isUseSoapAction()) {
			stubProperties.put(BindingProvider.SOAPACTION_USE_PROPERTY, Boolean.TRUE);
		}
		String soapActionUri = getSoapActionUri();
		if (soapActionUri != null) {
			stubProperties.put(BindingProvider.SOAPACTION_URI_PROPERTY, soapActionUri);
		}
		stubProperties.putAll(getCustomProperties());
		if (!stubProperties.isEmpty()) {
			if (!(stub instanceof BindingProvider)) {
				throw new RemoteLookupFailureException("Port stub of class [" + stub.getClass().getName() +
						"] is not a customizable JAX-WS stub: it does not implement interface [javax.xml.ws.BindingProvider]");
			}
			((BindingProvider) stub).getRequestContext().putAll(stubProperties);
		}
	}

	/**
	 * Return the underlying JAX-WS port stub that this interceptor delegates to
	 * for each method invocation on the proxy.
	 */
	/**
	 * 返回此拦截器委托给代理上每个方法调用的基础JAX-WS端口存根。 
	 * 
	 */
	@Nullable
	protected Object getPortStub() {
		return this.portStub;
	}


	@Override
	@Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {
		if (AopUtils.isToStringMethod(invocation.getMethod())) {
			return "JAX-WS proxy for port [" + getPortName() + "] of service [" + getServiceName() + "]";
		}
		// Lazily prepare service and stub if necessary.
		synchronized (this.preparationMonitor) {
			if (!isPrepared()) {
				prepare();
			}
		}
		return doInvoke(invocation);
	}

	/**
	 * Perform a JAX-WS service invocation based on the given method invocation.
	 * @param invocation the AOP method invocation
	 * @return the invocation result, if any
	 * @throws Throwable in case of invocation failure
	 * @see #getPortStub()
	 * @see #doInvoke(org.aopalliance.intercept.MethodInvocation, Object)
	 */
	/**
	 * 根据给定的方法调用执行JAX-WS服务调用。 
	 *  
	 * @param 调用AOP方法调用
	 * @return 调用结果（如果有）
	 * @throws 在调用失败的情况下可抛出
	 * @see  #getPortStub（）
	 * @see  #doInvoke（org.aopalliance.intercept。 
	 * 方法调用，对象）
	 */
	@Nullable
	protected Object doInvoke(MethodInvocation invocation) throws Throwable {
		try {
			return doInvoke(invocation, getPortStub());
		}
		catch (SOAPFaultException ex) {
			throw new JaxWsSoapFaultException(ex);
		}
		catch (ProtocolException ex) {
			throw new RemoteConnectFailureException(
					"Could not connect to remote service [" + getEndpointAddress() + "]", ex);
		}
		catch (WebServiceException ex) {
			throw new RemoteAccessException(
					"Could not access remote service at [" + getEndpointAddress() + "]", ex);
		}
	}

	/**
	 * Perform a JAX-WS service invocation on the given port stub.
	 * @param invocation the AOP method invocation
	 * @param portStub the RMI port stub to invoke
	 * @return the invocation result, if any
	 * @throws Throwable in case of invocation failure
	 * @see #getPortStub()
	 */
	/**
	 * 在给定的端口存根上执行JAX-WS服务调用。 
	 *  
	 * @param 调用AOP方法调用
	 * @param  portStub RMI端口存根以调用
	 * @return 调用结果（如果有的话）
	 * @throws 调用失败时可抛出
	 * @see  #getPortStub（）
	 */
	@Nullable
	protected Object doInvoke(MethodInvocation invocation, @Nullable Object portStub) throws Throwable {
		Method method = invocation.getMethod();
		try {
			return method.invoke(portStub, invocation.getArguments());
		}
		catch (InvocationTargetException ex) {
			throw ex.getTargetException();
		}
		catch (Throwable ex) {
			throw new RemoteProxyFailureException("Invocation of stub method failed: " + method, ex);
		}
	}

}
