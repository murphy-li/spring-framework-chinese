/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.testfixture.http.server.reactive;

import java.net.InetSocketAddress;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;

import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferFactory;
import org.springframework.core.io.buffer.DefaultDataBufferFactory;
import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRange;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.AbstractServerHttpRequest;
import org.springframework.http.server.reactive.SslInfo;
import org.springframework.lang.Nullable;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MimeType;
import org.springframework.util.MultiValueMap;
import org.springframework.web.util.UriComponentsBuilder;

/**
 * Mock extension of {@link AbstractServerHttpRequest} for use in tests without
 * an actual server. Use the static methods to obtain a builder.
 *
 * @author Rossen Stoyanchev
 * @since 5.0
 */
/**
 * {@link  AbstractServerHttpRequest}的模拟扩展，用于没有实际服务器的测试。 
 * 使用静态方法获取构建器。 
 *  @author  Rossen Stoyanchev @从5.0开始
 */
public final class MockServerHttpRequest extends AbstractServerHttpRequest {

	private final HttpMethod httpMethod;

	private final MultiValueMap<String, HttpCookie> cookies;

	@Nullable
	private final InetSocketAddress remoteAddress;

	@Nullable
	private final InetSocketAddress localAddress;

	@Nullable
	private final SslInfo sslInfo;

	private final Flux<DataBuffer> body;


	private MockServerHttpRequest(HttpMethod httpMethod, URI uri, @Nullable String contextPath,
			HttpHeaders headers, MultiValueMap<String, HttpCookie> cookies,
			@Nullable InetSocketAddress remoteAddress, @Nullable InetSocketAddress localAddress,
			@Nullable SslInfo sslInfo, Publisher<? extends DataBuffer> body) {

		super(uri, contextPath, headers);
		this.httpMethod = httpMethod;
		this.cookies = cookies;
		this.remoteAddress = remoteAddress;
		this.localAddress = localAddress;
		this.sslInfo = sslInfo;
		this.body = Flux.from(body);
	}


	@Override
	public HttpMethod getMethod() {
		return this.httpMethod;
	}

	@Override
	public String getMethodValue() {
		return this.httpMethod.name();
	}

	@Override
	@Nullable
	public InetSocketAddress getRemoteAddress() {
		return this.remoteAddress;
	}

	@Nullable
	@Override
	public InetSocketAddress getLocalAddress() {
		return this.localAddress;
	}

	@Nullable
	@Override
	protected SslInfo initSslInfo() {
		return this.sslInfo;
	}

	@Override
	public Flux<DataBuffer> getBody() {
		return this.body;
	}

	@Override
	protected MultiValueMap<String, HttpCookie> initCookies() {
		return this.cookies;
	}

	@Override
	public <T> T getNativeRequest() {
		throw new IllegalStateException("This is a mock. No running server, no native request.");
	}


	// Static builder methods

	/**
	 * Create a builder with the given HTTP method and a {@link URI}.
	 * @param method the HTTP method (GET, POST, etc)
	 * @param url the URL
	 * @return the created builder
	 */
	/**
	 * 使用给定的HTTP方法和{@link  URI}创建一个构建器。 
	 *  
	 * @param 方法HTTP方法（GET，POST等）
	 * @param  URL URL 
	 * @return 创建的构建器
	 */
	public static BodyBuilder method(HttpMethod method, URI url) {
		return new DefaultBodyBuilder(method, url);
	}

	/**
	 * Alternative to {@link #method(HttpMethod, URI)} that accepts a URI template.
	 * The given URI may contain query parameters, or those may be added later via
	 * {@link BaseBuilder#queryParam queryParam} builder methods.
	 * @param method the HTTP method (GET, POST, etc)
	 * @param urlTemplate the URL template
	 * @param vars variables to expand into the template
	 * @return the created builder
	 */
	/**
	 * 替代{@link  #method（HttpMethod，URI）}的替代方法，该方法接受URI模板。 
	 * 给定的URI可以包含查询参数，或者可以稍后通过{@link  BaseBuilder＃queryParam queryParam}构建器方法添加这些参数。 
	 *  
	 * @param 方法HTTP方法（GET，POST等）
	 * @param  urlTemplate URL模板
	 * @param  vars变量以扩展为模板
	 * @return 创建的构建器
	 */
	public static BodyBuilder method(HttpMethod method, String urlTemplate, Object... vars) {
		URI url = UriComponentsBuilder.fromUriString(urlTemplate).buildAndExpand(vars).encode().toUri();
		return new DefaultBodyBuilder(method, url);
	}

	/**
	 * Create an HTTP GET builder with the given URI template. The given URI may
	 * contain query parameters, or those may be added later via
	 * {@link BaseBuilder#queryParam queryParam} builder methods.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * 使用给定的URI模板创建HTTP GET构建器。 
	 * 给定的URI可以包含查询参数，或者可以稍后通过{@link  BaseBuilder＃queryParam queryParam}构建器方法添加这些参数。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BaseBuilder<?> get(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.GET, urlTemplate, uriVars);
	}

	/**
	 * HTTP HEAD variant. See {@link #get(String, Object...)} for general info.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP HEAD变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BaseBuilder<?> head(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.HEAD, urlTemplate, uriVars);
	}

	/**
	 * HTTP POST variant. See {@link #get(String, Object...)} for general info.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP POST变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BodyBuilder post(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.POST, urlTemplate, uriVars);
	}

	/**
	 * HTTP PUT variant. See {@link #get(String, Object...)} for general info.
	 * {@link BaseBuilder#queryParam queryParam} builder methods.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP PUT变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  {@link  BaseBuilder＃queryParam queryParam}构建器方法。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BodyBuilder put(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.PUT, urlTemplate, uriVars);
	}

	/**
	 * HTTP PATCH variant. See {@link #get(String, Object...)} for general info.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP PATCH变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BodyBuilder patch(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.PATCH, urlTemplate, uriVars);
	}

	/**
	 * HTTP DELETE variant. See {@link #get(String, Object...)} for general info.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP DELETE变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BaseBuilder<?> delete(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.DELETE, urlTemplate, uriVars);
	}

	/**
	 * HTTP OPTIONS variant. See {@link #get(String, Object...)} for general info.
	 * @param urlTemplate a URL template; the resulting URL will be encoded
	 * @param uriVars zero or more URI variables
	 * @return the created builder
	 */
	/**
	 * HTTP OPTIONS变体。 
	 * 有关一般信息，请参见{@link  #get（String，Object ...）}。 
	 *  
	 * @param  urlTemplate URL模板； 
	 * 生成的URL将被编码
	 * @param  uriVars零个或多个URI变量
	 * @return 创建的构建器
	 */
	public static BaseBuilder<?> options(String urlTemplate, Object... uriVars) {
		return method(HttpMethod.OPTIONS, urlTemplate, uriVars);
	}


	/**
	 * Request builder exposing properties not related to the body.
	 * @param <B> the builder sub-class
	 */
	/**
	 * 请求构建器公开与主体无关的属性。 
	 *  
	 * @param  <B>构建器子类
	 */
	public interface BaseBuilder<B extends BaseBuilder<B>> {

		/**
		 * Set the contextPath to return.
		 */
		/**
		 * 设置contextPath返回。 
		 * 
		 */
		B contextPath(String contextPath);

		/**
		 * Append the given query parameter to the existing query parameters.
		 * If no values are given, the resulting URI will contain the query
		 * parameter name only (i.e. {@code ?foo} instead of {@code ?foo=bar}).
		 * <p>The provided query name and values will be encoded.
		 * @param name the query parameter name
		 * @param values the query parameter values
		 * @return this UriComponentsBuilder
		 */
		/**
		 * 将给定的查询参数附加到现有的查询参数。 
		 * 如果未提供任何值，则结果URI将仅包含查询参数名称（即{@code ？foo}而不是{@code ？foo = bar}）。 
		 *  <p>提供的查询名称和值将被编码。 
		 *  
		 * @param 命名查询参数名称
		 * @param 值查询参数值
		 * @return 此UriComponentsBuilder
		 */
		B queryParam(String name, Object... values);

		/**
		 * Add the given query parameters and values. The provided query name
		 * and corresponding values will be encoded.
		 * @param params the params
		 * @return this UriComponentsBuilder
		 */
		/**
		 * 添加给定的查询参数和值。 
		 * 提供的查询名称和相应的值将被编码。 
		 *  
		 * @param 参数params 
		 * @return 此UriComponentsBuilder
		 */
		B queryParams(MultiValueMap<String, String> params);

		/**
		 * Set the remote address to return.
		 */
		/**
		 * 设置返回的远程地址。 
		 * 
		 */
		B remoteAddress(InetSocketAddress remoteAddress);

		/**
		 * Set the local address to return.
		 * @since 5.2.3
		 */
		/**
		 * 将本地地址设置为返回。 
		 *  @从5.2.3开始
		 */
		B localAddress(InetSocketAddress localAddress);

		/**
		 * Set SSL session information and certificates.
		 */
		/**
		 * 设置SSL会话信息和证书。 
		 * 
		 */
		void sslInfo(SslInfo sslInfo);

		/**
		 * Add one or more cookies.
		 */
		/**
		 * 添加一个或多个Cookie。 
		 * 
		 */
		B cookie(HttpCookie... cookie);

		/**
		 * Add the given cookies.
		 * @param cookies the cookies.
		 */
		/**
		 * 添加给定的cookie。 
		 *  
		 * @param  cookie cookie。 
		 * 
		 */
		B cookies(MultiValueMap<String, HttpCookie> cookies);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @see HttpHeaders#add(String, String)
		 */
		/**
		 * 在给定名称下添加给定的单个标头值。 
		 *  
		 * @param  headerName标头名称
		 * @param  headerValues标头值
		 * @see  HttpHeaders＃add（String，String）
		 */
		B header(String headerName, String... headerValues);

		/**
		 * Add the given header values.
		 * @param headers the header values
		 */
		/**
		 * 添加给定的标头值。 
		 *  
		 * @param 标头标头值
		 */
		B headers(MultiValueMap<String, String> headers);

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 */
		/**
		 * 设置可接受的{@link  plain MediaType媒体类型}列表，如{@code  Accept}标头所指定。 
		 *  
		 * @param  acceptMediaMedias可接受的媒体类型
		 */
		B accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 */
		/**
		 * 按照{@code  Accept-Charset}标头指定的设置可接受的{@link  plain Charset字符集}的列表。 
		 *  
		 * @param  acceptableCharsets可接受的字符集
		 */
		B acceptCharset(Charset... acceptableCharsets);

		/**
		 * Set the list of acceptable {@linkplain Locale locales}, as specified
		 * by the {@code Accept-Languages} header.
		 * @param acceptableLocales the acceptable locales
		 */
		/**
		 * 按照{@code  Accept-Languages}标头指定的设置可接受的{@link  plain Locale locales}的列表。 
		 *  
		 * @param  acceptableLocales可接受的语言环境
		 */
		B acceptLanguageAsLocales(Locale... acceptableLocales);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 */
		/**
		 * 设置{@code  If-Modified-Since}标头的值。 
		 *  <p>日期应指定为格林尼治标准时间1970年1月1日以来的毫秒数。 
		 *  
		 * @param  ifModifiedSince标头的新值
		 */
		B ifModifiedSince(long ifModifiedSince);

		/**
		 * Set the (new) value of the {@code If-Unmodified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifUnmodifiedSince the new value of the header
		 * @see HttpHeaders#setIfUnmodifiedSince(long)
		 */
		/**
		 * 设置{@code  If-Unmodified-Since}标头的（新）值。 
		 *  <p>日期应指定为格林尼治标准时间1970年1月1日以来的毫秒数。 
		 *  
		 * @param  ifUnmodifiedSince标头的新值
		 * @see  HttpHeaders＃setIfUnmodifiedSince（long）
		 */
		B ifUnmodifiedSince(long ifUnmodifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 */
		/**
		 * 设置{@code  If-None-Match}标头的值。 
		 *  
		 * @param  ifNoneMatch标题的新值
		 */
		B ifNoneMatch(String... ifNoneMatches);

		/**
		 * Set the (new) value of the Range header.
		 * @param ranges the HTTP ranges
		 * @see HttpHeaders#setRange(List)
		 */
		/**
		 * 设置范围标头的（新）值。 
		 *  
		 * @param 范围HTTP范围
		 * @see  HttpHeaders＃setRange（列表）
		 */
		B range(HttpRange... ranges);

		/**
		 * Builds the request with no body.
		 * @return the request
		 * @see BodyBuilder#body(Publisher)
		 * @see BodyBuilder#body(String)
		 */
		/**
		 * 毫无要求地建立请求。 
		 *  
		 * @return 请求
		 * @see  BodyBuilder＃body（Publisher）
		 * @see  BodyBuilder＃body（String）
		 */
		MockServerHttpRequest build();

	}

	/**
	 * A builder that adds a body to the request.
	 */
	/**
	 * 向请求添加主体的构建器。 
	 * 
	 */
	public interface BodyBuilder extends BaseBuilder<BodyBuilder> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return this builder
		 * @see HttpHeaders#setContentLength(long)
		 */
		/**
		 * 按照{@code  Content-Length}标头指定的内容，以字节为单位设置正文的长度。 
		 *  
		 * @param  contentLength内容长度
		 * @return 此构建器
		 * @see  HttpHeaders＃setContentLength（long）
		 */
		BodyBuilder contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return this builder
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		/**
		 * 设置主体的{@link  plain MediaType媒体类型}，如{@code  Content-Type}标头所指定。 
		 *  
		 * @param  contentType内容类型
		 * @return 此构建器
		 * @see  HttpHeaders＃setContentType（MediaType）
		 */
		BodyBuilder contentType(MediaType contentType);

		/**
		 * Set the body of the request and build it.
		 * @param body the body
		 * @return the built request entity
		 */
		/**
		 * 设置请求的主体并生成它。 
		 *  
		 * @param 正文正文
		 * @return 已构建的请求实体
		 */
		MockServerHttpRequest body(Publisher<? extends DataBuffer> body);

		/**
		 * Set the body of the request and build it.
		 * <p>The String is assumed to be UTF-8 encoded unless the request has a
		 * "content-type" header with a charset attribute.
		 * @param body the body as text
		 * @return the built request entity
		 */
		/**
		 * 设置请求的主体并生成它。 
		 *  <p>除非请求具有带有charset属性的"content-type"标头，否则该字符串假定为UTF-8编码。 
		 *  
		 * @param 正文正文为文本
		 * @return 构建的请求实体
		 */
		MockServerHttpRequest body(String body);

	}


	private static class DefaultBodyBuilder implements BodyBuilder {

		private static final DataBufferFactory BUFFER_FACTORY = new DefaultDataBufferFactory();


		private final HttpMethod method;

		private final URI url;

		@Nullable
		private String contextPath;

		private final UriComponentsBuilder queryParamsBuilder = UriComponentsBuilder.newInstance();

		private final HttpHeaders headers = new HttpHeaders();

		private final MultiValueMap<String, HttpCookie> cookies = new LinkedMultiValueMap<>();

		@Nullable
		private InetSocketAddress remoteAddress;

		@Nullable
		private InetSocketAddress localAddress;

		@Nullable
		private SslInfo sslInfo;


		public DefaultBodyBuilder(HttpMethod method, URI url) {
			this.method = method;
			this.url = url;
		}

		@Override
		public BodyBuilder contextPath(String contextPath) {
			this.contextPath = contextPath;
			return this;
		}

		@Override
		public BodyBuilder queryParam(String name, Object... values) {
			this.queryParamsBuilder.queryParam(name, values);
			return this;
		}

		@Override
		public BodyBuilder queryParams(MultiValueMap<String, String> params) {
			this.queryParamsBuilder.queryParams(params);
			return this;
		}

		@Override
		public BodyBuilder remoteAddress(InetSocketAddress remoteAddress) {
			this.remoteAddress = remoteAddress;
			return this;
		}

		@Override
		public BodyBuilder localAddress(InetSocketAddress localAddress) {
			this.localAddress = localAddress;
			return this;
		}

		@Override
		public void sslInfo(SslInfo sslInfo) {
			this.sslInfo = sslInfo;
		}

		@Override
		public BodyBuilder cookie(HttpCookie... cookies) {
			Arrays.stream(cookies).forEach(cookie -> this.cookies.add(cookie.getName(), cookie));
			return this;
		}

		@Override
		public BodyBuilder cookies(MultiValueMap<String, HttpCookie> cookies) {
			this.cookies.putAll(cookies);
			return this;
		}

		@Override
		public BodyBuilder header(String headerName, String... headerValues) {
			for (String headerValue : headerValues) {
				this.headers.add(headerName, headerValue);
			}
			return this;
		}

		@Override
		public BodyBuilder headers(MultiValueMap<String, String> headers) {
			this.headers.putAll(headers);
			return this;
		}

		@Override
		public BodyBuilder accept(MediaType... acceptableMediaTypes) {
			this.headers.setAccept(Arrays.asList(acceptableMediaTypes));
			return this;
		}

		@Override
		public BodyBuilder acceptCharset(Charset... acceptableCharsets) {
			this.headers.setAcceptCharset(Arrays.asList(acceptableCharsets));
			return this;
		}

		@Override
		public BodyBuilder acceptLanguageAsLocales(Locale... acceptableLocales) {
			this.headers.setAcceptLanguageAsLocales(Arrays.asList(acceptableLocales));
			return this;
		}

		@Override
		public BodyBuilder contentLength(long contentLength) {
			this.headers.setContentLength(contentLength);
			return this;
		}

		@Override
		public BodyBuilder contentType(MediaType contentType) {
			this.headers.setContentType(contentType);
			return this;
		}

		@Override
		public BodyBuilder ifModifiedSince(long ifModifiedSince) {
			this.headers.setIfModifiedSince(ifModifiedSince);
			return this;
		}

		@Override
		public BodyBuilder ifUnmodifiedSince(long ifUnmodifiedSince) {
			this.headers.setIfUnmodifiedSince(ifUnmodifiedSince);
			return this;
		}

		@Override
		public BodyBuilder ifNoneMatch(String... ifNoneMatches) {
			this.headers.setIfNoneMatch(Arrays.asList(ifNoneMatches));
			return this;
		}

		@Override
		public BodyBuilder range(HttpRange... ranges) {
			this.headers.setRange(Arrays.asList(ranges));
			return this;
		}

		@Override
		public MockServerHttpRequest build() {
			return body(Flux.empty());
		}

		@Override
		public MockServerHttpRequest body(String body) {
			return body(Flux.just(BUFFER_FACTORY.wrap(body.getBytes(getCharset()))));
		}

		private Charset getCharset() {
			return Optional.ofNullable(this.headers.getContentType())
					.map(MimeType::getCharset).orElse(StandardCharsets.UTF_8);
		}

		@Override
		public MockServerHttpRequest body(Publisher<? extends DataBuffer> body) {
			applyCookiesIfNecessary();
			return new MockServerHttpRequest(this.method, getUrlToUse(), this.contextPath,
					this.headers, this.cookies, this.remoteAddress, this.localAddress, this.sslInfo, body);
		}

		private void applyCookiesIfNecessary() {
			if (this.headers.get(HttpHeaders.COOKIE) == null) {
				this.cookies.values().stream().flatMap(Collection::stream)
						.forEach(cookie -> this.headers.add(HttpHeaders.COOKIE, cookie.toString()));
			}
		}

		private URI getUrlToUse() {
			MultiValueMap<String, String> params =
					this.queryParamsBuilder.buildAndExpand().encode().getQueryParams();

			if (!params.isEmpty()) {
				return UriComponentsBuilder.fromUri(this.url).queryParams(params).build(true).toUri();
			}

			return this.url;
		}
	}

}
