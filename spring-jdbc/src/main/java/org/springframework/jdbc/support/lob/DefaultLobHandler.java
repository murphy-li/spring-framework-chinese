/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.support.lob;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.lang.Nullable;

/**
 * Default implementation of the {@link LobHandler} interface.
 * Invokes the direct accessor methods that {@code java.sql.ResultSet}
 * and {@code java.sql.PreparedStatement} offer.
 *
 * <p>By default, incoming streams are going to be passed to the appropriate
 * {@code setBinary/Ascii/CharacterStream} method on the JDBC driver's
 * {@link PreparedStatement}. If the specified content length is negative,
 * this handler will use the JDBC 4.0 variants of the set-stream methods
 * without a length parameter; otherwise, it will pass the specified length
 * on to the driver.
 *
 * <p>This LobHandler should work for any JDBC driver that is JDBC compliant
 * in terms of the spec's suggestions regarding simple BLOB and CLOB handling.
 * This does not apply to Oracle 9i's drivers at all; as of Oracle 10g,
 * it does work but may still come with LOB size limitations. Consider using
 * recent Oracle drivers even when working against an older database server.
 * See the {@link LobHandler} javadoc for the full set of recommendations.
 *
 * <p>Some JDBC drivers require values with a BLOB/CLOB target column to be
 * explicitly set through the JDBC {@code setBlob} / {@code setClob} API:
 * for example, PostgreSQL's driver. Switch the {@link #setWrapAsLob "wrapAsLob"}
 * property to "true" when operating against such a driver.
 *
 * <p>On JDBC 4.0, this LobHandler also supports streaming the BLOB/CLOB content
 * via the {@code setBlob} / {@code setClob} variants that take a stream
 * argument directly. Consider switching the {@link #setStreamAsLob "streamAsLob"}
 * property to "true" when operating against a fully compliant JDBC 4.0 driver.
 *
 * <p>Finally, this LobHandler also supports the creation of temporary BLOB/CLOB
 * objects. Consider switching the {@link #setCreateTemporaryLob "createTemporaryLob"}
 * property to "true" when "streamAsLob" happens to run into LOB size limitations.
 *
 * <p>See the {@link LobHandler} interface javadoc for a summary of recommendations.
 *
 * @author Juergen Hoeller
 * @since 04.12.2003
 * @see java.sql.ResultSet#getBytes
 * @see java.sql.ResultSet#getBinaryStream
 * @see java.sql.ResultSet#getString
 * @see java.sql.ResultSet#getAsciiStream
 * @see java.sql.ResultSet#getCharacterStream
 * @see java.sql.PreparedStatement#setBytes
 * @see java.sql.PreparedStatement#setBinaryStream
 * @see java.sql.PreparedStatement#setString
 * @see java.sql.PreparedStatement#setAsciiStream
 * @see java.sql.PreparedStatement#setCharacterStream
 */
/**
 * {@link  LobHandler}接口的默认实现。 
 * 调用{@code  java.sql.ResultSet}和{@code  java.sql.PreparedStatement}提供的直接访问器方法。 
 *  <p>默认情况下，传入的流将被传递到JDBC驱动程序的{@link  PreparedStatement}上的相应{@code  setBinary / Ascii / CharacterStream}方法。 
 * 如果指定的内容长度为负数，则此处理程序将使用set-stream方法的JDBC 4.0变体，而没有length参数； 
 * 否则，它将把指定的长度传递给驱动程序。 
 *  <p>根据有关简单BLOB和CLOB处理的规范建议，此LobHandler应该适用于所有与JDBC兼容的JDBC驱动程序。 
 * 这一点根本不适用于Oracle 9i的驱动程序。 
 * 从Oracle 10g开始，它确实可以工作，但可能仍具有LOB大小限制。 
 * 即使使用较旧的数据库服务器，也应考虑使用最新的Oracle驱动程序。 
 * 有关完整的建议集，请参见{@link  LobHandler} Javadoc。 
 *  <p>某些JDBC驱动程序要求通过JDBC {@code  setBlob} / {@code  setClob} API显式设置带有BLOB / CLOB目标列的值：例如PostgreSQL的驱动程序。 
 * 针对此类驱动程序进行操作时，请将{@link  #setWrapAsLob"wrapAsLob"}属性切换为"true"。 
 *  <p>在JDBC 4.0上，此LobHandler还支持通过{@code  setBlob} / {@code  setClob}变体（直接采用流参数）流BLOB / CLOB内容。 
 * 当对完全兼容的JDBC 4.0驱动程序进行操作时，请考虑将{@link  #setStreamAsLob"streamAsLob"}属性切换为"true"。 
 *  <p>最后，此LobHandler还支持创建临时BLOB / CLOB对象。 
 * 当"streamAsLob"碰巧遇到LOB大小限制时，请考虑将{@link  #setCreateTemporaryLob"createTemporaryLob"}属性切换为"true"。 
 *  <p>有关建议的摘要，请参见{@link  LobHandler}接口javadoc。 
 *  @author  Juergen Hoeller @2003年12月4日起
 * @see  java.sql.ResultSet＃getBytes 
 * @see  java.sql.ResultSet＃getBinaryStream 
 * @see  java.sql.ResultSet＃getString 
 * @see  Java。 
 *  sql.ResultSet＃getAsciiStream 
 * @see  java.sql.ResultSet＃getCharacterStream 
 * @see  java.sql.PreparedStatement＃setBytes 
 * @see  java.sql.PreparedStatement＃setBinaryStream 
 * @see  java.sql.PreparedStatement＃setString 
 * @see  java.sql.PreparedStatement＃setAsciiStream 
 * @see  java.sql.PreparedStatement＃setCharacterStream
 */
public class DefaultLobHandler extends AbstractLobHandler {

	protected final Log logger = LogFactory.getLog(getClass());

	private boolean wrapAsLob = false;

	private boolean streamAsLob = false;

	private boolean createTemporaryLob = false;


	/**
	 * Specify whether to submit a byte array / String to the JDBC driver
	 * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /
	 * {@code setClob} method with a Blob / Clob argument.
	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
	 * / {@code setCharacterStream} method for setting the content. Switch this
	 * to "true" for explicit Blob / Clob wrapping against JDBC drivers that
	 * are known to require such wrapping (e.g. PostgreSQL's for access to OID
	 * columns, whereas BYTEA columns need to be accessed the standard way).
	 * <p>This setting affects byte array / String arguments as well as stream
	 * arguments, unless {@link #setStreamAsLob "streamAsLob"} overrides this
	 * handling to use JDBC 4.0's new explicit streaming support (if available).
	 * @see java.sql.PreparedStatement#setBlob(int, java.sql.Blob)
	 * @see java.sql.PreparedStatement#setClob(int, java.sql.Clob)
	 */
	/**
	 * 使用带有Blob / Clob参数的JDBC {@code  setBlob} / {@code  setClob}方法，指定是否将字节数组/ String提交给包裹在JDBC Blob / Clob对象中的JDBC驱动程序。 
	 *  <p>默认为"false"，使用通用的JDBC 2.0 {@code  setBinaryStream} / {@code  setCharacterStream}方法设置内容。 
	 * 将其切换为"true"以针对已知需要这种包装的JDBC驱动程序进行显式Blob / Clob包装（例如，PostgreSQL用于访问OID列，而BYTEA列则需要以标准方式进行访问）。 
	 *  <p>此设置会影响字节数组/字符串参数以及流参数，除非{@link  #setStreamAsLob"streamAsLob"}覆盖此处理以使用JDBC 4.0的新显式流支持（如果有）。 
	 *  
	 * @see  java.sql.PreparedStatement＃setBlob（int，java.sql.Blob）
	 * @see  java.sql.PreparedStatement＃setClob（int，java.sql.Clob）
	 */
	public void setWrapAsLob(boolean wrapAsLob) {
		this.wrapAsLob = wrapAsLob;
	}

	/**
	 * Specify whether to submit a binary stream / character stream to the JDBC
	 * driver as explicit LOB content, using the JDBC 4.0 {@code setBlob} /
	 * {@code setClob} method with a stream argument.
	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
	 * / {@code setCharacterStream} method for setting the content.
	 * Switch this to "true" for explicit JDBC 4.0 streaming, provided that your
	 * JDBC driver actually supports those JDBC 4.0 operations (e.g. Derby's).
	 * <p>This setting affects stream arguments as well as byte array / String
	 * arguments, requiring JDBC 4.0 support. For supporting LOB content against
	 * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.
	 * @see java.sql.PreparedStatement#setBlob(int, java.io.InputStream, long)
	 * @see java.sql.PreparedStatement#setClob(int, java.io.Reader, long)
	 */
	/**
	 * 使用带有流参数的JDBC 4.0 {@code  setBlob} / {@code  setClob}方法，指定是否将二进制流/字符流作为显式LOB内容提交给JDBC驱动程序。 
	 *  <p>默认为"false"，使用通用的JDBC 2.0 {@code  setBinaryStream} / {@code  setCharacterStream}方法设置内容。 
	 * 如果您的JDBC驱动程序实际上支持那些JDBC 4.0操作（例如Derby），则将其切换为"true"以进行明确的JDBC 4.0流传输。 
	 *  <p>此设置影响流参数以及字节数组/字符串参数，需要JDBC 4.0支持。 
	 * 要支持JDBC 3.0的LOB内容，请检查{@link  #setWrapAsLob"wrapAsLob"}设置。 
	 *  
	 * @see  java.sql.PreparedStatement＃setBlob（int，java.io.InputStream，长）
	 * @see  java.sql.PreparedStatement＃setClob（int，java.io.Reader，long）
	 */
	public void setStreamAsLob(boolean streamAsLob) {
		this.streamAsLob = streamAsLob;
	}

	/**
	 * Specify whether to copy a byte array / String into a temporary JDBC
	 * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /
	 * {@code createClob} methods.
	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
	 * / {@code setCharacterStream} method for setting the content. Switch this
	 * to "true" for explicit Blob / Clob creation using JDBC 4.0.
	 * <p>This setting affects stream arguments as well as byte array / String
	 * arguments, requiring JDBC 4.0 support. For supporting LOB content against
	 * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.
	 * @see java.sql.Connection#createBlob()
	 * @see java.sql.Connection#createClob()
	 */
	/**
	 * 指定是否将字节数组/字符串复制到通过JDBC 4.0 {@code  createBlob} / {@code  createClob}方法创建的临时JDBC Blob / Clob对象中。 
	 *  <p>默认为"false"，使用通用的JDBC 2.0 {@code  setBinaryStream} / {@code  setCharacterStream}方法设置内容。 
	 * 将其切换为"true"以使用JDBC 4.0显式创建Blob / Clob。 
	 *  <p>此设置影响流参数以及字节数组/字符串参数，需要JDBC 4.0支持。 
	 * 要支持JDBC 3.0的LOB内容，请检查{@link  #setWrapAsLob"wrapAsLob"}设置。 
	 *  
	 * @see  java.sql.Connection＃createBlob（）
	 * @see  java.sql.Connection＃createClob（）
	 */
	public void setCreateTemporaryLob(boolean createTemporaryLob) {
		this.createTemporaryLob = createTemporaryLob;
	}


	@Override
	@Nullable
	public byte[] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException {
		logger.debug("Returning BLOB as bytes");
		if (this.wrapAsLob) {
			Blob blob = rs.getBlob(columnIndex);
			return blob.getBytes(1, (int) blob.length());
		}
		else {
			return rs.getBytes(columnIndex);
		}
	}

	@Override
	@Nullable
	public InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {
		logger.debug("Returning BLOB as binary stream");
		if (this.wrapAsLob) {
			Blob blob = rs.getBlob(columnIndex);
			return blob.getBinaryStream();
		}
		else {
			return rs.getBinaryStream(columnIndex);
		}
	}

	@Override
	@Nullable
	public String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {
		logger.debug("Returning CLOB as string");
		if (this.wrapAsLob) {
			Clob clob = rs.getClob(columnIndex);
			return clob.getSubString(1, (int) clob.length());
		}
		else {
			return rs.getString(columnIndex);
		}
	}

	@Override
	public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {
		logger.debug("Returning CLOB as ASCII stream");
		if (this.wrapAsLob) {
			Clob clob = rs.getClob(columnIndex);
			return clob.getAsciiStream();
		}
		else {
			return rs.getAsciiStream(columnIndex);
		}
	}

	@Override
	public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {
		logger.debug("Returning CLOB as character stream");
		if (this.wrapAsLob) {
			Clob clob = rs.getClob(columnIndex);
			return clob.getCharacterStream();
		}
		else {
			return rs.getCharacterStream(columnIndex);
		}
	}

	@Override
	public LobCreator getLobCreator() {
		return (this.createTemporaryLob ? new TemporaryLobCreator() : new DefaultLobCreator());
	}


	/**
	 * Default LobCreator implementation as an inner class.
	 * Can be subclassed in DefaultLobHandler extensions.
	 */
	/**
	 * 默认的LobCreator实现作为内部类。 
	 * 可以在DefaultLobHandler扩展中子类化。 
	 * 
	 */
	protected class DefaultLobCreator implements LobCreator {

		@Override
		public void setBlobAsBytes(PreparedStatement ps, int paramIndex, @Nullable byte[] content)
				throws SQLException {

			if (streamAsLob) {
				if (content != null) {
					ps.setBlob(paramIndex, new ByteArrayInputStream(content), content.length);
				}
				else {
					ps.setBlob(paramIndex, (Blob) null);
				}
			}
			else if (wrapAsLob) {
				if (content != null) {
					ps.setBlob(paramIndex, new PassThroughBlob(content));
				}
				else {
					ps.setBlob(paramIndex, (Blob) null);
				}
			}
			else {
				ps.setBytes(paramIndex, content);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(content != null ? "Set bytes for BLOB with length " + content.length :
						"Set BLOB to null");
			}
		}

		@Override
		public void setBlobAsBinaryStream(
				PreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength)
				throws SQLException {

			if (streamAsLob) {
				if (binaryStream != null) {
					if (contentLength >= 0) {
						ps.setBlob(paramIndex, binaryStream, contentLength);
					}
					else {
						ps.setBlob(paramIndex, binaryStream);
					}
				}
				else {
					ps.setBlob(paramIndex, (Blob) null);
				}
			}
			else if (wrapAsLob) {
				if (binaryStream != null) {
					ps.setBlob(paramIndex, new PassThroughBlob(binaryStream, contentLength));
				}
				else {
					ps.setBlob(paramIndex, (Blob) null);
				}
			}
			else if (contentLength >= 0) {
				ps.setBinaryStream(paramIndex, binaryStream, contentLength);
			}
			else {
				ps.setBinaryStream(paramIndex, binaryStream);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(binaryStream != null ? "Set binary stream for BLOB with length " + contentLength :
						"Set BLOB to null");
			}
		}

		@Override
		public void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content)
				throws SQLException {

			if (streamAsLob) {
				if (content != null) {
					ps.setClob(paramIndex, new StringReader(content), content.length());
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else if (wrapAsLob) {
				if (content != null) {
					ps.setClob(paramIndex, new PassThroughClob(content));
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else {
				ps.setString(paramIndex, content);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(content != null ? "Set string for CLOB with length " + content.length() :
						"Set CLOB to null");
			}
		}

		@Override
		public void setClobAsAsciiStream(
				PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength)
				throws SQLException {

			if (streamAsLob) {
				if (asciiStream != null) {
					Reader reader = new InputStreamReader(asciiStream, StandardCharsets.US_ASCII);
					if (contentLength >= 0) {
						ps.setClob(paramIndex, reader, contentLength);
					}
					else {
						ps.setClob(paramIndex, reader);
					}
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else if (wrapAsLob) {
				if (asciiStream != null) {
					ps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else if (contentLength >= 0) {
				ps.setAsciiStream(paramIndex, asciiStream, contentLength);
			}
			else {
				ps.setAsciiStream(paramIndex, asciiStream);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(asciiStream != null ? "Set ASCII stream for CLOB with length " + contentLength :
						"Set CLOB to null");
			}
		}

		@Override
		public void setClobAsCharacterStream(
				PreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength)
				throws SQLException {

			if (streamAsLob) {
				if (characterStream != null) {
					if (contentLength >= 0) {
						ps.setClob(paramIndex, characterStream, contentLength);
					}
					else {
						ps.setClob(paramIndex, characterStream);
					}
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else if (wrapAsLob) {
				if (characterStream != null) {
					ps.setClob(paramIndex, new PassThroughClob(characterStream, contentLength));
				}
				else {
					ps.setClob(paramIndex, (Clob) null);
				}
			}
			else if (contentLength >= 0) {
				ps.setCharacterStream(paramIndex, characterStream, contentLength);
			}
			else {
				ps.setCharacterStream(paramIndex, characterStream);
			}
			if (logger.isDebugEnabled()) {
				logger.debug(characterStream != null ? "Set character stream for CLOB with length " + contentLength :
						"Set CLOB to null");
			}
		}

		@Override
		public void close() {
			// nothing to do when not creating temporary LOBs
		}
	}

}
