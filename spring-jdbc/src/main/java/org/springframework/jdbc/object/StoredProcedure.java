/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.object;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.dao.DataAccessException;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ParameterMapper;
import org.springframework.jdbc.core.SqlParameter;

/**
 * Superclass for object abstractions of RDBMS stored procedures.
 * This class is abstract and it is intended that subclasses will provide a typed
 * method for invocation that delegates to the supplied {@link #execute} method.
 *
 * <p>The inherited {@link #setSql sql} property is the name of the stored procedure
 * in the RDBMS.
 *
 * @author Rod Johnson
 * @author Thomas Risberg
 */
/**
 * RDBMS存储过程的对象抽象的超类。 
 * 此类是抽象的，旨在使子类提供一种类型化的调用方法，该方法委托给提供的{@link  #execute}方法。 
 *  <p>继承的{@link  #setSql sql}属性是RDBMS中存储过程的名称。 
 *  @author 罗德·约翰逊@author 托马斯·里斯伯格
 */
public abstract class StoredProcedure extends SqlCall {

	/**
	 * Allow use as a bean.
	 */
	/**
	 * 允许用作Bean。 
	 * 
	 */
	protected StoredProcedure() {
	}

	/**
	 * Create a new object wrapper for a stored procedure.
	 * @param ds the DataSource to use throughout the lifetime
	 * of this object to obtain connections
	 * @param name name of the stored procedure in the database
	 */
	/**
	 * 为存储过程创建一个新的对象包装。 
	 *  
	 * @param  ds在该对象的整个生命周期中使用的数据源，以获取连接
	 * @param 名称数据库中存储过程的名称
	 */
	protected StoredProcedure(DataSource ds, String name) {
		setDataSource(ds);
		setSql(name);
	}

	/**
	 * Create a new object wrapper for a stored procedure.
	 * @param jdbcTemplate the JdbcTemplate which wraps DataSource
	 * @param name name of the stored procedure in the database
	 */
	/**
	 * 为存储过程创建一个新的对象包装。 
	 *  
	 * @param  jdbcTemplate包装数据源的JdbcTemplate 
	 * @param 名称数据库中存储过程的名称
	 */
	protected StoredProcedure(JdbcTemplate jdbcTemplate, String name) {
		setJdbcTemplate(jdbcTemplate);
		setSql(name);
	}


	/**
	 * StoredProcedure parameter Maps are by default allowed to contain
	 * additional entries that are not actually used as parameters.
	 */
	/**
	 * 默认情况下，StoredProcedure参数映射允许包含实际上不用作参数的其他条目。 
	 * 
	 */
	@Override
	protected boolean allowsUnusedParameters() {
		return true;
	}

	/**
	 * Declare a parameter. Overridden method.
	 * Parameters declared as {@code SqlParameter} and {@code SqlInOutParameter}
	 * will always be used to provide input values.  In addition to this any parameter declared
	 * as {@code SqlOutParameter} where an non-null input value is provided will also be used
	 * as an input paraneter.
	 * <b>Note: Calls to declareParameter must be made in the same order as
	 * they appear in the database's stored procedure parameter list.</b>
	 * Names are purely used to help mapping.
	 * @param param parameter object
	 */
	/**
	 * 声明一个参数。 
	 * 重写的方法。 
	 * 声明为{@code  SqlParameter}和{@code  SqlInOutParameter}的参数将始终用于提供输入值。 
	 * 除此之外，任何声明为{@code  SqlOutParameter}的参数（其中提供了非空输入值）也将用作输入参数。 
	 *  <b>注意：必须以与数据库存储过程参数列表中出现的顺序相同的顺序进行对defineParameter的调用。 
	 * </ b>名称仅用于帮助映射。 
	 *  
	 * @param 参数参数对象
	 */
	@Override
	public void declareParameter(SqlParameter param) throws InvalidDataAccessApiUsageException {
		if (param.getName() == null) {
			throw new InvalidDataAccessApiUsageException("Parameters to stored procedures must have names as well as types");
		}
		super.declareParameter(param);
	}

	/**
	 * Execute the stored procedure with the provided parameter values. This is
	 * a convenience method where the order of the passed in parameter values
	 * must match the order that the parameters where declared in.
	 * @param inParams variable number of input parameters. Output parameters should
	 * not be included in this map. It is legal for values to be {@code null}, and this
	 * will produce the correct behavior using a NULL argument to the stored procedure.
	 * @return map of output params, keyed by name as in parameter declarations.
	 * Output parameters will appear here, with their values after the stored procedure
	 * has been called.
	 */
	/**
	 * 使用提供的参数值执行存储过程。 
	 * 这是一种方便的方法，其中传入的参数值的顺序必须与声明参数的顺序相匹配。 
	 * 
	 * @param  inParams输入参数的可变数量。 
	 * 输出参数不应包含在此映射中。 
	 * 值为{@code  null}是合法的，这将使用存储过程的NULL参数产生正确的行为。 
	 * 输出参数的
	 * @return 映射，按名称声明，如参数声明中所述。 
	 * 在存储过程被调用之后，输出参数及其值将显示在此处。 
	 * 
	 */
	public Map<String, Object> execute(Object... inParams) {
		Map<String, Object> paramsToUse = new HashMap<>();
		validateParameters(inParams);
		int i = 0;
		for (SqlParameter sqlParameter : getDeclaredParameters()) {
			if (sqlParameter.isInputValueProvided() && i < inParams.length) {
				paramsToUse.put(sqlParameter.getName(), inParams[i++]);
			}
		}
		return getJdbcTemplate().call(newCallableStatementCreator(paramsToUse), getDeclaredParameters());
	}

	/**
	 * Execute the stored procedure. Subclasses should define a strongly typed
	 * execute method (with a meaningful name) that invokes this method, populating
	 * the input map and extracting typed values from the output map. Subclass
	 * execute methods will often take domain objects as arguments and return values.
	 * Alternatively, they can return void.
	 * @param inParams map of input parameters, keyed by name as in parameter
	 * declarations. Output parameters need not (but can) be included in this map.
	 * It is legal for map entries to be {@code null}, and this will produce the
	 * correct behavior using a NULL argument to the stored procedure.
	 * @return map of output params, keyed by name as in parameter declarations.
	 * Output parameters will appear here, with their values after the
	 * stored procedure has been called.
	 */
	/**
	 * 执行存储过程。 
	 * 子类应定义一个强类型的execute方法（具有有意义的名称），该方法将调用此方法，填充输入映射并从输出映射中提取类型化的值。 
	 * 子类的execute方法通常将域对象作为参数并返回值。 
	 * 或者，它们可以返回void。 
	 *  
	 * @param  inParams输入参数的映射，按名称声明，如参数声明中所述。 
	 * 输出参数不必（但可以）包含在此映射中。 
	 * 映射条目为{@code  null}是合法的，这将使用存储过程的NULL参数产生正确的行为。 
	 * 输出参数的
	 * @return 映射，按名称声明，如参数声明中所述。 
	 * 在存储过程被调用之后，输出参数及其值将显示在此处。 
	 * 
	 */
	public Map<String, Object> execute(Map<String, ?> inParams) throws DataAccessException {
		validateParameters(inParams.values().toArray());
		return getJdbcTemplate().call(newCallableStatementCreator(inParams), getDeclaredParameters());
	}

	/**
	 * Execute the stored procedure. Subclasses should define a strongly typed
	 * execute method (with a meaningful name) that invokes this method, passing in
	 * a ParameterMapper that will populate the input map.  This allows mapping database
	 * specific features since the ParameterMapper has access to the Connection object.
	 * The execute method is also responsible for extracting typed values from the output map.
	 * Subclass execute methods will often take domain objects as arguments and return values.
	 * Alternatively, they can return void.
	 * @param inParamMapper map of input parameters, keyed by name as in parameter
	 * declarations. Output parameters need not (but can) be included in this map.
	 * It is legal for map entries to be {@code null}, and this will produce the correct
	 * behavior using a NULL argument to the stored procedure.
	 * @return map of output params, keyed by name as in parameter declarations.
	 * Output parameters will appear here, with their values after the
	 * stored procedure has been called.
	 */
	/**
	 * 执行存储过程。 
	 * 子类应定义一个强类型的execute方法（具有有意义的名称），该方法调用此方法，并传入ParameterMapper并将填充输入映射。 
	 * 这允许映射数据库特定的功能，因为ParameterMapper可以访问Connection对象。 
	 *  execute方法还负责从输出映射中提取类型化的值。 
	 * 子类的execute方法通常将域对象作为参数并返回值。 
	 * 或者，它们可以返回void。 
	 * 输入参数的
	 * @param  inParamMapper映射，按名称声明，如参数声明中所述。 
	 * 输出参数不必（但可以）包含在此映射中。 
	 * 映射条目为{@code  null}是合法的，这将使用存储过程的NULL参数产生正确的行为。 
	 * 输出参数的
	 * @return 映射，按名称声明，如参数声明中所述。 
	 * 在存储过程被调用之后，输出参数及其值将显示在此处。 
	 * 
	 */
	public Map<String, Object> execute(ParameterMapper inParamMapper) throws DataAccessException {
		checkCompiled();
		return getJdbcTemplate().call(newCallableStatementCreator(inParamMapper), getDeclaredParameters());
	}

}
