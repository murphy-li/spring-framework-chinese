/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.object;

import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.dao.DataAccessException;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterUtils;
import org.springframework.jdbc.core.namedparam.ParsedSql;
import org.springframework.lang.Nullable;

/**
 * Reusable operation object representing an SQL query.
 *
 * <p>Subclasses must implement the {@link #newRowMapper} method to provide
 * an object that can extract the results of iterating over the
 * {@code ResultSet} created during the execution of the query.
 *
 * <p>This class provides a number of public {@code execute} methods that are
 * analogous to the different convenient JDO query execute methods. Subclasses
 * can either rely on one of these inherited methods, or can add their own
 * custom execution methods, with meaningful names and typed parameters
 * (definitely a best practice). Each custom query method will invoke one of
 * this class's untyped query methods.
 *
 * <p>Like all {@code RdbmsOperation} classes that ship with the Spring
 * Framework, {@code SqlQuery} instances are thread-safe after their
 * initialization is complete. That is, after they are constructed and configured
 * via their setter methods, they can be used safely from multiple threads.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Thomas Risberg
 * @param <T> the result type
 * @see SqlUpdate
 */
/**
 * 表示SQL查询的可重用操作对象。 
 *  <p>子类必须实现{@link  #newRowMapper}方法，以提供一个对象，该对象可以提取在执行查询期间创建的{@code  ResultSet}上进行迭代的结果。 
 *  <p>此类提供许多公共的{@code  execute}方法，这些方法类似于不同的便捷JDO查询执行方法。 
 * 子类可以依赖于这些继承的方法之一，也可以添加具有有意义的名称和类型化参数的自定义执行方法（绝对是最佳实践）。 
 * 每个自定义查询方法将调用此类的无类型查询方法之一。 
 *  <p>就像Spring框架附带的所有{@code  RdbmsOperation}类一样，{<@code> SqlQuery}实例在初始化完成后也是线程安全的。 
 * 也就是说，在通过其setter方法构造和配置它们之后，可以从多个线程中安全地使用它们。 
 *  @author  Rod Johnson @author  Juergen Hoeller @author  Thomas Risberg 
 * @param  <T>结果类型
 * @see  SqlUpdate
 */
public abstract class SqlQuery<T> extends SqlOperation {

	/** The number of rows to expect; if 0, unknown. */
	/**
	 * 预期的行数； 
	 * 如果为0，则未知。 
	 * 
	 */
	private int rowsExpected = 0;


	/**
	 * Constructor to allow use as a JavaBean.
	 * <p>The {@code DataSource} and SQL must be supplied before
	 * compilation and use.
	 */
	/**
	 * 允许用作JavaBean的构造方法。 
	 *  <p>在编译和使用之前必须提供{@code 数据源}和SQL。 
	 * 
	 */
	public SqlQuery() {
	}

	/**
	 * Convenient constructor with a {@code DataSource} and SQL string.
	 * @param ds the {@code DataSource} to use to get connections
	 * @param sql the SQL to execute; SQL can also be supplied at runtime
	 * by overriding the {@link #getSql()} method.
	 */
	/**
	 * 带有{@code  DataSource}和SQL字符串的便捷构造函数。 
	 *  
	 * @param  ds {@code  DataSource}用于获取要执行SQL的连接
	 * @param  sql； 
	 * 还可以通过覆盖{@link  #getSql（）}方法在运行时提供SQL。 
	 * 
	 */
	public SqlQuery(DataSource ds, String sql) {
		setDataSource(ds);
		setSql(sql);
	}


	/**
	 * Set the number of rows expected.
	 * <p>This can be used to ensure efficient storage of results. The
	 * default behavior is not to expect any specific number of rows.
	 */
	/**
	 * 设置预期的行数。 
	 *  <p>这可用于确保有效存储结果。 
	 * 默认行为是不期望任何特定数量的行。 
	 * 
	 */
	public void setRowsExpected(int rowsExpected) {
		this.rowsExpected = rowsExpected;
	}

	/**
	 * Get the number of rows expected.
	 */
	/**
	 * 获取预期的行数。 
	 * 
	 */
	public int getRowsExpected() {
		return this.rowsExpected;
	}


	/**
	 * Central execution method. All un-named parameter execution goes through this method.
	 * @param params parameters, similar to JDO query parameters.
	 * Primitive parameters must be represented by their Object wrapper type.
	 * The ordering of parameters is significant.
	 * @param context contextual information passed to the {@code mapRow}
	 * callback method. The JDBC operation itself doesn't rely on this parameter,
	 * but it can be useful for creating the objects of the result list.
	 * @return a List of objects, one per row of the ResultSet. Normally all these
	 * will be of the same class, although it is possible to use different types.
	 */
	/**
	 * 中央执行方法。 
	 * 所有未命名的参数执行都通过此方法进行。 
	 *  
	 * @param 参数参数，类似于JDO查询参数。 
	 * 原始参数必须由其对象包装器类型表示。 
	 * 参数的顺序很重要。 
	 * 传递给{@code  mapRow}回调方法的
	 * @param 上下文上下文信息。 
	 *  JDBC操作本身并不依赖于此参数，但是它对于创建结果列表的对象很有用。 
	 *  
	 * @return 对象列表，ResultSet每行一个。 
	 * 尽管可以使用不同的类型，但是通常所有这些都属于同一类。 
	 * 
	 */
	public List<T> execute(@Nullable Object[] params, @Nullable Map<?, ?> context) throws DataAccessException {
		validateParameters(params);
		RowMapper<T> rowMapper = newRowMapper(params, context);
		return getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper);
	}

	/**
	 * Convenient method to execute without context.
	 * @param params parameters for the query. Primitive parameters must
	 * be represented by their Object wrapper type. The ordering of parameters is
	 * significant.
	 */
	/**
	 * 无需上下文即可执行的便捷方法。 
	 *  
	 * @param 用于查询的参数参数。 
	 * 原始参数必须由其对象包装器类型表示。 
	 * 参数的顺序很重要。 
	 * 
	 */
	public List<T> execute(Object... params) throws DataAccessException {
		return execute(params, null);
	}

	/**
	 * Convenient method to execute without parameters.
	 * @param context the contextual information for object creation
	 */
	/**
	 * 无需参数即可执行的便捷方法。 
	 *  
	 * @param 上下文用于对象创建的上下文信息
	 */
	public List<T> execute(Map<?, ?> context) throws DataAccessException {
		return execute((Object[]) null, context);
	}

	/**
	 * Convenient method to execute without parameters nor context.
	 */
	/**
	 * 无需参数或上下文即可执行的便捷方法。 
	 * 
	 */
	public List<T> execute() throws DataAccessException {
		return execute((Object[]) null, null);
	}

	/**
	 * Convenient method to execute with a single int parameter and context.
	 * @param p1 single int parameter
	 * @param context the contextual information for object creation
	 */
	/**
	 * 使用单个int参数和上下文执行的便捷方法。 
	 *  
	 * @param  p1单个int参数
	 * @param 上下文用于对象创建的上下文信息
	 */
	public List<T> execute(int p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return execute(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to execute with a single int parameter.
	 * @param p1 single int parameter
	 */
	/**
	 * 使用单个int参数执行的便捷方法。 
	 *  
	 * @param  p1单整数参数
	 */
	public List<T> execute(int p1) throws DataAccessException {
		return execute(p1, null);
	}

	/**
	 * Convenient method to execute with two int parameters and context.
	 * @param p1 first int parameter
	 * @param p2 second int parameter
	 * @param context the contextual information for object creation
	 */
	/**
	 * 使用两个int参数和上下文执行的便捷方法。 
	 *  
	 * @param  p1第一个int参数
	 * @param  p2第二个int参数
	 * @param  context用于创建对象的上下文信息
	 */
	public List<T> execute(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {
		return execute(new Object[] {p1, p2}, context);
	}

	/**
	 * Convenient method to execute with two int parameters.
	 * @param p1 first int parameter
	 * @param p2 second int parameter
	 */
	/**
	 * 使用两个int参数执行的便捷方法。 
	 *  
	 * @param  p1第一个int参数
	 * @param  p2第二个int参数
	 */
	public List<T> execute(int p1, int p2) throws DataAccessException {
		return execute(p1, p2, null);
	}

	/**
	 * Convenient method to execute with a single long parameter and context.
	 * @param p1 single long parameter
	 * @param context the contextual information for object creation
	 */
	/**
	 * 使用单个long参数和上下文执行的便捷方法。 
	 *  
	 * @param  p1单长参数
	 * @param 上下文用于对象创建的上下文信息
	 */
	public List<T> execute(long p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return execute(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to execute with a single long parameter.
	 * @param p1 single long parameter
	 */
	/**
	 * 使用单个long参数执行的便捷方法。 
	 *  
	 * @param  p1单长参数
	 */
	public List<T> execute(long p1) throws DataAccessException {
		return execute(p1, null);
	}

	/**
	 * Convenient method to execute with a single String parameter and context.
	 * @param p1 single String parameter
	 * @param context the contextual information for object creation
	 */
	/**
	 * 使用单个String参数和上下文执行的便捷方法。 
	 *  
	 * @param  p1单个字符串参数
	 * @param  context用于创建对象的上下文信息
	 */
	public List<T> execute(String p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return execute(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to execute with a single String parameter.
	 * @param p1 single String parameter
	 */
	/**
	 * 使用单个String参数执行的便捷方法。 
	 *  
	 * @param  p1单字符串参数
	 */
	public List<T> execute(String p1) throws DataAccessException {
		return execute(p1, null);
	}

	/**
	 * Central execution method. All named parameter execution goes through this method.
	 * @param paramMap parameters associated with the name specified while declaring
	 * the SqlParameters. Primitive parameters must be represented by their Object wrapper
	 * type. The ordering of parameters is not significant since they are supplied in a
	 * SqlParameterMap which is an implementation of the Map interface.
	 * @param context contextual information passed to the {@code mapRow}
	 * callback method. The JDBC operation itself doesn't rely on this parameter,
	 * but it can be useful for creating the objects of the result list.
	 * @return a List of objects, one per row of the ResultSet. Normally all these
	 * will be of the same class, although it is possible to use different types.
	 */
	/**
	 * 中央执行方法。 
	 * 所有命名参数的执行都通过此方法进行。 
	 *  
	 * @param 与在声明SqlParameters时指定的名称关联的paramMap参数。 
	 * 原始参数必须由其对象包装器类型表示。 
	 * 参数的顺序并不重要，因为它们在SqlParameterMap中提供，该参数是Map接口的实现。 
	 * 传递给{@code  mapRow}回调方法的
	 * @param 上下文上下文信息。 
	 *  JDBC操作本身并不依赖于此参数，但是它对于创建结果列表的对象很有用。 
	 *  
	 * @return 对象列表，ResultSet每行一个。 
	 * 尽管可以使用不同的类型，但是通常所有这些都属于同一类。 
	 * 
	 */
	public List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {
		validateNamedParameters(paramMap);
		ParsedSql parsedSql = getParsedSql();
		MapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap);
		String sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);
		Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters());
		RowMapper<T> rowMapper = newRowMapper(params, context);
		return getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, params), rowMapper);
	}

	/**
	 * Convenient method to execute without context.
	 * @param paramMap parameters associated with the name specified while declaring
	 * the SqlParameters. Primitive parameters must be represented by their Object wrapper
	 * type. The ordering of parameters is not significant.
	 */
	/**
	 * 无需上下文即可执行的便捷方法。 
	 *  
	 * @param 与在声明SqlParameters时指定的名称关联的paramMap参数。 
	 * 原始参数必须由其对象包装器类型表示。 
	 * 参数的顺序并不重要。 
	 * 
	 */
	public List<T> executeByNamedParam(Map<String, ?> paramMap) throws DataAccessException {
		return executeByNamedParam(paramMap, null);
	}


	/**
	 * Generic object finder method, used by all other {@code findObject} methods.
	 * Object finder methods are like EJB entity bean finders, in that it is
	 * considered an error if they return more than one result.
	 * @return the result object, or {@code null} if not found. Subclasses may
	 * choose to treat this as an error and throw an exception.
	 * @see org.springframework.dao.support.DataAccessUtils#singleResult
	 */
	/**
	 * 通用对象查找器方法，由所有其他{@code  findObject}方法使用。 
	 * 对象查找器方法类似于EJB实体bean查找器，因为如果它们返回多个结果，则将其视为错误。 
	 *  
	 * @return 结果对象，如果找不到，则为{<@@code> null}。 
	 * 子类可以选择将此视为错误并引发异常。 
	 *  
	 * @see  org.springframework.dao.support.DataAccessUtils＃singleResult
	 */
	@Nullable
	public T findObject(@Nullable Object[] params, @Nullable Map<?, ?> context) throws DataAccessException {
		List<T> results = execute(params, context);
		return DataAccessUtils.singleResult(results);
	}

	/**
	 * Convenient method to find a single object without context.
	 */
	/**
	 * 查找没有上下文的单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(Object... params) throws DataAccessException {
		return findObject(params, null);
	}

	/**
	 * Convenient method to find a single object given a single int parameter
	 * and a context.
	 */
	/**
	 * 给定单个int参数和上下文的便捷方法，用于查找单个对象。 
	 * 
	 */
	@Nullable
	public T findObject(int p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return findObject(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to find a single object given a single int parameter.
	 */
	/**
	 * 给定单个int参数来查找单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(int p1) throws DataAccessException {
		return findObject(p1, null);
	}

	/**
	 * Convenient method to find a single object given two int parameters
	 * and a context.
	 */
	/**
	 * 给定两个int参数和一个上下文的查找单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {
		return findObject(new Object[] {p1, p2}, context);
	}

	/**
	 * Convenient method to find a single object given two int parameters.
	 */
	/**
	 * 给定两个int参数的查找单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(int p1, int p2) throws DataAccessException {
		return findObject(p1, p2, null);
	}

	/**
	 * Convenient method to find a single object given a single long parameter
	 * and a context.
	 */
	/**
	 * 给定单个long参数和上下文的便捷方法，用于查找单个对象。 
	 * 
	 */
	@Nullable
	public T findObject(long p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return findObject(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to find a single object given a single long parameter.
	 */
	/**
	 * 给定单个long参数的单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(long p1) throws DataAccessException {
		return findObject(p1, null);
	}

	/**
	 * Convenient method to find a single object given a single String parameter
	 * and a context.
	 */
	/**
	 * 给定单个String参数和上下文的便捷方法，用于查找单个对象。 
	 * 
	 */
	@Nullable
	public T findObject(String p1, @Nullable Map<?, ?> context) throws DataAccessException {
		return findObject(new Object[] {p1}, context);
	}

	/**
	 * Convenient method to find a single object given a single String parameter.
	 */
	/**
	 * 给定单个String参数来查找单个对象的便捷方法。 
	 * 
	 */
	@Nullable
	public T findObject(String p1) throws DataAccessException {
		return findObject(p1, null);
	}

	/**
	 * Generic object finder method for named parameters.
	 * @param paramMap a Map of parameter name to parameter object,
	 * matching named parameters specified in the SQL statement.
	 * Ordering is not significant.
	 * @param context contextual information passed to the {@code mapRow}
	 * callback method. The JDBC operation itself doesn't rely on this parameter,
	 * but it can be useful for creating the objects of the result list.
	 * @return a List of objects, one per row of the ResultSet. Normally all these
	 * will be of the same class, although it is possible to use different types.
	 */
	/**
	 * 命名参数的通用对象查找器方法。 
	 *  
	 * @param  paramMap参数名到参数对象的映射，匹配SQL语句中指定的命名参数。 
	 * 订购不重要。 
	 * 传递给{@code  mapRow}回调方法的
	 * @param 上下文上下文信息。 
	 *  JDBC操作本身并不依赖于此参数，但是它对于创建结果列表的对象很有用。 
	 *  
	 * @return 对象列表，ResultSet每行一个。 
	 * 尽管可以使用不同的类型，但是通常所有这些都属于同一类。 
	 * 
	 */
	@Nullable
	public T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {
		List<T> results = executeByNamedParam(paramMap, context);
		return DataAccessUtils.singleResult(results);
	}

	/**
	 * Convenient method to execute without context.
	 * @param paramMap a Map of parameter name to parameter object,
	 * matching named parameters specified in the SQL statement.
	 * Ordering is not significant.
	 */
	/**
	 * 无需上下文即可执行的便捷方法。 
	 *  
	 * @param  paramMap参数名到参数对象的映射，匹配SQL语句中指定的命名参数。 
	 * 订购不重要。 
	 * 
	 */
	@Nullable
	public T findObjectByNamedParam(Map<String, ?> paramMap) throws DataAccessException {
		return findObjectByNamedParam(paramMap, null);
	}


	/**
	 * Subclasses must implement this method to extract an object per row, to be
	 * returned by the {@code execute} method as an aggregated {@link List}.
	 * @param parameters the parameters to the {@code execute()} method,
	 * in case subclass is interested; may be {@code null} if there
	 * were no parameters.
	 * @param context contextual information passed to the {@code mapRow}
	 * callback method. The JDBC operation itself doesn't rely on this parameter,
	 * but it can be useful for creating the objects of the result list.
	 * @see #execute
	 */
	/**
	 * 子类必须实现此方法以提取每行对象，并由{@code  execute}方法作为汇总的{@link  List}返回。 
	 *  
	 * @param 参数是子类感兴趣的{@code  execute（）}方法的参数。 
	 * 如果没有参数，则可以为{@code  null}。 
	 * 传递给{@code  mapRow}回调方法的
	 * @param 上下文上下文信息。 
	 *  JDBC操作本身并不依赖于此参数，但是它对于创建结果列表的对象很有用。 
	 *  
	 * @see ＃执行
	 */
	protected abstract RowMapper<T> newRowMapper(@Nullable Object[] parameters, @Nullable Map<?, ?> context);

}
