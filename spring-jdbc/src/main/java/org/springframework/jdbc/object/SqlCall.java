/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.object;

import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.CallableStatementCreator;
import org.springframework.jdbc.core.CallableStatementCreatorFactory;
import org.springframework.jdbc.core.ParameterMapper;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * RdbmsOperation using a JdbcTemplate and representing an SQL-based
 * call such as a stored procedure or a stored function.
 *
 * <p>Configures a CallableStatementCreatorFactory based on the declared
 * parameters.
 *
 * @author Rod Johnson
 * @author Thomas Risberg
 * @see CallableStatementCreatorFactory
 */
/**
 * RdbmsOperation使用JdbcTemplate并表示基于SQL的调用，例如存储过程或存储函数。 
 *  <p>根据声明的参数配置Call​​ableStatementCreatorFactory。 
 *  @author 罗德·约翰逊@author 托马斯·里斯伯格
 * @see  CallableStatementCreatorFactory
 */
public abstract class SqlCall extends RdbmsOperation {

	/**
	 * Flag used to indicate that this call is for a function and to
	 * use the {? = call get_invoice_count(?)} syntax.
	 */
	/**
	 * 用于指示此调用是针对某个函数并使用{？ =调用get_invoice_count（？）}语法。 
	 * 
	 */
	private boolean function = false;

	/**
	 * Flag used to indicate that the sql for this call should be used exactly as
	 * it is defined. No need to add the escape syntax and parameter place holders.
	 */
	/**
	 * 用于指示此调用的sql应该完全按照定义使用的标志。 
	 * 无需添加转义语法和参数占位符。 
	 * 
	 */
	private boolean sqlReadyForUse = false;

	/**
	 * Call string as defined in java.sql.CallableStatement.
	 * String of form {call add_invoice(?, ?, ?)} or {? = call get_invoice_count(?)}
	 * if isFunction is set to true. Updated after each parameter is added.
	 */
	/**
	 * 调用字符串，如java.sql.CallableStatement中所定义。 
	 * 字符串形式为{call add_invoice（?,？，？）}或{？ =如果isFunction设置为true，则调用get_invoice_count（？）}。 
	 * 添加每个参数后更新。 
	 * 
	 */
	@Nullable
	private String callString;

	/**
	 * Object enabling us to create CallableStatementCreators
	 * efficiently, based on this class's declared parameters.
	 */
	/**
	 * 使我们能够基于此类的已声明参数有效创建CallableStatementCreator的对象。 
	 * 
	 */
	@Nullable
	private CallableStatementCreatorFactory callableStatementFactory;


	/**
	 * Constructor to allow use as a JavaBean.
	 * A DataSource, SQL and any parameters must be supplied before
	 * invoking the {@code compile} method and using this object.
	 * @see #setDataSource
	 * @see #setSql
	 * @see #compile
	 */
	/**
	 * 允许用作JavaBean的构造方法。 
	 * 在调用{@code  compile}方法并使用此对象之前，必须提供DataSource，SQL和任何参数。 
	 *  
	 * @see  #setDataSource 
	 * @see  #setSql 
	 * @see  #compile
	 */
	public SqlCall() {
	}

	/**
	 * Create a new SqlCall object with SQL, but without parameters.
	 * Must add parameters or settle with none.
	 * @param ds the DataSource to obtain connections from
	 * @param sql the SQL to execute
	 */
	/**
	 * 使用SQL创建一个新的SqlCall对象，但不带参数。 
	 * 必须添加参数或不设置任何参数。 
	 *  
	 * @param  ds数据源从
	 * @param  sql获取连接以执行SQL
	 */
	public SqlCall(DataSource ds, String sql) {
		setDataSource(ds);
		setSql(sql);
	}


	/**
	 * Set whether this call is for a function.
	 */
	/**
	 * 设置此调用是否用于函数。 
	 * 
	 */
	public void setFunction(boolean function) {
		this.function = function;
	}

	/**
	 * Return whether this call is for a function.
	 */
	/**
	 * 返回此调用是否用于函数。 
	 * 
	 */
	public boolean isFunction() {
		return this.function;
	}

	/**
	 * Set whether the SQL can be used as is.
	 */
	/**
	 * 设置是否可以按原样使用SQL。 
	 * 
	 */
	public void setSqlReadyForUse(boolean sqlReadyForUse) {
		this.sqlReadyForUse = sqlReadyForUse;
	}

	/**
	 * Return whether the SQL can be used as is.
	 */
	/**
	 * 返回是否可以按原样使用SQL。 
	 * 
	 */
	public boolean isSqlReadyForUse() {
		return this.sqlReadyForUse;
	}


	/**
	 * Overridden method to configure the CallableStatementCreatorFactory
	 * based on our declared parameters.
	 * @see RdbmsOperation#compileInternal()
	 */
	/**
	 * 根据我们声明的参数配置Call​​ableStatementCreatorFactory的重写方法。 
	 *  
	 * @see  RdbmsOperation＃compileInternal（）
	 */
	@Override
	protected final void compileInternal() {
		if (isSqlReadyForUse()) {
			this.callString = resolveSql();
		}
		else {
			StringBuilder callString = new StringBuilder(32);
			List<SqlParameter> parameters = getDeclaredParameters();
			int parameterCount = 0;
			if (isFunction()) {
				callString.append("{? = call ").append(resolveSql()).append('(');
				parameterCount = -1;
			}
			else {
				callString.append("{call ").append(resolveSql()).append('(');
			}
			for (SqlParameter parameter : parameters) {
				if (!parameter.isResultsParameter()) {
					if (parameterCount > 0) {
						callString.append(", ");
					}
					if (parameterCount >= 0) {
						callString.append('?');
					}
					parameterCount++;
				}
			}
			callString.append(")}");
			this.callString = callString.toString();
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Compiled stored procedure. Call string is [" + this.callString + "]");
		}

		this.callableStatementFactory = new CallableStatementCreatorFactory(this.callString, getDeclaredParameters());
		this.callableStatementFactory.setResultSetType(getResultSetType());
		this.callableStatementFactory.setUpdatableResults(isUpdatableResults());

		onCompileInternal();
	}

	/**
	 * Hook method that subclasses may override to react to compilation.
	 * This implementation does nothing.
	 */
	/**
	 * 子类的Hook方法可能会覆盖以响应编译。 
	 * 此实现不执行任何操作。 
	 * 
	 */
	protected void onCompileInternal() {
	}

	/**
	 * Get the call string.
	 */
	/**
	 * 获取呼叫字符串。 
	 * 
	 */
	@Nullable
	public String getCallString() {
		return this.callString;
	}

	/**
	 * Return a CallableStatementCreator to perform an operation
	 * with this parameters.
	 * @param inParams parameters. May be {@code null}.
	 */
	/**
	 * 返回一个CallableStatementCreator来使用此参数执行操作。 
	 *  
	 * @param  inParams参数。 
	 * 可能为{@code  null}。 
	 * 
	 */
	protected CallableStatementCreator newCallableStatementCreator(@Nullable Map<String, ?> inParams) {
		Assert.state(this.callableStatementFactory != null, "No CallableStatementFactory available");
		return this.callableStatementFactory.newCallableStatementCreator(inParams);
	}

	/**
	 * Return a CallableStatementCreator to perform an operation
	 * with the parameters returned from this ParameterMapper.
	 * @param inParamMapper parametermapper. May not be {@code null}.
	 */
	/**
	 * 返回一个CallableStatementCreator以使用从此ParameterMapper返回的参数执行操作。 
	 *  
	 * @param  inParamMapper参数映射器。 
	 * 可能不是{@code  null}。 
	 * 
	 */
	protected CallableStatementCreator newCallableStatementCreator(ParameterMapper inParamMapper) {
		Assert.state(this.callableStatementFactory != null, "No CallableStatementFactory available");
		return this.callableStatementFactory.newCallableStatementCreator(inParamMapper);
	}

}
