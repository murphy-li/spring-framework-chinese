/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.core;

import java.util.Collection;
import java.util.List;
import java.util.Map;

import org.springframework.dao.DataAccessException;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.lang.Nullable;

/**
 * Interface specifying a basic set of JDBC operations.
 * Implemented by {@link JdbcTemplate}. Not often used directly, but a useful
 * option to enhance testability, as it can easily be mocked or stubbed.
 *
 * <p>Alternatively, the standard JDBC infrastructure can be mocked.
 * However, mocking this interface constitutes significantly less work.
 * As an alternative to a mock objects approach to testing data access code,
 * consider the powerful integration testing support provided in the
 * {@code org.springframework.test} package, shipped in
 * {@code spring-test.jar}.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see JdbcTemplate
 */
/**
 * 指定一组基本JDBC操作的接口。 
 * 由{@link  JdbcTemplate}实现。 
 * 它不经常直接使用，而是增强可测试性的有用选项，因为它很容易被嘲笑或存根。 
 *  <p>或者，可以模拟标准JDBC基础结构。 
 * 但是，模拟此接口将大大减少工作量。 
 * 作为模拟对象测试数据访问代码的方法的替代方法，请考虑{@code  spring-test.jar}中提供的{@code  org.springframework.test}软件包中提供的强大集成测试支持。 
 *  @author 罗德·约翰逊@author  Juergen Hoeller 
 * @see  JdbcTemplate
 */
public interface JdbcOperations {

	//-------------------------------------------------------------------------
	// Methods dealing with a plain java.sql.Connection
	//-------------------------------------------------------------------------

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC Connection. This allows for implementing arbitrary
	 * data access operations, within Spring's managed JDBC environment:
	 * that is, participating in Spring-managed transactions and converting
	 * JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param action a callback object that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作实现为在JDBC连接上进行的回调操作。 
	 * 这允许在Spring的托管JDBC环境中实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  action一个回调对象，它指定操作
	 * @return 该操作返回的结果对象； 
	 * 如果没有，则返回{@code  null} 
	 * @throws  DataAccessException如果存在任何问题
	 */
	@Nullable
	<T> T execute(ConnectionCallback<T> action) throws DataAccessException;


	//-------------------------------------------------------------------------
	// Methods dealing with static SQL (java.sql.Statement)
	//-------------------------------------------------------------------------

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC Statement. This allows for implementing arbitrary data
	 * access operations on a single Statement, within Spring's managed JDBC
	 * environment: that is, participating in Spring-managed transactions and
	 * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param action a callback that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作作为对JDBC语句起作用的回调操作实现。 
	 * 这允许在Spring的托管JDBC环境中的单个Statement上实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  action一个回调，它指定操作
	 * @return 该操作返回的结果对象； 
	 * 如果没有，则返回{@code  null} 
	 * @throws  DataAccessException如果存在任何问题
	 */
	@Nullable
	<T> T execute(StatementCallback<T> action) throws DataAccessException;

	/**
	 * Issue a single SQL execute, typically a DDL statement.
	 * @param sql static SQL to execute
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 发出单个SQL执行，通常是DDL语句。 
	 *  
	 * @param  sql静态SQL，如果有任何问题，则执行
	 * @throws  DataAccessException
	 */
	void execute(String sql) throws DataAccessException;

	/**
	 * Execute a query given static SQL, reading the ResultSet with a
	 * ResultSetExtractor.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code query} method with {@code null} as argument array.
	 * @param sql the SQL query to execute
	 * @param rse a callback that will extract all rows of results
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #query(String, Object[], ResultSetExtractor)
	 */
	/**
	 * 执行给定静态SQL的查询，并使用ResultSetExtractor读取ResultSet。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  query}方法。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rse回调，它将提取结果的所有行
	 * @return 任意结果对象，由ResultSetExtractor返回的结果
	 * @throws  DataAccessException如果执行查询
	 * @see  #query（String，Object []，ResultSetExtractor）
	 */
	@Nullable
	<T> T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException;

	/**
	 * Execute a query given static SQL, reading the ResultSet on a per-row
	 * basis with a RowCallbackHandler.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code query} method with {@code null} as argument array.
	 * @param sql the SQL query to execute
	 * @param rch a callback that will extract results, one row at a time
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #query(String, Object[], RowCallbackHandler)
	 */
	/**
	 * 执行给定静态SQL的查询，并使用RowCallbackHandler每行读取ResultSet。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  query}方法。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rch一个将提取结果的回调，一次一行。 
	 * 
	 * @throws  DataAccessException如果执行查询有任何问题
	 * @see  #query（String，Object []，RowCallbackHandler）
	 */
	void query(String sql, RowCallbackHandler rch) throws DataAccessException;

	/**
	 * Execute a query given static SQL, mapping each row to a result object
	 * via a RowMapper.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code query} method with {@code null} as argument array.
	 * @param sql the SQL query to execute
	 * @param rowMapper a callback that will map one object per row
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #query(String, Object[], RowMapper)
	 */
	/**
	 * 执行给定静态SQL的查询，通过RowMapper将每一行映射到结果对象。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  query}方法。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rowMapper一种回调，该回调将每行映射一个对象
	 * @return 结果列表，其中包含映射的对象
	 * @throws  DataAccessException如果执行查询遇到任何问题<@参见> #query（String，Object []，RowMapper）
	 */
	<T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Execute a query given static SQL, mapping a single result row to a
	 * result object via a RowMapper.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@link #queryForObject(String, RowMapper, Object...)} method with
	 * {@code null} as argument array.
	 * @param sql the SQL query to execute
	 * @param rowMapper a callback that will map one object per row
	 * @return the single mapped object (may be {@code null} if the given
	 * {@link RowMapper} returned {@code} null)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForObject(String, Object[], RowMapper)
	 */
	/**
	 * 执行给定静态SQL的查询，通过RowMapper将单个结果行映射到结果对象。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@link  #queryForObject（String，RowMapper，Object ...）}方法。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rowMapper回调，该回调将每行映射一个对象
	 * @return 单个映射的对象（如果给定的{@link ，则可能为{@code  null} RowMapper}返回{@code } null）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行
	 * @throws  DataAccessException如果执行查询有任何问题
	 * @see  #queryForObject（String，Object [] ，RowMapper）
	 */
	@Nullable
	<T> T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Execute a query for a result object, given static SQL.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@link #queryForObject(String, Class, Object...)} method with
	 * {@code null} as argument array.
	 * <p>This method is useful for running static SQL with a known outcome.
	 * The query is expected to be a single row/single column query; the returned
	 * result will be directly mapped to the corresponding object type.
	 * @param sql the SQL query to execute
	 * @param requiredType the type that the result object is expected to match
	 * @return the result object of the required type, or {@code null} in case of SQL NULL
	 * @throws IncorrectResultSizeDataAccessException if the query does not return
	 * exactly one row, or does not return exactly one column in that row
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForObject(String, Object[], Class)
	 */
	/**
	 * 给定静态SQL，对结果对象执行查询。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@link  #queryForObject（String，Class，Object ...）}方法。 
	 *  <p>此方法对于运行具有已知结果的静态SQL很有用。 
	 * 该查询应为单行/单列查询； 
	 * 返回的结果将直接映射到相应的对象类型。 
	 *  
	 * @param  sql执行查询的SQL查询
	 * @param  requiredType期望结果对象匹配的类型
	 * @return 所需类型的结果对象，如果SQL NULL，则为{@code  null} 
	 * @throws  IncorrectResultSizeDataAccessException，如果查询没有完全返回一行，或者该行中没有完全返回一列。 
	 *  ，班级）
	 */
	@Nullable
	<T> T queryForObject(String sql, Class<T> requiredType) throws DataAccessException;

	/**
	 * Execute a query for a result map, given static SQL.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@link #queryForMap(String, Object...)} method with {@code null}
	 * as argument array.
	 * <p>The query is expected to be a single row query; the result row will be
	 * mapped to a Map (one entry for each column, using the column name as the key).
	 * @param sql the SQL query to execute
	 * @return the result Map (one entry per column, with column name as key)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForMap(String, Object[])
	 * @see ColumnMapRowMapper
	 */
	/**
	 * 给定静态SQL，对结果图执行查询。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@link  #queryForMap（String，Object ...）}方法。 
	 *  <p>该查询应为单行查询； 
	 * 结果行将被映射到Map（每列一个条目，使用列名作为键）。 
	 *  
	 * @param  sql SQL查询以执行
	 * @return 结果映射（每列一个条目，以列名作为键）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未返回准确的一行
	 * @throws  DataAccessException如果存在执行查询
	 * @see  #queryForMap（String，Object []）
	 * @see  ColumnMapRowMapper有什么问题吗？
	 */
	Map<String, Object> queryForMap(String sql) throws DataAccessException;

	/**
	 * Execute a query for a result list, given static SQL.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code queryForList} method with {@code null} as argument array.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * result objects, each of them matching the specified element type.
	 * @param sql the SQL query to execute
	 * @param elementType the required type of element in the result list
	 * (for example, {@code Integer.class})
	 * @return a List of objects that match the specified element type
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForList(String, Object[], Class)
	 * @see SingleColumnRowMapper
	 */
	/**
	 * 给定静态SQL，对结果列表执行查询。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  queryForList}方法。 
	 *  <p>结果将映射到结果对象的列表（每行一个条目），每个结果对象都与指定的元素类型匹配。 
	 *  
	 * @param  sql执行查询的SQL查询
	 * @param  element键入结果列表中所需元素的类型（例如{@code  Integer.class}）
	 * @return 与指定对象匹配的对象列表元素类型
	 * @throws  DataAccessException如果执行查询时遇到任何问题
	 * @see  #queryForList（String，Object []，Class）
	 * @see  SingleColumnRowMapper
	 */
	<T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException;

	/**
	 * Execute a query for a result list, given static SQL.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code queryForList} method with {@code null} as argument array.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * Maps (one entry for each column using the column name as the key).
	 * Each element in the list will be of the form returned by this interface's
	 * {@code queryForMap} methods.
	 * @param sql the SQL query to execute
	 * @return an List that contains a Map per row
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForList(String, Object[])
	 */
	/**
	 * 给定静态SQL，对结果列表执行查询。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  queryForList}方法。 
	 *  <p>结果将映射到Maps的列表（每行一个条目）（使用列名作为键的每个列一个条目）。 
	 * 列表中的每个元素将采用此接口的{@code  queryForMap}方法返回的形式。 
	 *  
	 * @param  sql SQL查询以执行
	 * @return 每个行包含一个Map的列表
	 * @throws  DataAccessException如果执行查询有任何问题
	 * @see  #queryForList（String，Object []）
	 */
	List<Map<String, Object>> queryForList(String sql) throws DataAccessException;

	/**
	 * Execute a query for an SqlRowSet, given static SQL.
	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
	 * execute a static query with a PreparedStatement, use the overloaded
	 * {@code queryForRowSet} method with {@code null} as argument array.
	 * <p>The results will be mapped to an SqlRowSet which holds the data in a
	 * disconnected fashion. This wrapper will translate any SQLExceptions thrown.
	 * <p>Note that, for the default implementation, JDBC RowSet support needs to
	 * be available at runtime: by default, Sun's {@code com.sun.rowset.CachedRowSetImpl}
	 * class is used, which is part of JDK 1.5+ and also available separately as part of
	 * Sun's JDBC RowSet Implementations download (rowset.jar).
	 * @param sql the SQL query to execute
	 * @return an SqlRowSet representation (possibly a wrapper around a
	 * {@code javax.sql.rowset.CachedRowSet})
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForRowSet(String, Object[])
	 * @see SqlRowSetResultSetExtractor
	 * @see javax.sql.rowset.CachedRowSet
	 */
	/**
	 * 给定静态SQL，对SqlRowSet执行查询。 
	 *  <p>使用JDBC语句，而不是PreparedStatement。 
	 * 如果要使用PreparedStatement执行静态查询，请使用带有{@code  null}作为参数数组的重载{@code  queryForRowSet}方法。 
	 *  <p>结果将映射到一个SqlRowSet，该SqlRowSet以断开连接的方式保存数据。 
	 * 该包装器将转换所有抛出的SQLException。 
	 *  <p>请注意，对于默认实现，JDBC行集支持需要在运行时可用：默认情况下，使用Sun的{@code  com.sun.rowset.CachedRowSetImpl}类，该类是JDK 1.5+和更高版本的一部分。 
	 * 也可以从Sun的JDBC RowSet Implementations下载（rowset.jar）中单独获得。 
	 *  
	 * @param  sql SQL查询以执行
	 * @return  SqlRowSet表示形式（可能是{@code  javax.sql.rowset.CachedRowSet}的包装）
	 * @throws  DataAccessException如果执行查询有任何问题
	 * @see  #queryForRowSet（String，Object []）
	 * @see  SqlRowSetResultSetExtractor 
	 * @see  javax.sql.rowset.CachedRowSet
	 */
	SqlRowSet queryForRowSet(String sql) throws DataAccessException;

	/**
	 * Issue a single SQL update operation (such as an insert, update or delete statement).
	 * @param sql static SQL to execute
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem.
	 */
	/**
	 * 发出单个SQL更新操作（例如insert，update或delete语句）。 
	 *  
	 * @param  sql静态SQL执行
	 * @return 受影响的行数
	 * @throws  DataAccessException，如果有任何问题。 
	 * 
	 */
	int update(String sql) throws DataAccessException;

	/**
	 * Issue multiple SQL updates on a single JDBC Statement using batching.
	 * <p>Will fall back to separate updates on a single Statement if the JDBC
	 * driver does not support batch updates.
	 * @param sql defining an array of SQL statements that will be executed.
	 * @return an array of the number of rows affected by each statement
	 * @throws DataAccessException if there is any problem executing the batch
	 */
	/**
	 * 使用批处理在单个JDBC语句上发布多个SQL更新。 
	 *  <p>如果JDBC驱动程序不支持批量更新，则将退回到单个语句的单独更新。 
	 *  
	 * @param  sql定义将要执行的SQL语句数组。 
	 *  
	 * @return 受每个语句影响的行数的数组
	 * @throws  DataAccessException如果执行批处理有任何问题
	 */
	int[] batchUpdate(String... sql) throws DataAccessException;


	//-------------------------------------------------------------------------
	// Methods dealing with prepared statements
	//-------------------------------------------------------------------------

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC PreparedStatement. This allows for implementing arbitrary
	 * data access operations on a single Statement, within Spring's managed JDBC
	 * environment: that is, participating in Spring-managed transactions and
	 * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param psc a callback that creates a PreparedStatement given a Connection
	 * @param action a callback that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作实现为对JDBC PreparedStatement进行的回调操作。 
	 * 这允许在Spring的托管JDBC环境中的单个Statement上实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  psc一个为连接
	 * @param 动作创建一个PreparedStatement的回调，该回调指定该动作
	 * @return 该动作返回的结果对象，如果没有，则返回{@code  null} > DataAccessException，如果有任何问题
	 */
	@Nullable
	<T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action) throws DataAccessException;

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC PreparedStatement. This allows for implementing arbitrary
	 * data access operations on a single Statement, within Spring's managed JDBC
	 * environment: that is, participating in Spring-managed transactions and
	 * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param sql the SQL to execute
	 * @param action a callback that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作实现为对JDBC PreparedStatement进行的回调操作。 
	 * 这允许在Spring的托管JDBC环境中的单个Statement上实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  sql要执行
	 * @param 操作的SQL回调，它指定操作
	 * @return 该操作返回的结果对象，如果没有，则返回{@code  null} 
	 * @throws  DataAccessException任何问题
	 */
	@Nullable
	<T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException;

	/**
	 * Query using a prepared statement, reading the ResultSet with a ResultSetExtractor.
	 * <p>A PreparedStatementCreator can either be implemented directly or
	 * configured through a PreparedStatementCreatorFactory.
	 * @param psc a callback that creates a PreparedStatement given a Connection
	 * @param rse a callback that will extract results
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if there is any problem
	 * @see PreparedStatementCreatorFactory
	 */
	/**
	 * 使用准备好的语句进行查询，并使用ResultSetExtractor读取ResultSet。 
	 *  <p> PreparedStatementCreator可以直接实现，也可以通过PreparedStatementCreatorFactory进行配置。 
	 *  
	 * @param  psc在给定连接的情况下创建PreparedStatement的回调
	 * @param  rse将提取结果
	 * @return 的任意结果对象的回调，如存在任何问题，由ResultSetExtractor 
	 * @throws  DataAccessException返回
	 * @see  PreparedStatementCreatorFactory
	 */
	@Nullable
	<T> T query(PreparedStatementCreator psc, ResultSetExtractor<T> rse) throws DataAccessException;

	/**
	 * Query using a prepared statement, reading the ResultSet with a ResultSetExtractor.
	 * @param sql the SQL query to execute
	 * @param pss a callback that knows how to set values on the prepared statement.
	 * If this is {@code null}, the SQL will be assumed to contain no bind parameters.
	 * Even if there are no bind parameters, this callback may be used to set the
	 * fetch size and other performance options.
	 * @param rse a callback that will extract results
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 使用准备好的语句进行查询，并使用ResultSetExtractor读取ResultSet。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  pss一个回调，该回调知道如何在准备好的语句上设置值。 
	 * 如果这是{@code  null}，则将假定SQL不包含绑定参数。 
	 * 即使没有绑定参数，此回调也可用于设置访存大小和其他性能选项。 
	 *  
	 * @param  rse一个回调将提取结果
	 * @return 一个任意结果对象，由ResultSetExtractor返回的结果
	 * @throws  DataAccessException如果存在任何问题
	 */
	@Nullable
	<T> T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor<T> rse) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of arguments
	 * to bind to the query, reading the ResultSet with a ResultSetExtractor.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param rse a callback that will extract results
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if the query fails
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表，并使用ResultSetExtractor读取ResultSet。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @param > rse一个回调，它将提取结果
	 * @return 一个任意结果对象，如果查询失败，则返回ResultSetExtractor 
	 * @throws  DataAccessException返回的结果
	 * @see  java.sql.Types
	 */
	@Nullable
	<T> T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor<T> rse) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of arguments
	 * to bind to the query, reading the ResultSet with a ResultSetExtractor.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param rse a callback that will extract results
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表，并使用ResultSetExtractor读取ResultSet。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，并可选地指示小数位数
	 * @param  rse回调，该回调将提取结果
	 * @return 任意结果对象，由如果查询失败，则返回ResultSetExtractor 
	 * @throws  DataAccessException
	 */
	@Nullable
	<T> T query(String sql, Object[] args, ResultSetExtractor<T> rse) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of arguments
	 * to bind to the query, reading the ResultSet with a ResultSetExtractor.
	 * @param sql the SQL query to execute
	 * @param rse a callback that will extract results
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return an arbitrary result object, as returned by the ResultSetExtractor
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表，并使用ResultSetExtractor读取ResultSet。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rse一个回调，该回调将提取结果
	 * @param  args参数以绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @return 一个任意结果对象，如果查询失败，则由ResultSetExtractor 
	 * @throws  DataAccessException返回@3.0.1起
	 */
	@Nullable
	<T> T query(String sql, ResultSetExtractor<T> rse, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query using a prepared statement, reading the ResultSet on a per-row basis
	 * with a RowCallbackHandler.
	 * <p>A PreparedStatementCreator can either be implemented directly or
	 * configured through a PreparedStatementCreatorFactory.
	 * @param psc a callback that creates a PreparedStatement given a Connection
	 * @param rch a callback that will extract results, one row at a time
	 * @throws DataAccessException if there is any problem
	 * @see PreparedStatementCreatorFactory
	 */
	/**
	 * 使用准备好的语句进行查询，并使用RowCallbackHandler逐行读取ResultSet。 
	 *  <p> PreparedStatementCreator可以直接实现，也可以通过PreparedStatementCreatorFactory进行配置。 
	 *  
	 * @param  psc一个给定Connection的连接创建一个PreparedStatement的回调
	 * @param  rch一个将提取结果的回调，一次提取一行
	 * @throws  DataAccessException如果存在任何问题
	 * @see  PreparedStatementCreatorFactory
	 */
	void query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a
	 * PreparedStatementSetter implementation that knows how to bind values to the
	 * query, reading the ResultSet on a per-row basis with a RowCallbackHandler.
	 * @param sql the SQL query to execute
	 * @param pss a callback that knows how to set values on the prepared statement.
	 * If this is {@code null}, the SQL will be assumed to contain no bind parameters.
	 * Even if there are no bind parameters, this callback may be used to set the
	 * fetch size and other performance options.
	 * @param rch a callback that will extract results, one row at a time
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL以从SQL和PreparedStatementSetter实现创建准备好的语句，该实现知道如何将值绑定到查询，并使用RowCallbackHandler逐行读取ResultSet。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  pss一个回调，该回调知道如何在准备好的语句上设置值。 
	 * 如果这是{@code  null}，则将假定SQL不包含绑定参数。 
	 * 即使没有绑定参数，此回调也可用于设置访存大小和其他性能选项。 
	 *  
	 * @param  rch将提取结果的回调，一次提取一行
	 * @throws  DataAccessException如果查询失败
	 */
	void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, reading the ResultSet on a per-row basis
	 * with a RowCallbackHandler.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param rch a callback that will extract results, one row at a time
	 * @throws DataAccessException if the query fails
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并使用RowCallbackHandler逐行读取ResultSet。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @param > rch一个将提取结果的回调，如果查询失败，一次一次行
	 * @throws  DataAccessException 
	 * @see  java.sql.Types
	 */
	void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, reading the ResultSet on a per-row basis
	 * with a RowCallbackHandler.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param rch a callback that will extract results, one row at a time
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并使用RowCallbackHandler逐行读取ResultSet。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以选择指示标度
	 * @param  rch将提取结果的回调，一次返回一行
	 * @throws  DataAccessException如果查询失败
	 */
	void query(String sql, Object[] args, RowCallbackHandler rch) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, reading the ResultSet on a per-row basis
	 * with a RowCallbackHandler.
	 * @param sql the SQL query to execute
	 * @param rch a callback that will extract results, one row at a time
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并使用RowCallbackHandler逐行读取ResultSet。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rch一个将提取结果的回调，一次一行
	 * @param  args参数绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）;可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，如果查询自@3.0.1起失败，还可以指示小数位数
	 * @throws  DataAccessException。 
	 * 
	 */
	void query(String sql, RowCallbackHandler rch, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query using a prepared statement, mapping each row to a result object
	 * via a RowMapper.
	 * <p>A PreparedStatementCreator can either be implemented directly or
	 * configured through a PreparedStatementCreatorFactory.
	 * @param psc a callback that creates a PreparedStatement given a Connection
	 * @param rowMapper a callback that will map one object per row
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if there is any problem
	 * @see PreparedStatementCreatorFactory
	 */
	/**
	 * 使用准备好的语句进行查询，并通过RowMapper将每一行映射到结果对象。 
	 *  <p> PreparedStatementCreator可以直接实现，也可以通过PreparedStatementCreatorFactory进行配置。 
	 *  
	 * @param  psc在给定连接的情况下创建PreparedStatement的回调。 
	 *  
	 * @see> PreparedStatementCreatorFactory
	 */
	<T> List<T> query(PreparedStatementCreator psc, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a
	 * PreparedStatementSetter implementation that knows how to bind values
	 * to the query, mapping each row to a result object via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param pss a callback that knows how to set values on the prepared statement.
	 * If this is {@code null}, the SQL will be assumed to contain no bind parameters.
	 * Even if there are no bind parameters, this callback may be used to set the
	 * fetch size and other performance options.
	 * @param rowMapper a callback that will map one object per row
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL，以从SQL和PreparedStatementSetter实现创建准备好的语句，该实现知道如何将值绑定到查询，并通过RowMapper将每一行映射到结果对象。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  pss一个回调，该回调知道如何在准备好的语句上设置值。 
	 * 如果这是{@code  null}，则将假定SQL不包含绑定参数。 
	 * 即使没有绑定参数，此回调也可用于设置访存大小和其他性能选项。 
	 *  
	 * @param  rowMapper回调，将在每行映射一个对象
	 * @return 结果列表，其中包含映射的对象
	 * @throws  DataAccessException如果查询失败
	 */
	<T> List<T> query(String sql, @Nullable PreparedStatementSetter pss, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, mapping each row to a result object
	 * via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param rowMapper a callback that will map one object per row
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if the query fails
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并通过RowMapper将每一行映射到结果对象。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @param > rowMapper回调，它将在每行中映射一个对象
	 * @return 结果列表，如果查询失败，则包含映射的对象
	 * @throws  DataAccessException 
	 * @see  java.sql.Types
	 */
	<T> List<T> query(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, mapping each row to a result object
	 * via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param rowMapper a callback that will map one object per row
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并通过RowMapper将每一行映射到结果对象。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @param  rowMapper，该回调将每行映射一个对象
	 * @return 结果列表，包含如果查询失败，则映射的对象
	 * @throws  DataAccessException
	 */
	<T> List<T> query(String sql, Object[] args, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, mapping each row to a result object
	 * via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param rowMapper a callback that will map one object per row
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return the result List, containing mapped objects
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，并通过RowMapper将每一行映射到结果对象。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rowMapper回调，该回调将每行映射一个对象
	 * @param  args参数绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示比例尺
	 * @return 结果列表，如果查询失败，则包含映射的对象
	 * @throws  DataAccessException（自3.0开始） .1
	 */
	<T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list
	 * of arguments to bind to the query, mapping a single result row to a
	 * result object via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type)
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param rowMapper a callback that will map one object per row
	 * @return the single mapped object (may be {@code null} if the given
	 * {@link RowMapper} returned {@code} null)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，从而通过RowMapper将单个结果行映射到结果对象。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询（将其保留在PreparedStatement上以猜测对应的SQL类型）
	 * @param  argTypes参数的SQL类型（{ @code> java.sql.Types}）
	 * @param  rowMapper一种回调，它将每行映射一个对象
	 * @return 单个映射的对象（如果给定的{@link ，则可能是{@code  null} RowMapper}返回{@code } null）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行
	 * @throws  DataAccessException如果查询失败
	 */
	@Nullable
	<T> T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper<T> rowMapper)
			throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list
	 * of arguments to bind to the query, mapping a single result row to a
	 * result object via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param rowMapper a callback that will map one object per row
	 * @return the single mapped object (may be {@code null} if the given
	 * {@link RowMapper} returned {@code} null)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if the query fails
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，从而通过RowMapper将单个结果行映射到结果对象。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示比例尺
	 * @param  rowMapper回调，该回调将每行映射一个对象
	 * @return 单个映射的对象（如果给定的{@link  RowMapper}返回了{@code } null，则可以为{@code  null}如果查询未返回正好返回的一行，则返回@<throws> DataAccessException失败
	 */
	@Nullable
	<T> T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list
	 * of arguments to bind to the query, mapping a single result row to a
	 * result object via a RowMapper.
	 * @param sql the SQL query to execute
	 * @param rowMapper a callback that will map one object per row
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return the single mapped object (may be {@code null} if the given
	 * {@link RowMapper} returned {@code} null)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 */
	/**
	 * 查询给定的SQL以从SQL创建准备好的语句，并创建要绑定到查询的参数列表，从而通过RowMapper将单个结果行映射到结果对象。 
	 *  
	 * @param  sql SQL查询以执行
	 * @param  rowMapper回调，该回调将每行映射一个对象
	 * @param  args参数绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @return 单个映射对象（如果给定的{@link  RowMapper}返回{@code } null）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行
	 * @throws  DataAccessException如果查询失败@3.0.1起
	 */
	@Nullable
	<T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result object.
	 * <p>The query is expected to be a single row/single column query; the returned
	 * result will be directly mapped to the corresponding object type.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param requiredType the type that the result object is expected to match
	 * @return the result object of the required type, or {@code null} in case of SQL NULL
	 * @throws IncorrectResultSizeDataAccessException if the query does not return
	 * exactly one row, or does not return exactly one column in that row
	 * @throws DataAccessException if the query fails
	 * @see #queryForObject(String, Class)
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表（需要一个结果对象）。 
	 *  <p>查询应为单行/单列查询； 
	 * 返回的结果将直接映射到相应的对象类型。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @param > requiredType要求结果对象与所需类型的结果对象匹配的类型
	 * @return ，如果SQL NULL 
	 * @throws ，则返回{@code  null} 
	 * @throws 如果查询未返回精确的结果，则为IncorrectResultSizeDataAccessException行，或者如果查询失败，则不完全返回该行中的一列
	 * @throws  DataAccessException 
	 * @see  #queryForObject（String，Class）
	 * @see  java.sql.Types
	 */
	@Nullable
	<T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> requiredType)
			throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result object.
	 * <p>The query is expected to be a single row/single column query; the returned
	 * result will be directly mapped to the corresponding object type.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param requiredType the type that the result object is expected to match
	 * @return the result object of the required type, or {@code null} in case of SQL NULL
	 * @throws IncorrectResultSizeDataAccessException if the query does not return
	 * exactly one row, or does not return exactly one column in that row
	 * @throws DataAccessException if the query fails
	 * @see #queryForObject(String, Class)
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表（需要一个结果对象）。 
	 *  <p>查询应为单行/单列查询； 
	 * 返回的结果将直接映射到相应的对象类型。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @param  requiredType期望结果对象与
	 * @return 的结果对象匹配的类型。 
	 * 必需的类型，如果为SQL NULL，则为{<@@code> null} 
	 * @throws 如果查询未返回精确的一行，则返回IncorrectResultSizeDataAccessException，或者如果查询未返回精确的一行，则返回
	 * @throws  DataAccessException失败
	 * @see  #queryForObject（String，Class）
	 */
	@Nullable
	<T> T queryForObject(String sql, Object[] args, Class<T> requiredType) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result object.
	 * <p>The query is expected to be a single row/single column query; the returned
	 * result will be directly mapped to the corresponding object type.
	 * @param sql the SQL query to execute
	 * @param requiredType the type that the result object is expected to match
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return the result object of the required type, or {@code null} in case of SQL NULL
	 * @throws IncorrectResultSizeDataAccessException if the query does not return
	 * exactly one row, or does not return exactly one column in that row
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 * @see #queryForObject(String, Class)
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表（需要一个结果对象）。 
	 *  <p>查询应为单行/单列查询； 
	 * 返回的结果将直接映射到相应的对象类型。 
	 *  
	 * @param  sql执行查询的SQL查询
	 * @param  requiredType期望结果对象与
	 * @param  args参数匹配的类型以绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，并可选地标度
	 * @return 所需类型的结果对象，或者指示{@code  null} SQL NULL 
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行或该行中未完全返回一列
	 * @throws  DataAccessException如果查询失败@@3.0.1起
	 * @see  #queryForObject（String，类）
	 */
	@Nullable
	<T> T queryForObject(String sql, Class<T> requiredType, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result map.
	 * <p>The query is expected to be a single row query; the result row will be
	 * mapped to a Map (one entry for each column, using the column name as the key).
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @return the result Map (one entry per column, with column name as key)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if the query fails
	 * @see #queryForMap(String)
	 * @see ColumnMapRowMapper
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到查询的参数列表，以得到结果映射。 
	 *  <p>该查询应为单行查询； 
	 * 结果行将被映射到Map（每列一个条目，使用列名作为键）。 
	 *  
	 * @param  sql要执行
	 * @param  args参数以绑定到查询的SQL查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @return >结果映射（每列一个条目，列名称为键）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行
	 * @throws  DataAccessException如果查询失败
	 * @see  #queryForMap（String）<@请参见> ColumnMapRowMapper <@请参见> java.sql.Types
	 */
	Map<String, Object> queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result map.
	 * <p>The {@code queryForMap} methods defined by this interface are appropriate
	 * when you don't have a domain model. Otherwise, consider using one of the
	 * {@code queryForObject} methods.
	 * <p>The query is expected to be a single row query; the result row will be
	 * mapped to a Map (one entry for each column, using the column name as the key).
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return the result Map (one entry for each column, using the
	 * column name as the key)
	 * @throws IncorrectResultSizeDataAccessException if the query does not
	 * return exactly one row
	 * @throws DataAccessException if the query fails
	 * @see #queryForMap(String)
	 * @see ColumnMapRowMapper
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到查询的参数列表，以得到结果映射。 
	 *  <p>当您没有域模型时，此接口定义的{@code  queryForMap}方法是合适的。 
	 * 否则，请考虑使用{@code  queryForObject}方法之一。 
	 *  <p>该查询应为单行查询； 
	 * 结果行将被映射到Map（每列一个条目，使用列名作为键）。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测对应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，并可选地标度
	 * @return 结果映射（每列一个条目，使用列名称作为键）
	 * @throws  IncorrectResultSizeDataAccessException如果查询未完全返回一行
	 * @throws  DataAccessException如果查询失败
	 * @see  #queryForMap（String）
	 * @see  ColumnMapRowMapper
	 */
	Map<String, Object> queryForMap(String sql, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result list.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * result objects, each of them matching the specified element type.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @param elementType the required type of element in the result list
	 * (for example, {@code Integer.class})
	 * @return a List of objects that match the specified element type
	 * @throws DataAccessException if the query fails
	 * @see #queryForList(String, Class)
	 * @see SingleColumnRowMapper
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到该查询的参数列表，并期望结果列表。 
	 *  <p>结果将映射到结果对象的列表（每行一个条目），每个结果对象都与指定的元素类型匹配。 
	 *  
	 * @param  sql执行SQL查询的
	 * @param  args参数以绑定到查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @param > element键入结果列表中所需元素的类型（例如{@code  Integer.class}）
	 * @return 一个与指定元素类型匹配的对象列表
	 * @throws  DataAccessException如果查询失败<@请参见> #queryForList（String，Class）<@请参见> SingleColumnRowMapper
	 */
	<T> List<T> queryForList(String sql, Object[] args, int[] argTypes, Class<T> elementType)
			throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result list.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * result objects, each of them matching the specified element type.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @param elementType the required type of element in the result list
	 * (for example, {@code Integer.class})
	 * @return a List of objects that match the specified element type
	 * @throws DataAccessException if the query fails
	 * @see #queryForList(String, Class)
	 * @see SingleColumnRowMapper
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到该查询的参数列表，并期望结果列表。 
	 *  <p>结果将映射到结果对象的列表（每行一个条目），每个结果对象都与指定的元素类型匹配。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @param  elementType结果列表中元素的必需类型（例如，{@code  Integer.class}）
	 * @return 匹配指定元素类型的对象的列表
	 * @throws 如果查询失败的DataAccessException 
	 * @see  #queryForList（String，Class）
	 * @see  SingleColumnRowMapper
	 */
	<T> List<T> queryForList(String sql, Object[] args, Class<T> elementType) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result list.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * result objects, each of them matching the specified element type.
	 * @param sql the SQL query to execute
	 * @param elementType the required type of element in the result list
	 * (for example, {@code Integer.class})
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return a List of objects that match the specified element type
	 * @throws DataAccessException if the query fails
	 * @since 3.0.1
	 * @see #queryForList(String, Class)
	 * @see SingleColumnRowMapper
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到该查询的参数列表，并期望结果列表。 
	 *  <p>结果将映射到结果对象的列表（每行一个条目），每个结果对象都与指定的元素类型匹配。 
	 *  
	 * @param  sql执行查询的SQL查询
	 * @param  elementType结果列表中所需元素的类型（例如{@code  Integer.class}）
	 * @param  args参数绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @return 如果查询失败，则与指定元素类型匹配的对象列表
	 * @throws  DataAccessException @since 3.0.1 
	 * @see  #queryForList（String，Class）
	 * @see  SingleColumnRowMapper
	 */
	<T> List<T> queryForList(String sql, Class<T> elementType, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result list.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * Maps (one entry for each column, using the column name as the key).
	 * Each element in the list will be of the form returned by this interface's
	 * {@code queryForMap} methods.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @return a List that contains a Map per row
	 * @throws DataAccessException if the query fails
	 * @see #queryForList(String)
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到该查询的参数列表，并期望结果列表。 
	 *  <p>结果将映射到Map的列表（每行一个条目）（每列一个条目，使用列名作为键）。 
	 * 列表中的每个元素将采用此接口的{@code  queryForMap}方法返回的形式。 
	 *  
	 * @param  sql要执行
	 * @param  args参数以绑定到查询的SQL查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @return >如果查询失败，则每行包含一个Map的列表
	 * @throws  DataAccessException 
	 * @see  #queryForList（String）
	 * @see  java.sql.Types
	 */
	List<Map<String, Object>> queryForList(String sql, Object[] args, int[] argTypes) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting a result list.
	 * <p>The results will be mapped to a List (one entry for each row) of
	 * Maps (one entry for each column, using the column name as the key).
	 * Each element in the list will be of the form returned by this interface's
	 * {@code queryForMap} methods.
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return a List that contains a Map per row
	 * @throws DataAccessException if the query fails
	 * @see #queryForList(String)
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并创建绑定到该查询的参数列表，并期望结果列表。 
	 *  <p>结果将映射到Map的列表（每行一个条目）（每列一个条目，使用列名作为键）。 
	 * 列表中的每个元素将采用此接口的{@code  queryForMap}方法返回的形式。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示比例尺
	 * @return 如果查询失败，则包含按行包含Map的List 
	 * @throws  DataAccessException <@查看> #queryForList（字符串）
	 */
	List<Map<String, Object>> queryForList(String sql, @Nullable Object... args) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting an SqlRowSet.
	 * <p>The results will be mapped to an SqlRowSet which holds the data in a
	 * disconnected fashion. This wrapper will translate any SQLExceptions thrown.
	 * <p>Note that, for the default implementation, JDBC RowSet support needs to
	 * be available at runtime: by default, Sun's {@code com.sun.rowset.CachedRowSetImpl}
	 * class is used, which is part of JDK 1.5+ and also available separately as part of
	 * Sun's JDBC RowSet Implementations download (rowset.jar).
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @return an SqlRowSet representation (possibly a wrapper around a
	 * {@code javax.sql.rowset.CachedRowSet})
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForRowSet(String)
	 * @see SqlRowSetResultSetExtractor
	 * @see javax.sql.rowset.CachedRowSet
	 * @see java.sql.Types
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表（期望使用SqlRowSet）。 
	 *  <p>结果将映射到一个SqlRowSet，该SqlRowSet以断开连接的方式保存数据。 
	 * 该包装器将转换所有抛出的SQLException。 
	 *  <p>请注意，对于默认实现，JDBC行集支持需要在运行时可用：默认情况下，使用Sun的{@code  com.sun.rowset.CachedRowSetImpl}类，该类是JDK 1.5+和更高版本的一部分。 
	 * 也可以从Sun的JDBC RowSet Implementations下载（rowset.jar）中单独获得。 
	 *  
	 * @param  sql要执行
	 * @param  args参数以绑定到查询的SQL查询
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @return > SqlRowSet表示形式（可能是{@code  javax.sql.rowset.CachedRowSet}的包装）
	 * @throws  DataAccessException如果执行查询时遇到任何问题
	 * @see  #queryForRowSet（String）
	 * @see  SqlRowSetResultSetExtractor 
	 * @see  javax.sql.rowset.CachedRowSet 
	 * @see  java.sql.Types
	 */
	SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes) throws DataAccessException;

	/**
	 * Query given SQL to create a prepared statement from SQL and a list of
	 * arguments to bind to the query, expecting an SqlRowSet.
	 * <p>The results will be mapped to an SqlRowSet which holds the data in a
	 * disconnected fashion. This wrapper will translate any SQLExceptions thrown.
	 * <p>Note that, for the default implementation, JDBC RowSet support needs to
	 * be available at runtime: by default, Sun's {@code com.sun.rowset.CachedRowSetImpl}
	 * class is used, which is part of JDK 1.5+ and also available separately as part of
	 * Sun's JDBC RowSet Implementations download (rowset.jar).
	 * @param sql the SQL query to execute
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return an SqlRowSet representation (possibly a wrapper around a
	 * {@code javax.sql.rowset.CachedRowSet})
	 * @throws DataAccessException if there is any problem executing the query
	 * @see #queryForRowSet(String)
	 * @see SqlRowSetResultSetExtractor
	 * @see javax.sql.rowset.CachedRowSet
	 */
	/**
	 * 查询给定的SQL，以从SQL创建准备好的语句，并绑定到查询的参数列表（期望使用SqlRowSet）。 
	 *  <p>结果将映射到一个SqlRowSet，该SqlRowSet以断开连接的方式保存数据。 
	 * 该包装器将转换所有抛出的SQLException。 
	 *  <p>请注意，对于默认实现，JDBC行集支持需要在运行时可用：默认情况下，使用Sun的{@code  com.sun.rowset.CachedRowSetImpl}类，该类是JDK 1.5+和更高版本的一部分。 
	 * 也可以从Sun的JDBC RowSet Implementations下载（rowset.jar）中单独获得。 
	 *  
	 * @param  sql用来执行
	 * @param  args参数的SQL查询绑定到查询（将其留给PreparedStatement来猜测对应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @return  SqlRowSet表示形式（可能是{@code  javax.sql.rowset的包装） .CachedRowSet}）
	 * @throws  DataAccessException，如果执行查询有任何问题
	 * @see  #queryForRowSet（String）
	 * @see  SqlRowSetResultSetExtractor 
	 * @see  javax.sql.rowset.CachedRowSet
	 */
	SqlRowSet queryForRowSet(String sql, @Nullable Object... args) throws DataAccessException;

	/**
	 * Issue a single SQL update operation (such as an insert, update or delete
	 * statement) using a PreparedStatementCreator to provide SQL and any
	 * required parameters.
	 * <p>A PreparedStatementCreator can either be implemented directly or
	 * configured through a PreparedStatementCreatorFactory.
	 * @param psc a callback that provides SQL and any necessary parameters
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem issuing the update
	 * @see PreparedStatementCreatorFactory
	 */
	/**
	 * 使用PreparedStatementCreator发出单个SQL更新操作（例如插入，更新或删除语句）以提供SQL和任何必需的参数。 
	 *  <p> PreparedStatementCreator可以直接实现，也可以通过PreparedStatementCreatorFactory进行配置。 
	 *  
	 * @param  psc提供了SQL和任何必要参数的回调
	 * @return 受影响的行数
	 * @throws  DataAccessException如果发布更新有任何问题
	 * @see  PreparedStatementCreatorFactory
	 */
	int update(PreparedStatementCreator psc) throws DataAccessException;

	/**
	 * Issue an update statement using a PreparedStatementCreator to provide SQL and
	 * any required parameters. Generated keys will be put into the given KeyHolder.
	 * <p>Note that the given PreparedStatementCreator has to create a statement
	 * with activated extraction of generated keys (a JDBC 3.0 feature). This can
	 * either be done directly or through using a PreparedStatementCreatorFactory.
	 * @param psc a callback that provides SQL and any necessary parameters
	 * @param generatedKeyHolder a KeyHolder that will hold the generated keys
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem issuing the update
	 * @see PreparedStatementCreatorFactory
	 * @see org.springframework.jdbc.support.GeneratedKeyHolder
	 */
	/**
	 * 使用PreparedStatementCreator发出更新语句以提供SQL和任何必需的参数。 
	 * 生成的密钥将放入给定的KeyHolder中。 
	 *  <p>请注意，给定的PreparedStatementCreator必须使用激活的生成键提取功能创建一条语句（JDBC 3.0功能）。 
	 * 这可以直接完成，也可以通过使用PreparedStatementCreatorFactory来完成。 
	 *  
	 * @param  psc提供SQL和任何必要参数的回调
	 * @param  generateKeyHolder一个将保存生成的键的KeyHolder 
	 * @return 受影响的行数
	 * @throws  DataAccessException如果发布更新有任何问题
	 * @see  PreparedStatementCreatorFactory 
	 * @see  org.springframework.jdbc.support.GeneratedKeyHolder
	 */
	int update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder) throws DataAccessException;

	/**
	 * Issue an update statement using a PreparedStatementSetter to set bind parameters,
	 * with given SQL. Simpler than using a PreparedStatementCreator as this method
	 * will create the PreparedStatement: The PreparedStatementSetter just needs to
	 * set parameters.
	 * @param sql the SQL containing bind parameters
	 * @param pss helper that sets bind parameters. If this is {@code null}
	 * we run an update with static SQL.
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem issuing the update
	 */
	/**
	 * 使用PreparedStatementSetter发出更新语句以设置给定SQL的绑定参数。 
	 * 与使用PreparedStatementCreator相比，此方法将创建PreparedStatement更为简单：PreparedStatementSetter只需设置参数即可。 
	 *  
	 * @param  sql包含绑定参数的SQL 
	 * @param 设置绑定参数的pss帮助器。 
	 * 如果这是{@code  null}，我们将使用静态SQL运行更新。 
	 *  
	 * @return 受影响的行数
	 * @throws  DataAccessException如果发布更新有任何问题
	 */
	int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException;

	/**
	 * Issue a single SQL update operation (such as an insert, update or delete statement)
	 * via a prepared statement, binding the given arguments.
	 * @param sql the SQL containing bind parameters
	 * @param args arguments to bind to the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem issuing the update
	 * @see java.sql.Types
	 */
	/**
	 * 通过准备好的语句绑定给定的参数来发出单个SQL更新操作（例如insert，update或delete语句）。 
	 *  
	 * @param  sql包含绑定参数的SQL 
	 * @param  args要绑定到查询的参数
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）<
	 * @return >如果发出更新问题，则受影响的行数
	 * @throws  DataAccessException 
	 * @see  java.sql.Types
	 */
	int update(String sql, Object[] args, int[] argTypes) throws DataAccessException;

	/**
	 * Issue a single SQL update operation (such as an insert, update or delete statement)
	 * via a prepared statement, binding the given arguments.
	 * @param sql the SQL containing bind parameters
	 * @param args arguments to bind to the query
	 * (leaving it to the PreparedStatement to guess the corresponding SQL type);
	 * may also contain {@link SqlParameterValue} objects which indicate not
	 * only the argument value but also the SQL type and optionally the scale
	 * @return the number of rows affected
	 * @throws DataAccessException if there is any problem issuing the update
	 */
	/**
	 * 通过准备好的语句绑定给定的参数来发出单个SQL更新操作（例如insert，update或delete语句）。 
	 *  
	 * @param  sql包含绑定参数的SQL 
	 * @param  args参数绑定到查询（将其保留在PreparedStatement中以猜测相应的SQL类型）； 
	 * 可能还包含{@link  SqlParameterValue}对象，这些对象不仅指示参数值，还指示SQL类型，还可以指示小数位数
	 * @return 受影响的行数
	 * @throws  DataAccessException（如果发布更新有任何问题）
	 */
	int update(String sql, @Nullable Object... args) throws DataAccessException;

	/**
	 * Issue multiple update statements on a single PreparedStatement,
	 * using batch updates and a BatchPreparedStatementSetter to set values.
	 * <p>Will fall back to separate updates on a single PreparedStatement
	 * if the JDBC driver does not support batch updates.
	 * @param sql defining PreparedStatement that will be reused.
	 * All statements in the batch will use the same SQL.
	 * @param pss object to set parameters on the PreparedStatement
	 * created by this method
	 * @return an array of the number of rows affected by each statement
	 * @throws DataAccessException if there is any problem issuing the update
	 */
	/**
	 * 使用批处理更新和BatchPreparedStatementSetter设置值，在单个PreparedStatement上发布多个更新语句。 
	 *  <p>如果JDBC驱动程序不支持批量更新，则将退回到单个PreparedStatement上的单独更新。 
	 *  
	 * @param  sql定义将被重用的PreparedStatement。 
	 * 批处理中的所有语句将使用相同的SQL。 
	 *  
	 * @param  pss对象，用于在通过此方法创建的PreparedStatement上设置参数
	 * @return 一个受每个语句影响的行数的数组
	 * @throws  DataAccessException如果发布更新存在任何问题
	 */
	int[] batchUpdate(String sql, BatchPreparedStatementSetter pss) throws DataAccessException;

	/**
	 * Execute a batch using the supplied SQL statement with the batch of supplied arguments.
	 * @param sql the SQL statement to execute
	 * @param batchArgs the List of Object arrays containing the batch of arguments for the query
	 * @return an array containing the numbers of rows affected by each update in the batch
	 */
	/**
	 * 使用提供的SQL语句和提供的参数批执行批处理。 
	 *  
	 * @param  sql要执行的SQL语句
	 * @param  batchArgs包含查询的参数批次的对象数组列表
	 * @return 包含该批次中每次更新影响的行数的数组
	 */
	int[] batchUpdate(String sql, List<Object[]> batchArgs) throws DataAccessException;

	/**
	 * Execute a batch using the supplied SQL statement with the batch of supplied arguments.
	 * @param sql the SQL statement to execute.
	 * @param batchArgs the List of Object arrays containing the batch of arguments for the query
	 * @param argTypes the SQL types of the arguments
	 * (constants from {@code java.sql.Types})
	 * @return an array containing the numbers of rows affected by each update in the batch
	 */
	/**
	 * 使用提供的SQL语句和提供的参数批执行批处理。 
	 *  
	 * @param  sql要执行的SQL语句。 
	 *  
	 * @param  batchArgs包含查询参数批次的对象数组列表
	 * @param  argTypes参数的SQL类型（来自{@code  java.sql.Types}的常量）
	 * @return 数组包含该批次中每次更新影响的行数
	 */
	int[] batchUpdate(String sql, List<Object[]> batchArgs, int[] argTypes) throws DataAccessException;

	/**
	 * Execute multiple batches using the supplied SQL statement with the collect of supplied arguments.
	 * The arguments' values will be set using the ParameterizedPreparedStatementSetter.
	 * Each batch should be of size indicated in 'batchSize'.
	 * @param sql the SQL statement to execute.
	 * @param batchArgs the List of Object arrays containing the batch of arguments for the query
	 * @param batchSize batch size
	 * @param pss the ParameterizedPreparedStatementSetter to use
	 * @return an array containing for each batch another array containing the numbers of rows affected
	 * by each update in the batch
	 * @since 3.1
	 */
	/**
	 * 使用提供的SQL语句和提供的参数集合执行多个批处理。 
	 * 参数的值将使用ParameterizedPreparedStatementSetter进行设置。 
	 * 每个批次的大小应在"batchSize"中指定。 
	 *  
	 * @param  sql要执行的SQL语句。 
	 *  
	 * @param  batchArgs包含查询批次参数的对象数组列表
	 * @param  batchSize批处理大小
	 * @param  pss ParameterizedPreparedStatementSetter使用
	 * @return 数组，该数组为每个批处理包含另一个数组，该数组包含从3.1起，批处理中的每个更新影响的行
	 */
	<T> int[][] batchUpdate(String sql, Collection<T> batchArgs, int batchSize,
			ParameterizedPreparedStatementSetter<T> pss) throws DataAccessException;


	//-------------------------------------------------------------------------
	// Methods dealing with callable statements
	//-------------------------------------------------------------------------

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC CallableStatement. This allows for implementing arbitrary
	 * data access operations on a single Statement, within Spring's managed JDBC
	 * environment: that is, participating in Spring-managed transactions and
	 * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param csc a callback that creates a CallableStatement given a Connection
	 * @param action a callback that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作作为对JDBC CallableStatement进行的回调操作实现。 
	 * 这允许在Spring的托管JDBC环境中的单个Statement上实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  csc一个回调，该回调创建给定Connection 
	 * @param 动作的CallableStatement，该回调指定该动作
	 * @return 该动作返回的结果对象，如果没有返回，则返回{@code  null} > DataAccessException，如果有任何问题
	 */
	@Nullable
	<T> T execute(CallableStatementCreator csc, CallableStatementCallback<T> action) throws DataAccessException;

	/**
	 * Execute a JDBC data access operation, implemented as callback action
	 * working on a JDBC CallableStatement. This allows for implementing arbitrary
	 * data access operations on a single Statement, within Spring's managed JDBC
	 * environment: that is, participating in Spring-managed transactions and
	 * converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
	 * <p>The callback action can return a result object, for example a domain
	 * object or a collection of domain objects.
	 * @param callString the SQL call string to execute
	 * @param action a callback that specifies the action
	 * @return a result object returned by the action, or {@code null} if none
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 执行JDBC数据访问操作，该操作作为对JDBC CallableStatement进行的回调操作实现。 
	 * 这允许在Spring的托管JDBC环境中的单个Statement上实现任意数据访问操作：也就是说，参与Spring托管的事务并将JDBC SQLExceptions转换为Spring的DataAccessException层次结构。 
	 *  <p>回调操作可以返回结果对象，例如域对象或域对象的集合。 
	 *  
	 * @param  callString执行
	 * @param 操作的SQL调用字符串一个指定操作的回调
	 * @return 操作返回的结果对象，如果没有，则返回{@code  null} 
	 * @throws  DataAccessException有什么问题
	 */
	@Nullable
	<T> T execute(String callString, CallableStatementCallback<T> action) throws DataAccessException;

	/**
	 * Execute an SQL call using a CallableStatementCreator to provide SQL and
	 * any required parameters.
	 * @param csc a callback that provides SQL and any necessary parameters
	 * @param declaredParameters list of declared SqlParameter objects
	 * @return a Map of extracted out parameters
	 * @throws DataAccessException if there is any problem issuing the update
	 */
	/**
	 * 使用CallableStatementCreator执行SQL调用以提供SQL和任何必需的参数。 
	 *  
	 * @param  csc提供了SQL和任何必要参数的回调
	 * @param 声明的SqlParameter对象的clarifiedParameters列表
	 * @return 提取出的参数的映射
	 * @throws  DataAccessException（如果发布更新有任何问题）
	 */
	Map<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters)
			throws DataAccessException;

}
