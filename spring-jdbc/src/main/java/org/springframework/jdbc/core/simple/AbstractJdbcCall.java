/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.core.simple;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.sql.DataSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.jdbc.core.CallableStatementCreator;
import org.springframework.jdbc.core.CallableStatementCreatorFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.metadata.CallMetaDataContext;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * Abstract class to provide base functionality for easy stored procedure calls
 * based on configuration options and database meta-data.
 *
 * <p>This class provides the base SPI for {@link SimpleJdbcCall}.
 *
 * @author Thomas Risberg
 * @author Juergen Hoeller
 * @since 2.5
 */
/**
 * 抽象类，为基于配置选项和数据库元数据的轻松存储过程调用提供基本功能。 
 *  <p>此类为{@link  SimpleJdbcCall}提供了基本SPI。 
 *  @author 托马斯·里斯伯格@author  Juergen Hoeller @since 2.5
 */
public abstract class AbstractJdbcCall {

	/** Logger available to subclasses. */
	/**
	 * 记录器可用于子类。 
	 * 
	 */
	protected final Log logger = LogFactory.getLog(getClass());

	/** Lower-level class used to execute SQL. */
	/**
	 * 用于执行SQL的较低级类。 
	 * 
	 */
	private final JdbcTemplate jdbcTemplate;

	/** Context used to retrieve and manage database meta-data. */
	/**
	 * 用于检索和管理数据库元数据的上下文。 
	 * 
	 */
	private final CallMetaDataContext callMetaDataContext = new CallMetaDataContext();

	/** List of SqlParameter objects. */
	/**
	 * SqlParameter对象的列表。 
	 * 
	 */
	private final List<SqlParameter> declaredParameters = new ArrayList<>();

	/** List of RefCursor/ResultSet RowMapper objects. */
	/**
	 * RefCursor / ResultSet RowMapper对象的列表。 
	 * 
	 */
	private final Map<String, RowMapper<?>> declaredRowMappers = new LinkedHashMap<>();

	/**
	 * Has this operation been compiled? Compilation means at least checking
	 * that a DataSource or JdbcTemplate has been provided.
	 */
	/**
	 * 此操作是否已编译？编译意味着至少检查是否已提供DataSource或JdbcTemplate。 
	 * 
	 */
	private volatile boolean compiled = false;

	/** The generated string used for call statement. */
	/**
	 * 生成的用于调用语句的字符串。 
	 * 
	 */
	@Nullable
	private String callString;

	/**
	 * A delegate enabling us to create CallableStatementCreators
	 * efficiently, based on this class's declared parameters.
	 */
	/**
	 * 一个委托，使我们能够基于此类的声明参数有效地创建CallableStatementCreators。 
	 * 
	 */
	@Nullable
	private CallableStatementCreatorFactory callableStatementFactory;


	/**
	 * Constructor to be used when initializing using a {@link DataSource}.
	 * @param dataSource the DataSource to be used
	 */
	/**
	 * 使用{@link  DataSource}进行初始化时要使用的构造方法。 
	 *  
	 * @param  dataSource要使用的数据源
	 */
	protected AbstractJdbcCall(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}

	/**
	 * Constructor to be used when initializing using a {@link JdbcTemplate}.
	 * @param jdbcTemplate the JdbcTemplate to use
	 */
	/**
	 * 使用{@link  JdbcTemplate}初始化时使用的构造方法。 
	 *  
	 * @param  jdbcTemplate要使用的JdbcTemplate
	 */
	protected AbstractJdbcCall(JdbcTemplate jdbcTemplate) {
		Assert.notNull(jdbcTemplate, "JdbcTemplate must not be null");
		this.jdbcTemplate = jdbcTemplate;
	}


	/**
	 * Get the configured {@link JdbcTemplate}.
	 */
	/**
	 * 获取配置的{@link  JdbcTemplate}。 
	 * 
	 */
	public JdbcTemplate getJdbcTemplate() {
		return this.jdbcTemplate;
	}

	/**
	 * Set the name of the stored procedure.
	 */
	/**
	 * 设置存储过程的名称。 
	 * 
	 */
	public void setProcedureName(@Nullable String procedureName) {
		this.callMetaDataContext.setProcedureName(procedureName);
	}

	/**
	 * Get the name of the stored procedure.
	 */
	/**
	 * 获取存储过程的名称。 
	 * 
	 */
	@Nullable
	public String getProcedureName() {
		return this.callMetaDataContext.getProcedureName();
	}

	/**
	 * Set the names of in parameters to be used.
	 */
	/**
	 * 设置要使用的in参数的名称。 
	 * 
	 */
	public void setInParameterNames(Set<String> inParameterNames) {
		this.callMetaDataContext.setLimitedInParameterNames(inParameterNames);
	}

	/**
	 * Get the names of in parameters to be used.
	 */
	/**
	 * 获取要使用的in参数的名称。 
	 * 
	 */
	public Set<String> getInParameterNames() {
		return this.callMetaDataContext.getLimitedInParameterNames();
	}

	/**
	 * Set the catalog name to use.
	 */
	/**
	 * 设置要使用的目录名称。 
	 * 
	 */
	public void setCatalogName(@Nullable String catalogName) {
		this.callMetaDataContext.setCatalogName(catalogName);
	}

	/**
	 * Get the catalog name used.
	 */
	/**
	 * 获取使用的目录名称。 
	 * 
	 */
	@Nullable
	public String getCatalogName() {
		return this.callMetaDataContext.getCatalogName();
	}

	/**
	 * Set the schema name to use.
	 */
	/**
	 * 设置要使用的架构名称。 
	 * 
	 */
	public void setSchemaName(@Nullable String schemaName) {
		this.callMetaDataContext.setSchemaName(schemaName);
	}

	/**
	 * Get the schema name used.
	 */
	/**
	 * 获取使用的架构名称。 
	 * 
	 */
	@Nullable
	public String getSchemaName() {
		return this.callMetaDataContext.getSchemaName();
	}

	/**
	 * Specify whether this call is a function call.
	 * The default is {@code false}.
	 */
	/**
	 * 指定此调用是否为函数调用。 
	 * 默认值为{@code  false}。 
	 * 
	 */
	public void setFunction(boolean function) {
		this.callMetaDataContext.setFunction(function);
	}

	/**
	 * Is this call a function call?
	 */
	/**
	 * 这是函数调用吗？
	 */
	public boolean isFunction() {
		return this.callMetaDataContext.isFunction();
	}

	/**
	 * Specify whether the call requires a return value.
	 * The default is {@code false}.
	 */
	/**
	 * 指定呼叫是否需要返回值。 
	 * 默认值为{@code  false}。 
	 * 
	 */
	public void setReturnValueRequired(boolean returnValueRequired) {
		this.callMetaDataContext.setReturnValueRequired(returnValueRequired);
	}

	/**
	 * Does the call require a return value?
	 */
	/**
	 * 调用是否需要返回值？
	 */
	public boolean isReturnValueRequired() {
		return this.callMetaDataContext.isReturnValueRequired();
	}

	/**
	 * Specify whether parameters should be bound by name.
	 * The default is {@code false}.
	 * @since 4.2
	 */
	/**
	 * 指定参数是否应按名称绑定。 
	 * 默认值为{@code  false}。 
	 *  @4.2起
	 */
	public void setNamedBinding(boolean namedBinding) {
		this.callMetaDataContext.setNamedBinding(namedBinding);
	}

	/**
	 * Should parameters be bound by name?
	 * @since 4.2
	 */
	/**
	 * 参数是否应按名称绑定？ @4.2起
	 */
	public boolean isNamedBinding() {
		return this.callMetaDataContext.isNamedBinding();
	}

	/**
	 * Specify whether the parameter meta-data for the call should be used.
	 * The default is {@code true}.
	 */
	/**
	 * 指定是否应使用该调用的参数元数据。 
	 * 默认值为{@code  true}。 
	 * 
	 */
	public void setAccessCallParameterMetaData(boolean accessCallParameterMetaData) {
		this.callMetaDataContext.setAccessCallParameterMetaData(accessCallParameterMetaData);
	}

	/**
	 * Get the call string that should be used based on parameters and meta-data.
	 */
	/**
	 * 根据参数和元数据获取应使用的调用字符串。 
	 * 
	 */
	@Nullable
	public String getCallString() {
		return this.callString;
	}

	/**
	 * Get the {@link CallableStatementCreatorFactory} being used.
	 */
	/**
	 * 获取正在使用的{@link  CallableStatementCreatorFactory}。 
	 * 
	 */
	protected CallableStatementCreatorFactory getCallableStatementFactory() {
		Assert.state(this.callableStatementFactory != null, "No CallableStatementCreatorFactory available");
		return this.callableStatementFactory;
	}


	/**
	 * Add a declared parameter to the list of parameters for the call.
	 * <p>Only parameters declared as {@code SqlParameter} and {@code SqlInOutParameter} will
	 * be used to provide input values. This is different from the {@code StoredProcedure}
	 * class which - for backwards compatibility reasons - allows input values to be provided
	 * for parameters declared as {@code SqlOutParameter}.
	 * @param parameter the {@link SqlParameter} to add
	 */
	/**
	 * 将已声明的参数添加到调用的参数列表中。 
	 *  <p>仅声明为{@code  SqlParameter}和{@code  SqlInOutParameter}的参数将用于提供输入值。 
	 * 这与{@code  StoredProcedure}类不同，出于向后兼容的原因，该类允许为声明为{@code  SqlOutParameter}的参数提供输入值。 
	 *  
	 * @param 参数{{@@link> SqlParameter}添加
	 */
	public void addDeclaredParameter(SqlParameter parameter) {
		Assert.notNull(parameter, "The supplied parameter must not be null");
		if (!StringUtils.hasText(parameter.getName())) {
			throw new InvalidDataAccessApiUsageException(
					"You must specify a parameter name when declaring parameters for \"" + getProcedureName() + "\"");
		}
		this.declaredParameters.add(parameter);
		if (logger.isDebugEnabled()) {
			logger.debug("Added declared parameter for [" + getProcedureName() + "]: " + parameter.getName());
		}
	}

	/**
	 * Add a {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
	 * @param parameterName name of parameter or column
	 * @param rowMapper the RowMapper implementation to use
	 */
	/**
	 * 为指定的参数或列添加一个{@link  org.springframework.jdbc.core.RowMapper}。 
	 *  
	 * @param  parameterName参数或列的名称
	 * @param  rowMapper要使用的RowMapper实现
	 */
	public void addDeclaredRowMapper(String parameterName, RowMapper<?> rowMapper) {
		this.declaredRowMappers.put(parameterName, rowMapper);
		if (logger.isDebugEnabled()) {
			logger.debug("Added row mapper for [" + getProcedureName() + "]: " + parameterName);
		}
	}


	//-------------------------------------------------------------------------
	// Methods handling compilation issues
	//-------------------------------------------------------------------------

	/**
	 * Compile this JdbcCall using provided parameters and meta-data plus other settings.
	 * <p>This finalizes the configuration for this object and subsequent attempts to compile are
	 * ignored. This will be implicitly called the first time an un-compiled call is executed.
	 * @throws org.springframework.dao.InvalidDataAccessApiUsageException if the object hasn't
	 * been correctly initialized, for example if no DataSource has been provided
	 */
	/**
	 * 使用提供的参数和元数据以及其他设置来编译此JdbcCall。 
	 *  <p>这将最终确定该对象的配置，随后的编译尝试将被忽略。 
	 * 第一次执行未编译的调用时，将隐式调用此方法。 
	 *  
	 * @throws  org.springframework.dao.InvalidDataAccessApiUsageException如果未正确初始化对象，例如，如果未提供DataSource
	 */
	public final synchronized void compile() throws InvalidDataAccessApiUsageException {
		if (!isCompiled()) {
			if (getProcedureName() == null) {
				throw new InvalidDataAccessApiUsageException("Procedure or Function name is required");
			}
			try {
				this.jdbcTemplate.afterPropertiesSet();
			}
			catch (IllegalArgumentException ex) {
				throw new InvalidDataAccessApiUsageException(ex.getMessage());
			}
			compileInternal();
			this.compiled = true;
			if (logger.isDebugEnabled()) {
				logger.debug("SqlCall for " + (isFunction() ? "function" : "procedure") +
						" [" + getProcedureName() + "] compiled");
			}
		}
	}

	/**
	 * Delegate method to perform the actual compilation.
	 * <p>Subclasses can override this template method to perform their own compilation.
	 * Invoked after this base class's compilation is complete.
	 */
	/**
	 * 委托方法执行实际的编译。 
	 *  <p>子类可以重写此模板方法以执行自己的编译。 
	 * 在此基类的编译完成之后调用。 
	 * 
	 */
	protected void compileInternal() {
		DataSource dataSource = getJdbcTemplate().getDataSource();
		Assert.state(dataSource != null, "No DataSource set");
		this.callMetaDataContext.initializeMetaData(dataSource);

		// Iterate over the declared RowMappers and register the corresponding SqlParameter
		this.declaredRowMappers.forEach((key, value) -> this.declaredParameters.add(this.callMetaDataContext.createReturnResultSetParameter(key, value)));
		this.callMetaDataContext.processParameters(this.declaredParameters);

		this.callString = this.callMetaDataContext.createCallString();
		if (logger.isDebugEnabled()) {
			logger.debug("Compiled stored procedure. Call string is [" + this.callString + "]");
		}

		this.callableStatementFactory = new CallableStatementCreatorFactory(
				this.callString, this.callMetaDataContext.getCallParameters());

		onCompileInternal();
	}

	/**
	 * Hook method that subclasses may override to react to compilation.
	 * This implementation does nothing.
	 */
	/**
	 * 子类的Hook方法可能会覆盖以响应编译。 
	 * 此实现不执行任何操作。 
	 * 
	 */
	protected void onCompileInternal() {
	}

	/**
	 * Is this operation "compiled"?
	 * @return whether this operation is compiled and ready to use
	 */
	/**
	 * 此操作是"编译的"吗？ 
	 * @return 此操作是否已编译并可以使用
	 */
	public boolean isCompiled() {
		return this.compiled;
	}

	/**
	 * Check whether this operation has been compiled already;
	 * lazily compile it if not already compiled.
	 * <p>Automatically called by {@code doExecute}.
	 */
	/**
	 * 检查该操作是否已经编译； 
	 * 如果尚未编译，请延迟编译。 
	 *  <p>由{@code  doExecute}自动调用。 
	 * 
	 */
	protected void checkCompiled() {
		if (!isCompiled()) {
			logger.debug("JdbcCall call not compiled before execution - invoking compile");
			compile();
		}
	}


	//-------------------------------------------------------------------------
	// Methods handling execution
	//-------------------------------------------------------------------------

	/**
	 * Delegate method that executes the call using the passed-in {@link SqlParameterSource}.
	 * @param parameterSource parameter names and values to be used in call
	 * @return a Map of out parameters
	 */
	/**
	 * 使用传入的{@link  SqlParameterSource}执行调用的委托方法。 
	 *  
	 * @param  parameterSource调用中使用的参数名称和值
	 * @return  out参数的映射
	 */
	protected Map<String, Object> doExecute(SqlParameterSource parameterSource) {
		checkCompiled();
		Map<String, Object> params = matchInParameterValuesWithCallParameters(parameterSource);
		return executeCallInternal(params);
	}

	/**
	 * Delegate method that executes the call using the passed-in array of parameters.
	 * @param args array of parameter values. The order of values must match the order
	 * declared for the stored procedure.
	 * @return a Map of out parameters
	 */
	/**
	 * 使用传入的参数数组执行调用的委托方法。 
	 *  
	 * @param 参数值的args数组。 
	 * 值的顺序必须与为存储过程声明的顺序匹配。 
	 *  
	 * @return 输出参数的映射
	 */
	protected Map<String, Object> doExecute(Object... args) {
		checkCompiled();
		Map<String, ?> params = matchInParameterValuesWithCallParameters(args);
		return executeCallInternal(params);
	}

	/**
	 * Delegate method that executes the call using the passed-in Map of parameters.
	 * @param args a Map of parameter name and values
	 * @return a Map of out parameters
	 */
	/**
	 * 使用传入的参数Map执行调用的委托方法。 
	 *  
	 * @param  args参数名称和值的映射
	 * @return  out参数的映射
	 */
	protected Map<String, Object> doExecute(Map<String, ?> args) {
		checkCompiled();
		Map<String, ?> params = matchInParameterValuesWithCallParameters(args);
		return executeCallInternal(params);
	}

	/**
	 * Delegate method to perform the actual call processing.
	 */
	/**
	 * 委托方法执行实际的呼叫处理。 
	 * 
	 */
	private Map<String, Object> executeCallInternal(Map<String, ?> args) {
		CallableStatementCreator csc = getCallableStatementFactory().newCallableStatementCreator(args);
		if (logger.isDebugEnabled()) {
			logger.debug("The following parameters are used for call " + getCallString() + " with " + args);
			int i = 1;
			for (SqlParameter param : getCallParameters()) {
				logger.debug(i + ": " +  param.getName() + ", SQL type "+ param.getSqlType() + ", type name " +
						param.getTypeName() + ", parameter class [" + param.getClass().getName() + "]");
				i++;
			}
		}
		return getJdbcTemplate().call(csc, getCallParameters());
	}


	/**
	 * Get the name of a single out parameter or return value.
	 * Used for functions or procedures with one out parameter.
	 */
	/**
	 * 获取单个输出参数的名称或返回值。 
	 * 用于具有一出参数的功能或过程。 
	 * 
	 */
	@Nullable
	protected String getScalarOutParameterName() {
		return this.callMetaDataContext.getScalarOutParameterName();
	}

	/**
	 * Get a List of all the call parameters to be used for call.
	 * This includes any parameters added based on meta-data processing.
	 */
	/**
	 * 获取要用于呼叫的所有呼叫参数的列表。 
	 * 这包括基于元数据处理添加的任何参数。 
	 * 
	 */
	protected List<SqlParameter> getCallParameters() {
		return this.callMetaDataContext.getCallParameters();
	}

	/**
	 * Match the provided in parameter values with registered parameters and
	 * parameters defined via meta-data processing.
	 * @param parameterSource the parameter vakues provided as a {@link SqlParameterSource}
	 * @return a Map with parameter names and values
	 */
	/**
	 * 将参数值中提供的参数与注册的参数和通过元数据处理定义的参数进行匹配。 
	 *  
	 * @param  parameterSource作为{@link  SqlParameterSource}提供的参数变量
	 * @return 具有参数名称和值的Map
	 */
	protected Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource) {
		return this.callMetaDataContext.matchInParameterValuesWithCallParameters(parameterSource);
	}

	/**
	 * Match the provided in parameter values with registered parameters and
	 * parameters defined via meta-data processing.
	 * @param args the parameter values provided as an array
	 * @return a Map with parameter names and values
	 */
	/**
	 * 将参数值中提供的参数与注册的参数和通过元数据处理定义的参数进行匹配。 
	 *  
	 * @param  args以数组形式提供的参数值
	 * @return 带有参数名称和值的Map
	 */
	private Map<String, ?> matchInParameterValuesWithCallParameters(Object[] args) {
		return this.callMetaDataContext.matchInParameterValuesWithCallParameters(args);
	}

	/**
	 * Match the provided in parameter values with registered parameters and
	 * parameters defined via meta-data processing.
	 * @param args the parameter values provided in a Map
	 * @return a Map with parameter names and values
	 */
	/**
	 * 将参数值中提供的参数与注册的参数和通过元数据处理定义的参数进行匹配。 
	 *  
	 * @param  args Map中提供的参数值
	 * @return  Map中的参数名称和值
	 */
	protected Map<String, ?> matchInParameterValuesWithCallParameters(Map<String, ?> args) {
		return this.callMetaDataContext.matchInParameterValuesWithCallParameters(args);
	}

}
