/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.datasource;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.Constants;
import org.springframework.lang.Nullable;

/**
 * Proxy for a target DataSource, fetching actual JDBC Connections lazily,
 * i.e. not until first creation of a Statement. Connection initialization
 * properties like auto-commit mode, transaction isolation and read-only mode
 * will be kept and applied to the actual JDBC Connection as soon as an
 * actual Connection is fetched (if ever). Consequently, commit and rollback
 * calls will be ignored if no Statements have been created.
 *
 * <p>This DataSource proxy allows to avoid fetching JDBC Connections from
 * a pool unless actually necessary. JDBC transaction control can happen
 * without fetching a Connection from the pool or communicating with the
 * database; this will be done lazily on first creation of a JDBC Statement.
 *
 * <p><b>If you configure both a LazyConnectionDataSourceProxy and a
 * TransactionAwareDataSourceProxy, make sure that the latter is the outermost
 * DataSource.</b> In such a scenario, data access code will talk to the
 * transaction-aware DataSource, which will in turn work with the
 * LazyConnectionDataSourceProxy.
 *
 * <p>Lazy fetching of physical JDBC Connections is particularly beneficial
 * in a generic transaction demarcation environment. It allows you to demarcate
 * transactions on all methods that could potentially perform data access,
 * without paying a performance penalty if no actual data access happens.
 *
 * <p>This DataSource proxy gives you behavior analogous to JTA and a
 * transactional JNDI DataSource (as provided by the Java EE server), even
 * with a local transaction strategy like DataSourceTransactionManager or
 * HibernateTransactionManager. It does not add value with Spring's
 * JtaTransactionManager as transaction strategy.
 *
 * <p>Lazy fetching of JDBC Connections is also recommended for read-only
 * operations with Hibernate, in particular if the chances of resolving the
 * result in the second-level cache are high. This avoids the need to
 * communicate with the database at all for such read-only operations.
 * You will get the same effect with non-transactional reads, but lazy fetching
 * of JDBC Connections allows you to still perform reads in transactions.
 *
 * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections
 * (which implement the {@link ConnectionProxy} interface) in order to handle
 * lazy fetching of an actual JDBC Connection. Use {@link Connection#unwrap}
 * to retrieve the native JDBC Connection.
 *
 * @author Juergen Hoeller
 * @since 1.1.4
 * @see DataSourceTransactionManager
 */
/**
 * 目标数据源的代理，延迟获取实际的JDBC连接，即直到第一次创建Statement之前。 
 * 连接初始化属性（例如自动提交模式，事务隔离和只读模式）将在获取实际的Connection（如果有）后立即保留并应用于实际的JDBC Connection。 
 * 因此，如果未创建任何语句，则将忽略提交和回滚调用。 
 *  <p>除非实际需要，否则此DataSource代理可避免从池中获取JDBC连接。 
 * 无需从池中获取Connection或与数据库进行通信就可以进行JDBC事务控制。 
 * 这将在第一次创建JDBC语句时懒惰地完成。 
 *  <p> <b>如果同时配置LazyConnectionDataSourceProxy和TransactionAwareDataSourceProxy，请确保后者是最外面的数据源。 
 * </ b>在这种情况下，数据访问代码将与事务感知的数据源进行通信，该数据源将在打开LazyConnectionDataSourceProxy。 
 *  <p>在常规事务划分环境中，物理JDBC连接的延迟获取特别有利。 
 * 它允许您在所有可能执行数据访问的方法上划分事务，如果没有实际的数据访问发生，则不会付出性能损失。 
 *  <p>此DataSource代理为您提供类似于JTA和事务性JNDI DataSource（由Java EE服务器提供）的行为，甚至具有诸如DataSourceTransactionManager或HibernateTransactionManager之类的本地事务处理策略。 
 * 它不会通过Spring的JtaTransactionManager作为交易策略来增加价值。 
 *  <p>对于与Hibernate进行的只读操作，也建议延迟获取JDBC连接，特别是在二级缓存中解决结果的机会很高时。 
 * 这样就完全不需要为此类只读操作与数据库通信。 
 * 使用非事务性读取将获得相同的效果，但是通过懒惰地获取JDBC连接，您仍然可以在事务中执行读取。 
 *  <p> <b>注意：</ b>此DataSource代理需要返回包装的Connections（实现{@link  ConnectionProxy}接口），以便处理实际JDBC Connection的延迟获取。 
 * 使用{@link  Connection＃unwrap}检索本机JDBC Connection。 
 *  @author  Juergen Hoeller @始于1.1.4 
 * @see  DataSourceTransactionManager
 */
public class LazyConnectionDataSourceProxy extends DelegatingDataSource {

	/** Constants instance for TransactionDefinition. */
	/**
	 * TransactionDefinition的常量实例。 
	 * 
	 */
	private static final Constants constants = new Constants(Connection.class);

	private static final Log logger = LogFactory.getLog(LazyConnectionDataSourceProxy.class);

	@Nullable
	private Boolean defaultAutoCommit;

	@Nullable
	private Integer defaultTransactionIsolation;


	/**
	 * Create a new LazyConnectionDataSourceProxy.
	 * @see #setTargetDataSource
	 */
	/**
	 * 创建一个新的LazyConnectionDataSourceProxy。 
	 *  
	 * @see  #setTargetDataSource
	 */
	public LazyConnectionDataSourceProxy() {
	}

	/**
	 * Create a new LazyConnectionDataSourceProxy.
	 * @param targetDataSource the target DataSource
	 */
	/**
	 * 创建一个新的LazyConnectionDataSourceProxy。 
	 *  
	 * @param  targetDataSource目标数据源
	 */
	public LazyConnectionDataSourceProxy(DataSource targetDataSource) {
		setTargetDataSource(targetDataSource);
		afterPropertiesSet();
	}


	/**
	 * Set the default auto-commit mode to expose when no target Connection
	 * has been fetched yet (-> actual JDBC Connection default not known yet).
	 * <p>If not specified, the default gets determined by checking a target
	 * Connection on startup. If that check fails, the default will be determined
	 * lazily on first access of a Connection.
	 * @see java.sql.Connection#setAutoCommit
	 */
	/**
	 * 设置默认的自动提交模式，以在尚未获取任何目标连接时公开（->实际的JDBC连接默认值未知）。 
	 *  <p>如果未指定，则默认值通过在启动时检查目标连接来确定。 
	 * 如果该检查失败，则将在首次访问Connection时延迟确定默认值。 
	 *  
	 * @see  java.sql.Connection＃setAutoCommit
	 */
	public void setDefaultAutoCommit(boolean defaultAutoCommit) {
		this.defaultAutoCommit = defaultAutoCommit;
	}

	/**
	 * Set the default transaction isolation level to expose when no target Connection
	 * has been fetched yet (-> actual JDBC Connection default not known yet).
	 * <p>This property accepts the int constant value (e.g. 8) as defined in the
	 * {@link java.sql.Connection} interface; it is mainly intended for programmatic
	 * use. Consider using the "defaultTransactionIsolationName" property for setting
	 * the value by name (e.g. "TRANSACTION_SERIALIZABLE").
	 * <p>If not specified, the default gets determined by checking a target
	 * Connection on startup. If that check fails, the default will be determined
	 * lazily on first access of a Connection.
	 * @see #setDefaultTransactionIsolationName
	 * @see java.sql.Connection#setTransactionIsolation
	 */
	/**
	 * 设置默认事务隔离级别，以在尚未提取目标连接时公开（->实际的JDBC Connection默认默认值尚不知道）。 
	 *  <p>此属性接受{@link  java.sql.Connection}接口中定义的int常数值（例如8）； 
	 * 它主要用于程序设计。 
	 * 考虑使用"defaultTransactionIsolationName"属性通过名称设置值（例如"TRANSACTION_SERIALIZABLE"）。 
	 *  <p>如果未指定，则默认值通过在启动时检查目标连接来确定。 
	 * 如果该检查失败，则将在首次访问Connection时延迟确定默认值。 
	 *  
	 * @see  #setDefaultTransactionIsolationName 
	 * @see  java.sql.Connection＃setTransactionIsolation
	 */
	public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {
		this.defaultTransactionIsolation = defaultTransactionIsolation;
	}

	/**
	 * Set the default transaction isolation level by the name of the corresponding
	 * constant in {@link java.sql.Connection}, e.g. "TRANSACTION_SERIALIZABLE".
	 * @param constantName name of the constant
	 * @see #setDefaultTransactionIsolation
	 * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED
	 * @see java.sql.Connection#TRANSACTION_READ_COMMITTED
	 * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ
	 * @see java.sql.Connection#TRANSACTION_SERIALIZABLE
	 */
	/**
	 * 通过{@link  java.sql.Connection}中相应常量的名称设置默认事务隔离级别，例如"TRANSACTION_SERIALIZABLE"。 
	 *  
	 * @param  constantName常量名称
	 * @see  #setDefaultTransactionIsolation 
	 * @see  java.sql.Connection＃TRANSACTION_READ_UNCOMMITTED 
	 * @see  java.sql.Connection＃TRANSACTION_READ_COMMITTED 
	 * @see  java.sql.Connection＃TRANSACTION_REPEATABLE_READ <@请参阅> java.sql.Connection＃TRANSACTION_SERIALIZABLE
	 */
	public void setDefaultTransactionIsolationName(String constantName) {
		setDefaultTransactionIsolation(constants.asNumber(constantName).intValue());
	}


	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();

		// Determine default auto-commit and transaction isolation
		// via a Connection from the target DataSource, if possible.
		if (this.defaultAutoCommit == null || this.defaultTransactionIsolation == null) {
			try {
				try (Connection con = obtainTargetDataSource().getConnection()) {
					checkDefaultConnectionProperties(con);
				}
			}
			catch (SQLException ex) {
				logger.debug("Could not retrieve default auto-commit and transaction isolation settings", ex);
			}
		}
	}

	/**
	 * Check the default connection properties (auto-commit, transaction isolation),
	 * keeping them to be able to expose them correctly without fetching an actual
	 * JDBC Connection from the target DataSource.
	 * <p>This will be invoked once on startup, but also for each retrieval of a
	 * target Connection. If the check failed on startup (because the database was
	 * down), we'll lazily retrieve those settings.
	 * @param con the Connection to use for checking
	 * @throws SQLException if thrown by Connection methods
	 */
	/**
	 * 检查默认的连接属性（自动提交，事务隔离），以使它们能够正确公开它们，而无需从目标数据源获取实际的JDBC连接。 
	 *  <p>这将在启动时被调用一次，但也将在每次检索目标Connection时被调用。 
	 * 如果检查在启动时失败（因为数据库已关闭），我们将懒惰地检索这些设置。 
	 *  
	 * @param 构造用于检查
	 * @throws  SQLException的Connection（如果由Connection方法抛出）
	 */
	protected synchronized void checkDefaultConnectionProperties(Connection con) throws SQLException {
		if (this.defaultAutoCommit == null) {
			this.defaultAutoCommit = con.getAutoCommit();
		}
		if (this.defaultTransactionIsolation == null) {
			this.defaultTransactionIsolation = con.getTransactionIsolation();
		}
	}

	/**
	 * Expose the default auto-commit value.
	 */
	/**
	 * 公开默认的自动提交值。 
	 * 
	 */
	@Nullable
	protected Boolean defaultAutoCommit() {
		return this.defaultAutoCommit;
	}

	/**
	 * Expose the default transaction isolation value.
	 */
	/**
	 * 公开默认的事务隔离值。 
	 * 
	 */
	@Nullable
	protected Integer defaultTransactionIsolation() {
		return this.defaultTransactionIsolation;
	}


	/**
	 * Return a Connection handle that lazily fetches an actual JDBC Connection
	 * when asked for a Statement (or PreparedStatement or CallableStatement).
	 * <p>The returned Connection handle implements the ConnectionProxy interface,
	 * allowing to retrieve the underlying target Connection.
	 * @return a lazy Connection handle
	 * @see ConnectionProxy#getTargetConnection()
	 */
	/**
	 * 返回一个Connection句柄，当要求输入Statement（或PreparedStatement或CallableStatement）时，它懒惰地获取实际的JDBC Connection。 
	 *  <p>返回的Connection句柄实现ConnectionProxy接口，允许检索基础目标Connection。 
	 *  
	 * @return 一个懒惰的Connection句柄
	 * @see  ConnectionProxy＃getTargetConnection（）
	 */
	@Override
	public Connection getConnection() throws SQLException {
		return (Connection) Proxy.newProxyInstance(
				ConnectionProxy.class.getClassLoader(),
				new Class<?>[] {ConnectionProxy.class},
				new LazyConnectionInvocationHandler());
	}

	/**
	 * Return a Connection handle that lazily fetches an actual JDBC Connection
	 * when asked for a Statement (or PreparedStatement or CallableStatement).
	 * <p>The returned Connection handle implements the ConnectionProxy interface,
	 * allowing to retrieve the underlying target Connection.
	 * @param username the per-Connection username
	 * @param password the per-Connection password
	 * @return a lazy Connection handle
	 * @see ConnectionProxy#getTargetConnection()
	 */
	/**
	 * 返回一个Connection句柄，当要求输入Statement（或PreparedStatement或CallableStatement）时，它懒惰地获取实际的JDBC Connection。 
	 *  <p>返回的Connection句柄实现ConnectionProxy接口，允许检索基础目标Connection。 
	 *  
	 * @param 用户名每个连接的用户名
	 * @param 密码每个连接的密码
	 * @return 惰性连接句柄
	 * @see  ConnectionProxy＃getTargetConnection（）
	 */
	@Override
	public Connection getConnection(String username, String password) throws SQLException {
		return (Connection) Proxy.newProxyInstance(
				ConnectionProxy.class.getClassLoader(),
				new Class<?>[] {ConnectionProxy.class},
				new LazyConnectionInvocationHandler(username, password));
	}


	/**
	 * Invocation handler that defers fetching an actual JDBC Connection
	 * until first creation of a Statement.
	 */
	/**
	 * 延迟获取实际的JDBC Connection的调用处理程序，直到首次创建Statement为止。 
	 * 
	 */
	private class LazyConnectionInvocationHandler implements InvocationHandler {

		@Nullable
		private String username;

		@Nullable
		private String password;

		@Nullable
		private Boolean autoCommit;

		@Nullable
		private Integer transactionIsolation;

		private boolean readOnly = false;

		private int holdability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

		private boolean closed = false;

		@Nullable
		private Connection target;

		public LazyConnectionInvocationHandler() {
			this.autoCommit = defaultAutoCommit();
			this.transactionIsolation = defaultTransactionIsolation();
		}

		public LazyConnectionInvocationHandler(String username, String password) {
			this();
			this.username = username;
			this.password = password;
		}

		@Override
		@Nullable
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			// Invocation on ConnectionProxy interface coming in...

			if (method.getName().equals("equals")) {
				// We must avoid fetching a target Connection for "equals".
				// Only consider equal when proxies are identical.
				return (proxy == args[0]);
			}
			else if (method.getName().equals("hashCode")) {
				// We must avoid fetching a target Connection for "hashCode",
				// and we must return the same hash code even when the target
				// Connection has been fetched: use hashCode of Connection proxy.
				return System.identityHashCode(proxy);
			}
			else if (method.getName().equals("unwrap")) {
				if (((Class<?>) args[0]).isInstance(proxy)) {
					return proxy;
				}
			}
			else if (method.getName().equals("isWrapperFor")) {
				if (((Class<?>) args[0]).isInstance(proxy)) {
					return true;
				}
			}
			else if (method.getName().equals("getTargetConnection")) {
				// Handle getTargetConnection method: return underlying connection.
				return getTargetConnection(method);
			}

			if (!hasTargetConnection()) {
				// No physical target Connection kept yet ->
				// resolve transaction demarcation methods without fetching
				// a physical JDBC Connection until absolutely necessary.

				if (method.getName().equals("toString")) {
					return "Lazy Connection proxy for target DataSource [" + getTargetDataSource() + "]";
				}
				else if (method.getName().equals("getAutoCommit")) {
					if (this.autoCommit != null) {
						return this.autoCommit;
					}
					// Else fetch actual Connection and check there,
					// because we didn't have a default specified.
				}
				else if (method.getName().equals("setAutoCommit")) {
					this.autoCommit = (Boolean) args[0];
					return null;
				}
				else if (method.getName().equals("getTransactionIsolation")) {
					if (this.transactionIsolation != null) {
						return this.transactionIsolation;
					}
					// Else fetch actual Connection and check there,
					// because we didn't have a default specified.
				}
				else if (method.getName().equals("setTransactionIsolation")) {
					this.transactionIsolation = (Integer) args[0];
					return null;
				}
				else if (method.getName().equals("isReadOnly")) {
					return this.readOnly;
				}
				else if (method.getName().equals("setReadOnly")) {
					this.readOnly = (Boolean) args[0];
					return null;
				}
				else if (method.getName().equals("getHoldability")) {
					return this.holdability;
				}
				else if (method.getName().equals("setHoldability")) {
					this.holdability = (Integer) args[0];
					return null;
				}
				else if (method.getName().equals("commit") || method.getName().equals("rollback")) {
					// Ignore: no statements created yet.
					return null;
				}
				else if (method.getName().equals("getWarnings") || method.getName().equals("clearWarnings")) {
					// Ignore: no warnings to expose yet.
					return null;
				}
				else if (method.getName().equals("close")) {
					// Ignore: no target connection yet.
					this.closed = true;
					return null;
				}
				else if (method.getName().equals("isClosed")) {
					return this.closed;
				}
				else if (this.closed) {
					// Connection proxy closed, without ever having fetched a
					// physical JDBC Connection: throw corresponding SQLException.
					throw new SQLException("Illegal operation: connection is closed");
				}
			}

			// Target Connection already fetched,
			// or target Connection necessary for current operation ->
			// invoke method on target connection.
			try {
				return method.invoke(getTargetConnection(method), args);
			}
			catch (InvocationTargetException ex) {
				throw ex.getTargetException();
			}
		}

		/**
		 * Return whether the proxy currently holds a target Connection.
		 */
		/**
		 * 返回代理当前是否持有目标连接。 
		 * 
		 */
		private boolean hasTargetConnection() {
			return (this.target != null);
		}

		/**
		 * Return the target Connection, fetching it and initializing it if necessary.
		 */
		/**
		 * 返回目标连接，获取它并在必要时对其进行初始化。 
		 * 
		 */
		private Connection getTargetConnection(Method operation) throws SQLException {
			if (this.target == null) {
				// No target Connection held -> fetch one.
				if (logger.isTraceEnabled()) {
					logger.trace("Connecting to database for operation '" + operation.getName() + "'");
				}

				// Fetch physical Connection from DataSource.
				this.target = (this.username != null) ?
						obtainTargetDataSource().getConnection(this.username, this.password) :
						obtainTargetDataSource().getConnection();

				// If we still lack default connection properties, check them now.
				checkDefaultConnectionProperties(this.target);

				// Apply kept transaction settings, if any.
				if (this.readOnly) {
					try {
						this.target.setReadOnly(true);
					}
					catch (Exception ex) {
						// "read-only not supported" -> ignore, it's just a hint anyway
						logger.debug("Could not set JDBC Connection read-only", ex);
					}
				}
				if (this.transactionIsolation != null &&
						!this.transactionIsolation.equals(defaultTransactionIsolation())) {
					this.target.setTransactionIsolation(this.transactionIsolation);
				}
				if (this.autoCommit != null && this.autoCommit != this.target.getAutoCommit()) {
					this.target.setAutoCommit(this.autoCommit);
				}
			}

			else {
				// Target Connection already held -> return it.
				if (logger.isTraceEnabled()) {
					logger.trace("Using existing database connection for operation '" + operation.getName() + "'");
				}
			}

			return this.target;
		}
	}

}
