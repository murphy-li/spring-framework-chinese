/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.datasource;

import java.sql.Connection;
import java.sql.SQLException;

import org.springframework.core.Constants;
import org.springframework.lang.Nullable;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.TransactionSynchronizationManager;

/**
 * An adapter for a target {@link javax.sql.DataSource}, applying the current
 * Spring transaction's isolation level (and potentially specified user credentials)
 * to every {@code getConnection} call. Also applies the read-only flag,
 * if specified.
 *
 * <p>Can be used to proxy a target JNDI DataSource that does not have the
 * desired isolation level (and user credentials) configured. Client code
 * can work with this DataSource as usual, not worrying about such settings.
 *
 * <p>Inherits the capability to apply specific user credentials from its superclass
 * {@link UserCredentialsDataSourceAdapter}; see the latter's javadoc for details
 * on that functionality (e.g. {@link #setCredentialsForCurrentThread}).
 *
 * <p><b>WARNING:</b> This adapter simply calls
 * {@link java.sql.Connection#setTransactionIsolation} and/or
 * {@link java.sql.Connection#setReadOnly} for every Connection obtained from it.
 * It does, however, <i>not</i> reset those settings; it rather expects the target
 * DataSource to perform such resetting as part of its connection pool handling.
 * <b>Make sure that the target DataSource properly cleans up such transaction state.</b>
 *
 * @author Juergen Hoeller
 * @since 2.0.3
 * @see #setIsolationLevel
 * @see #setIsolationLevelName
 * @see #setUsername
 * @see #setPassword
 */
/**
 * 目标{@link  javax.sql.DataSource}的适配器，将当前Spring事务的隔离级别（以及可能指定的用户凭据）应用于每个{@code  getConnection}调用。 
 * 如果指定，还应用只读标志。 
 *  <p>可用于代理未配置所需隔离级别（和用户凭据）的目标JNDI数据源。 
 * 客户端代码可以照常使用此DataSource，而不必担心此类设置。 
 *  <p>从其超类{@link  UserCredentialsDataSourceAdapter}继承应用特定用户凭据的功能； 
 * 有关该功能的详细信息，请参见后者的javadoc（例如{@link  #setCredentialsForCurrentThread}）。 
 *  <p> <b>警告：</ b>对于从中获得的每个连接，此适配器仅调用{@link  java.sql.Connection＃setTransactionIsolation}和/或{@link  java.sql.Connection＃setReadOnly}它。 
 * 但是，它不会<i>不</ i>重置那些设置。 
 * 而是希望目标数据源在连接池处理过程中执行此类重置。 
 *  <b>确保目标数据源正确清理了这种事务状态。 
 * </ b> @author  Juergen Hoeller @since 2.0.3 
 * @see  #setIsolationLevel 
 * @see  #setIsolationLevelName 
 * @see  #setUsername 
 * @see  #setPassword
 */
public class IsolationLevelDataSourceAdapter extends UserCredentialsDataSourceAdapter {

	/** Constants instance for TransactionDefinition. */
	/**
	 * TransactionDefinition的常量实例。 
	 * 
	 */
	private static final Constants constants = new Constants(TransactionDefinition.class);

	@Nullable
	private Integer isolationLevel;


	/**
	 * Set the default isolation level by the name of the corresponding constant
	 * in {@link org.springframework.transaction.TransactionDefinition}, e.g.
	 * "ISOLATION_SERIALIZABLE".
	 * <p>If not specified, the target DataSource's default will be used.
	 * Note that a transaction-specific isolation value will always override
	 * any isolation setting specified at the DataSource level.
	 * @param constantName name of the constant
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE
	 * @see #setIsolationLevel
	 */
	/**
	 * 通过{@link  org.springframework.transaction.TransactionDefinition}中相应常量的名称设置默认隔离级别，例如"ISOLATION_SERIALIZABLE"。 
	 *  <p>如果未指定，将使用目标数据源的默认值。 
	 * 请注意，特定于事务的隔离值将始终覆盖在数据源级别指定的任何隔离设置。 
	 *  
	 * @param  constantName常量名称
	 * @see  org.springframework.transaction.TransactionDefinition＃ISOLATION_READ_UNCOMMITTED请参阅> org.springframework.transaction.TransactionDefinition＃ISOLATION_SERIALIZABLE <@请参阅#setIsolationLevel
	 */
	public final void setIsolationLevelName(String constantName) throws IllegalArgumentException {
		if (!constantName.startsWith(DefaultTransactionDefinition.PREFIX_ISOLATION)) {
			throw new IllegalArgumentException("Only isolation constants allowed");
		}
		setIsolationLevel(constants.asNumber(constantName).intValue());
	}

	/**
	 * Specify the default isolation level to use for Connection retrieval,
	 * according to the JDBC {@link java.sql.Connection} constants
	 * (equivalent to the corresponding Spring
	 * {@link org.springframework.transaction.TransactionDefinition} constants).
	 * <p>If not specified, the target DataSource's default will be used.
	 * Note that a transaction-specific isolation value will always override
	 * any isolation setting specified at the DataSource level.
	 * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED
	 * @see java.sql.Connection#TRANSACTION_READ_COMMITTED
	 * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ
	 * @see java.sql.Connection#TRANSACTION_SERIALIZABLE
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_UNCOMMITTED
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_READ_COMMITTED
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_REPEATABLE_READ
	 * @see org.springframework.transaction.TransactionDefinition#ISOLATION_SERIALIZABLE
	 * @see org.springframework.transaction.TransactionDefinition#getIsolationLevel()
	 * @see org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionIsolationLevel()
	 */
	/**
	 * 根据JDBC {@link  java.sql.Connection}常量（相当于相应的Spring {@link  org.springframework.transaction.TransactionDefinition}常量），指定用于连接检索的默认隔离级别。 
	 *  <p>如果未指定，将使用目标数据源的默认值。 
	 * 请注意，特定于事务的隔离值将始终覆盖在数据源级别指定的任何隔离设置。 
	 *  
	 * @see  java.sql.Connection＃TRANSACTION_READ_UNCOMMITTED 
	 * @see  java.sql.Connection＃TRANSACTION_READ_COMMITTED 
	 * @see  java.sql.Connection＃TRANSACTION_REPEATABLE_READ 
	 * @see  java.sql.Connection＃TRANSACTION_SERIALIZABLE 
	 * @see 组织。 
	 *  springframework.transaction.TransactionDefinition＃ISOLATION_READ_UNCOMMITTED 
	 * @see  org.springframework.transaction.TransactionDefinition＃ISOLATION_READ_COMMITTED 
	 * @see  org.springframework.transaction.TransactionDefinition＃ISOLATION_REPEATABLE_READ 
	 * @see  org.springframework.transaction.Transaction定义org.springframework.transaction.TransactionDefinition＃getIsolationLevel（）
	 * @see  org.springframework.transaction.support.TransactionSynchronizationManager＃getCurrentTransactionIsolationLevel（）
	 */
	public void setIsolationLevel(int isolationLevel) {
		if (!constants.getValues(DefaultTransactionDefinition.PREFIX_ISOLATION).contains(isolationLevel)) {
			throw new IllegalArgumentException("Only values of isolation constants allowed");
		}
		this.isolationLevel = (isolationLevel != TransactionDefinition.ISOLATION_DEFAULT ? isolationLevel : null);
	}

	/**
	 * Return the statically specified isolation level,
	 * or {@code null} if none.
	 */
	/**
	 * 返回静态指定的隔离级别，如果没有，则返回{@code  null}。 
	 * 
	 */
	@Nullable
	protected Integer getIsolationLevel() {
		return this.isolationLevel;
	}


	/**
	 * Applies the current isolation level value and read-only flag
	 * to the returned Connection.
	 * @see #getCurrentIsolationLevel()
	 * @see #getCurrentReadOnlyFlag()
	 */
	/**
	 * 将当前隔离级别值和只读标志应用于返回的Connection。 
	 *  
	 * @see  #getCurrentIsolationLevel（）
	 * @see  #getCurrentReadOnlyFlag（）
	 */
	@Override
	protected Connection doGetConnection(@Nullable String username, @Nullable String password) throws SQLException {
		Connection con = super.doGetConnection(username, password);
		Boolean readOnlyToUse = getCurrentReadOnlyFlag();
		if (readOnlyToUse != null) {
			con.setReadOnly(readOnlyToUse);
		}
		Integer isolationLevelToUse = getCurrentIsolationLevel();
		if (isolationLevelToUse != null) {
			con.setTransactionIsolation(isolationLevelToUse);
		}
		return con;
	}

	/**
	 * Determine the current isolation level: either the transaction's
	 * isolation level or a statically defined isolation level.
	 * @return the current isolation level, or {@code null} if none
	 * @see org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionIsolationLevel()
	 * @see #setIsolationLevel
	 */
	/**
	 * 确定当前隔离级别：事务的隔离级别或静态定义的隔离级别。 
	 *  
	 * @return 当前隔离级别，如果没有，则为{@code  null} 
	 * @see  org.springframework.transaction.support.TransactionSynchronizationManager＃getCurrentTransactionIsolationLevel（）
	 * @see  #setIsolationLevel
	 */
	@Nullable
	protected Integer getCurrentIsolationLevel() {
		Integer isolationLevelToUse = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
		if (isolationLevelToUse == null) {
			isolationLevelToUse = getIsolationLevel();
		}
		return isolationLevelToUse;
	}

	/**
	 * Determine the current read-only flag: by default,
	 * the transaction's read-only hint.
	 * @return whether there is a read-only hint for the current scope
	 * @see org.springframework.transaction.support.TransactionSynchronizationManager#isCurrentTransactionReadOnly()
	 */
	/**
	 * 确定当前的只读标志：默认情况下，事务的只读提示。 
	 *  
	 * @return 当前范围是否存在只读提示
	 * @see  org.springframework.transaction.support.TransactionSynchronizationManager＃isCurrentTransactionReadOnly（）
	 */
	@Nullable
	protected Boolean getCurrentReadOnlyFlag() {
		boolean txReadOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
		return (txReadOnly ? Boolean.TRUE : null);
	}

}
