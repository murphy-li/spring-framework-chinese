/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jdbc.datasource;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;

/**
 * Simple implementation of the standard JDBC {@link javax.sql.DataSource} interface,
 * configuring the plain old JDBC {@link java.sql.DriverManager} via bean properties, and
 * returning a new {@link java.sql.Connection} from every {@code getConnection} call.
 *
 * <p><b>NOTE: This class is not an actual connection pool; it does not actually
 * pool Connections.</b> It just serves as simple replacement for a full-blown
 * connection pool, implementing the same standard interface, but creating new
 * Connections on every call.
 *
 * <p>Useful for test or standalone environments outside of a Java EE container, either
 * as a DataSource bean in a corresponding ApplicationContext or in conjunction with
 * a simple JNDI environment. Pool-assuming {@code Connection.close()} calls will
 * simply close the Connection, so any DataSource-aware persistence code should work.
 *
 * <p><b>NOTE: Within special class loading environments such as OSGi, this class
 * is effectively superseded by {@link SimpleDriverDataSource} due to general class
 * loading issues with the JDBC DriverManager that be resolved through direct Driver
 * usage (which is exactly what SimpleDriverDataSource does).</b>
 *
 * <p>In a Java EE container, it is recommended to use a JNDI DataSource provided by
 * the container. Such a DataSource can be exposed as a DataSource bean in a Spring
 * ApplicationContext via {@link org.springframework.jndi.JndiObjectFactoryBean},
 * for seamless switching to and from a local DataSource bean like this class.
 * For tests, you can then either set up a mock JNDI environment through Spring's
 * {@link org.springframework.mock.jndi.SimpleNamingContextBuilder}, or switch the
 * bean definition to a local DataSource (which is simpler and thus recommended).
 *
 * <p>This {@code DriverManagerDataSource} class was originally designed alongside
 * <a href="https://commons.apache.org/proper/commons-dbcp">Apache Commons DBCP</a>
 * and <a href="https://sourceforge.net/projects/c3p0">C3P0</a>, featuring bean-style
 * {@code BasicDataSource}/{@code ComboPooledDataSource} classes with configuration
 * properties for local resource setups. For a modern JDBC connection pool, consider
 * <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> instead,
 * exposing a corresponding {@code HikariDataSource} instance to the application.
 *
 * @author Juergen Hoeller
 * @since 14.03.2003
 * @see SimpleDriverDataSource
 */
/**
 * 标准JDBC {@link  javax.sql.DataSource}接口的简单实现，通​​过bean属性配置普通的旧JDBC {@link  java.sql.DriverManager}，并返回一个新的{@link  java。 
 * 每次{@code  getConnection}调用中的sql.Connection}。 
 *  <p> <b>注意：此类不是实际的连接池； 
 * 它实际上并没有合并连接。 
 * </ b>它只是对功能完善的连接池的简单替代，实现了相同的标准接口，但是在每次调用时都创建了新的连接。 
 *  <p>可用于Java EE容器之外的测试或独立环境，既可以作为对应ApplicationContext中的DataSource bean，也可以与简单的JNDI环境结合使用。 
 * 池假设{@code  Connection.close（）}调用将简单地关闭Connection，因此任何可识别DataSource的持久性代码都应起作用。 
 *  <p> <b>注意：在特殊的类加载环境（例如OSGi）中，由于JDBC DriverManager的一般类加载问题可以通过直接使用驱动程序解决（完全是SimpleDriverDataSource的功能。 
 * ）</ b> <p>在Java EE容器中，建议使用该容器提供的JNDI数据源。 
 * 可以通过{@link  org.springframework.jndi.JndiObjectFactoryBean}在Spring ApplicationContext中将这样的DataSource公开为DataSource bean，以实现与此类之类的本地DataSource bean之间的无缝切换。 
 * 对于测试，您可以通过Spring的{@link  org.springframework.mock.jndi.SimpleNamingContextBuilder}来设置模拟JNDI环境，或者将Bean定义切换到本地DataSource（因此更简单）。 
 *  <p>此{@code  DriverManagerDataSource}类最初与<a href="https://commons.apache.org/proper/commons-dbcp"> Apache Commons DBCP </a>和<a href = "https://sourceforge.net/projects/c3p0">C3P0 </a>，具有bean样式的{@code  BasicDataSource} / {<@code> ComboPooledDataSource}类，并具有用于本地资源设置的配置属性。 
 * 对于现代JDBC连接池，请考虑使用<a href="https://github.com/brettwooldridge/HikariCP"> HikariCP </a>，向应用程序公开一个相应的{@code  HikariDataSource}实例。 
 *  @author  Juergen Hoeller @2003年3月14日起
 * @see  SimpleDriverDataSource
 */
public class DriverManagerDataSource extends AbstractDriverBasedDataSource {

	/**
	 * Constructor for bean-style configuration.
	 */
	/**
	 * Bean样式配置的构造函数。 
	 * 
	 */
	public DriverManagerDataSource() {
	}

	/**
	 * Create a new DriverManagerDataSource with the given JDBC URL,
	 * not specifying a username or password for JDBC access.
	 * @param url the JDBC URL to use for accessing the DriverManager
	 * @see java.sql.DriverManager#getConnection(String)
	 */
	/**
	 * 使用给定的JDBC URL创建新的DriverManagerDataSource，而不指定用于JDBC访问的用户名或密码。 
	 *  
	 * @param  URL用于访问DriverManager的JDBC URL 
	 * @see  java.sql.DriverManager＃getConnection（String）
	 */
	public DriverManagerDataSource(String url) {
		setUrl(url);
	}

	/**
	 * Create a new DriverManagerDataSource with the given standard
	 * DriverManager parameters.
	 * @param url the JDBC URL to use for accessing the DriverManager
	 * @param username the JDBC username to use for accessing the DriverManager
	 * @param password the JDBC password to use for accessing the DriverManager
	 * @see java.sql.DriverManager#getConnection(String, String, String)
	 */
	/**
	 * 使用给定的标准DriverManager参数创建一个新的DriverManagerDataSource。 
	 *  
	 * @param  url用于访问DriverManager的JDBC URL 
	 * @param 用户名用于访问DriverManager的JDBC用户名
	 * @param 密码用于访问DriverManager的JDBC密码
	 * @see  java.sql。 
	 *  DriverManager＃getConnection（字符串，字符串，字符串）
	 */
	public DriverManagerDataSource(String url, String username, String password) {
		setUrl(url);
		setUsername(username);
		setPassword(password);
	}

	/**
	 * Create a new DriverManagerDataSource with the given JDBC URL,
	 * not specifying a username or password for JDBC access.
	 * @param url the JDBC URL to use for accessing the DriverManager
	 * @param conProps the JDBC connection properties
	 * @see java.sql.DriverManager#getConnection(String)
	 */
	/**
	 * 使用给定的JDBC URL创建新的DriverManagerDataSource，而不指定用于JDBC访问的用户名或密码。 
	 *  
	 * @param  URL用于访问DriverManager的JDBC URL 
	 * @param 支持JDBC连接属性
	 * @see  java.sql.DriverManager＃getConnection（String）
	 */
	public DriverManagerDataSource(String url, Properties conProps) {
		setUrl(url);
		setConnectionProperties(conProps);
	}


	/**
	 * Set the JDBC driver class name. This driver will get initialized
	 * on startup, registering itself with the JDK's DriverManager.
	 * <p><b>NOTE: DriverManagerDataSource is primarily intended for accessing
	 * <i>pre-registered</i> JDBC drivers.</b> If you need to register a new driver,
	 * consider using {@link SimpleDriverDataSource} instead. Alternatively, consider
	 * initializing the JDBC driver yourself before instantiating this DataSource.
	 * The "driverClassName" property is mainly preserved for backwards compatibility,
	 * as well as for migrating between Commons DBCP and this DataSource.
	 * @see java.sql.DriverManager#registerDriver(java.sql.Driver)
	 * @see SimpleDriverDataSource
	 */
	/**
	 * 设置JDBC驱动程序类名称。 
	 * 该驱动程序将在启动时初始化，并在JDK的DriverManager中进行注册。 
	 *  <p> <b>注意：DriverManagerDataSource主要用于访问<i>预注册的</ i> JDBC驱动程序。 
	 * </ b>如果需要注册新的驱动程序，请考虑使用{@link  SimpleDriverDataSource} 。 
	 * 另外，在实例化此DataSource之前，请考虑自己初始化JDBC驱动程序。 
	 * 保留"driverClassName"属性主要是为了向后兼容，以及在Commons DBCP和此DataSource之间迁移。 
	 *  
	 * @see  java.sql.DriverManager＃registerDriver（java.sql.Driver）
	 * @see  SimpleDriverDataSource
	 */
	public void setDriverClassName(String driverClassName) {
		Assert.hasText(driverClassName, "Property 'driverClassName' must not be empty");
		String driverClassNameToUse = driverClassName.trim();
		try {
			Class.forName(driverClassNameToUse, true, ClassUtils.getDefaultClassLoader());
		}
		catch (ClassNotFoundException ex) {
			throw new IllegalStateException("Could not load JDBC driver class [" + driverClassNameToUse + "]", ex);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Loaded JDBC driver: " + driverClassNameToUse);
		}
	}


	@Override
	protected Connection getConnectionFromDriver(Properties props) throws SQLException {
		String url = getUrl();
		Assert.state(url != null, "'url' not set");
		if (logger.isDebugEnabled()) {
			logger.debug("Creating new JDBC DriverManager Connection to [" + url + "]");
		}
		return getConnectionFromDriverManager(url, props);
	}

	/**
	 * Getting a Connection using the nasty static from DriverManager is extracted
	 * into a protected method to allow for easy unit testing.
	 * @see java.sql.DriverManager#getConnection(String, java.util.Properties)
	 */
	/**
	 * 使用来自DriverManager的讨厌的静态方法获取连接被提取到受保护的方法中，以便进行简单的单元测试。 
	 *  
	 * @see  java.sql.DriverManager＃getConnection（String，java.util.Properties）
	 */
	protected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {
		return DriverManager.getConnection(url, props);
	}

}
