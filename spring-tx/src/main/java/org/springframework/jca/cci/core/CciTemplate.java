/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jca.cci.core;

import java.sql.SQLException;

import javax.resource.NotSupportedException;
import javax.resource.ResourceException;
import javax.resource.cci.Connection;
import javax.resource.cci.ConnectionFactory;
import javax.resource.cci.ConnectionSpec;
import javax.resource.cci.IndexedRecord;
import javax.resource.cci.Interaction;
import javax.resource.cci.InteractionSpec;
import javax.resource.cci.MappedRecord;
import javax.resource.cci.Record;
import javax.resource.cci.RecordFactory;
import javax.resource.cci.ResultSet;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataAccessResourceFailureException;
import org.springframework.jca.cci.CannotCreateRecordException;
import org.springframework.jca.cci.CciOperationNotSupportedException;
import org.springframework.jca.cci.InvalidResultSetAccessException;
import org.springframework.jca.cci.RecordTypeNotSupportedException;
import org.springframework.jca.cci.connection.ConnectionFactoryUtils;
import org.springframework.jca.cci.connection.NotSupportedRecordFactory;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * <b>This is the central class in the CCI core package.</b>
 * It simplifies the use of CCI and helps to avoid common errors.
 * It executes core CCI workflow, leaving application code to provide parameters
 * to CCI and extract results. This class executes EIS queries or updates,
 * catching ResourceExceptions and translating them to the generic exception
 * hierarchy defined in the {@code org.springframework.dao} package.
 *
 * <p>Code using this class can pass in and receive {@link javax.resource.cci.Record}
 * instances, or alternatively implement callback interfaces for creating input
 * Records and extracting result objects from output Records (or CCI ResultSets).
 *
 * <p>Can be used within a service implementation via direct instantiation
 * with a ConnectionFactory reference, or get prepared in an application context
 * and given to services as bean reference. Note: The ConnectionFactory should
 * always be configured as a bean in the application context, in the first case
 * given to the service directly, in the second case to the prepared template.
 *
 * @author Thierry Templier
 * @author Juergen Hoeller
 * @since 1.2
 * @see RecordCreator
 * @see RecordExtractor
 */
/**
 * <b>这是CCI核心软件包中的中心类。 
 * </ b>它简化了CCI的使用并有助于避免常见错误。 
 * 它执行核心的CCI工作流程，只剩下应用程序代码来为CCI提供参数并提取结果。 
 * 此类执行EIS查询或更新，以捕获ResourceExceptions并将其转换为{@code  org.springframework.dao}包中定义的通用异常层次结构。 
 *  <p>使用此类的代码可以传入和接收{@link  javax.resource.cci.Record}实例，或者实现用于创建输入记录并从输出记录（或CCI ResultSet）提取结果对象的回调接口。 
 *  <p>可以通过使用ConnectionFactory引用直接实例化在服务实现中使用，或在应用程序上下文中进行准备并作为bean引用提供给服务。 
 * 注意：在应用程序上下文中，应始终将ConnectionFactory配置为Bean，第一种情况是直接提供给服务，第二种情况是已准备好的模板。 
 *  @author  Thierry Templier @author  Juergen Hoeller @始于1.2 
 * @see  RecordCreator 
 * @see  RecordExtractor
 */
public class CciTemplate implements CciOperations {

	private final Log logger = LogFactory.getLog(getClass());

	@Nullable
	private ConnectionFactory connectionFactory;

	@Nullable
	private ConnectionSpec connectionSpec;

	@Nullable
	private RecordCreator outputRecordCreator;


	/**
	 * Construct a new CciTemplate for bean usage.
	 * <p>Note: The ConnectionFactory has to be set before using the instance.
	 * @see #setConnectionFactory
	 */
	/**
	 * 构造一个新的CciTemplate供bean使用。 
	 *  <p>注意：必须在使用实例之前设置ConnectionFactory。 
	 *  
	 * @see  #setConnectionFactory
	 */
	public CciTemplate() {
	}

	/**
	 * Construct a new CciTemplate, given a ConnectionFactory to obtain Connections from.
	 * Note: This will trigger eager initialization of the exception translator.
	 * @param connectionFactory the JCA ConnectionFactory to obtain Connections from
	 */
	/**
	 * 构造一个新的CciTemplate，并提供一个ConnectionFactory来从中获取Connections。 
	 * 注意：这将触发异常转换器的急切初始化。 
	 *  
	 * @param  connectionFactory JCA ConnectionFactory可以从中获取连接
	 */
	public CciTemplate(ConnectionFactory connectionFactory) {
		setConnectionFactory(connectionFactory);
		afterPropertiesSet();
	}

	/**
	 * Construct a new CciTemplate, given a ConnectionFactory to obtain Connections from.
	 * Note: This will trigger eager initialization of the exception translator.
	 * @param connectionFactory the JCA ConnectionFactory to obtain Connections from
	 * @param connectionSpec the CCI ConnectionSpec to obtain Connections for
	 * (may be {@code null})
	 */
	/**
	 * 构造一个新的CciTemplate，并提供一个ConnectionFactory来从中获取Connections。 
	 * 注意：这将触发异常转换器的急切初始化。 
	 *  
	 * @param  connectionFactory JCA ConnectionFactory可以从
	 * @param  connectionSpec获取连接CCI ConnectionSpec可以获取其连接（可能为{@code  null}）
	 */
	public CciTemplate(ConnectionFactory connectionFactory, @Nullable ConnectionSpec connectionSpec) {
		setConnectionFactory(connectionFactory);
		if (connectionSpec != null) {
			setConnectionSpec(connectionSpec);
		}
		afterPropertiesSet();
	}


	/**
	 * Set the CCI ConnectionFactory to obtain Connections from.
	 */
	/**
	 * 设置CCI ConnectionFactory以获得连接。 
	 * 
	 */
	public void setConnectionFactory(@Nullable ConnectionFactory connectionFactory) {
		this.connectionFactory = connectionFactory;
	}

	/**
	 * Return the CCI ConnectionFactory used by this template.
	 */
	/**
	 * 返回此模板使用的CCI ConnectionFactory。 
	 * 
	 */
	@Nullable
	public ConnectionFactory getConnectionFactory() {
		return this.connectionFactory;
	}

	private ConnectionFactory obtainConnectionFactory() {
		ConnectionFactory connectionFactory = getConnectionFactory();
		Assert.state(connectionFactory != null, "No ConnectionFactory set");
		return connectionFactory;
	}

	/**
	 * Set the CCI ConnectionSpec that this template instance is
	 * supposed to obtain Connections for.
	 */
	/**
	 * 设置此模板实例应为其获取连接的CCI ConnectionSpec。 
	 * 
	 */
	public void setConnectionSpec(@Nullable ConnectionSpec connectionSpec) {
		this.connectionSpec = connectionSpec;
	}

	/**
	 * Return the CCI ConnectionSpec used by this template, if any.
	 */
	/**
	 * 返回此模板使用的CCI ConnectionSpec（如果有）。 
	 * 
	 */
	@Nullable
	public ConnectionSpec getConnectionSpec() {
		return this.connectionSpec;
	}

	/**
	 * Set a RecordCreator that should be used for creating default output Records.
	 * <p>Default is none: When no explicit output Record gets passed into an
	 * {@code execute} method, CCI's {@code Interaction.execute} variant
	 * that returns an output Record will be called.
	 * <p>Specify a RecordCreator here if you always need to call CCI's
	 * {@code Interaction.execute} variant with a passed-in output Record.
	 * Unless there is an explicitly specified output Record, CciTemplate will
	 * then invoke this RecordCreator to create a default output Record instance.
	 * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record)
	 * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record, Record)
	 */
	/**
	 * 设置一个RecordCreator，用于创建默认输出记录。 
	 *  <p>默认为无：当没有显式输出Record传递到{@code  execute}方法中时，将调用CCI的{@code  Interaction.execute}变体返回输出Record。 
	 *  <p>如果您始终需要使用传入的输出Record调用CCI的{@code  Interaction.execute}变体，请在此处指定RecordCreator。 
	 * 除非有明确指定的输出Record，否则CciTemplate将随后调用此RecordCreator创建默认的输出Record实例。 
	 *  
	 * @see  javax.resource.cci.Interaction＃execute（javax.resource.cci.InteractionSpec，Record）
	 * @see  javax.resource.cci.Interaction＃execute（javax.resource.cci.InteractionSpec，Record，Record）
	 */
	public void setOutputRecordCreator(@Nullable RecordCreator creator) {
		this.outputRecordCreator = creator;
	}

	/**
	 * Return a RecordCreator that should be used for creating default output Records.
	 */
	/**
	 * 返回一个RecordCreator，用于创建默认输出记录。 
	 * 
	 */
	@Nullable
	public RecordCreator getOutputRecordCreator() {
		return this.outputRecordCreator;
	}

	public void afterPropertiesSet() {
		if (getConnectionFactory() == null) {
			throw new IllegalArgumentException("Property 'connectionFactory' is required");
		}
	}


	/**
	 * Create a template derived from this template instance,
	 * inheriting the ConnectionFactory and other settings but
	 * overriding the ConnectionSpec used for obtaining Connections.
	 * @param connectionSpec the CCI ConnectionSpec that the derived template
	 * instance is supposed to obtain Connections for
	 * @return the derived template instance
	 * @see #setConnectionSpec
	 */
	/**
	 * 创建一个从该模板实例派生的模板，该模板继承ConnectionFactory和其他设置，但覆盖用于获取连接的ConnectionSpec。 
	 *  
	 * @param  connectionSpec CCI ConnectionSpec，即派生的模板实例应获得
	 * @return 派生的模板实例的连接
	 * @see  #setConnectionSpec
	 */
	public CciTemplate getDerivedTemplate(ConnectionSpec connectionSpec) {
		CciTemplate derived = new CciTemplate(obtainConnectionFactory(), connectionSpec);
		RecordCreator recordCreator = getOutputRecordCreator();
		if (recordCreator != null) {
			derived.setOutputRecordCreator(recordCreator);
		}
		return derived;
	}


	@Override
	@Nullable
	public <T> T execute(ConnectionCallback<T> action) throws DataAccessException {
		Assert.notNull(action, "Callback object must not be null");
		ConnectionFactory connectionFactory = obtainConnectionFactory();
		Connection con = ConnectionFactoryUtils.getConnection(connectionFactory, getConnectionSpec());
		try {
			return action.doInConnection(con, connectionFactory);
		}
		catch (NotSupportedException ex) {
			throw new CciOperationNotSupportedException("CCI operation not supported by connector", ex);
		}
		catch (ResourceException ex) {
			throw new DataAccessResourceFailureException("CCI operation failed", ex);
		}
		catch (SQLException ex) {
			throw new InvalidResultSetAccessException("Parsing of CCI ResultSet failed", ex);
		}
		finally {
			ConnectionFactoryUtils.releaseConnection(con, getConnectionFactory());
		}
	}

	@Override
	@Nullable
	public <T> T execute(final InteractionCallback<T> action) throws DataAccessException {
		Assert.notNull(action, "Callback object must not be null");
		return execute((ConnectionCallback<T>) (connection, connectionFactory) -> {
			Interaction interaction = connection.createInteraction();
			try {
				return action.doInInteraction(interaction, connectionFactory);
			}
			finally {
				closeInteraction(interaction);
			}
		});
	}

	@Override
	@Nullable
	public Record execute(InteractionSpec spec, Record inputRecord) throws DataAccessException {
		return doExecute(spec, inputRecord, null, new SimpleRecordExtractor());
	}

	@Override
	public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord) throws DataAccessException {
		doExecute(spec, inputRecord, outputRecord, null);
	}

	@Override
	public Record execute(InteractionSpec spec, RecordCreator inputCreator) throws DataAccessException {
		Record output = doExecute(spec, createRecord(inputCreator), null, new SimpleRecordExtractor());
		Assert.state(output != null, "Invalid output record");
		return output;
	}

	@Override
	public <T> T execute(InteractionSpec spec, Record inputRecord, RecordExtractor<T> outputExtractor)
			throws DataAccessException {

		return doExecute(spec, inputRecord, null, outputExtractor);
	}

	@Override
	public <T> T execute(InteractionSpec spec, RecordCreator inputCreator, RecordExtractor<T> outputExtractor)
			throws DataAccessException {

		return doExecute(spec, createRecord(inputCreator), null, outputExtractor);
	}

	/**
	 * Execute the specified interaction on an EIS with CCI.
	 * All other interaction execution methods go through this.
	 * @param spec the CCI InteractionSpec instance that defines
	 * the interaction (connector-specific)
	 * @param inputRecord the input record
	 * @param outputRecord output record (can be {@code null})
	 * @param outputExtractor object to convert the output record to a result object
	 * @return the output data extracted with the RecordExtractor object
	 * @throws DataAccessException if there is any problem
	 */
	/**
	 * 使用CCI在EIS上执行指定的交互。 
	 * 所有其他交互执行方法都将通过此过程。 
	 *  
	 * @param  spec定义交互的CCI InteractionSpec实例（特定于连接器）
	 * @param  inputRecord输入记录
	 * @param  outputRecord输出记录（可以为{@code  null}）
	 * @param  outputExtractor对象将输出记录转换为结果对象
	 * @return 用RecordExtractor对象
	 * @throws  DataAccessException提取的输出数据（如果存在任何问题）
	 */
	@Nullable
	protected <T> T doExecute(
			final InteractionSpec spec, final Record inputRecord, @Nullable final Record outputRecord,
			@Nullable final RecordExtractor<T> outputExtractor) throws DataAccessException {

		return execute((InteractionCallback<T>) (interaction, connectionFactory) -> {
			Record outputRecordToUse = outputRecord;
			try {
				if (outputRecord != null || getOutputRecordCreator() != null) {
					// Use the CCI execute method with output record as parameter.
					if (outputRecord == null) {
						RecordFactory recordFactory = getRecordFactory(connectionFactory);
						outputRecordToUse = getOutputRecordCreator().createRecord(recordFactory);
					}
					interaction.execute(spec, inputRecord, outputRecordToUse);
				}
				else {
					outputRecordToUse = interaction.execute(spec, inputRecord);
				}
				return (outputExtractor != null ? outputExtractor.extractData(outputRecordToUse) : null);
			}
			finally {
				if (outputRecordToUse instanceof ResultSet) {
					closeResultSet((ResultSet) outputRecordToUse);
				}
			}
		});
	}


	/**
	 * Create an indexed Record through the ConnectionFactory's RecordFactory.
	 * @param name the name of the record
	 * @return the Record
	 * @throws DataAccessException if creation of the Record failed
	 * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)
	 * @see javax.resource.cci.RecordFactory#createIndexedRecord(String)
	 */
	/**
	 * 通过ConnectionFactory的RecordFactory创建索引记录。 
	 *  
	 * @param 命名记录的名称
	 * @return 记录
	 * @throws  DataAccessException如果创建记录失败
	 * @see  #getRecordFactory（javax.resource.cci.ConnectionFactory）
	 * @see  javax.resource。 
	 *  cci.RecordFactory＃createIndexedRecord（String）
	 */
	public IndexedRecord createIndexedRecord(String name) throws DataAccessException {
		try {
			RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory());
			return recordFactory.createIndexedRecord(name);
		}
		catch (NotSupportedException ex) {
			throw new RecordTypeNotSupportedException("Creation of indexed Record not supported by connector", ex);
		}
		catch (ResourceException ex) {
			throw new CannotCreateRecordException("Creation of indexed Record failed", ex);
		}
	}

	/**
	 * Create a mapped Record from the ConnectionFactory's RecordFactory.
	 * @param name record name
	 * @return the Record
	 * @throws DataAccessException if creation of the Record failed
	 * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)
	 * @see javax.resource.cci.RecordFactory#createMappedRecord(String)
	 */
	/**
	 * 从ConnectionFactory的RecordFactory创建映射的Record。 
	 *  
	 * @param 名称记录名称
	 * @return 记录
	 * @throws  DataAccessException如果创建记录失败
	 * @see  #getRecordFactory（javax.resource.cci.ConnectionFactory）
	 * @see  javax.resource.cci.RecordFactory #createMappedRecord（String）
	 */
	public MappedRecord createMappedRecord(String name) throws DataAccessException {
		try {
			RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory());
			return recordFactory.createMappedRecord(name);
		}
		catch (NotSupportedException ex) {
			throw new RecordTypeNotSupportedException("Creation of mapped Record not supported by connector", ex);
		}
		catch (ResourceException ex) {
			throw new CannotCreateRecordException("Creation of mapped Record failed", ex);
		}
	}

	/**
	 * Invoke the given RecordCreator, converting JCA ResourceExceptions
	 * to Spring's DataAccessException hierarchy.
	 * @param recordCreator the RecordCreator to invoke
	 * @return the created Record
	 * @throws DataAccessException if creation of the Record failed
	 * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)
	 * @see RecordCreator#createRecord(javax.resource.cci.RecordFactory)
	 */
	/**
	 * 调用给定的RecordCreator，将JCA ResourceExceptions转换为Spring的DataAccessException层次结构。 
	 *  
	 * @param  recordCreator如果创建记录失败，则RecordCreator调用
	 * @return 创建的记录
	 * @throws  DataAccessException 
	 * @see  #getRecordFactory（javax.resource.cci.ConnectionFactory）
	 * @see  RecordCreator＃createRecord（ javax.resource.cci.RecordFactory）
	 */
	protected Record createRecord(RecordCreator recordCreator) throws DataAccessException {
		try {
			RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory());
			return recordCreator.createRecord(recordFactory);
		}
		catch (NotSupportedException ex) {
			throw new RecordTypeNotSupportedException(
					"Creation of the desired Record type not supported by connector", ex);
		}
		catch (ResourceException ex) {
			throw new CannotCreateRecordException("Creation of the desired Record failed", ex);
		}
	}

	/**
	 * Return a RecordFactory for the given ConnectionFactory.
	 * <p>Default implementation returns the connector's RecordFactory if
	 * available, falling back to a NotSupportedRecordFactory placeholder.
	 * This allows to invoke a RecordCreator callback with a non-null
	 * RecordFactory reference in any case.
	 * @param connectionFactory the CCI ConnectionFactory
	 * @return the CCI RecordFactory for the ConnectionFactory
	 * @throws ResourceException if thrown by CCI methods
	 * @see org.springframework.jca.cci.connection.NotSupportedRecordFactory
	 */
	/**
	 * 返回给定ConnectionFactory的RecordFactory。 
	 *  <p>默认实现将返回连接器的RecordFactory（如果有），并回退到NotSupportedRecordFactory占位符。 
	 * 在任何情况下，这都允许使用非null的RecordFactory引用来调用RecordCreator回调。 
	 *  
	 * @param  connectionFactory CCI ConnectionFactory 
	 * @return  ConnectionFactory的CCI RecordFactory 
	 * @throws  ResourceException如果由CCI方法抛出
	 * @see  org.springframework.jca.cci.connection.NotSupportedRecordFactory
	 */
	protected RecordFactory getRecordFactory(ConnectionFactory connectionFactory) throws ResourceException {
		try {
			return connectionFactory.getRecordFactory();
		}
		catch (NotSupportedException ex) {
			return new NotSupportedRecordFactory();
		}
	}


	/**
	 * Close the given CCI Interaction and ignore any thrown exception.
	 * This is useful for typical finally blocks in manual CCI code.
	 * @param interaction the CCI Interaction to close
	 * @see javax.resource.cci.Interaction#close()
	 */
	/**
	 * 关闭给定的CCI交互，并忽略任何引发的异常。 
	 * 这对于手动CCI代码中的典型的finally块很有用。 
	 *  
	 * @param 交互CCI交互关闭
	 * @see  javax.resource.cci.Interaction＃close（）
	 */
	private void closeInteraction(@Nullable Interaction interaction) {
		if (interaction != null) {
			try {
				interaction.close();
			}
			catch (ResourceException ex) {
				logger.trace("Could not close CCI Interaction", ex);
			}
			catch (Throwable ex) {
				// We don't trust the CCI driver: It might throw RuntimeException or Error.
				logger.trace("Unexpected exception on closing CCI Interaction", ex);
			}
		}
	}

	/**
	 * Close the given CCI ResultSet and ignore any thrown exception.
	 * This is useful for typical finally blocks in manual CCI code.
	 * @param resultSet the CCI ResultSet to close
	 * @see javax.resource.cci.ResultSet#close()
	 */
	/**
	 * 关闭给定的CCI ResultSet，并忽略任何引发的异常。 
	 * 这对于手动CCI代码中的典型的finally块很有用。 
	 *  
	 * @param  resultSet CCI结果集关闭
	 * @see  javax.resource.cci.ResultSet＃close（）
	 */
	private void closeResultSet(@Nullable ResultSet resultSet) {
		if (resultSet != null) {
			try {
				resultSet.close();
			}
			catch (SQLException ex) {
				logger.trace("Could not close CCI ResultSet", ex);
			}
			catch (Throwable ex) {
				// We don't trust the CCI driver: It might throw RuntimeException or Error.
				logger.trace("Unexpected exception on closing CCI ResultSet", ex);
			}
		}
	}


	private static class SimpleRecordExtractor implements RecordExtractor<Record> {

		@Override
		public Record extractData(Record record) {
			return record;
		}
	}

}
