/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jca.endpoint;

import java.lang.reflect.Method;

import javax.resource.ResourceException;
import javax.resource.spi.ApplicationServerInternalException;
import javax.resource.spi.UnavailableException;
import javax.resource.spi.endpoint.MessageEndpoint;
import javax.resource.spi.endpoint.MessageEndpointFactory;
import javax.transaction.Transaction;
import javax.transaction.TransactionManager;
import javax.transaction.xa.XAResource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.beans.factory.BeanNameAware;
import org.springframework.lang.Nullable;
import org.springframework.transaction.jta.SimpleTransactionFactory;
import org.springframework.transaction.jta.TransactionFactory;
import org.springframework.util.Assert;

/**
 * Abstract base implementation of the JCA 1.7
 * {@link javax.resource.spi.endpoint.MessageEndpointFactory} interface,
 * providing transaction management capabilities as well as ClassLoader
 * exposure for endpoint invocations.
 *
 * @author Juergen Hoeller
 * @since 2.5
 * @see #setTransactionManager
 */
/**
 * JCA 1.7 {@link  javax.resource.spi.endpoint.MessageEndpointFactory}接口的抽象基础实现，提供事务管理功能以及用于端点调用的ClassLoader公开。 
 *  @author  Juergen Hoeller @从2.5开始
 * @see  #setTransactionManager
 */
public abstract class AbstractMessageEndpointFactory implements MessageEndpointFactory, BeanNameAware {

	/** Logger available to subclasses. */
	/**
	 * 记录器可用于子类。 
	 * 
	 */
	protected final Log logger = LogFactory.getLog(getClass());

	@Nullable
	private TransactionFactory transactionFactory;

	@Nullable
	private String transactionName;

	private int transactionTimeout = -1;

	@Nullable
	private String beanName;


	/**
	 * Set the XA transaction manager to use for wrapping endpoint
	 * invocations, enlisting the endpoint resource in each such transaction.
	 * <p>The passed-in object may be a transaction manager which implements
	 * Spring's {@link org.springframework.transaction.jta.TransactionFactory}
	 * interface, or a plain {@link javax.transaction.TransactionManager}.
	 * <p>If no transaction manager is specified, the endpoint invocation
	 * will simply not be wrapped in an XA transaction. Check out your
	 * resource provider's ActivationSpec documentation for local
	 * transaction options of your particular provider.
	 * @see #setTransactionName
	 * @see #setTransactionTimeout
	 */
	/**
	 * 设置XA事务管理器以用于包装端点调用，并在每个此类事务中登记端点资源。 
	 *  <p>传入的对象可以是实现Spring的{@link  org.springframework.transaction.jta.TransactionFactory}接口的事务管理器，也可以是普通的{@link  javax.transaction.TransactionManager}接口。 
	 *  <p>如果未指定事务管理器，则端点调用将不会简单地包装在XA事务中。 
	 * 请查看资源提供商的ActivationSpec文档，以了解特定提供商的本地交易选项。 
	 *  
	 * @see  #setTransactionName 
	 * @see  #setTransactionTimeout
	 */
	public void setTransactionManager(Object transactionManager) {
		if (transactionManager instanceof TransactionFactory) {
			this.transactionFactory = (TransactionFactory) transactionManager;
		}
		else if (transactionManager instanceof TransactionManager) {
			this.transactionFactory = new SimpleTransactionFactory((TransactionManager) transactionManager);
		}
		else {
			throw new IllegalArgumentException("Transaction manager [" + transactionManager +
					"] is neither a [org.springframework.transaction.jta.TransactionFactory} nor a " +
					"[javax.transaction.TransactionManager]");
		}
	}

	/**
	 * Set the Spring TransactionFactory to use for wrapping endpoint
	 * invocations, enlisting the endpoint resource in each such transaction.
	 * <p>Alternatively, specify an appropriate transaction manager through
	 * the {@link #setTransactionManager "transactionManager"} property.
	 * <p>If no transaction factory is specified, the endpoint invocation
	 * will simply not be wrapped in an XA transaction. Check out your
	 * resource provider's ActivationSpec documentation for local
	 * transaction options of your particular provider.
	 * @see #setTransactionName
	 * @see #setTransactionTimeout
	 */
	/**
	 * 将Spring TransactionFactory设置为用于包装端点调用，并在每个此类事务中获取端点资源。 
	 *  <p>或者，通过{@link  #setTransactionManager"transactionManager"}属性指定适当的事务管理器。 
	 *  <p>如果未指定事务工厂，则端点调用将不会仅包装在XA事务中。 
	 * 请查看资源提供商的ActivationSpec文档，以了解特定提供商的本地交易选项。 
	 *  
	 * @see  #setTransactionName 
	 * @see  #setTransactionTimeout
	 */
	public void setTransactionFactory(TransactionFactory transactionFactory) {
		this.transactionFactory = transactionFactory;
	}

	/**
	 * Specify the name of the transaction, if any.
	 * <p>Default is none. A specified name will be passed on to the transaction
	 * manager, allowing to identify the transaction in a transaction monitor.
	 */
	/**
	 * 指定交易名称（如果有）。 
	 *  <p>默认为无。 
	 * 指定的名称将传递给事务管理器，从而允许在事务监视器中标识事务。 
	 * 
	 */
	public void setTransactionName(String transactionName) {
		this.transactionName = transactionName;
	}

	/**
	 * Specify the transaction timeout, if any.
	 * <p>Default is -1: rely on the transaction manager's default timeout.
	 * Specify a concrete timeout to restrict the maximum duration of each
	 * endpoint invocation.
	 */
	/**
	 * 指定事务超时（如果有）。 
	 *  <p>默认值为-1：依赖事务管理器的默认超时。 
	 * 指定一个具体的超时时间以限制每个端点调用的最大持续时间。 
	 * 
	 */
	public void setTransactionTimeout(int transactionTimeout) {
		this.transactionTimeout = transactionTimeout;
	}

	/**
	 * Set the name of this message endpoint. Populated with the bean name
	 * automatically when defined within Spring's bean factory.
	 */
	/**
	 * 设置此消息端点的名称。 
	 * 在Spring的bean工厂中定义时，将自动用bean名称填充。 
	 * 
	 */
	@Override
	public void setBeanName(String beanName) {
		this.beanName = beanName;
	}


	/**
	 * Implementation of the JCA 1.7 {@code #getActivationName()} method,
	 * returning the bean name as set on this MessageEndpointFactory.
	 * @see #setBeanName
	 */
	/**
	 * JCA 1.7 {@code  #getActivationName（）}方法的实现，返回在此MessageEndpointFactory上设置的bean名称。 
	 *  
	 * @see  #setBeanName
	 */
	@Override
	@Nullable
	public String getActivationName() {
		return this.beanName;
	}

	/**
	 * Implementation of the JCA 1.7 {@code #getEndpointClass()} method,
	 * returning {@code} null in order to indicate a synthetic endpoint type.
	 */
	/**
	 * JCA 1.7 {@code  #getEndpointClass（）}方法的实现，返回{@code } null以指示综合端点类型。 
	 * 
	 */
	@Override
	@Nullable
	public Class<?> getEndpointClass() {
		return null;
	}

	/**
	 * This implementation returns {@code true} if a transaction manager
	 * has been specified; {@code false} otherwise.
	 * @see #setTransactionManager
	 * @see #setTransactionFactory
	 */
	/**
	 * 如果已指定事务管理器，则此实现返回{@code  true}； 
	 * 否则为{@code  false}。 
	 *  
	 * @see  #setTransactionManager 
	 * @see  #setTransactionFactory
	 */
	@Override
	public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
		return (this.transactionFactory != null);
	}

	/**
	 * The standard JCA 1.5 version of {@code createEndpoint}.
	 * <p>This implementation delegates to {@link #createEndpointInternal()},
	 * initializing the endpoint's XAResource before the endpoint gets invoked.
	 */
	/**
	 * {@code  createEndpoint}的标准JCA 1.5版本。 
	 *  <p>此实现委托给{@link  #createEndpointInternal（）}，在调用端点之前初始化端点的XAResource。 
	 * 
	 */
	@Override
	public MessageEndpoint createEndpoint(XAResource xaResource) throws UnavailableException {
		AbstractMessageEndpoint endpoint = createEndpointInternal();
		endpoint.initXAResource(xaResource);
		return endpoint;
	}

	/**
	 * The alternative JCA 1.6 version of {@code createEndpoint}.
	 * <p>This implementation delegates to {@link #createEndpointInternal()},
	 * ignoring the specified timeout. It is only here for JCA 1.6 compliance.
	 */
	/**
	 * {@code  createEndpoint}的JCA 1.6替代版本。 
	 *  <p>此实现委托给{@link  #createEndpointInternal（）}，而忽略了指定的超时。 
	 * 仅在这里符合JCA 1.6规范。 
	 * 
	 */
	@Override
	public MessageEndpoint createEndpoint(XAResource xaResource, long timeout) throws UnavailableException {
		AbstractMessageEndpoint endpoint = createEndpointInternal();
		endpoint.initXAResource(xaResource);
		return endpoint;
	}

	/**
	 * Create the actual endpoint instance, as a subclass of the
	 * {@link AbstractMessageEndpoint} inner class of this factory.
	 * @return the actual endpoint instance (never {@code null})
	 * @throws UnavailableException if no endpoint is available at present
	 */
	/**
	 * 创建实际的终结点实例，作为此工厂的{@link  AbstractMessageEndpoint}内部类的子类。 
	 *  
	 * @return 实际的终结点实例（永不{<@@code> null}）
	 * @throws 如果当前没有终结点可用，则UnavailableException
	 */
	protected abstract AbstractMessageEndpoint createEndpointInternal() throws UnavailableException;


	/**
	 * Inner class for actual endpoint implementations, based on template
	 * method to allow for any kind of concrete endpoint implementation.
	 */
	/**
	 * 基于模板方法的实际终结点实现的内部类，以允许任何种类的具体终结点实现。 
	 * 
	 */
	protected abstract class AbstractMessageEndpoint implements MessageEndpoint {

		@Nullable
		private TransactionDelegate transactionDelegate;

		private boolean beforeDeliveryCalled = false;

		@Nullable
		private ClassLoader previousContextClassLoader;

		/**
		 * Initialize this endpoint's TransactionDelegate.
		 * @param xaResource the XAResource for this endpoint
		 */
		/**
		 * 初始化此终结点的TransactionDelegate。 
		 *  
		 * @param  xaResource此端点的XAResource
		 */
		void initXAResource(XAResource xaResource) {
			this.transactionDelegate = new TransactionDelegate(xaResource);
		}

		/**
		 * This {@code beforeDelivery} implementation starts a transaction,
		 * if necessary, and exposes the endpoint ClassLoader as current
		 * thread context ClassLoader.
		 * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter
		 * to call this method before invoking the concrete endpoint. If this method
		 * has not been called (check {@link #hasBeforeDeliveryBeenCalled()}), the
		 * concrete endpoint method should call {@code beforeDelivery} and its
		 * sibling {@link #afterDelivery()} explicitly, as part of its own processing.
		 */
		/**
		 * 此{@code  beforeDelivery}实现在必要时启动事务，并将端点ClassLoader公开为当前线程上下文ClassLoader。 
		 *  <p>请注意，在调用具体端点之前，JCA 1.7规范不需要ResourceAdapter来调用此方法。 
		 * 如果尚未调用此方法（请检查{@link  #hasBeforeDeliveryBeenCalled（）}），则具体端点方法应显式调用{@code  beforeDelivery}及其同级{@link  #afterDelivery（）}，如下所示：自己处理的一部分。 
		 * 
		 */
		@Override
		public void beforeDelivery(@Nullable Method method) throws ResourceException {
			this.beforeDeliveryCalled = true;
			Assert.state(this.transactionDelegate != null, "Not initialized");
			try {
				this.transactionDelegate.beginTransaction();
			}
			catch (Throwable ex) {
				throw new ApplicationServerInternalException("Failed to begin transaction", ex);
			}
			Thread currentThread = Thread.currentThread();
			this.previousContextClassLoader = currentThread.getContextClassLoader();
			currentThread.setContextClassLoader(getEndpointClassLoader());
		}

		/**
		 * Template method for exposing the endpoint's ClassLoader
		 * (typically the ClassLoader that the message listener class
		 * has been loaded with).
		 * @return the endpoint ClassLoader (never {@code null})
		 */
		/**
		 * 公开端点的ClassLoader（通常是消息侦听器类所加载的ClassLoader）的模板方法。 
		 *  
		 * @return 端点ClassLoader（从不{<@@code> null}）
		 */
		protected abstract ClassLoader getEndpointClassLoader();

		/**
		 * Return whether the {@link #beforeDelivery} method of this endpoint
		 * has already been called.
		 */
		/**
		 * 返回此端点的{@link  #beforeDelivery}方法是否已被调用。 
		 * 
		 */
		protected final boolean hasBeforeDeliveryBeenCalled() {
			return this.beforeDeliveryCalled;
		}

		/**
		 * Callback method for notifying the endpoint base class
		 * that the concrete endpoint invocation led to an exception.
		 * <p>To be invoked by subclasses in case of the concrete
		 * endpoint throwing an exception.
		 * @param ex the exception thrown from the concrete endpoint
		 */
		/**
		 * 用于通知端点基类具体端点调用导致异常的回调方法。 
		 *  <p>在具体端点抛出异常的情况下由子类调用。 
		 *  
		 * @param 从具体端点抛出异常
		 */
		protected void onEndpointException(Throwable ex) {
			Assert.state(this.transactionDelegate != null, "Not initialized");
			this.transactionDelegate.setRollbackOnly();
			logger.debug("Transaction marked as rollback-only after endpoint exception", ex);
		}

		/**
		 * This {@code afterDelivery} implementation resets the thread context
		 * ClassLoader and completes the transaction, if any.
		 * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter
		 * to call this method after invoking the concrete endpoint. See the
		 * explanation in {@link #beforeDelivery}'s javadoc.
		 */
		/**
		 * 此{@code  afterDelivery}实现可重置线程上下文ClassLoader并完成事务（如果有）。 
		 *  <p>请注意，在调用具体端点之后，JCA 1.7规范不需要ResourceAdapter来调用此方法。 
		 * 请参阅{@link  #beforeDelivery}的javadoc中的说明。 
		 * 
		 */
		@Override
		public void afterDelivery() throws ResourceException {
			Assert.state(this.transactionDelegate != null, "Not initialized");
			this.beforeDeliveryCalled = false;
			Thread.currentThread().setContextClassLoader(this.previousContextClassLoader);
			this.previousContextClassLoader = null;
			try {
				this.transactionDelegate.endTransaction();
			}
			catch (Throwable ex) {
				logger.warn("Failed to complete transaction after endpoint delivery", ex);
				throw new ApplicationServerInternalException("Failed to complete transaction", ex);
			}
		}

		@Override
		public void release() {
			if (this.transactionDelegate != null) {
				try {
					this.transactionDelegate.setRollbackOnly();
					this.transactionDelegate.endTransaction();
				}
				catch (Throwable ex) {
					logger.warn("Could not complete unfinished transaction on endpoint release", ex);
				}
			}
		}
	}


	/**
	 * Private inner class that performs the actual transaction handling,
	 * including enlistment of the endpoint's XAResource.
	 */
	/**
	 * 私有内部类，用于执行实际的事务处理，包括征募端点的XAResource。 
	 * 
	 */
	private class TransactionDelegate {

		@Nullable
		private final XAResource xaResource;

		@Nullable
		private Transaction transaction;

		private boolean rollbackOnly;

		public TransactionDelegate(@Nullable XAResource xaResource) {
			if (xaResource == null && transactionFactory != null &&
					!transactionFactory.supportsResourceAdapterManagedTransactions()) {
				throw new IllegalStateException("ResourceAdapter-provided XAResource is required for " +
						"transaction management. Check your ResourceAdapter's configuration.");
			}
			this.xaResource = xaResource;
		}

		public void beginTransaction() throws Exception {
			if (transactionFactory != null && this.xaResource != null) {
				this.transaction = transactionFactory.createTransaction(transactionName, transactionTimeout);
				this.transaction.enlistResource(this.xaResource);
			}
		}

		public void setRollbackOnly() {
			if (this.transaction != null) {
				this.rollbackOnly = true;
			}
		}

		public void endTransaction() throws Exception {
			if (this.transaction != null) {
				try {
					if (this.rollbackOnly) {
						this.transaction.rollback();
					}
					else {
						this.transaction.commit();
					}
				}
				finally {
					this.transaction = null;
					this.rollbackOnly = false;
				}
			}
		}
	}

}
