/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jca.endpoint;

import javax.resource.ResourceException;
import javax.resource.spi.ActivationSpec;
import javax.resource.spi.ResourceAdapter;
import javax.resource.spi.endpoint.MessageEndpointFactory;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.SmartLifecycle;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Generic bean that manages JCA 1.7 message endpoints within a Spring
 * application context, activating and deactivating the endpoint as part
 * of the application context's lifecycle.
 *
 * <p>This class is completely generic in that it may work with any
 * ResourceAdapter, any MessageEndpointFactory, and any ActivationSpec.
 * It can be configured in standard bean style, for example through
 * Spring's XML bean definition format, as follows:
 *
 * <pre class="code">
 * &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointManager"&gt;
 * 	 &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
 * 	 &lt;property name="messageEndpointFactory"&gt;
 *     &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointFactory"&gt;
 *       &lt;property name="messageListener" ref="messageListener"/&gt;
 *     &lt;/bean&gt;
 * 	 &lt;/property&gt;
 * 	 &lt;property name="activationSpec"&gt;
 *     &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
 *       &lt;property name="destination" value="myQueue"/&gt;
 *       &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
 *     &lt;/bean&gt;
 *   &lt;/property&gt;
 * &lt;/bean&gt;</pre>
 *
 * In this example, Spring's own {@link GenericMessageEndpointFactory} is used
 * to point to a standard message listener object that happens to be supported
 * by the specified target ResourceAdapter: in this case, a JMS
 * {@link javax.jms.MessageListener} object as supported by the ActiveMQ
 * message broker, defined as a Spring bean:
 *
 * <pre class="code">
 * &lt;bean id="messageListener" class="com.myorg.messaging.myMessageListener"&gt;
 *   ...
 * &lt;/bean&gt;</pre>
 *
 * The target ResourceAdapter may be configured as a local Spring bean as well
 * (the typical case) or obtained from JNDI (e.g. on WebLogic). For the
 * example above, a local ResourceAdapter bean could be defined as follows
 * (matching the "resourceAdapter" bean reference above):
 *
 * <pre class="code">
 * &lt;bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean"&gt;
 *   &lt;property name="resourceAdapter"&gt;
 *     &lt;bean class="org.apache.activemq.ra.ActiveMQResourceAdapter"&gt;
 *       &lt;property name="serverUrl" value="tcp://localhost:61616"/&gt;
 *     &lt;/bean&gt;
 *   &lt;/property&gt;
 *   &lt;property name="workManager"&gt;
 *     &lt;bean class="org.springframework.jca.work.SimpleTaskWorkManager"/&gt;
 *   &lt;/property&gt;
 * &lt;/bean&gt;</pre>
 *
 * For a different target resource, the configuration would simply point to a
 * different ResourceAdapter and a different ActivationSpec object (which are
 * both specific to the resource provider), and possibly a different message
 * listener (e.g. a CCI {@link javax.resource.cci.MessageListener} for a
 * resource adapter which is based on the JCA Common Client Interface).
 *
 * <p>The asynchronous execution strategy can be customized through the
 * "workManager" property on the ResourceAdapterFactoryBean (as shown above).
 * Check out {@link org.springframework.jca.work.SimpleTaskWorkManager}'s
 * javadoc for its configuration options; alternatively, any other
 * JCA-compliant WorkManager can be used (e.g. Geronimo's).
 *
 * <p>Transactional execution is a responsibility of the concrete message endpoint,
 * as built by the specified MessageEndpointFactory. {@link GenericMessageEndpointFactory}
 * supports XA transaction participation through its "transactionManager" property,
 * typically with a Spring {@link org.springframework.transaction.jta.JtaTransactionManager}
 * or a plain {@link javax.transaction.TransactionManager} implementation specified there.
 *
 * <pre class="code">
 * &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointManager"&gt;
 * 	 &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
 * 	 &lt;property name="messageEndpointFactory"&gt;
 *     &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointFactory"&gt;
 *       &lt;property name="messageListener" ref="messageListener"/&gt;
 *       &lt;property name="transactionManager" ref="transactionManager"/&gt;
 *     &lt;/bean&gt;
 * 	 &lt;/property&gt;
 * 	 &lt;property name="activationSpec"&gt;
 *     &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
 *       &lt;property name="destination" value="myQueue"/&gt;
 *       &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
 *     &lt;/bean&gt;
 *   &lt;/property&gt;
 * &lt;/bean&gt;
 *
 * &lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre>
 *
 * Alternatively, check out your resource provider's ActivationSpec object,
 * which should support local transactions through a provider-specific config flag,
 * e.g. ActiveMQActivationSpec's "useRAManagedTransaction" bean property.
 *
 * <pre class="code">
 * &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointManager"&gt;
 * 	 &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
 * 	 &lt;property name="messageEndpointFactory"&gt;
 *     &lt;bean class="org.springframework.jca.endpoint.GenericMessageEndpointFactory"&gt;
 *       &lt;property name="messageListener" ref="messageListener"/&gt;
 *     &lt;/bean&gt;
 * 	 &lt;/property&gt;
 * 	 &lt;property name="activationSpec"&gt;
 *     &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
 *       &lt;property name="destination" value="myQueue"/&gt;
 *       &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
 *       &lt;property name="useRAManagedTransaction" value="true"/&gt;
 *     &lt;/bean&gt;
 *   &lt;/property&gt;
 * &lt;/bean&gt;</pre>
 *
 * @author Juergen Hoeller
 * @since 2.5
 * @see javax.resource.spi.ResourceAdapter#endpointActivation
 * @see javax.resource.spi.ResourceAdapter#endpointDeactivation
 * @see javax.resource.spi.endpoint.MessageEndpointFactory
 * @see javax.resource.spi.ActivationSpec
 */
/**
 * 通用bean，用于管理Spring应用程序上下文中的JCA 1.7消息端点，并在应用程序上下文的生命周期中激活和停用端点。 
 *  <p>该类是完全通用的，因为它可以与任何ResourceAdapter，任何MessageEndpointFactory和任何ActivationSpec一起使用。 
 * 可以采用标准bean样式进行配置，例如通过Spring的XML bean定义格式，如下所示：<pre class ="code"> <bean class ="org.springframework.jca.endpoint.GenericMessageEndpointManager"> <property name ="resourceAdapter"ref ="resourceAdapter"/> <属性名称="messageEndpointFactory"> <bean class ="org.springframework.jca.endpoint.GenericMessageEndpointFactory"> <属性名称="messageListener"ref ="messageListener"/> </ bean > </ property> <property name ="activationSpec"> <bean class ="org.apache.activemq.ra.ActiveMQActivationSpec"> <property name ="destination"value ="myQueue"/> <property name ="destinationType"value ="javax.jms.Queue"/> </ bean> </ property> </ bean> </ pre>在此示例中，使用Spring自己的{<< @link >> GenericMessageEndpointFactory}指向标准消息指定的目标ResourceAdapter恰好支持的侦听器对象：在这种情况下，ActiveMQ消息代理支持的JMS {<< @link >> javax.jms.MessageListener}对象ker，定义为Spring bean：<pre class ="code"> <bean id ="messageListener"class ="com.myorg.messaging.myMessageListener"> ... </ bean> </ pre>目标ResourceAdapter可能也可以配置为本地Spring bean（典型情况）或从JNDI获得（例如在WebLogic上）。 
 * 对于上面的示例，可以如下定义本地ResourceAdapter Bean（与上面的"resourceAdapter"Bean引用匹配）：<pre class ="code"> <bean id ="resourceAdapter"class ="org.springframework.jca.support .ResourceAdapterFactoryBean"> <属性名称="resourceAdapter"> <bean类="org.apache.activemq.ra.ActiveMQResourceAdapter"> <属性名称="serverUrl"value ="tcp：// localhost：61616"/> </ bean> </ property> <property name ="workManager"> <bean class ="org.springframework.jca.work.SimpleTaskWorkManager"/> </ property> </ bean> </ pre>对于其他目标资源，配置将仅指向不同的ResourceAdapter和不同的ActivationSpec对象（它们都特定于资源提供者），并且可能指向不同的消息侦听器（例如，用于CCI {<< @link >> javax.resource.cci.MessageListener}基于JCA通用客户端接口的资源适配器）。 
 *  <p>可以通过ResourceAdapterFactoryBean上的"workManager"属性来定制异步执行策略（如上所示）。 
 * 查看{<< @link >> org.springframework.jca.work.SimpleTaskWorkManager}的javadoc，了解其配置选项； 
 * 或者，可以使用任何其他符合JCA的WorkManager（例如Geronimo）。 
 *  <p>事务执行是由指定MessageEndpointFactory构建的具体消息端点的责任。 
 *  {<< @link >> GenericMessageEndpointFactory}通过其"transactionManager"属性支持XA事务参与，通常通过Spring {<< @link >> org.springframework.transaction.jta.JtaTransactionManager}或普通{<< @link> >在此处指定的javax.transaction.TransactionManager}实现。 
 *  <pre class ="code"> <bean class ="org.springframework.jca.endpoint.GenericMessageEndpointManager"> <属性名称="resourceAdapter"ref ="resourceAdapter"/> <属性名称="messageEndpointFactory"> <bean class = "org.springframework.jca.endpoint.GenericMessageEndpointFactory"> <property name ="messageListener"ref ="messageListener"/> <property name ="transactionManager"ref ="transactionManager"/> </ bean> </ property> <property name ="activationSpec"> <bean class ="org.apache.activemq.ra.ActiveMQActivationSpec"> <property name ="destination"value ="myQueue"/> <property name ="destinationType"value ="javax.jms。 
 * 队列"/> </ bean> </ property> </ bean> <bean id ="transactionManager"class ="org.springframework.transaction.jta.JtaTransactionManager"/> </ pre>或者，检查资源提供者的ActivationSpec对象，该对象应通过提供者特定的配置标志来支持本地事务，例如ActiveMQActivationSpec的"useRAManagedTransaction"Bean属性
 */
/**
 * <pre class ="code"> <bean class ="org.springframework.jca.endpoint.GenericMessageEndpointManager"> <属性名称="resourceAdapter"ref ="resourceAdapter"/> <属性名称="messageEndpointFactory"> <bean class = "org.springframework.jca.endpoint.GenericMessageEndpointFactory"> <property name ="messageListener"ref ="messageListener"/> </ bean> </ property> <property name ="activationSpec"> <bean class ="org.apache .activemq.ra.ActiveMQActivationSpec"> <属性名称="destination"value ="myQueue"/> <属性名称="destinationType"value ="javax.jms.Queue"/> <属性名称="useRAManagedTransaction"value ="true"/> </ bean> </ property> </ bean> </ pre> << @author >> Juergen Hoeller @since 2.5 << 
 * @see >> javax.resource.spi.ResourceAdapter＃endpointActivation << 
 * @see >> javax.resource.spi.ResourceAdapter＃endpointDeactivation << 
 * @see >> javax.resource.spi.endpoint.MessageEndpointFactory << 
 * @see >> javax.resource.spi.ActivationSpec
 */
public class GenericMessageEndpointManager implements SmartLifecycle, InitializingBean, DisposableBean {

	@Nullable
	private ResourceAdapter resourceAdapter;

	@Nullable
	private MessageEndpointFactory messageEndpointFactory;

	@Nullable
	private ActivationSpec activationSpec;

	private boolean autoStartup = true;

	private int phase = DEFAULT_PHASE;

	private volatile boolean running = false;

	private final Object lifecycleMonitor = new Object();


	/**
	 * Set the JCA ResourceAdapter to manage endpoints for.
	 */
	/**
	 * 设置JCA ResourceAdapter来管理端点。 
	 * 
	 */
	public void setResourceAdapter(@Nullable ResourceAdapter resourceAdapter) {
		this.resourceAdapter = resourceAdapter;
	}

	/**
	 * Return the JCA ResourceAdapter to manage endpoints for.
	 */
	/**
	 * 返回JCA ResourceAdapter来管理端点。 
	 * 
	 */
	@Nullable
	public ResourceAdapter getResourceAdapter() {
		return this.resourceAdapter;
	}

	/**
	 * Set the JCA MessageEndpointFactory to activate, pointing to a
	 * MessageListener object that the endpoints will delegate to.
	 * <p>A MessageEndpointFactory instance may be shared across multiple
	 * endpoints (i.e. multiple GenericMessageEndpointManager instances),
	 * with different {@link #setActivationSpec ActivationSpec} objects applied.
	 * @see GenericMessageEndpointFactory#setMessageListener
	 */
	/**
	 * 将JCA MessageEndpointFactory设置为激活，指向端点将委托到的MessageListener对象。 
	 *  <p>可以使用多个{@link  #setActivationSpec ActivationSpec}对象在多个端点（即多个GenericMessageEndpointManager实例）之间共享MessageEndpointFactory实例。 
	 *  
	 * @see  GenericMessageEndpointFactory＃setMessageListener
	 */
	public void setMessageEndpointFactory(@Nullable MessageEndpointFactory messageEndpointFactory) {
		this.messageEndpointFactory = messageEndpointFactory;
	}

	/**
	 * Return the JCA MessageEndpointFactory to activate.
	 */
	/**
	 * 返回JCA MessageEndpointFactory进行激活。 
	 * 
	 */
	@Nullable
	public MessageEndpointFactory getMessageEndpointFactory() {
		return this.messageEndpointFactory;
	}

	/**
	 * Set the JCA ActivationSpec to use for activating the endpoint.
	 * <p>Note that this ActivationSpec instance should not be shared
	 * across multiple ResourceAdapter instances.
	 */
	/**
	 * 设置JCA ActivationSpec以用于激活端点。 
	 *  <p>请注意，不应在多个ResourceAdapter实例之间共享该ActivationSpec实例。 
	 * 
	 */
	public void setActivationSpec(@Nullable ActivationSpec activationSpec) {
		this.activationSpec = activationSpec;
	}

	/**
	 * Return the JCA ActivationSpec to use for activating the endpoint.
	 */
	/**
	 * 返回用于激活端点的JCA ActivationSpec。 
	 * 
	 */
	@Nullable
	public ActivationSpec getActivationSpec() {
		return this.activationSpec;
	}

	/**
	 * Set whether to auto-start the endpoint activation after this endpoint
	 * manager has been initialized and the context has been refreshed.
	 * <p>Default is "true". Turn this flag off to defer the endpoint
	 * activation until an explicit {@link #start()} call.
	 */
	/**
	 * 设置在初始化此端点管理器并刷新上下文之后是否自动启动端点激活。 
	 *  <p>默认为"true"。 
	 * 关闭此标志可延迟端点激活，直到显式{@link  #start（）}调用为止。 
	 * 
	 */
	public void setAutoStartup(boolean autoStartup) {
		this.autoStartup = autoStartup;
	}

	/**
	 * Return the value for the 'autoStartup' property.	If "true", this
	 * endpoint manager will start upon a ContextRefreshedEvent.
	 */
	/**
	 * 返回"autoStartup"属性的值。 
	 * 如果为"true"，则此终结点管理器将从ContextRefreshedEvent开始。 
	 * 
	 */
	@Override
	public boolean isAutoStartup() {
		return this.autoStartup;
	}

	/**
	 * Specify the phase in which this endpoint manager should be started
	 * and stopped. The startup order proceeds from lowest to highest, and
	 * the shutdown order is the reverse of that. By default this value is
	 * Integer.MAX_VALUE meaning that this endpoint manager starts as late
	 * as possible and stops as soon as possible.
	 */
	/**
	 * 指定启动和停止此端点管理器的阶段。 
	 * 启动顺序从最低到最高，而关闭顺序则相反。 
	 * 默认情况下，此值为Integer.MAX_VALUE，表示此端点管理器将尽可能晚地启动并尽快停止。 
	 * 
	 */
	public void setPhase(int phase) {
		this.phase = phase;
	}

	/**
	 * Return the phase in which this endpoint manager will be started and stopped.
	 */
	/**
	 * 返回此端点管理器将启动和停止的阶段。 
	 * 
	 */
	@Override
	public int getPhase() {
		return this.phase;
	}

	/**
	 * Prepares the message endpoint, and automatically activates it
	 * if the "autoStartup" flag is set to "true".
	 */
	/**
	 * 准备消息端点，如果"autoStartup"标志设置为"true"，则自动激活它。 
	 * 
	 */
	@Override
	public void afterPropertiesSet() throws ResourceException {
		if (getResourceAdapter() == null) {
			throw new IllegalArgumentException("Property 'resourceAdapter' is required");
		}
		if (getMessageEndpointFactory() == null) {
			throw new IllegalArgumentException("Property 'messageEndpointFactory' is required");
		}
		ActivationSpec activationSpec = getActivationSpec();
		if (activationSpec == null) {
			throw new IllegalArgumentException("Property 'activationSpec' is required");
		}

		if (activationSpec.getResourceAdapter() == null) {
			activationSpec.setResourceAdapter(getResourceAdapter());
		}
		else if (activationSpec.getResourceAdapter() != getResourceAdapter()) {
			throw new IllegalArgumentException("ActivationSpec [" + activationSpec +
					"] is associated with a different ResourceAdapter: " + activationSpec.getResourceAdapter());
		}
	}

	/**
	 * Activates the configured message endpoint.
	 */
	/**
	 * 激活配置的消息端点。 
	 * 
	 */
	@Override
	public void start() {
		synchronized (this.lifecycleMonitor) {
			if (!this.running) {
				ResourceAdapter resourceAdapter = getResourceAdapter();
				Assert.state(resourceAdapter != null, "No ResourceAdapter set");
				try {
					resourceAdapter.endpointActivation(getMessageEndpointFactory(), getActivationSpec());
				}
				catch (ResourceException ex) {
					throw new IllegalStateException("Could not activate message endpoint", ex);
				}
				this.running = true;
			}
		}
	}

	/**
	 * Deactivates the configured message endpoint.
	 */
	/**
	 * 停用已配置的消息端点。 
	 * 
	 */
	@Override
	public void stop() {
		synchronized (this.lifecycleMonitor) {
			if (this.running) {
				ResourceAdapter resourceAdapter = getResourceAdapter();
				Assert.state(resourceAdapter != null, "No ResourceAdapter set");
				resourceAdapter.endpointDeactivation(getMessageEndpointFactory(), getActivationSpec());
				this.running = false;
			}
		}
	}

	@Override
	public void stop(Runnable callback) {
		synchronized (this.lifecycleMonitor) {
			stop();
			callback.run();
		}
	}

	/**
	 * Return whether the configured message endpoint is currently active.
	 */
	/**
	 * 返回配置的消息端点当前是否处于活动状态。 
	 * 
	 */
	@Override
	public boolean isRunning() {
		return this.running;
	}

	/**
	 * Deactivates the message endpoint, preparing it for shutdown.
	 */
	/**
	 * 停用消息端点，使其准备关闭。 
	 * 
	 */
	@Override
	public void destroy() {
		stop();
	}

}
