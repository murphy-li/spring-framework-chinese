/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.interceptor;

import java.util.Properties;

import org.springframework.aop.Pointcut;
import org.springframework.aop.framework.AbstractSingletonProxyFactoryBean;
import org.springframework.aop.framework.ProxyFactory;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.lang.Nullable;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Proxy factory bean for simplified declarative transaction handling.
 * This is a convenient alternative to a standard AOP
 * {@link org.springframework.aop.framework.ProxyFactoryBean}
 * with a separate {@link TransactionInterceptor} definition.
 *
 * <p><strong>HISTORICAL NOTE:</strong> This class was originally designed to cover the
 * typical case of declarative transaction demarcation: namely, wrapping a singleton
 * target object with a transactional proxy, proxying all the interfaces that the target
 * implements. However, in Spring versions 2.0 and beyond, the functionality provided here
 * is superseded by the more convenient {@code tx:} XML namespace. See the
 * <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative">declarative transaction management</a>
 * section of the Spring reference documentation to understand modern options for managing
 * transactions in Spring applications. For these reasons, <strong>users should favor
 * the {@code tx:} XML namespace as well as
 * the @{@link org.springframework.transaction.annotation.Transactional Transactional}
 * and @{@link org.springframework.transaction.annotation.EnableTransactionManagement
 * EnableTransactionManagement} annotations.</strong>
 *
 * <p>There are three main properties that need to be specified:
 * <ul>
 * <li>"transactionManager": the {@link PlatformTransactionManager} implementation to use
 * (for example, a {@link org.springframework.transaction.jta.JtaTransactionManager} instance)
 * <li>"target": the target object that a transactional proxy should be created for
 * <li>"transactionAttributes": the transaction attributes (for example, propagation
 * behavior and "readOnly" flag) per target method name (or method name pattern)
 * </ul>
 *
 * <p>If the "transactionManager" property is not set explicitly and this {@link FactoryBean}
 * is running in a {@link ListableBeanFactory}, a single matching bean of type
 * {@link PlatformTransactionManager} will be fetched from the {@link BeanFactory}.
 *
 * <p>In contrast to {@link TransactionInterceptor}, the transaction attributes are
 * specified as properties, with method names as keys and transaction attribute
 * descriptors as values. Method names are always applied to the target class.
 *
 * <p>Internally, a {@link TransactionInterceptor} instance is used, but the user of this
 * class does not have to care. Optionally, a method pointcut can be specified
 * to cause conditional invocation of the underlying {@link TransactionInterceptor}.
 *
 * <p>The "preInterceptors" and "postInterceptors" properties can be set to add
 * additional interceptors to the mix, like
 * {@link org.springframework.aop.interceptor.PerformanceMonitorInterceptor}.
 *
 * <p><b>HINT:</b> This class is often used with parent / child bean definitions.
 * Typically, you will define the transaction manager and default transaction
 * attributes (for method name patterns) in an abstract parent bean definition,
 * deriving concrete child bean definitions for specific target objects.
 * This reduces the per-bean definition effort to a minimum.
 *
 * <pre code="class">
 * &lt;bean id="baseTransactionProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"
 *     abstract="true"&gt;
 *   &lt;property name="transactionManager" ref="transactionManager"/&gt;
 *   &lt;property name="transactionAttributes"&gt;
 *     &lt;props&gt;
 *       &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
 *       &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
 *       &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
 *     &lt;/props&gt;
 *   &lt;/property&gt;
 * &lt;/bean&gt;
 *
 * &lt;bean id="myProxy" parent="baseTransactionProxy"&gt;
 *   &lt;property name="target" ref="myTarget"/&gt;
 * &lt;/bean&gt;
 *
 * &lt;bean id="yourProxy" parent="baseTransactionProxy"&gt;
 *   &lt;property name="target" ref="yourTarget"/&gt;
 * &lt;/bean&gt;</pre>
 *
 * @author Juergen Hoeller
 * @author Dmitriy Kopylenko
 * @author Rod Johnson
 * @author Chris Beams
 * @since 21.08.2003
 * @see #setTransactionManager
 * @see #setTarget
 * @see #setTransactionAttributes
 * @see TransactionInterceptor
 * @see org.springframework.aop.framework.ProxyFactoryBean
 */
/**
 * 代理工厂bean，用于简化声明式事务处理。 
 * 这是使用单独的{@link  TransactionInterceptor}定义的标准AOP {@link  org.springframework.aop.framework.ProxyFactoryBean}的便捷替代方法。 
 *  <p> <strong>历史性注释：</ strong>此类最初旨在涵盖声明性事务划分的典型情况：即，将单个对象对象包装为事务代理，代理目标实现的所有接口。 
 * 但是，在Spring 2.0及更高版本中，此处提供的功能已被更方便的{@code  tx：} XML名称空间所取代。 
 * 请参阅以下网址的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative">声明式事务管理</a>部分Spring参考文档，了解在Spring应用程序中管理事务的现代选项。 
 * 由于这些原因，<strong>用户应偏爱{@code  tx：} XML名称空间以及@{<@link> org.springframework.transaction.annotation.Transactional Transactional}和@{<@link> org .springframework.transaction.annotation.EnableTransactionManagement EnableTransactionManagement}注释。 
 * </ strong> <p>需要指定三个主要属性：<ul> <li>"transactionManager"：{@link  PlatformTransactionManager}实现使用（例如，一个{@link  org.springframework.transaction.jta.JtaTransactionManager}实例）<li>"target"：应为<li>"transactionAttributes"创建事务代理的目标对象：事务目标方法名称（或方法名称模式）的属性（例如，传播行为和"readOnly"标志）</ ul> <p>如果未明确设置"transactionManager"属性，并且此{@link  FactoryBean}为运行在{@link  ListableBeanFactory}（类型为<< @link> PlatformTr）的单个匹配bean中ansactionManager}将从{@link  BeanFactory}获取。 
 *  <p>与{@link  TransactionInterceptor}相比，事务属性被指定为属性，方法名称为键，事务属性描述符为值。 
 * 方法名称始终应用于目标类。 
 *  <p>在内部，使用{@link  TransactionInterceptor}实例，但是此类的用户不必关心。 
 *  （可选）可以指定方法切入点以引起对基础{@link  TransactionInterceptor}的条件调用。 
 *  <p>可以设置"preInterceptors"和"postInterceptors"属性，以向混合添加其他拦截器，例如{@link  org.springframework.aop.interceptor.PerformanceMonitorInterceptor}。 
 *  <p> <b>提示：</ b>此类通常与父/子bean定义一起使用。 
 * 通常，您将在抽象父bean定义中定义事务管理器和默认事务属性（用于方法名称模式），从而为特定目标对象派生具体的子bean定义。 
 * 这将每个bean的定义工作减少到最低限度。 
 *  <pre code ="class"> <bean id ="baseTransactionProxy"class ="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"abstract ="true"> <属性名称="transactionManager"ref ="transactionManager"/> <属性name ="transactionAttributes"> <props> <prop key ="insert"> PROPAGATION_REQUIRED </ prop> <prop key ="update"> PROPAGATION_REQUIRED </ prop> <prop key =""> PROPAGATION_REQUIRED，只读</ prop> < / props> </ property> </ bean> <bean id ="myProxy"parent ="baseTransactionProxy"> <property name ="target"ref ="myTarget"/> </ bean> <bean id ="yourProxy"parent ="baseTransactionProxy"> <属性名称="target"ref ="yourTarget"/> </ bean> </ pre> @author  Juergen Hoeller @author  Dmitriy Kopylenko @author  Rod Johnson @author 克里斯Beams @自从21.08.2003 
 * @see  #setTransactionManager 
 * @see  #setTarget 
 * @see  #setTransactionAttributes 
 * @see  TransactionInterceptor 
 * @see  org.springframework.aop.framework.ProxyFactoryBean
 */
@SuppressWarnings("serial")
public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean
		implements BeanFactoryAware {

	private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();

	@Nullable
	private Pointcut pointcut;


	/**
	 * Set the default transaction manager. This will perform actual
	 * transaction management: This class is just a way of invoking it.
	 * @see TransactionInterceptor#setTransactionManager
	 */
	/**
	 * 设置默认的事务管理器。 
	 * 这将执行实际的事务管理：此类仅是调用它的一种方法。 
	 *  
	 * @see  TransactionInterceptor＃setTransactionManager
	 */
	public void setTransactionManager(PlatformTransactionManager transactionManager) {
		this.transactionInterceptor.setTransactionManager(transactionManager);
	}

	/**
	 * Set properties with method names as keys and transaction attribute
	 * descriptors (parsed via TransactionAttributeEditor) as values:
	 * e.g. key = "myMethod", value = "PROPAGATION_REQUIRED,readOnly".
	 * <p>Note: Method names are always applied to the target class,
	 * no matter if defined in an interface or the class itself.
	 * <p>Internally, a NameMatchTransactionAttributeSource will be
	 * created from the given properties.
	 * @see #setTransactionAttributeSource
	 * @see TransactionInterceptor#setTransactionAttributes
	 * @see TransactionAttributeEditor
	 * @see NameMatchTransactionAttributeSource
	 */
	/**
	 * 设置属性，方法名称为键，事务属性描述符（通过TransactionAttributeEditor解析）为值：例如键="myMethod"，值="PROPAGATION_REQUIRED，只读"。 
	 *  <p>注意：方法名称始终应用于目标类，无论是在接口中定义还是在类本身中定义。 
	 *  <p>内部，将根据给定的属性创建一个NameMatchTransactionAttributeSource。 
	 *  
	 * @see  #setTransactionAttributeSource 
	 * @see  TransactionInterceptor＃setTransactionAttributes 
	 * @see  TransactionAttributeEditor 
	 * @see  NameMatchTransactionAttributeSource
	 */
	public void setTransactionAttributes(Properties transactionAttributes) {
		this.transactionInterceptor.setTransactionAttributes(transactionAttributes);
	}

	/**
	 * Set the transaction attribute source which is used to find transaction
	 * attributes. If specifying a String property value, a PropertyEditor
	 * will create a MethodMapTransactionAttributeSource from the value.
	 * @see #setTransactionAttributes
	 * @see TransactionInterceptor#setTransactionAttributeSource
	 * @see TransactionAttributeSourceEditor
	 * @see MethodMapTransactionAttributeSource
	 * @see NameMatchTransactionAttributeSource
	 * @see org.springframework.transaction.annotation.AnnotationTransactionAttributeSource
	 */
	/**
	 * 设置用于查找交易属性的交易属性源。 
	 * 如果指定String属性值，PropertyEditor将根据该值创建MethodMapTransactionAttributeSource。 
	 *  
	 * @see  #setTransactionAttributes 
	 * @see  TransactionInterceptor＃setTransactionAttributeSource 
	 * @see  TransactionAttributeSourceEditor 
	 * @see  MethodMapTransactionAttributeSource 
	 * @see  NameMatchTransactionAttributeSource 
	 * @see  org.springframework.transaction.annotation.AnnotationTransactionAttributeSource
	 */
	public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) {
		this.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);
	}

	/**
	 * Set a pointcut, i.e a bean that can cause conditional invocation
	 * of the TransactionInterceptor depending on method and attributes passed.
	 * Note: Additional interceptors are always invoked.
	 * @see #setPreInterceptors
	 * @see #setPostInterceptors
	 */
	/**
	 * 设置切入点，即可以根据传递的方法和属性而导致有条件地调用TransactionInterceptor的bean。 
	 * 注意：总是会调用其他拦截器。 
	 *  
	 * @see  #setPreInterceptors 
	 * @see  #setPostInterceptors
	 */
	public void setPointcut(Pointcut pointcut) {
		this.pointcut = pointcut;
	}

	/**
	 * This callback is optional: If running in a BeanFactory and no transaction
	 * manager has been set explicitly, a single matching bean of type
	 * {@link PlatformTransactionManager} will be fetched from the BeanFactory.
	 * @see org.springframework.beans.factory.BeanFactory#getBean(Class)
	 * @see org.springframework.transaction.PlatformTransactionManager
	 */
	/**
	 * 此回调是可选的：如果在BeanFactory中运行并且未显式设置任何事务管理器，则将从BeanFactory中获取类型为{@link  PlatformTransactionManager}的单个匹配Bean。 
	 *  
	 * @see  org.springframework.beans.factory.BeanFactory＃getBean（Class）
	 * @see  org.springframework.transaction.PlatformTransactionManager
	 */
	@Override
	public void setBeanFactory(BeanFactory beanFactory) {
		this.transactionInterceptor.setBeanFactory(beanFactory);
	}


	/**
	 * Creates an advisor for this FactoryBean's TransactionInterceptor.
	 */
	/**
	 * 为此FactoryBean的TransactionInterceptor创建一个顾问。 
	 * 
	 */
	@Override
	protected Object createMainInterceptor() {
		this.transactionInterceptor.afterPropertiesSet();
		if (this.pointcut != null) {
			return new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor);
		}
		else {
			// Rely on default pointcut.
			return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);
		}
	}

	/**
	 * As of 4.2, this method adds {@link TransactionalProxy} to the set of
	 * proxy interfaces in order to avoid re-processing of transaction metadata.
	 */
	/**
	 * 从4.2开始，此方法将{@link  TransactionalProxy}添加到代理接口集，以避免重新处理事务元数据。 
	 * 
	 */
	@Override
	protected void postProcessProxyFactory(ProxyFactory proxyFactory) {
		proxyFactory.addInterface(TransactionalProxy.class);
	}

}
