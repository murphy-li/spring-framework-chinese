/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.reactive;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.transaction.ReactiveTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionException;

/**
 * Operator class that simplifies programmatic transaction demarcation and
 * transaction exception handling.
 *
 * <p>The central method is {@link #transactional}, supporting transactional wrapping
 * of functional sequences code that. This operator handles the transaction lifecycle
 * and possible exceptions such that neither the ReactiveTransactionCallback
 * implementation nor the calling code needs to explicitly handle transactions.
 *
 * <p>Typical usage: Allows for writing low-level data access objects that use
 * resources such as database connections but are not transaction-aware themselves.
 * Instead, they can implicitly participate in transactions handled by higher-level
 * application services utilizing this class, making calls to the low-level
 * services via an inner-class callback object.
 *
 * <p>Transactional Publishers should avoid Subscription cancellation.
 * Cancelling initiates asynchronous transaction cleanup that does not allow for
 * synchronization on completion.
 *
 * @author Mark Paluch
 * @author Juergen Hoeller
 * @since 5.2
 * @see #execute
 * @see ReactiveTransactionManager
 */
/**
 * 运算符类，可简化程序化事务划分和事务异常处理。 
 *  <p>中心方法是{@link  #transactional}，它支持对功能序列代码进行事务包装。 
 * 此运算符处理事务生命周期和可能的异常，这样ReactiveTransactionCallback实现和调用代码都不需要显式处理事务。 
 *  <p>典型用法：允许编写使用诸如数据库连接之类的资源但本身不支持事务的低级数据访问对象。 
 * 取而代之的是，他们可以隐式参与使用此类由高层应用程序服务处理的事务，并通过内部类回调对象对低层服务进行调用。 
 *  <p>交易发布者应避免取消订阅。 
 * 取消将启动异步事务清理，该清理不允许在完成时进行同步。 
 *  @author  Mark Paluch @author  Juergen Hoeller @5.2起
 * @see  #execute 
 * @see  ReactiveTransactionManager
 */
public interface TransactionalOperator {

	/**
	 * Wrap the functional sequence specified by the given Flux within a transaction.
	 * @param flux the Flux that should be executed within the transaction
	 * @return a result publisher returned by the callback, or {@code null} if none
	 * @throws TransactionException in case of initialization, rollback, or system errors
	 * @throws RuntimeException if thrown by the TransactionCallback
	 */
	/**
	 * 将给定通量指定的功能序列包装在事务中。 
	 *  
	 * @param 使事务中应执行的Flux变通。 
	 * 
	 * @return 回调返回的结果发布者； 
	 * 如果没有，则返回{@code  null} 
	 * @throws 初始化，回滚或系统时为TransactionException如果由TransactionCallback引发，则错误
	 * @throws  RuntimeException
	 */
	default <T> Flux<T> transactional(Flux<T> flux) {
		return execute(it -> flux);
	}

	/**
	 * Wrap the functional sequence specified by the given Mono within a transaction.
	 * @param mono the Mono that should be executed within the transaction
	 * @return a result publisher returned by the callback
	 * @throws TransactionException in case of initialization, rollback, or system errors
	 * @throws RuntimeException if thrown by the TransactionCallback
	 */
	/**
	 * 将给定Mono指定的功能序列包装在事务中。 
	 *  
	 * @param  mono应该在事务内执行的Mono 
	 * @return 由回调返回的结果发布者
	 * @throws 在初始化，回滚或系统错误的情况下，TransactionException 
	 * @throws 如果由TransactionCallback抛出，则为RuntimeException
	 */
	<T> Mono<T> transactional(Mono<T> mono);

	/**
	 * Execute the action specified by the given callback object within a transaction.
	 * <p>Allows for returning a result object created within the transaction, that is,
	 * a domain object or a collection of domain objects. A RuntimeException thrown
	 * by the callback is treated as a fatal exception that enforces a rollback.
	 * Such an exception gets propagated to the caller of the template.
	 * @param action the callback object that specifies the transactional action
	 * @return a result object returned by the callback
	 * @throws TransactionException in case of initialization, rollback, or system errors
	 * @throws RuntimeException if thrown by the TransactionCallback
	 */
	/**
	 * 在事务中执行由给定的回调对象指定的操作。 
	 *  <p>允许返回在事务内创建的结果对象，即域对象或域对象的集合。 
	 * 回调引发的RuntimeException被视为执行回滚的致命异常。 
	 * 这样的异常会传播到模板的调用者。 
	 *  
	 * @param 操作指定事务操作的回调对象
	 * @return 回调
	 * @throws 返回的结果对象
	 * @throws 在初始化，回滚或系统错误的情况下，TransactionException 
	 * @throws 如果由TransactionCallback抛出，则为RuntimeException
	 */
	<T> Flux<T> execute(TransactionCallback<T> action) throws TransactionException;


	// Static builder methods

	/**
	 * Create a new {@link TransactionalOperator} using {@link ReactiveTransactionManager},
	 * using a default transaction.
	 * @param transactionManager the transaction management strategy to be used
	 * @return the transactional operator
	 */
	/**
	 * 使用{@link  ReactiveTransactionManager}（使用默认事务）创建新的{@link  TransactionalOperator}。 
	 *  
	 * @param  transactionManager要使用的事务管理策略
	 * @return 事务运算符
	 */
	static TransactionalOperator create(ReactiveTransactionManager transactionManager){
		return create(transactionManager, TransactionDefinition.withDefaults());
	}

	/**
	 * Create a new {@link TransactionalOperator} using {@link ReactiveTransactionManager}
	 * and {@link TransactionDefinition}.
	 * @param transactionManager the transaction management strategy to be used
	 * @param transactionDefinition the transaction definition to apply
	 * @return the transactional operator
	 */
	/**
	 * 使用{@link  ReactiveTransactionManager}和{@link  TransactionDefinition}创建一个新的{@link  TransactionalOperator}。 
	 *  
	 * @param  transactionManager要使用的事务管理策略
	 * @param  transactionDefinition要应用的事务定义
	 * @return 事务运算符
	 */
	static TransactionalOperator create(
			ReactiveTransactionManager transactionManager, TransactionDefinition transactionDefinition){

		return new TransactionalOperatorImpl(transactionManager, transactionDefinition);
	}

}
