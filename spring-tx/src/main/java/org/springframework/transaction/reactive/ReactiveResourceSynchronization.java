/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.reactive;

import reactor.core.publisher.Mono;

/**
 * {@link TransactionSynchronization} implementation that manages a
 * resource object bound through {@link TransactionSynchronizationManager}.
 *
 * @author Mark Paluch
 * @author Juergen Hoeller
 * @since 5.2
 * @param <O> the resource holder type
 * @param <K> the resource key type
 */
/**
 * {@link  TransactionSynchronization}实现，用于管理通过{@link  TransactionSynchronizationManager}绑定的资源对象。 
 *  @author  Mark Paluch @author  Juergen Hoeller @自5.2起
 * @param  <O>资源持有者类型
 * @param  <K>资源密钥类型
 */
public abstract class ReactiveResourceSynchronization<O, K> implements TransactionSynchronization {

	private final O resourceObject;

	private final K resourceKey;

	private final TransactionSynchronizationManager synchronizationManager;

	private volatile boolean holderActive = true;


	/**
	 * Create a new ReactiveResourceSynchronization for the given holder.
	 * @param resourceObject the resource object to manage
	 * @param resourceKey the key to bind the resource object for
	 * @param synchronizationManager the synchronization manager bound to the current transaction
	 * @see TransactionSynchronizationManager#bindResource
	 */
	/**
	 * 为给定的持有人创建一个新的ReactiveResourceSynchronization。 
	 *  
	 * @param  resourceObject管理的资源对象
	 * @param  resourceKey绑定资源对象的键，用于
	 * @param  syncManager绑定到当前事务的同步管理器
	 * @see  TransactionSynchronizationManager＃bindResource
	 */
	public ReactiveResourceSynchronization(
			O resourceObject, K resourceKey, TransactionSynchronizationManager synchronizationManager) {

		this.resourceObject = resourceObject;
		this.resourceKey = resourceKey;
		this.synchronizationManager = synchronizationManager;
	}


	@Override
	public Mono<Void> suspend() {
		if (this.holderActive) {
			this.synchronizationManager.unbindResource(this.resourceKey);
		}
		return Mono.empty();
	}

	@Override
	public Mono<Void> resume() {
		if (this.holderActive) {
			this.synchronizationManager.bindResource(this.resourceKey, this.resourceObject);
		}
		return Mono.empty();
	}

	@Override
	public Mono<Void> beforeCommit(boolean readOnly) {
		return Mono.empty();
	}

	@Override
	public Mono<Void> beforeCompletion() {
		if (shouldUnbindAtCompletion()) {
			this.synchronizationManager.unbindResource(this.resourceKey);
			this.holderActive = false;
			if (shouldReleaseBeforeCompletion()) {
				return releaseResource(this.resourceObject, this.resourceKey);
			}
		}
		return Mono.empty();
	}

	@Override
	public Mono<Void> afterCommit() {
		if (!shouldReleaseBeforeCompletion()) {
			return processResourceAfterCommit(this.resourceObject);
		}
		return Mono.empty();
	}

	@Override
	public Mono<Void> afterCompletion(int status) {
		return Mono.defer(() -> {
			Mono<Void> sync = Mono.empty();
			if (shouldUnbindAtCompletion()) {
				boolean releaseNecessary = false;
				if (this.holderActive) {
					// The thread-bound resource holder might not be available anymore,
					// since afterCompletion might get called from a different thread.
					this.holderActive = false;
					this.synchronizationManager.unbindResourceIfPossible(this.resourceKey);
					releaseNecessary = true;
				}
				else {
					releaseNecessary = shouldReleaseAfterCompletion(this.resourceObject);
				}
				if (releaseNecessary) {
					sync = releaseResource(this.resourceObject, this.resourceKey);
				}
			}
			else {
				// Probably a pre-bound resource...
				sync = cleanupResource(this.resourceObject, this.resourceKey, (status == STATUS_COMMITTED));
			}
			return sync;
		});
	}


	/**
	 * Return whether this holder should be unbound at completion
	 * (or should rather be left bound to the thread after the transaction).
	 * <p>The default implementation returns {@code true}.
	 */
	/**
	 * 返回此持有人是否应在完成时解除绑定（或在事务处理后绑定到线程）。 
	 *  <p>默认实现返回{@code  true}。 
	 * 
	 */
	protected boolean shouldUnbindAtCompletion() {
		return true;
	}

	/**
	 * Return whether this holder's resource should be released before
	 * transaction completion ({@code true}) or rather after
	 * transaction completion ({@code false}).
	 * <p>Note that resources will only be released when they are
	 * unbound from the thread ({@link #shouldUnbindAtCompletion()}).
	 * <p>The default implementation returns {@code true}.
	 * @see #releaseResource
	 */
	/**
	 * 返回是在交易完成之前（{@code  true}）还是在交易完成之后（{@code  false}）释放此持有人的资源。 
	 *  <p>请注意，仅当资源与线程未绑定时才释放资源（{@link  #shouldUnbindAtCompletion（）}）。 
	 *  <p>默认实现返回{@code  true}。 
	 *  
	 * @see  #releaseResource
	 */
	protected boolean shouldReleaseBeforeCompletion() {
		return true;
	}

	/**
	 * Return whether this holder's resource should be released after
	 * transaction completion ({@code true}).
	 * <p>The default implementation returns {@code !shouldReleaseBeforeCompletion()},
	 * releasing after completion if no attempt was made before completion.
	 * @see #releaseResource
	 */
	/**
	 * 返回在交易完成后是否应释放此持有人的资源（{@code  true}）。 
	 *  <p>默认实现返回{@code ！ 
	 * shouldReleaseBeforeCompletion（）}，如果在完成前未进行任何尝试，则在完成后释放。 
	 *  
	 * @see  #releaseResource
	 */
	protected boolean shouldReleaseAfterCompletion(O resourceHolder) {
		return !shouldReleaseBeforeCompletion();
	}

	/**
	 * After-commit callback for the given resource holder.
	 * Only called when the resource hasn't been released yet
	 * ({@link #shouldReleaseBeforeCompletion()}).
	 * @param resourceHolder the resource holder to process
	 */
	/**
	 * 给定资源所有者的提交后回调。 
	 * 仅在尚未释放资源时调用（{@link  #shouldReleaseBeforeCompletion（）}）。 
	 *  
	 * @param  resourceHolder资源持有人要处理
	 */
	protected Mono<Void> processResourceAfterCommit(O resourceHolder) {
		return Mono.empty();
	}

	/**
	 * Release the given resource (after it has been unbound from the thread).
	 * @param resourceHolder the resource holder to process
	 * @param resourceKey the key that the resource object was bound for
	 */
	/**
	 * 释放给定的资源（在与线程解除绑定之后）。 
	 *  
	 * @param  resource持有资源持有者以处理
	 * @param  resourceKey绑定资源对象的键
	 */
	protected Mono<Void> releaseResource(O resourceHolder, K resourceKey) {
		return Mono.empty();
	}

	/**
	 * Perform a cleanup on the given resource (which is left bound to the thread).
	 * @param resourceHolder the resource holder to process
	 * @param resourceKey the key that the resource object was bound for
	 * @param committed whether the transaction has committed ({@code true})
	 * or rolled back ({@code false})
	 */
	/**
	 * 对给定的资源（留在线程上）执行清除。 
	 *  
	 * @param  resource持有资源持有者以处理
	 * @param  resourceKey资源对象绑定到
	 * @param 的密钥已提交，无论事务已提交（{@code  true}）还是回滚（{<@代码> false}）
	 */
	protected Mono<Void> cleanupResource(O resourceHolder, K resourceKey, boolean committed) {
		return Mono.empty();
	}

}
