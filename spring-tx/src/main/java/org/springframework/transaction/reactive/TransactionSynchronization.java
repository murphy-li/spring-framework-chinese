/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.reactive;

import reactor.core.publisher.Mono;

/**
 * Interface for reactive transaction synchronization callbacks.
 * Supported by {@link AbstractReactiveTransactionManager}.
 *
 * <p>TransactionSynchronization implementations can implement the
 * {@link org.springframework.core.Ordered} interface to influence their execution order.
 * A synchronization that does not implement the {@link org.springframework.core.Ordered}
 * interface is appended to the end of the synchronization chain.
 *
 * <p>System synchronizations performed by Spring itself use specific order values,
 * allowing for fine-grained interaction with their execution order (if necessary).
 *
 * @author Mark Paluch
 * @author Juergen Hoeller
 * @since 5.2
 * @see TransactionSynchronizationManager
 * @see AbstractReactiveTransactionManager
 */
/**
 * 反应式事务同步回调的接口。 
 * 由{@link  AbstractReactiveTransactionManager}支持。 
 *  <p> TransactionSynchronization实现可以实现{@link  org.springframework.core.Ordered}接口以影响其执行顺序。 
 * 未实现{@link  org.springframework.core.Ordered}接口的同步将附加到同步链的末尾。 
 *  <p> Spring本身执行的系统同步使用特定的顺序值，从而允许与其执行顺序进行细粒度的交互（如有必要）。 
 *  @author  Mark Paluch @author  Juergen Hoeller @5.2起
 * @see  TransactionSynchronizationManager 
 * @see  AbstractReactiveTransactionManager
 */
public interface TransactionSynchronization {

	/** Completion status in case of proper commit. */
	/**
	 * 正确提交时的完成状态。 
	 * 
	 */
	int STATUS_COMMITTED = 0;

	/** Completion status in case of proper rollback. */
	/**
	 * 正确回滚的情况下的完成状态。 
	 * 
	 */
	int STATUS_ROLLED_BACK = 1;

	/** Completion status in case of heuristic mixed completion or system errors. */
	/**
	 * 启发式混合完成或系统错误时的完成状态。 
	 * 
	 */
	int STATUS_UNKNOWN = 2;


	/**
	 * Suspend this synchronization.
	 * Supposed to unbind resources from TransactionSynchronizationManager if managing any.
	 * @see TransactionSynchronizationManager#unbindResource
	 */
	/**
	 * 暂停此同步。 
	 * 如果管理任何资源，则应取消与TransactionSynchronizationManager的资源绑定。 
	 *  
	 * @see  TransactionSynchronizationManager＃unbindResource
	 */
	default Mono<Void> suspend() {
		return Mono.empty();
	}

	/**
	 * Resume this synchronization.
	 * Supposed to rebind resources to TransactionSynchronizationManager if managing any.
	 * @see TransactionSynchronizationManager#bindResource
	 */
	/**
	 * 恢复此同步。 
	 * 如果管理资源，则应将资源重新绑定到TransactionSynchronizationManager。 
	 *  
	 * @see  TransactionSynchronizationManager＃bindResource
	 */
	default Mono<Void> resume() {
		return Mono.empty();
	}

	/**
	 * Invoked before transaction commit (before "beforeCompletion").
	 * <p>This callback does <i>not</i> mean that the transaction will actually be committed.
	 * A rollback decision can still occur after this method has been called. This callback
	 * is rather meant to perform work that's only relevant if a commit still has a chance
	 * to happen, such as flushing SQL statements to the database.
	 * <p>Note that exceptions will get propagated to the commit caller and cause a
	 * rollback of the transaction.
	 * @param readOnly whether the transaction is defined as read-only transaction
	 * @throws RuntimeException in case of errors; will be <b>propagated to the caller</b>
	 * (note: do not throw TransactionException subclasses here!)
	 * @see #beforeCompletion
	 */
	/**
	 * 在事务提交之前调用（在"beforeCompletion"之前）。 
	 *  <p>此回调<i>不</ i>并不意味着该事务将实际提交。 
	 * 在调用此方法后，仍然可能发生回滚决定。 
	 * 相反，此回调旨在执行仅在提交仍有机会发生时才有意义的工作，例如将SQL语句刷新到数据库中。 
	 *  <p>请注意，异常将传播到提交调用者，并导致事务回滚。 
	 *  
	 * @param  readOnly是否在发生错误时将事务定义为只读事务
	 * @throws  RuntimeException； 
	 * 将<b>传播给调用者</ b>（注意：不要在此处抛出TransactionException子类！ 
	 * ）
	 * @see  #beforeCompletion
	 */
	default Mono<Void> beforeCommit(boolean readOnly) {
		return Mono.empty();
	}

	/**
	 * Invoked before transaction commit/rollback.
	 * Can perform resource cleanup <i>before</i> transaction completion.
	 * <p>This method will be invoked after {@code beforeCommit}, even when
	 * {@code beforeCommit} threw an exception. This callback allows for
	 * closing resources before transaction completion, for any outcome.
	 * @throws RuntimeException in case of errors; will be <b>logged but not propagated</b>
	 * (note: do not throw TransactionException subclasses here!)
	 * @see #beforeCommit
	 * @see #afterCompletion
	 */
	/**
	 * 在事务提交/回滚之前调用。 
	 * 可以在事务完成之前<i> </ i>执行资源清理。 
	 *  <p>即使{{@code> beforeCommit}引发异常，此方法也会在{@code  beforeCommit}之后被调用。 
	 * 对于任何结果，此回调都允许在事务完成之前关闭资源。 
	 *  
	 * @throws  RuntimeException出现错误； 
	 * 将被记录<b>但不会传播</ b>（注意：不要在这里抛出TransactionException子类！ 
	 * ）
	 * @see  #beforeCommit 
	 * @see  #afterCompletion
	 */
	default Mono<Void> beforeCompletion() {
		return Mono.empty();
	}

	/**
	 * Invoked after transaction commit. Can perform further operations right
	 * <i>after</i> the main transaction has <i>successfully</i> committed.
	 * <p>Can e.g. commit further operations that are supposed to follow on a successful
	 * commit of the main transaction, like confirmation messages or emails.
	 * <p><b>NOTE:</b> The transaction will have been committed already, but the
	 * transactional resources might still be active and accessible. As a consequence,
	 * any data access code triggered at this point will still "participate" in the
	 * original transaction, allowing to perform some cleanup (with no commit following
	 * anymore!), unless it explicitly declares that it needs to run in a separate
	 * transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW} for any
	 * transactional operation that is called from here.</b>
	 * @throws RuntimeException in case of errors; will be <b>propagated to the caller</b>
	 * (note: do not throw TransactionException subclasses here!)
	 */
	/**
	 * 事务提交后调用。 
	 * 可以在<i>成功</ i>提交成功后立即<i>执行</ i>进一步的操作。 
	 *  <p>例如提交应该在成功提交主要交易后执行的其他操作，例如确认消息或电子邮件。 
	 *  <p> <b>注意：</ b>事务将已经提交，但是事务资源可能仍处于活动状态并且可以访问。 
	 * 结果，此时触发的任何数据访问代码仍将"参与"原始事务，从而允许执行一些清除操作（不再执行任何提交！ 
	 * ），除非它明确声明需要在单独的事务中运行。 
	 * 因此：<b>对于从此处调用的任何事务操作，请使用{@code  PROPAGATION_REQUIRES_NEW}。 
	 * </ b> 
	 * @throws 发生错误时发生RuntimeException； 
	 * 将<b>传播给调用方</ b>（注意：不要在此处抛出TransactionException子类！ 
	 * ）
	 */
	default Mono<Void> afterCommit() {
		return Mono.empty();
	}

	/**
	 * Invoked after transaction commit/rollback.
	 * Can perform resource cleanup <i>after</i> transaction completion.
	 * <p><b>NOTE:</b> The transaction will have been committed or rolled back already,
	 * but the transactional resources might still be active and accessible. As a
	 * consequence, any data access code triggered at this point will still "participate"
	 * in the original transaction, allowing to perform some cleanup (with no commit
	 * following anymore!), unless it explicitly declares that it needs to run in a
	 * separate transaction. Hence: <b>Use {@code PROPAGATION_REQUIRES_NEW}
	 * for any transactional operation that is called from here.</b>
	 * @param status completion status according to the {@code STATUS_*} constants
	 * @throws RuntimeException in case of errors; will be <b>logged but not propagated</b>
	 * (note: do not throw TransactionException subclasses here!)
	 * @see #STATUS_COMMITTED
	 * @see #STATUS_ROLLED_BACK
	 * @see #STATUS_UNKNOWN
	 * @see #beforeCompletion
	 */
	/**
	 * 在事务提交/回滚后调用。 
	 * 可以在事务完成后<i> </ i>执行资源清理。 
	 *  <p> <b>注意：</ b>事务将已经提交或回滚，但是事务资源可能仍处于活动状态并且可以访问。 
	 * 结果，此时触发的任何数据访问代码仍将"参与"原始事务，从而允许执行一些清除操作（不再执行任何提交！ 
	 * ），除非它明确声明需要在单独的事务中运行。 
	 * 因此：<b>将{@code  PROPAGATION_REQUIRES_NEW}用于从此处调用的任何事务操作。 
	 * </ b> 
	 * @param 状态完成状态根据{@code  STATUS_}常量
	 * @throws  RuntimeException如果有错误； 
	 * 将被记录<b>但不会传播</ b>（注意：请勿在此处抛出TransactionException子类！ 
	 * ）
	 * @see  #STATUS_COMMITTED 
	 * @see  #STATUS_ROLLED_BACK 
	 * @see  #STATUS_UNKNOWN 
	 * @see  #beforeCompletion
	 */
	default Mono<Void> afterCompletion(int status) {
		return Mono.empty();
	}

}
