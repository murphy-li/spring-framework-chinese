/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.reactive;

import java.util.ArrayDeque;
import java.util.function.Function;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.context.Context;

import org.springframework.transaction.NoTransactionException;

/**
 * Delegate to register and obtain transactional contexts.
 *
 * <p>Typically used by components that intercept or orchestrate transactional flows
 * such as AOP interceptors or transactional operators.
 *
 * @author Mark Paluch
 * @since 5.2
 * @see TransactionSynchronization
 */
/**
 * 委托注册并获取事务上下文。 
 *  <p>通常由拦截或编排事务流的组件（例如AOP拦截器或事务运算符）使用。 
 *  @author  Mark Paluch @自5.2起
 * @see  TransactionSynchronization
 */
public abstract class TransactionContextManager {

	private TransactionContextManager() {
	}


	/**
	 * Obtain the current {@link TransactionContext} from the subscriber context or the
	 * transactional context holder. Context retrieval fails with NoTransactionException
	 * if no context or context holder is registered.
	 * @return the current {@link TransactionContext}
	 * @throws NoTransactionException if no TransactionContext was found in the subscriber context
	 * or no context found in a holder
	 */
	/**
	 * 从订阅者上下文或事务上下文持有者那里获取当前的{@link  TransactionContext}。 
	 * 如果未注册任何上下文或上下文所有者，则上下文检索将失败，并显示NoTransactionException。 
	 *  
	 * @return 当前{@link  TransactionContext} 
	 * @throws  NoTransactionException如果在订阅者上下文中未找到TransactionContext或在持有者中未找到上下文
	 */
	public static Mono<TransactionContext> currentContext() throws NoTransactionException {
		return Mono.subscriberContext().handle((ctx, sink) -> {
			if (ctx.hasKey(TransactionContext.class)) {
				sink.next(ctx.get(TransactionContext.class));
				return;
			}
			if (ctx.hasKey(TransactionContextHolder.class)) {
				TransactionContextHolder holder = ctx.get(TransactionContextHolder.class);
				if (holder.hasContext()) {
					sink.next(holder.currentContext());
					return;
				}
			}
			sink.error(new NoTransactionInContextException());
		});
	}

	/**
	 * Create a {@link TransactionContext} and register it in the subscriber {@link Context}.
	 * @return functional context registration.
	 * @throws IllegalStateException if a transaction context is already associated.
	 * @see Mono#subscriberContext(Function)
	 * @see Flux#subscriberContext(Function)
	 */
	/**
	 * 创建一个{@link  TransactionContext}并将其注册到订阅者{@link  Context}中。 
	 *  
	 * @return 功能上下文注册。 
	 *  
	 * @throws  IllegalStateException如果事务上下文已经关联。 
	 *  
	 * @see  Mono＃subscriberContext（功能）
	 * @see  Flux＃subscriberContext（功能）
	 */
	public static Function<Context, Context> createTransactionContext() {
		return context -> context.put(TransactionContext.class, new TransactionContext());
	}

	/**
	 * Return a {@link Function} to create or associate a new {@link TransactionContext}.
	 * Interaction with transactional resources through
	 * {@link TransactionSynchronizationManager} requires a TransactionContext
	 * to be registered in the subscriber context.
	 * @return functional context registration.
	 */
	/**
	 * 返回一个{@link  Function}来创建或关联一个新的{@link  TransactionContext}。 
	 * 通过{@link  TransactionSynchronizationManager}与事务资源的交互需要在订户上下文中注册一个TransactionContext。 
	 *  
	 * @return 功能上下文注册。 
	 * 
	 */
	public static Function<Context, Context> getOrCreateContext() {
		return context -> {
			TransactionContextHolder holder = context.get(TransactionContextHolder.class);
			if (holder.hasContext()) {
				return context.put(TransactionContext.class, holder.currentContext());
			}
			return context.put(TransactionContext.class, holder.createContext());
		};
	}

	/**
	 * Return a {@link Function} to create or associate a new
	 * {@link TransactionContextHolder}. Creation and release of transactions
	 * within a reactive flow requires a mutable holder that follows a top to
	 * down execution scheme. Reactor's subscriber context follows a down to top
	 * approach regarding mutation visibility.
	 * @return functional context registration.
	 */
	/**
	 * 返回一个{@link  Function}来创建或关联一个新的{@link  TransactionContextHolder}。 
	 * 在反应流中创建和释放事务需要遵循从上到下执行方案的可变持有人。 
	 *  Reactor的订户上下文遵循有关突变可见性的自下而上的方法。 
	 *  
	 * @return 功能上下文注册。 
	 * 
	 */
	public static Function<Context, Context> getOrCreateContextHolder() {
		return context -> {
			if (!context.hasKey(TransactionContextHolder.class)) {
				return context.put(TransactionContextHolder.class, new TransactionContextHolder(new ArrayDeque<>()));
			}
			return context;
		};
	}


	/**
	 * Stackless variant of {@link NoTransactionException} for reactive flows.
	 */
	/**
	 * {@link  NoTransactionException}的无堆栈变体，用于响应流。 
	 * 
	 */
	@SuppressWarnings("serial")
	private static class NoTransactionInContextException extends NoTransactionException {

		public NoTransactionInContextException() {
			super("No transaction in context");
		}

		@Override
		public synchronized Throwable fillInStackTrace() {
			// stackless exception
			return this;
		}
	}

}
