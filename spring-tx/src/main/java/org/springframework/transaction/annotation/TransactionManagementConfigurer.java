/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.transaction.annotation;

import org.springframework.transaction.TransactionManager;

/**
 * Interface to be implemented by @{@link org.springframework.context.annotation.Configuration
 * Configuration} classes annotated with @{@link EnableTransactionManagement} that wish to
 * (or need to) explicitly specify the default {@code PlatformTransactionManager} bean
 * (or {@code ReactiveTransactionManager} bean) to be used for annotation-driven
 * transaction management, as opposed to the default approach of a by-type lookup.
 * One reason this might be necessary is if there are two {@code PlatformTransactionManager}
 * beans present in the container.
 *
 * <p>See @{@link EnableTransactionManagement} for general examples and context;
 * see {@link #annotationDrivenTransactionManager()} for detailed instructions.
 *
 * <p>Note that in by-type lookup disambiguation cases, an alternative approach to
 * implementing this interface is to simply mark one of the offending
 * {@code PlatformTransactionManager} {@code @Bean} methods as
 * {@link org.springframework.context.annotation.Primary @Primary}.
 * This is even generally preferred since it doesn't lead to early initialization
 * of the {@code PlatformTransactionManager} bean.
 *
 * @author Chris Beams
 * @since 3.1
 * @see EnableTransactionManagement
 * @see org.springframework.context.annotation.Primary
 * @see org.springframework.transaction.PlatformTransactionManager
 * @see org.springframework.transaction.ReactiveTransactionManager
 */
/**
 * 将由@{<@link> org.springframework.context.annotation.Configuration Configuration}类实现的接口，该类带有@{<@link> EnableTransactionManagement}注释，这些类希望（或需要）明确指定默认的{@code 与按类型查找的默认方法相反，PlatformTransactionManager} bean（或{@code  ReactiveTransactionManager} bean）将用于注释驱动的事务管理。 
 * 可能有必要的一个原因是，如果容器中存在两个{@code  PlatformTransactionManager} Bean。 
 *  <p>有关一般示例和上下文，请参见@{<@link> EnableTransactionManagement}； 
 * 有关详细说明，请参见{@link  #annotationDrivenTransactionManager（）}。 
 *  <p>请注意，在按类型查找消除歧义的情况下，实现此接口的另一种方法是将存在问题的{@code  PlatformTransactionManager} {@code  @Bean}方法之一简单标记为{@link  org.springframework.context.annotation.Primary @Primary}。 
 * 它甚至通常是首选，因为它不会导致{@code  PlatformTransactionManager} bean的早期初始化。 
 *  @author 克里斯·比姆斯（Chris Beams）@始于3.1 
 * @see  EnableTransactionManagement 
 * @see  org.springframework.context.annotation.Primary 
 * @see  org.springframework.transaction.PlatformTransactionManager 
 * @see  org.springframework.transaction.ReactiveTransactionManager
 */
public interface TransactionManagementConfigurer {

	/**
	 * Return the default transaction manager bean to use for annotation-driven database
	 * transaction management, i.e. when processing {@code @Transactional} methods.
	 * <p>There are two basic approaches to implementing this method:
	 * <h3>1. Implement the method and annotate it with {@code @Bean}</h3>
	 * In this case, the implementing {@code @Configuration} class implements this method,
	 * marks it with {@code @Bean} and configures and returns the transaction manager
	 * directly within the method body:
	 * <pre class="code">
	 * &#064;Bean
	 * &#064;Override
	 * public PlatformTransactionManager annotationDrivenTransactionManager() {
	 *     return new DataSourceTransactionManager(dataSource());
	 * }</pre>
	 * <h3>2. Implement the method without {@code @Bean} and delegate to another existing
	 * {@code @Bean} method</h3>
	 * <pre class="code">
	 * &#064;Bean
	 * public PlatformTransactionManager txManager() {
	 *     return new DataSourceTransactionManager(dataSource());
	 * }
	 *
	 * &#064;Override
	 * public PlatformTransactionManager annotationDrivenTransactionManager() {
	 *     return txManager(); // reference the existing {@code @Bean} method above
	 * }</pre>
	 * If taking approach #2, be sure that <em>only one</em> of the methods is marked
	 * with {@code @Bean}!
	 * <p>In either scenario #1 or #2, it is important that the
	 * {@code PlatformTransactionManager} instance is managed as a Spring bean within the
	 * container as all {@code PlatformTransactionManager} implementations take advantage
	 * of Spring lifecycle callbacks such as {@code InitializingBean} and
	 * {@code BeanFactoryAware}.
	 * @return a {@link org.springframework.transaction.PlatformTransactionManager} or
	 * {@link org.springframework.transaction.ReactiveTransactionManager} implementation
	 */
	/**
	 * 返回默认的事务管理器bean，用于注释驱动的数据库事务管理，即在处理{@code  @Transactional}方法时。 
	 *  <p>有两种实现此方法的基本方法：<h3> 1。 
	 * 实现该方法并使用{@code  @Bean}注释它。 
	 * </ h3>在这种情况下，实现{@code  @Configuration}类将实现此方法，并用{@code  @Bean}进行标记，直接在方法体内配置和返回事务管理器：<pre class ="code"> @Bean @Override public PlatformTransactionManager注解DrivenTransactionManager（）{返回新的DataSourceTransactionManager（dataSource（））; } </ pre> <h3> 2。 
	 * 在没有{@code  @Bean}的情况下实现该方法，并委托给另一个现有的{@code  @Bean}方法</ h3> <pre class ="code"> @Bean public PlatformTransactionManager txManager（）{返回新的DataSourceTransactionManager（数据源（））; } @Override公共PlatformTransactionManager注解DrivenTransactionManager（）{return txManager（）; //请参考上面现有的{@code  @Bean}方法</ </ >>如果采用方法2，请确保<em>只有一个</ em>方法标记为{@code  @豆角，扁豆}！ 
	 *  <p>在场景＃1或＃2中，将{@code  PlatformTransactionManager}实例作为容器中的Spring bean管理非常重要，因为所有{@code  PlatformTransactionManager}实现都利用了Spring生命周期回调例如{@code  InitializingBean}和{@code  BeanFactoryAware}。 
	 *  
	 * @return 一个{@link  org.springframework.transaction.PlatformTransactionManager}或{@link  org.springframework.transaction.ReactiveTransactionManager}实现
	 */
	TransactionManager annotationDrivenTransactionManager();

}
