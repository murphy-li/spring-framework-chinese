/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.util;

import java.io.ByteArrayInputStream;
import java.util.Collections;
import java.util.Map;

import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.hamcrest.Matcher;
import org.hamcrest.MatcherAssert;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.SimpleNamespaceContext;

/**
 * A helper class for applying assertions via XPath expressions.
 *
 * @author Rossen Stoyanchev
 * @since 3.2
 */
/**
 * 通过XPath表达式应用断言的助手类。 
 *  @author  Rossen Stoyanchev @从3.2开始
 */
public class XpathExpectationsHelper {

	private final String expression;

	private final XPathExpression xpathExpression;

	private final boolean hasNamespaces;


	/**
	 * XpathExpectationsHelper constructor.
	 * @param expression the XPath expression
	 * @param namespaces the XML namespaces referenced in the XPath expression, or {@code null}
	 * @param args arguments to parameterize the XPath expression with using the
	 * formatting specifiers defined in {@link String#format(String, Object...)}
	 * @throws XPathExpressionException if expression compilation failed
	 */
	/**
	 * XpathExpectationsHelper构造函数。 
	 *  
	 * @param 表达式XPath表达式
	 * @param 命名空间XPath表达式中引用的XML命名空间，或{@code  null} 
	 * @param  args参数使用在{<中定义的格式说明符来参数化XPath表达式。 
	 *  @link> String＃format（String，Object ...）} 
	 * @throws  XPathExpressionException如果表达式编译失败
	 */
	public XpathExpectationsHelper(String expression, @Nullable Map<String, String> namespaces, Object... args)
			throws XPathExpressionException {

		this.expression = String.format(expression, args);
		this.xpathExpression = compileXpathExpression(this.expression, namespaces);
		this.hasNamespaces = !CollectionUtils.isEmpty(namespaces);
	}

	private static XPathExpression compileXpathExpression(String expression,
			@Nullable Map<String, String> namespaces) throws XPathExpressionException {

		SimpleNamespaceContext namespaceContext = new SimpleNamespaceContext();
		namespaceContext.setBindings(namespaces != null ? namespaces : Collections.emptyMap());
		XPath xpath = XPathFactory.newInstance().newXPath();
		xpath.setNamespaceContext(namespaceContext);
		return xpath.compile(expression);
	}


	/**
	 * Return the compiled XPath expression.
	 */
	/**
	 * 返回编译的XPath表达式。 
	 * 
	 */
	protected XPathExpression getXpathExpression() {
		return this.xpathExpression;
	}


	/**
	 * Parse the content, evaluate the XPath expression as a {@link Node},
	 * and assert it with the given {@code Matcher<Node>}.
	 */
	/**
	 * 解析内容，将XPath表达式评估为{@link  Node}，并使用给定的{@code  Matcher <Node>}对其进行断言。 
	 * 
	 */
	public void assertNode(byte[] content, @Nullable String encoding, Matcher<? super Node> matcher)
			throws Exception {

		Node node = evaluateXpath(content, encoding, Node.class);
		MatcherAssert.assertThat("XPath " + this.expression, node, matcher);
	}

	/**
	 * Parse the content, evaluate the XPath expression as a {@link NodeList},
	 * and assert it with the given {@code Matcher<NodeList>}.
	 * @since 5.2.2
	 */
	/**
	 * 解析内容，将XPath表达式评估为{@link  NodeList}，并使用给定的{@code  Matcher <NodeList>}对其进行断言。 
	 *  @从5.2.2开始
	 */
	public void assertNodeList(byte[] content, @Nullable String encoding, Matcher<? super NodeList> matcher)
			throws Exception {

		Document document = parseXmlByteArray(content, encoding);
		NodeList nodeList = evaluateXpath(document, XPathConstants.NODESET, NodeList.class);
		MatcherAssert.assertThat("XPath " + this.getXpathExpression(), nodeList, matcher);
	}

	/**
	 * Apply the XPath expression and assert the resulting content exists.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并断言结果内容存在。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void exists(byte[] content, @Nullable String encoding) throws Exception {
		Node node = evaluateXpath(content, encoding, Node.class);
		AssertionErrors.assertNotNull("XPath " + this.expression + " does not exist", node);
	}

	/**
	 * Apply the XPath expression and assert the resulting content does not exist.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并断言结果内容不存在。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {
		Node node = evaluateXpath(content, encoding, Node.class);
		AssertionErrors.assertNull("XPath " + this.expression + " exists", node);
	}

	/**
	 * Apply the XPath expression and assert the resulting content with the
	 * given Hamcrest matcher.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并使用给定的Hamcrest匹配器声明结果内容。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<Integer> matcher)
			throws Exception {

		NodeList nodeList = evaluateXpath(content, encoding, NodeList.class);
		String reason = "nodeCount for XPath " + this.expression;
		MatcherAssert.assertThat(reason, nodeList != null ? nodeList.getLength() : 0, matcher);
	}

	/**
	 * Apply the XPath expression and assert the resulting content as an integer.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并将结果内容声明为整数。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount) throws Exception {
		NodeList nodeList = evaluateXpath(content, encoding, NodeList.class);
		AssertionErrors.assertEquals("nodeCount for XPath " + this.expression, expectedCount,
				(nodeList != null ? nodeList.getLength() : 0));
	}

	/**
	 * Apply the XPath expression and assert the resulting content with the
	 * given Hamcrest matcher.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并使用给定的Hamcrest匹配器声明结果内容。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher)
			throws Exception {

		String actual = evaluateXpath(content, encoding, String.class);
		MatcherAssert.assertThat("XPath " + this.expression, actual, matcher);
	}

	/**
	 * Apply the XPath expression and assert the resulting content as a String.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并将断言的内容声明为String。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertString(byte[] content, @Nullable String encoding, String expectedValue) throws Exception {
		String actual = evaluateXpath(content, encoding, String.class);
		AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, actual);
	}

	/**
	 * Apply the XPath expression and assert the resulting content with the
	 * given Hamcrest matcher.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并使用给定的Hamcrest匹配器声明结果内容。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher) throws Exception {
		Double actual = evaluateXpath(content, encoding, Double.class);
		MatcherAssert.assertThat("XPath " + this.expression, actual, matcher);
	}

	/**
	 * Apply the XPath expression and assert the resulting content as a Double.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并将断言的内容声明为Double。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {
		Double actual = evaluateXpath(content, encoding, Double.class);
		AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, actual);
	}

	/**
	 * Apply the XPath expression and assert the resulting content as a Boolean.
	 * @throws Exception if content parsing or expression evaluation fails
	 */
	/**
	 * 应用XPath表达式并将结果内容声明为布尔值。 
	 *  
	 * @throws 如果内容解析或表达式求值失败，则异常
	 */
	public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {
		String actual = evaluateXpath(content, encoding, String.class);
		AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, Boolean.parseBoolean(actual));
	}

	/**
	 * Evaluate the XPath and return the resulting value.
	 * @param content the content to evaluate against
	 * @param encoding the encoding to use (optionally)
	 * @param targetClass the target class, one of Number, String, Boolean,
	 * org.w3c.Node, or NodeList
	 * @throws Exception if content parsing or expression evaluation fails
	 * @since 5.1
	 */
	/**
	 * 评估XPath并返回结果值。 
	 *  
	 * @param 内容要根据
	 * @param 编码进行评估的内容（要使用的编码）
	 * @param  targetClass目标类，Number，String，Boolean，org.w3c.Node或NodeList中的一种，<
	 * @throws >如果自5.1起内容解析或表达式求值失败，则为异常
	 */
	@Nullable
	public <T> T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {
		Document document = parseXmlByteArray(content, encoding);
		return evaluateXpath(document, toQName(targetClass), targetClass);
	}

	/**
	 * Parse the given XML content to a {@link Document}.
	 * @param xml the content to parse
	 * @param encoding optional content encoding, if provided as metadata (e.g. in HTTP headers)
	 * @return the parsed document
	 */
	/**
	 * 将给定的XML内容解析为{@link  Document}。 
	 *  
	 * @param  xml要解析的内容
	 * @param 编码可选的内容编码，如果作为元数据提供（例如，在HTTP标头中）
	 * @return 解析的文档
	 */
	protected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(this.hasNamespaces);
		DocumentBuilder documentBuilder = factory.newDocumentBuilder();
		InputSource inputSource = new InputSource(new ByteArrayInputStream(xml));
		if (StringUtils.hasText(encoding)) {
			inputSource.setEncoding(encoding);
		}
		return documentBuilder.parse(inputSource);
	}

	/**
	 * Apply the XPath expression to given document.
	 * @throws XPathExpressionException if expression evaluation failed
	 */
	/**
	 * 将XPath表达式应用于给定的文档。 
	 *  
	 * @throws  XPathExpressionException如果表达式求值失败
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	protected <T> T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass)
			throws XPathExpressionException {

		return (T) getXpathExpression().evaluate(document, evaluationType);
	}

	private <T> QName toQName(Class<T> expectedClass) {
		QName evaluationType;
		if (Number.class.isAssignableFrom(expectedClass)) {
			evaluationType = XPathConstants.NUMBER;
		}
		else if (CharSequence.class.isAssignableFrom(expectedClass)) {
			evaluationType = XPathConstants.STRING;
		}
		else if (Boolean.class.isAssignableFrom(expectedClass)) {
			evaluationType = XPathConstants.BOOLEAN;
		}
		else if (Node.class.isAssignableFrom(expectedClass)) {
			evaluationType = XPathConstants.NODE;
		}
		else if (NodeList.class.isAssignableFrom(expectedClass)) {
			evaluationType = XPathConstants.NODESET;
		}
		else {
			throw new IllegalArgumentException("Unexpected target class " + expectedClass + ". " +
					"Supported: numbers, strings, boolean, and org.w3c.Node and NodeList");
		}
		return evaluationType;
	}

}
