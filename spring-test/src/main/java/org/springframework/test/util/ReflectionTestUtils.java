/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.util;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.MethodInvoker;
import org.springframework.util.ObjectUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * {@code ReflectionTestUtils} is a collection of reflection-based utility
 * methods for use in unit and integration testing scenarios.
 *
 * <p>There are often times when it would be beneficial to be able to set a
 * non-{@code public} field, invoke a non-{@code public} setter method, or
 * invoke a non-{@code public} <em>configuration</em> or <em>lifecycle</em>
 * callback method when testing code involving, for example:
 *
 * <ul>
 * <li>ORM frameworks such as JPA and Hibernate which condone the usage of
 * {@code private} or {@code protected} field access as opposed to
 * {@code public} setter methods for properties in a domain entity.</li>
 * <li>Spring's support for annotations such as
 * {@link org.springframework.beans.factory.annotation.Autowired @Autowired},
 * {@link javax.inject.Inject @Inject}, and
 * {@link javax.annotation.Resource @Resource} which provides dependency
 * injection for {@code private} or {@code protected} fields, setter methods,
 * and configuration methods.</li>
 * <li>Use of annotations such as {@link javax.annotation.PostConstruct @PostConstruct}
 * and {@link javax.annotation.PreDestroy @PreDestroy} for lifecycle callback
 * methods.</li>
 * </ul>
 *
 * <p>In addition, several methods in this class provide support for {@code static}
 * fields and {@code static} methods &mdash; for example,
 * {@link #setField(Class, String, Object)}, {@link #getField(Class, String)},
 * {@link #invokeMethod(Class, String, Object...)},
 * {@link #invokeMethod(Object, Class, String, Object...)}, etc.
 *
 * @author Sam Brannen
 * @author Juergen Hoeller
 * @since 2.5
 * @see ReflectionUtils
 * @see AopTestUtils
 */
/**
 * {@code  ReflectionTestUtils}是基于反射的实用程序方法的集合，用于单元测试和集成测试方案。 
 *  <p>有时候，设置非{@code  public}字段，调用非{@code  public} setter方法或调用非{@code  public} <em> configuration </ em>或<em> lifecycle </ em>回调方法在测试涉及以下内容的代码时，例如：<ul> <li> ORM框架，例如JPA和Hibernate，它们纵容了与域实体中属性的{@code  public}设置方法相比，{<@code> private}或{@code  protected}字段访问。 
 * </ li> <li> Spring对注释的支持，例如{ @link  org.springframework.beans.factory.annotation.Autowired @Autowired}，{<@link> javax.inject.Inject @Inject}和{@link  javax.annotation.Resource @Resource}提供依赖关系注入{@code  private}或{@code  protected}字段，setter方法和配置方法。 
 * </ li> <li>使用注释，例如{@link  javax.annotation.PostConstruct @PostConstruct }和{@link  javax.annotation.PreDestroy @PreDestroy}代表lifecyc回调方法。 
 * </ li> </ ul> <p>此外，此类中的一些方法还支持{@code  static}字段和{<@@code> static}方法，例如{<@link> #setField（Class，String，Object）}，{@link  #getField（Class，String）}，{@link  #invokeMethod（Class，String，Object ...）}，{<@link > #invokeMethod（Object，Class，String，Object ...）}等。 
 * @author  Sam Brannen @author  Juergen Hoeller @since 2.5起
 * @see  ReflectionUtils 
 * @see  AopTestUtils
 */
public abstract class ReflectionTestUtils {

	private static final String SETTER_PREFIX = "set";

	private static final String GETTER_PREFIX = "get";

	private static final Log logger = LogFactory.getLog(ReflectionTestUtils.class);

	private static final boolean springAopPresent = ClassUtils.isPresent(
			"org.springframework.aop.framework.Advised", ReflectionTestUtils.class.getClassLoader());


	/**
	 * Set the {@linkplain Field field} with the given {@code name} on the
	 * provided {@code targetObject} to the supplied {@code value}.
	 * <p>This method delegates to {@link #setField(Object, String, Object, Class)},
	 * supplying {@code null} for the {@code type} argument.
	 * @param targetObject the target object on which to set the field; never {@code null}
	 * @param name the name of the field to set; never {@code null}
	 * @param value the value to set
	 */
	/**
	 * 将提供的{@code  targetObject}上具有给定{<@@code>名称}的{@link  plain字段}设置为提供的{@code  value}。 
	 *  <p>此方法委托给{@link  #setField（Object，String，Object，Class）}，为{@code  type}参数提供{@code  null}。 
	 *  
	 * @param  targetObject要在其上设置字段的目标对象； 
	 * 从不{@code  null} 
	 * @param 命名要设置的字段的名称； 
	 * 从不{@code  null} 
	 * @param 值要设置的值
	 */
	public static void setField(Object targetObject, String name, @Nullable Object value) {
		setField(targetObject, name, value, null);
	}

	/**
	 * Set the {@linkplain Field field} with the given {@code name}/{@code type}
	 * on the provided {@code targetObject} to the supplied {@code value}.
	 * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},
	 * supplying {@code null} for the {@code targetClass} argument.
	 * @param targetObject the target object on which to set the field; never {@code null}
	 * @param name the name of the field to set; may be {@code null} if
	 * {@code type} is specified
	 * @param value the value to set
	 * @param type the type of the field to set; may be {@code null} if
	 * {@code name} is specified
	 */
	/**
	 * 将提供的{@code  targetObject}上具有给定的{@code  name} / {<@code> type}的{@link  plain Field字段}设置为提供的{@code  value}。 
	 *  <p>此方法委托给{@link  #setField（Object，Class，String，Object，Class）}，为{@code  targetClass}参数提供{@code  null}。 
	 *  
	 * @param  targetObject要在其上设置字段的目标对象； 
	 * 从不{@code  null} 
	 * @param 命名要设置的字段的名称； 
	 * 如果指定了{@code  type}，则可以为{@code  null}。 
	 * 
	 * @param  value要设置的值
	 * @param  type要设置的字段的类型； 
	 * 如果指定了{@code  name}，则可以为{@code  null}
	 */
	public static void setField(Object targetObject, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {
		setField(targetObject, null, name, value, type);
	}

	/**
	 * Set the static {@linkplain Field field} with the given {@code name} on
	 * the provided {@code targetClass} to the supplied {@code value}.
	 * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},
	 * supplying {@code null} for the {@code targetObject} and {@code type} arguments.
	 * <p>This method does not support setting {@code static final} fields.
	 * @param targetClass the target class on which to set the static field;
	 * never {@code null}
	 * @param name the name of the field to set; never {@code null}
	 * @param value the value to set
	 * @since 4.2
	 */
	/**
	 * 将提供的{@code  targetClass}上具有给定{<@@code>名称}的静态{@link  plain Field字段}设置为提供的{@code  value}。 
	 *  <p>此方法委托给{@link  #setField（Object，Class，String，Object，Class）}，为{@code  targetObject}和{@code 类型}参数。 
	 *  <p>此方法不支持设置{@code  static final}字段。 
	 *  
	 * @param  targetClass要在其上设置静态字段的目标类； 
	 * 从不{@code  null} 
	 * @param 命名要设置的字段的名称； 
	 * 从不{@code  null} 
	 * @param 设置要设置的值@since 4.2
	 */
	public static void setField(Class<?> targetClass, String name, @Nullable Object value) {
		setField(null, targetClass, name, value, null);
	}

	/**
	 * Set the static {@linkplain Field field} with the given
	 * {@code name}/{@code type} on the provided {@code targetClass} to
	 * the supplied {@code value}.
	 * <p>This method delegates to {@link #setField(Object, Class, String, Object, Class)},
	 * supplying {@code null} for the {@code targetObject} argument.
	 * <p>This method does not support setting {@code static final} fields.
	 * @param targetClass the target class on which to set the static field;
	 * never {@code null}
	 * @param name the name of the field to set; may be {@code null} if
	 * {@code type} is specified
	 * @param value the value to set
	 * @param type the type of the field to set; may be {@code null} if
	 * {@code name} is specified
	 * @since 4.2
	 */
	/**
	 * 将提供的{@code  targetClass}上具有给定的{@code  name} / {<@code> type}的静态{@link  plain Field字段}设置为提供的{@code 值} 。 
	 *  <p>此方法委托给{@link  #setField（Object，Class，String，Object，Class）}，为{@code  targetObject}参数提供{@code  null}。 
	 *  <p>此方法不支持设置{@code  static final}字段。 
	 *  
	 * @param  targetClass要在其上设置静态字段的目标类； 
	 * 从不{@code  null} 
	 * @param 命名要设置的字段的名称； 
	 * 如果指定了{@code  type}，则可以为{@code  null}。 
	 * 
	 * @param  value要设置的值
	 * @param  type要设置的字段的类型； 
	 * 如果自4.2起已指定{@code  name}，则可以为{@code  null}
	 */
	public static void setField(
			Class<?> targetClass, @Nullable String name, @Nullable Object value, @Nullable Class<?> type) {

		setField(null, targetClass, name, value, type);
	}

	/**
	 * Set the {@linkplain Field field} with the given {@code name}/{@code type}
	 * on the provided {@code targetObject}/{@code targetClass} to the supplied
	 * {@code value}.
	 * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will
	 * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing
	 * the field to be set on the ultimate target of the proxy.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * field. In addition, an attempt will be made to make non-{@code public}
	 * fields <em>accessible</em>, thus allowing one to set {@code protected},
	 * {@code private}, and <em>package-private</em> fields.
	 * <p>This method does not support setting {@code static final} fields.
	 * @param targetObject the target object on which to set the field; may be
	 * {@code null} if the field is static
	 * @param targetClass the target class on which to set the field; may
	 * be {@code null} if the field is an instance field
	 * @param name the name of the field to set; may be {@code null} if
	 * {@code type} is specified
	 * @param value the value to set
	 * @param type the type of the field to set; may be {@code null} if
	 * {@code name} is specified
	 * @since 4.2
	 * @see ReflectionUtils#findField(Class, String, Class)
	 * @see ReflectionUtils#makeAccessible(Field)
	 * @see ReflectionUtils#setField(Field, Object, Object)
	 * @see AopTestUtils#getUltimateTargetObject(Object)
	 */
	/**
	 * 将提供的{@code  targetObject} / {<@code> targetClass}上具有给定的{@code  name} / {<@code> type}的{@link  plain Field字段}设置为提供的{ {@code 值}。 
	 *  <p>如果提供的{@code  targetObject}是<em> proxy </ em>，它将是{@link  plain AopTestUtils＃getUltimateTargetObject unwrapped}，从而可以将字段设置为最终对象代理。 
	 *  <p>此方法遍历类层次结构以查找所需字段。 
	 * 另外，将尝试使非{@code  public}字段变为<em>可访问</ em>，从而允许人们将{@code  protected}，{<@code> private}，和<em> package-private </ em>字段。 
	 *  <p>此方法不支持设置{@code  static final}字段。 
	 *  
	 * @param  targetObject要在其上设置字段的目标对象； 
	 * 如果字段是静态的，则可以为{@code  null} 
	 * @param  targetClass设置字段的目标类； 
	 * 如果该字段是实例字段，则可以为{@code  null}。 
	 * 
	 * @param  name要设置的字段的名称； 
	 * 如果指定了{@code  type}，则可以为{@code  null}。 
	 * 
	 * @param  value要设置的值
	 * @param  type要设置的字段的类型； 
	 * 从4.2开始，如果指定了{@code  name}，则可能为{@code  null} 
	 * @see  ReflectionUtils＃findField（Class，String，Class）
	 * @see  ReflectionUtils＃makeAccessible（Field）
	 * @see  ReflectionUtils＃setField（Field，Object，Object）
	 * @see  AopTestUtils＃getUltimateTargetObject（Object）
	 */
	public static void setField(@Nullable Object targetObject, @Nullable Class<?> targetClass,
			@Nullable String name, @Nullable Object value, @Nullable Class<?> type) {

		Assert.isTrue(targetObject != null || targetClass != null,
				"Either targetObject or targetClass for the field must be specified");

		if (targetObject != null && springAopPresent) {
			targetObject = AopTestUtils.getUltimateTargetObject(targetObject);
		}
		if (targetClass == null) {
			targetClass = targetObject.getClass();
		}

		Field field = ReflectionUtils.findField(targetClass, name, type);
		if (field == null) {
			throw new IllegalArgumentException(String.format(
					"Could not find field '%s' of type [%s] on %s or target class [%s]", name, type,
					safeToString(targetObject), targetClass));
		}

		if (logger.isDebugEnabled()) {
			logger.debug(String.format(
					"Setting field '%s' of type [%s] on %s or target class [%s] to value [%s]", name, type,
					safeToString(targetObject), targetClass, value));
		}
		ReflectionUtils.makeAccessible(field);
		ReflectionUtils.setField(field, targetObject, value);
	}

	/**
	 * Get the value of the {@linkplain Field field} with the given {@code name}
	 * from the provided {@code targetObject}.
	 * <p>This method delegates to {@link #getField(Object, Class, String)},
	 * supplying {@code null} for the {@code targetClass} argument.
	 * @param targetObject the target object from which to get the field;
	 * never {@code null}
	 * @param name the name of the field to get; never {@code null}
	 * @return the field's current value
	 * @see #getField(Class, String)
	 */
	/**
	 * 从提供的{@code  targetObject}中获取具有给定的{@code 名称}的{@link  plain字段}的值。 
	 *  <p>此方法委托给{@link  #getField（Object，Class，String）}，为{@code  targetClass}参数提供{@code  null}。 
	 *  
	 * @param  targetObject从中获取字段的目标对象； 
	 * 从不{@code  null} 
	 * @param 命名要获取的字段的名称； 
	 * 从不{@code  null} 
	 * @return 字段的当前值
	 * @see  #getField（Class，String）
	 */
	@Nullable
	public static Object getField(Object targetObject, String name) {
		return getField(targetObject, null, name);
	}

	/**
	 * Get the value of the static {@linkplain Field field} with the given
	 * {@code name} from the provided {@code targetClass}.
	 * <p>This method delegates to {@link #getField(Object, Class, String)},
	 * supplying {@code null} for the {@code targetObject} argument.
	 * @param targetClass the target class from which to get the static field;
	 * never {@code null}
	 * @param name the name of the field to get; never {@code null}
	 * @return the field's current value
	 * @since 4.2
	 * @see #getField(Object, String)
	 */
	/**
	 * 从提供的{@code  targetClass}中获取具有给定的{@code 名称}的静态{@link  plain Field字段}的值。 
	 *  <p>此方法委托给{@link  #getField（Object，Class，String）}，为{@code  targetObject}参数提供{@code  null}。 
	 *  
	 * @param  targetClass从中获取静态字段的目标类； 
	 * 从不{@code  null} 
	 * @param 命名要获取的字段的名称； 
	 * 从不{@code  null} 
	 * @return 字段的当前值@从4.2开始
	 * @see  #getField（Object，String）
	 */
	@Nullable
	public static Object getField(Class<?> targetClass, String name) {
		return getField(null, targetClass, name);
	}

	/**
	 * Get the value of the {@linkplain Field field} with the given {@code name}
	 * from the provided {@code targetObject}/{@code targetClass}.
	 * <p>If the supplied {@code targetObject} is a <em>proxy</em>, it will
	 * be {@linkplain AopTestUtils#getUltimateTargetObject unwrapped} allowing
	 * the field to be retrieved from the ultimate target of the proxy.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * field. In addition, an attempt will be made to make non-{@code public}
	 * fields <em>accessible</em>, thus allowing one to get {@code protected},
	 * {@code private}, and <em>package-private</em> fields.
	 * @param targetObject the target object from which to get the field; may be
	 * {@code null} if the field is static
	 * @param targetClass the target class from which to get the field; may
	 * be {@code null} if the field is an instance field
	 * @param name the name of the field to get; never {@code null}
	 * @return the field's current value
	 * @since 4.2
	 * @see #getField(Object, String)
	 * @see #getField(Class, String)
	 * @see ReflectionUtils#findField(Class, String, Class)
	 * @see ReflectionUtils#makeAccessible(Field)
	 * @see ReflectionUtils#getField(Field, Object)
	 * @see AopTestUtils#getUltimateTargetObject(Object)
	 */
	/**
	 * 从提供的{@code  targetObject} / {<@code> targetClass}中获取具有给定的{@code 名称}的{@link  plain字段}的值。 
	 *  <p>如果提供的{@code  targetObject}是<em> proxy </ em>，它将是{@link  plain AopTestUtils＃getUltimateTargetObject unwrapped}，从而可以从最终目标中检索字段代理。 
	 *  <p>此方法遍历类层次结构以查找所需字段。 
	 * 另外，将尝试使非{@code  public}字段变为<em>可访问</ em>，从而允许人们获得{@code 保护}，{<@code>私有}，和<em> package-private </ em>字段。 
	 *  
	 * @param  targetObject从中获取字段的目标对象； 
	 * 如果字段是静态的，则可以为{@code  null} 
	 * @param  targetClass从中获取字段的目标类； 
	 * 如果该字段是实例字段，则可以为{@code  null}。 
	 * 
	 * @param  name要获取的字段的名称； 
	 * 从不{@code  null} 
	 * @return 字段的当前值@从4.2开始
	 * @see  #getField（Object，String）
	 * @see  #getField（Class，String）
	 * @see  ReflectionUtils＃findField（Class ，String，Class）
	 * @see  ReflectionUtils＃makeAccessible（Field）
	 * @see  ReflectionUtils＃getField（Field，Object）
	 * @see  AopTestUtils＃getUltimateTargetObject（Object）
	 */
	@Nullable
	public static Object getField(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name) {
		Assert.isTrue(targetObject != null || targetClass != null,
			"Either targetObject or targetClass for the field must be specified");

		if (targetObject != null && springAopPresent) {
			targetObject = AopTestUtils.getUltimateTargetObject(targetObject);
		}
		if (targetClass == null) {
			targetClass = targetObject.getClass();
		}

		Field field = ReflectionUtils.findField(targetClass, name);
		if (field == null) {
			throw new IllegalArgumentException(String.format("Could not find field '%s' on %s or target class [%s]",
					name, safeToString(targetObject), targetClass));
		}

		if (logger.isDebugEnabled()) {
			logger.debug(String.format("Getting field '%s' from %s or target class [%s]", name,
					safeToString(targetObject), targetClass));
		}
		ReflectionUtils.makeAccessible(field);
		return ReflectionUtils.getField(field, targetObject);
	}

	/**
	 * Invoke the setter method with the given {@code name} on the supplied
	 * target object with the supplied {@code value}.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * method. In addition, an attempt will be made to make non-{@code public}
	 * methods <em>accessible</em>, thus allowing one to invoke {@code protected},
	 * {@code private}, and <em>package-private</em> setter methods.
	 * <p>In addition, this method supports JavaBean-style <em>property</em>
	 * names. For example, if you wish to set the {@code name} property on the
	 * target object, you may pass either &quot;name&quot; or
	 * &quot;setName&quot; as the method name.
	 * @param target the target object on which to invoke the specified setter
	 * method
	 * @param name the name of the setter method to invoke or the corresponding
	 * property name
	 * @param value the value to provide to the setter method
	 * @see ReflectionUtils#findMethod(Class, String, Class[])
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 */
	/**
	 * 在具有提供的{@code  value}的提供的目标对象上，以给定的{@code  name}调用setter方法。 
	 *  <p>此方法遍历类层次结构以查找所需的方法。 
	 * 此外，将尝试使非{@code  public}方法可访问<em> </ em>，从而允许人们调用{@code  protected}，{<@code> private}，和<em> package-private </ em> setter方法。 
	 *  <p>此外，此方法支持JavaBean样式的<em>属性</ em>名称。 
	 * 例如，如果您希望在目标对象上设置{@code  name}属性，则可以传递"name"或"setName"作为方法名称。 
	 *  
	 * @param 以要在其上调用指定的setter方法的目标对象为目标。 
	 * 
	 * @param 名称要调用的setter方法的名称或相应的属性名称
	 * @param 值，以提供给setter方法的值<
	 * @see > ReflectionUtils＃findMethod（Class，String，Class []）
	 * @see  ReflectionUtils＃makeAccessible（Method）
	 * @see  ReflectionUtils＃invokeMethod（Method，Object，Object []）
	 */
	public static void invokeSetterMethod(Object target, String name, Object value) {
		invokeSetterMethod(target, name, value, null);
	}

	/**
	 * Invoke the setter method with the given {@code name} on the supplied
	 * target object with the supplied {@code value}.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * method. In addition, an attempt will be made to make non-{@code public}
	 * methods <em>accessible</em>, thus allowing one to invoke {@code protected},
	 * {@code private}, and <em>package-private</em> setter methods.
	 * <p>In addition, this method supports JavaBean-style <em>property</em>
	 * names. For example, if you wish to set the {@code name} property on the
	 * target object, you may pass either &quot;name&quot; or
	 * &quot;setName&quot; as the method name.
	 * @param target the target object on which to invoke the specified setter
	 * method
	 * @param name the name of the setter method to invoke or the corresponding
	 * property name
	 * @param value the value to provide to the setter method
	 * @param type the formal parameter type declared by the setter method
	 * @see ReflectionUtils#findMethod(Class, String, Class[])
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 */
	/**
	 * 在具有提供的{@code  value}的提供的目标对象上，以给定的{@code  name}调用setter方法。 
	 *  <p>此方法遍历类层次结构以查找所需的方法。 
	 * 此外，将尝试使非{@code  public}方法可访问<em> </ em>，从而允许人们调用{@code  protected}，{<@code> private}，和<em> package-private </ em> setter方法。 
	 *  <p>此外，此方法支持JavaBean样式的<em>属性</ em>名称。 
	 * 例如，如果您希望在目标对象上设置{@code  name}属性，则可以传递"name"或"setName"作为方法名称。 
	 *  
	 * @param 以要在其上调用指定的setter方法的目标对象为目标。 
	 * 
	 * @param 名称要调用的setter方法的名称或相应的属性名称
	 * @param 值，以提供给setter方法的值<
	 * @param >键入由setter方法声明的形式参数类型
	 * @see  ReflectionUtils＃findMethod（Class，String，Class []）
	 * @see  ReflectionUtils＃makeAccessible（Method）
	 * @see  ReflectionUtils＃invokeMethod（Method，Object，Object []）
	 */
	public static void invokeSetterMethod(Object target, String name, @Nullable Object value, @Nullable Class<?> type) {
		Assert.notNull(target, "Target object must not be null");
		Assert.hasText(name, "Method name must not be empty");
		Class<?>[] paramTypes = (type != null ? new Class<?>[] {type} : null);

		String setterMethodName = name;
		if (!name.startsWith(SETTER_PREFIX)) {
			setterMethodName = SETTER_PREFIX + StringUtils.capitalize(name);
		}

		Method method = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);
		if (method == null && !setterMethodName.equals(name)) {
			setterMethodName = name;
			method = ReflectionUtils.findMethod(target.getClass(), setterMethodName, paramTypes);
		}
		if (method == null) {
			throw new IllegalArgumentException(String.format(
					"Could not find setter method '%s' on %s with parameter type [%s]", setterMethodName,
					safeToString(target), type));
		}

		if (logger.isDebugEnabled()) {
			logger.debug(String.format("Invoking setter method '%s' on %s with value [%s]", setterMethodName,
					safeToString(target), value));
		}

		ReflectionUtils.makeAccessible(method);
		ReflectionUtils.invokeMethod(method, target, value);
	}

	/**
	 * Invoke the getter method with the given {@code name} on the supplied
	 * target object with the supplied {@code value}.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * method. In addition, an attempt will be made to make non-{@code public}
	 * methods <em>accessible</em>, thus allowing one to invoke {@code protected},
	 * {@code private}, and <em>package-private</em> getter methods.
	 * <p>In addition, this method supports JavaBean-style <em>property</em>
	 * names. For example, if you wish to get the {@code name} property on the
	 * target object, you may pass either &quot;name&quot; or
	 * &quot;getName&quot; as the method name.
	 * @param target the target object on which to invoke the specified getter
	 * method
	 * @param name the name of the getter method to invoke or the corresponding
	 * property name
	 * @return the value returned from the invocation
	 * @see ReflectionUtils#findMethod(Class, String, Class[])
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 */
	/**
	 * 在具有提供的{@code  value}的提供的目标对象上，以给定的{@code  name}调用getter方法。 
	 *  <p>此方法遍历类层次结构以查找所需的方法。 
	 * 此外，将尝试使非{@code  public}方法可访问<em> </ em>，从而允许人们调用{@code  protected}，{<@code> private}，和<em> package-private </ em> getter方法。 
	 *  <p>此外，此方法支持JavaBean样式的<em>属性</ em>名称。 
	 * 例如，如果您希望在目标对象上获得{@code  name}属性，则可以传递"name"或"getName"作为方法名称。 
	 *  
	 * @param 将要在其上调用指定的getter方法的目标对象作为目标。 
	 * 
	 * @param 为要调用的getter方法的名称或相应的属性名称
	 * @return 从调用返回的值
	 * @see  ReflectionUtils＃ findMethod（Class，String，Class []）
	 * @see  ReflectionUtils＃makeAccessible（Method）
	 * @see  ReflectionUtils＃invokeMethod（Method，Object，Object []）
	 */
	@Nullable
	public static Object invokeGetterMethod(Object target, String name) {
		Assert.notNull(target, "Target object must not be null");
		Assert.hasText(name, "Method name must not be empty");

		String getterMethodName = name;
		if (!name.startsWith(GETTER_PREFIX)) {
			getterMethodName = GETTER_PREFIX + StringUtils.capitalize(name);
		}
		Method method = ReflectionUtils.findMethod(target.getClass(), getterMethodName);
		if (method == null && !getterMethodName.equals(name)) {
			getterMethodName = name;
			method = ReflectionUtils.findMethod(target.getClass(), getterMethodName);
		}
		if (method == null) {
			throw new IllegalArgumentException(String.format(
					"Could not find getter method '%s' on %s", getterMethodName, safeToString(target)));
		}

		if (logger.isDebugEnabled()) {
			logger.debug(String.format("Invoking getter method '%s' on %s", getterMethodName, safeToString(target)));
		}
		ReflectionUtils.makeAccessible(method);
		return ReflectionUtils.invokeMethod(method, target);
	}

	/**
	 * Invoke the method with the given {@code name} on the supplied target
	 * object with the supplied arguments.
	 * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},
	 * supplying {@code null} for the {@code targetClass} argument.
	 * @param target the target object on which to invoke the specified method
	 * @param name the name of the method to invoke
	 * @param args the arguments to provide to the method
	 * @return the invocation result, if any
	 * @see #invokeMethod(Class, String, Object...)
	 * @see #invokeMethod(Object, Class, String, Object...)
	 * @see MethodInvoker
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 * @see ReflectionUtils#handleReflectionException(Exception)
	 */
	/**
	 * 使用提供的参数在提供的目标对象上使用给定的{@code  name}调用该方法。 
	 *  <p>此方法委托给{@link  #invokeMethod（Object，Class，String，Object ...）}，为{@code  targetClass}参数提供{@code  null}。 
	 *  
	 * @param 以要在其上调用指定方法的目标对象为目标
	 * @param 命名要调用的方法的名称
	 * @param  args将参数提供给方法
	 * @return 的调用结果（如果有的话）
	 * @see  #invokeMethod（类，字符串，对象...）
	 * @see  #invokeMethod（对象，类，字符串，对象...）
	 * @see  MethodInvoker 
	 * @see  ReflectionUtils＃makeAccessible（Method）<@请参见> ReflectionUtils＃invokeMethod（方法，对象，对象[]）<@请参阅> ReflectionUtils＃handleReflectionException（Exception）
	 */
	@Nullable
	public static <T> T invokeMethod(Object target, String name, Object... args) {
		Assert.notNull(target, "Target object must not be null");
		return invokeMethod(target, null, name, args);
	}

	/**
	 * Invoke the static method with the given {@code name} on the supplied target
	 * class with the supplied arguments.
	 * <p>This method delegates to {@link #invokeMethod(Object, Class, String, Object...)},
	 * supplying {@code null} for the {@code targetObject} argument.
	 * @param targetClass the target class on which to invoke the specified method
	 * @param name the name of the method to invoke
	 * @param args the arguments to provide to the method
	 * @return the invocation result, if any
	 * @since 5.2
	 * @see #invokeMethod(Object, String, Object...)
	 * @see #invokeMethod(Object, Class, String, Object...)
	 * @see MethodInvoker
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 * @see ReflectionUtils#handleReflectionException(Exception)
	 */
	/**
	 * 使用提供的参数在提供的目标类上使用给定的{@code  name}调用静态方法。 
	 *  <p>此方法委派给{@link  #invokeMethod（Object，Class，String，Object ...）}，为{@code  targetObject}参数提供{@code  null}。 
	 *  
	 * @param  targetClass要在其上调用指定方法的目标类
	 * @param 命名要调用的方法的名称
	 * @param  args将参数提供给方法
	 * @return 的调用结果（如果有）@从5.2开始
	 * @see  #invokeMethod（Object，String，Object ...）
	 * @see  #invokeMethod（Object，Class，String，Object ...）
	 * @see  MethodInvoker 
	 * @see  ReflectionUtils＃makeAccessible（Method ）
	 * @see  ReflectionUtils＃invokeMethod（方法，对象，对象[]）
	 * @see  ReflectionUtils＃handleReflectionException（Exception）
	 */
	@Nullable
	public static <T> T invokeMethod(Class<?> targetClass, String name, Object... args) {
		Assert.notNull(targetClass, "Target class must not be null");
		return invokeMethod(null, targetClass, name, args);
	}

	/**
	 * Invoke the method with the given {@code name} on the provided
	 * {@code targetObject}/{@code targetClass} with the supplied arguments.
	 * <p>This method traverses the class hierarchy in search of the desired
	 * method. In addition, an attempt will be made to make non-{@code public}
	 * methods <em>accessible</em>, thus allowing one to invoke {@code protected},
	 * {@code private}, and <em>package-private</em> methods.
	 * @param targetObject the target object on which to invoke the method; may
	 * be {@code null} if the method is static
	 * @param targetClass the target class on which to invoke the method; may
	 * be {@code null} if the method is an instance method
	 * @param name the name of the method to invoke
	 * @param args the arguments to provide to the method
	 * @return the invocation result, if any
	 * @since 5.2
	 * @see #invokeMethod(Object, String, Object...)
	 * @see #invokeMethod(Class, String, Object...)
	 * @see MethodInvoker
	 * @see ReflectionUtils#makeAccessible(Method)
	 * @see ReflectionUtils#invokeMethod(Method, Object, Object[])
	 * @see ReflectionUtils#handleReflectionException(Exception)
	 */
	/**
	 * 使用提供的参数在提供的{@code  targetObject} / {<@code> targetClass}上使用给定的{@code 名称}调用方法。 
	 *  <p>此方法遍历类层次结构以查找所需的方法。 
	 * 此外，将尝试使非{@code  public}方法可访问<em> </ em>，从而允许人们调用{@code  protected}，{<@code> private}，和<em> package-private </ em>方法。 
	 *  
	 * @param  targetObject在其上调用方法的目标对象； 
	 * 如果方法是静态的，则可以为{@code  null}。 
	 * targetClass调用该方法的目标类。 
	 * 如果方法是实例方法
	 * @param ，则可以为{@code  null}名称调用方法的名称
	 * @param  args将参数提供给方法
	 * @return 的调用结果（如果有） @since 5.2 
	 * @see  #invokeMethod（对象，字符串，对象...）
	 * @see  #invokeMethod（类，字符串，对象...）
	 * @see  MethodInvoker 
	 * @see  ReflectionUtils＃makeAccessible（Method） 
	 * @see  ReflectionUtils＃invokeMethod（方法，对象，对象[]）
	 * @see  ReflectionUtils＃handleReflectionException（Exception）
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <T> T invokeMethod(@Nullable Object targetObject, @Nullable Class<?> targetClass, String name,
			Object... args) {

		Assert.isTrue(targetObject != null || targetClass != null,
				"Either 'targetObject' or 'targetClass' for the method must be specified");
		Assert.hasText(name, "Method name must not be empty");

		try {
			MethodInvoker methodInvoker = new MethodInvoker();
			methodInvoker.setTargetObject(targetObject);
			if (targetClass != null) {
				methodInvoker.setTargetClass(targetClass);
			}
			methodInvoker.setTargetMethod(name);
			methodInvoker.setArguments(args);
			methodInvoker.prepare();

			if (logger.isDebugEnabled()) {
				logger.debug(String.format("Invoking method '%s' on %s or %s with arguments %s", name,
						safeToString(targetObject), safeToString(targetClass), ObjectUtils.nullSafeToString(args)));
			}

			return (T) methodInvoker.invoke();
		}
		catch (Exception ex) {
			ReflectionUtils.handleReflectionException(ex);
			throw new IllegalStateException("Should never get here");
		}
	}

	private static String safeToString(@Nullable Object target) {
		try {
			return String.format("target object [%s]", target);
		}
		catch (Exception ex) {
			return String.format("target of type [%s] whose toString() method threw [%s]",
					(target != null ? target.getClass().getName() : "unknown"), ex);
		}
	}

	private static String safeToString(@Nullable Class<?> clazz) {
		return String.format("target class [%s]", (clazz != null ? clazz.getName() : null));
	}

}
