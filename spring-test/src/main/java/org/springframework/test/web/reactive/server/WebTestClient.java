/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.web.reactive.server;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import org.hamcrest.Matcher;
import org.reactivestreams.Publisher;

import org.springframework.context.ApplicationContext;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.format.FormatterRegistry;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ClientHttpConnector;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.http.codec.ClientCodecConfigurer;
import org.springframework.http.codec.ServerCodecConfigurer;
import org.springframework.lang.Nullable;
import org.springframework.util.MultiValueMap;
import org.springframework.validation.Validator;
import org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder;
import org.springframework.web.reactive.config.CorsRegistry;
import org.springframework.web.reactive.config.PathMatchConfigurer;
import org.springframework.web.reactive.config.ViewResolverRegistry;
import org.springframework.web.reactive.config.WebFluxConfigurer;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.server.HandlerStrategies;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.result.method.annotation.ArgumentResolverConfigurer;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebHandler;
import org.springframework.web.server.session.WebSessionManager;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Client for testing web servers that uses {@link WebClient} internally to
 * perform requests while also providing a fluent API to verify responses.
 * This client can connect to any server over HTTP, or to a WebFlux application
 * via mock request and response objects.
 *
 * <p>Use one of the bindToXxx methods to create an instance. For example:
 * <ul>
 * <li>{@link #bindToController(Object...)}
 * <li>{@link #bindToRouterFunction(RouterFunction)}
 * <li>{@link #bindToApplicationContext(ApplicationContext)}
 * <li>{@link #bindToServer()}
 * <li>...
 * </ul>
 *
 * <p><strong>Warning</strong>: {@code WebTestClient} is not usable yet in
 * Kotlin due to a <a href="https://youtrack.jetbrains.com/issue/KT-5464">type inference issue</a>
 * which is expected to be fixed as of Kotlin 1.3. You can watch
 * <a href="https://github.com/spring-projects/spring-framework/issues/20606">gh-20606</a>
 * for up-to-date information. Meanwhile, the proposed alternative is to use
 * directly {@link WebClient} with its Reactor and Spring Kotlin extensions to
 * perform integration tests on an embedded WebFlux server.
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @since 5.0
 * @see StatusAssertions
 * @see HeaderAssertions
 * @see JsonPathAssertions
 */
/**
 * 测试Web服务器的客户端，该客户端内部使用{@link  WebClient}执行请求，同时还提供流利的API来验证响应。 
 * 该客户端可以通过HTTP连接到任何服务器，或通过模拟请求和响应对象连接到WebFlux应用程序。 
 *  <p>使用bindToXxx方法之一创建实例。 
 * 例如：<ul> <li> {<@link> #bindToController（Object ...）} <li> {<@link> #bindToRouterFunction（RouterFunction）} <li> {<@link> #bindToApplicationContext（ApplicationContext） } <li> {<@link> #bindToServer（）} <li> ... </ ul> <p> <strong>警告</ strong>：{@code  WebTestClient}在Kotlin中尚不可用到<a href="https://youtrack.jetbrains.com/issue/KT-5464">类型推断问题</a>，该问题预计将在Kotlin 1.3中修复。 
 * 您可以观看<a href="https://github.com/spring-projects/spring-framework/issues/20606"> gh-20606 </a>以获得最新信息。 
 * 同时，建议的替代方法是直接使用{@link  WebClient}及其Reactor和Spring Kotlin扩展在嵌入式WebFlux服务器上执行集成测试。 
 *  @author  Rossen Stoyanchev @author  Brian Clozel @since 5.0起
 * @see  StatusAssertions 
 * @see  HeaderAssertions 
 * @see  JsonPathAssertions
 */
public interface WebTestClient {

	/**
	 * The name of a request header used to assign a unique id to every request
	 * performed through the {@code WebTestClient}. This can be useful for
	 * storing contextual information at all phases of request processing (e.g.
	 * from a server-side component) under that id and later to look up
	 * that information once an {@link ExchangeResult} is available.
	 */
	/**
	 * 请求标头的名称，该标头用于为通过{@code  WebTestClient}执行的每个请求分配唯一的ID。 
	 * 这对于在请求处理的所有阶段（例如，来自服务器端组件）在该ID下存储上下文信息很有用，并在{@link  ExchangeResult}可用时稍后查找该信息。 
	 * 
	 */
	String WEBTESTCLIENT_REQUEST_ID = "WebTestClient-Request-Id";


	/**
	 * Prepare an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP GET请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Prepare an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP HEAD请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Prepare an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP POST请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec post();

	/**
	 * Prepare an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP PUT请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec put();

	/**
	 * Prepare an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP PATCH请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec patch();

	/**
	 * Prepare an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP DELETE请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Prepare an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 准备一个HTTP OPTIONS请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Prepare a request for the specified {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	/**
	 * 为指定的{@code  HttpMethod}准备一个请求。 
	 *  
	 * @return 用于指定目标URL的规范
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to mutate properties of this web test client.
	 */
	/**
	 * 返回一个构建器以更改此Web测试客户端的属性。 
	 * 
	 */
	Builder mutate();

	/**
	 * Mutate the {@link WebTestClient}, apply the given configurer, and build
	 * a new instance. Essentially a shortcut for:
	 * <pre>
	 * mutate().apply(configurer).build();
	 * </pre>
	 * @param configurer the configurer to apply
	 * @return the mutated test client
	 */
	/**
	 * 突变{@link  WebTestClient}，应用给定的配置程序，并构建一个新实例。 
	 * 本质上是以下快捷方式：<pre> mutate（）。 
	 * apply（configurer）.build（）; </ pre> 
	 * @param 配置器，配置器应用
	 * @return 变异测试客户端
	 */
	WebTestClient mutateWith(WebTestClientConfigurer configurer);


	// Static factory methods

	/**
	 * Use this server setup to test one `@Controller` at a time.
	 * This option loads the default configuration of
	 * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}.
	 * There are builder methods to customize the Java config. The resulting
	 * WebFlux application will be tested without an HTTP server using a mock
	 * request and response.
	 * @param controllers one or more controller instances to tests
	 * (specified {@code Class} will be turned into instance)
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	/**
	 * 使用此服务器设置可一次测试一个`@Controller`。 
	 * 此选项将加载默认配置{@link  org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}。 
	 * 有一些用于定制Java配置的构建器方法。 
	 * 最终的WebFlux应用程序将在没有HTTP服务器的情况下使用模拟请求和响应进行测试。 
	 *  
	 * @param 控制一个或多个控制器实例进行测试（指定的{@code  Class}将转换为实例）
	 * @return 链接的API，用于自定义服务器和客户端配置； 
	 * 使用{@link  MockServerSpec＃configureClient（）}过渡到客户端配置
	 */
	static ControllerSpec bindToController(Object... controllers) {
		return new DefaultControllerSpec(controllers);
	}

	/**
	 * Use this option to set up a server from a {@link RouterFunction}.
	 * Internally the provided configuration is passed to
	 * {@code RouterFunctions#toWebHandler}. The resulting WebFlux application
	 * will be tested without an HTTP server using a mock request and response.
	 * @param routerFunction the RouterFunction to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	/**
	 * 使用此选项可通过{@link  RouterFunction}设置服务器。 
	 * 在内部将提供的配置传递到{@code  RouterFunctions＃toWebHandler}。 
	 * 最终的WebFlux应用程序将在没有HTTP服务器的情况下使用模拟请求和响应进行测试。 
	 *  
	 * @param  routerFunction RouterFunction用于测试
	 * @return 链接的API，以自定义服务器和客户端配置； 
	 * 使用{@link  MockServerSpec＃configureClient（）}过渡到客户端配置
	 */
	static RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {
		return new DefaultRouterFunctionSpec(routerFunction);
	}

	/**
	 * Use this option to setup a server from the Spring configuration of your
	 * application, or some subset of it. Internally the provided configuration
	 * is passed to {@code WebHttpHandlerBuilder} to set up the request
	 * processing chain. The resulting WebFlux application will be tested
	 * without an HTTP server using a mock request and response.
	 * <p>Consider using the TestContext framework and
	 * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}
	 * in order to efficiently load and inject the Spring configuration into the
	 * test class.
	 * @param applicationContext the Spring context
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	/**
	 * 使用此选项可以从应用程序的Spring配置或其一部分来设置服务器。 
	 * 在内部将提供的配置传递给{@code  WebHttpHandlerBuilder}以建立请求处理链。 
	 * 最终的WebFlux应用程序将在没有HTTP服务器的情况下使用模拟请求和响应进行测试。 
	 *  <p>请考虑使用TestContext框架和{@link  org.springframework.test.context.ContextConfiguration @ContextConfiguration}，以便有效地将Spring配置加载并注入到测试类中。 
	 *  
	 * @param  applicationContext Spring上下文<@r​​eturn>链接的API，用于自定义服务器和客户端配置； 
	 * 使用{@link  MockServerSpec＃configureClient（）}过渡到客户端配置
	 */
	static MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {
		return new ApplicationContextSpec(applicationContext);
	}

	/**
	 * Integration testing with a "mock" server targeting the given WebHandler.
	 * @param webHandler the handler to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	/**
	 * 与针对给定WebHandler的"模拟"服务器进行集成测试。 
	 *  
	 * @param  webHandler处理程序，用于测试
	 * @return 链接的API，以自定义服务器和客户端配置； 
	 * 使用{@link  MockServerSpec＃configureClient（）}过渡到客户端配置
	 */
	static MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {
		return new DefaultMockServerSpec(webHandler);
	}

	/**
	 * This server setup option allows you to connect to a running server via
	 * Reactor Netty.
	 * <p><pre class="code">
	 * WebTestClient client = WebTestClient.bindToServer()
	 *         .baseUrl("http://localhost:8080")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 */
	/**
	 * 该服务器设置选项使您可以通过Reactor Netty连接到正在运行的服务器。 
	 *  <p> <pre class ="code"> WebTestClient客户端= WebTestClient.bindToServer（）.baseUrl（"http：// localhost：8080"）.build（）; </ pre> 
	 * @return 链接的API自定义客户端配置
	 */
	static Builder bindToServer() {
		return new DefaultWebTestClientBuilder();
	}

	/**
	 * A variant of {@link #bindToServer()} with a pre-configured connector.
	 * <p><pre class="code">
	 * WebTestClient client = WebTestClient.bindToServer()
	 *         .baseUrl("http://localhost:8080")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 * @since 5.0.2
	 */
	/**
	 * {@link  #bindToServer（）}的变体，带有预先配置的连接器。 
	 *  <p> <pre class ="code"> WebTestClient客户端= WebTestClient.bindToServer（）.baseUrl（"http：// localhost：8080"）.build（）; </ pre> 
	 * @return 链接的API自定义客户端配置（自5.0.2开始）
	 */
	static Builder bindToServer(ClientHttpConnector connector) {
		return new DefaultWebTestClientBuilder(connector);
	}


	/**
	 * Base specification for setting up tests without a server.
	 *
	 * @param <B> a self reference to the builder type
	 */
	/**
	 * 在没有服务器的情况下设置测试的基本规范。 
	 *  
	 * @param  <B>对构建器类型的自引用
	 */
	interface MockServerSpec<B extends MockServerSpec<B>> {

		/**
		 * Register {@link WebFilter} instances to add to the mock server.
		 * @param filter one or more filters
		 */
		/**
		 * 注册{@link  WebFilter}实例以添加到模拟服务器。 
		 *  
		 * @param 过滤一个或多个过滤器
		 */
		<T extends B> T webFilter(WebFilter... filter);

		/**
		 * Provide a session manager instance for the mock server.
		 * <p>By default an instance of
		 * {@link org.springframework.web.server.session.DefaultWebSessionManager
		 * DefaultWebSessionManager} is used.
		 * @param sessionManager the session manager to use
		 */
		/**
		 * 提供模拟服务器的会话管理器实例。 
		 *  <p>默认情况下，使用{@link  org.springframework.web.server.session.DefaultWebSessionManager DefaultWebSessionManager}的实例。 
		 *  
		 * @param  sessionManager会话管理器要使用
		 */
		<T extends B> T webSessionManager(WebSessionManager sessionManager);

		/**
		 * Shortcut for pre-packaged customizations to the mock server setup.
		 * @param configurer the configurer to apply
		 */
		/**
		 * 预打包的自定义模拟服务器设置的快捷方式。 
		 *  
		 * @param  configurer配置器要应用
		 */
		<T extends B> T apply(MockServerConfigurer configurer);

		/**
		 * Proceed to configure and build the test client.
		 */
		/**
		 * 继续配置和构建测试客户端。 
		 * 
		 */
		Builder configureClient();

		/**
		 * Shortcut to build the test client.
		 */
		/**
		 * 构建测试客户端的快捷方式。 
		 * 
		 */
		WebTestClient build();
	}


	/**
	 * Specification for customizing controller configuration equivalent to, and
	 * internally delegating to, a {@link WebFluxConfigurer}.
	 */
	/**
	 * 用于自定义控制器配置的规范，该规范等同于并在内部委托给{@link  WebFluxConfigurer}。 
	 * 
	 */
	interface ControllerSpec extends MockServerSpec<ControllerSpec> {

		/**
		 * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}
		 * instances to be used in tests (specified {@code Class} will be turned into instance).
		 */
		/**
		 * 注册一个或多个要在测试中使用的{@link  org.springframework.web.bind.annotation.ControllerAdvice}实例（指定的{@code  Class}将变为实例）。 
		 * 
		 */
		ControllerSpec controllerAdvice(Object... controllerAdvice);

		/**
		 * Customize content type resolution.
		 * @see WebFluxConfigurer#configureContentTypeResolver
		 */
		/**
		 * 自定义内容类型解析。 
		 *  
		 * @see  WebFluxConfigurer＃configureContentTypeResolver
		 */
		ControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer);

		/**
		 * Configure CORS support.
		 * @see WebFluxConfigurer#addCorsMappings
		 */
		/**
		 * 配置CORS支持。 
		 *  
		 * @see  WebFluxConfigurer＃addCorsMappings
		 */
		ControllerSpec corsMappings(Consumer<CorsRegistry> consumer);

		/**
		 * Configure path matching options.
		 * @see WebFluxConfigurer#configurePathMatching
		 */
		/**
		 * 配置路径匹配选项。 
		 *  
		 * @see  WebFluxConfigurer＃configurePathMatching
		 */
		ControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer);

		/**
		 * Configure resolvers for custom controller method arguments.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		/**
		 * 为自定义控制器方法参数配置解析器。 
		 *  
		 * @see  WebFluxConfigurer＃configureHttpMessageCodecs
		 */
		ControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer);

		/**
		 * Configure custom HTTP message readers and writers or override built-in ones.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		/**
		 * 配置自定义HTTP消息读取器和写入器，或覆盖内置的HTTP和消息读取器。 
		 *  
		 * @see  WebFluxConfigurer＃configureHttpMessageCodecs
		 */
		ControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer);

		/**
		 * Register formatters and converters to use for type conversion.
		 * @see WebFluxConfigurer#addFormatters
		 */
		/**
		 * 注册格式器和转换器以用于类型转换。 
		 *  
		 * @see  WebFluxConfigurer＃addFormatters
		 */
		ControllerSpec formatters(Consumer<FormatterRegistry> consumer);

		/**
		 * Configure a global Validator.
		 * @see WebFluxConfigurer#getValidator()
		 */
		/**
		 * 配置全局验证器。 
		 *  
		 * @see  WebFluxConfigurer＃getValidator（）
		 */
		ControllerSpec validator(Validator validator);

		/**
		 * Configure view resolution.
		 * @see WebFluxConfigurer#configureViewResolvers
		 */
		/**
		 * 配置视图分辨率。 
		 *  
		 * @see  WebFluxConfigurer＃configureViewResolvers
		 */
		ControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer);
	}


	/**
	 * Specification for customizing router function configuration.
	 */
	/**
	 * 定制路由器功能配置的规范。 
	 * 
	 */
	interface RouterFunctionSpec extends MockServerSpec<RouterFunctionSpec> {

		/**
		 * Configure handler strategies.
		 */
		/**
		 * 配置处理程序策略。 
		 * 
		 */
		RouterFunctionSpec handlerStrategies(HandlerStrategies handlerStrategies);
	}


	/**
	 * Steps for customizing the {@link WebClient} used to test with,
	 * internally delegating to a
	 * {@link org.springframework.web.reactive.function.client.WebClient.Builder
	 * WebClient.Builder}.
	 */
	/**
	 * 定制用于测试的{@link  WebClient}的步骤，内部委托给{@link  org.springframework.web.reactive.function.client.WebClient.Builder WebClient.Builder}。 
	 * 
	 */
	interface Builder {

		/**
		 * Configure a base URI as described in
		 * {@link org.springframework.web.reactive.function.client.WebClient#create(String)
		 * WebClient.create(String)}.
		 */
		/**
		 * 如{@link  org.springframework.web.reactive.function.client.WebClient＃create（String）WebClient.create（String）}中所述配置基本URI。 
		 * 
		 */
		Builder baseUrl(String baseUrl);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance as an
		 * alternative to and effectively overriding {@link #baseUrl(String)}.
		 */
		/**
		 * 提供预先配置的{@link  UriBuilderFactory}实例，以替代并有效地覆盖{@link  #baseUrl（String）}。 
		 * 
		 */
		Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Add the given header to all requests that haven't added it.
		 * @param headerName the header name
		 * @param headerValues the header values
		 */
		/**
		 * 将给定标头添加到所有未添加标头的请求中。 
		 *  
		 * @param  headerName标头名称
		 * @param  headerValues标头值
		 */
		Builder defaultHeader(String headerName, String... headerValues);

		/**
		 * Manipulate the default headers with the given consumer. The
		 * headers provided to the consumer are "live", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		/**
		 * 使用给定的使用者处理默认标题。 
		 * 提供给使用者的标头是"活动的"，因此使用者可以用来{@link 纯HttpHeaders＃set（String，String）覆盖}现有标头值{@link 纯HttpHeaders＃remove（Object ）删除}值，或使用其他任何{@link  HttpHeaders}方法。 
		 *  
		 * @param  headers消费一个使用{@code  HttpHeaders} 
		 * @return 此构建器的函数
		 */
		Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add the given header to all requests that haven't added it.
		 * @param cookieName the cookie name
		 * @param cookieValues the cookie values
		 */
		/**
		 * 将给定标头添加到所有未添加标头的请求中。 
		 *  
		 * @param  cookieName cookie名称
		 * @param  cookieValues cookie值
		 */
		Builder defaultCookie(String cookieName, String... cookieValues);

		/**
		 * Manipulate the default cookies with the given consumer. The
		 * map provided to the consumer is "live", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		/**
		 * 与给定的使用者一起操作默认cookie。 
		 * 提供给使用者的映射是"实时的"，因此使用者可以用来{@link  plain MultiValueMap＃set（Object，Object）覆盖}现有的标头值，{<@link> plain MultiValueMap＃remove（Object ）删除}值，或使用其他任何{@link  MultiValueMap}方法。 
		 *  
		 * @param  cookies消费一个使用Cookies映射的函数
		 * @return 此构建器
		 */
		Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Add the given filter to the filter chain.
		 * @param filter the filter to be added to the chain
		 */
		/**
		 * 将给定的过滤器添加到过滤器链。 
		 *  
		 * @param 过滤器要添加到链中的过滤器
		 */
		Builder filter(ExchangeFilterFunction filter);

		/**
		 * Manipulate the filters with the given consumer. The
		 * list provided to the consumer is "live", so that the consumer can be used to remove
		 * filters, change ordering, etc.
		 * @param filtersConsumer a function that consumes the filter list
		 * @return this builder
		 */
		/**
		 * 与给定的使用者一起操作过滤器。 
		 * 提供给使用者的列表是"活动的"，以便可以使用使用者删除过滤器，更改顺序等。 
		 * 
		 * @param  filtersConsumer使用此过滤器的函数，@
		 * @return>此构建器
		 */
		Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer);

		/**
		 * Configure the codecs for the {@code WebClient} in the
		 * {@link #exchangeStrategies(ExchangeStrategies) underlying}
		 * {@code ExchangeStrategies}.
		 * @param configurer the configurer to apply
		 * @since 5.1.13
		 */
		/**
		 * 在{@link  #exchangeStrategies（ExchangeStrategies）基础} {@code  ExchangeStrategies}中为{@code  WebClient}配置编解码器。 
		 *  
		 * @param 配置器配置器从5.1.13开始应用
		 */
		Builder codecs(Consumer<ClientCodecConfigurer> configurer);

		/**
		 * Configure the {@link ExchangeStrategies} to use.
		 * <p>For most cases, prefer using {@link #codecs(Consumer)} which allows
		 * customizing the codecs in the {@code ExchangeStrategies} rather than
		 * replace them. That ensures multiple parties can contribute to codecs
		 * configuration.
		 * <p>By default this is set to {@link ExchangeStrategies#withDefaults()}.
		 * @param strategies the strategies to use
		 */
		/**
		 * 配置{@link  ExchangeStrategies}以供使用。 
		 *  <p>在大多数情况下，更喜欢使用{@link  #codecs（Consumer）}，它允许在{@code  ExchangeStrategies}中自定义编解码器，而不是替换它们。 
		 * 这样可以确保多方可以为编解码器配置做出贡献。 
		 *  <p>默认情况下，它设置为{@link  ExchangeStrategies＃withDefaults（）}。 
		 *  
		 * @param 策略使用的策略
		 */
		Builder exchangeStrategies(ExchangeStrategies strategies);

		/**
		 * Customize the strategies configured via
		 * {@link #exchangeStrategies(ExchangeStrategies)}. This method is
		 * designed for use in scenarios where multiple parties wish to update
		 * the {@code ExchangeStrategies}.
		 * @deprecated as of 5.1.13 in favor of {@link #codecs(Consumer)}
		 */
		/**
		 * 自定义通过{@link  #exchangeStrategies（ExchangeStrategies）}配置的策略。 
		 * 此方法设计用于多方希望更新{@code  ExchangeStrategies}的方案。 
		 *  @自5.1.13起不推荐使用{@link  #codecs（Consumer）}
		 */
		@Deprecated
		Builder exchangeStrategies(Consumer<ExchangeStrategies.Builder> configurer);

		/**
		 * Max amount of time to wait for responses.
		 * <p>By default 5 seconds.
		 * @param timeout the response timeout value
		 */
		/**
		 * 等待响应的最长时间。 
		 *  <p>默认为5秒。 
		 *  
		 * @param 超时响应超时值
		 */
		Builder responseTimeout(Duration timeout);

		/**
		 * Apply the given configurer to this builder instance.
		 * <p>This can be useful for applying pre-packaged customizations.
		 * @param configurer the configurer to apply
		 */
		/**
		 * 将给定的配置器应用于此构建器实例。 
		 *  <p>这对于应用预打包的自定义项很有用。 
		 *  
		 * @param  configurer配置器要应用
		 */
		Builder apply(WebTestClientConfigurer configurer);

		/**
		 * Build the {@link WebTestClient} instance.
		 */
		/**
		 * 生成{@link  WebTestClient}实例。 
		 * 
		 */
		WebTestClient build();
	}


	/**
	 * Specification for providing the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 提供请求URI的规范。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link URI}.
		 * @return spec to add headers or perform the exchange
		 */
		/**
		 * 使用绝对的，完全构造的{@link  URI}指定URI。 
		 *  
		 * @return 规范以添加标题或执行交换
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * If a {@link UriBuilderFactory} was configured for the client (e.g.
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		/**
		 * 使用URI模板和URI变量指定请求的URI。 
		 * 如果为客户端配置了{@link  UriBuilderFactory}（例如，使用基本URI），它将用于扩展URI模板。 
		 *  
		 * @return 规范以添加标题或执行交换
		 */
		S uri(String uri, Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * If a {@link UriBuilderFactory} was configured for the client (e.g.
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		/**
		 * 使用URI模板和URI变量指定请求的URI。 
		 * 如果为客户端配置了{@link  UriBuilderFactory}（例如，使用基本URI），它将用于扩展URI模板。 
		 *  
		 * @return 规范以添加标题或执行交换
		 */
		S uri(String uri, Map<String, ?> uriVariables);

		/**
		 * Build the URI for the request with a {@link UriBuilder} obtained
		 * through the {@link UriBuilderFactory} configured for this client.
		 * @return spec to add headers or perform the exchange
		 */
		/**
		 * 使用通过为此客户端配置的{@link  UriBuilderFactory}获得的{@link  UriBuilder}构建请求的URI。 
		 *  
		 * @return 规范以添加标题或执行交换
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Specification for adding request headers and performing an exchange.
	 *
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 添加请求标头和执行交换的规范。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return the same instance
		 */
		/**
		 * 设置可接受的{@link  plain MediaType媒体类型}列表，如{@code  Accept}标头所指定。 
		 *  
		 * @param  acceptMediaMedias接受同一实例的媒体类型
		 * @return 
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return the same instance
		 */
		/**
		 * 按照{@code  Accept-Charset}标头指定的设置可接受的{@link  plain Charset字符集}的列表。 
		 *  
		 * @param  acceptableCharsets接受同一实例的字符集
		 * @return 
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return the same instance
		 */
		/**
		 * 添加具有给定名称和值的cookie。 
		 *  
		 * @param 命名cookie名称
		 * @param 值cookie值
		 * @return 相同的实例
		 */
		S cookie(String name, String value);

		/**
		 * Manipulate this request's cookies with the given consumer. The
		 * map provided to the consumer is "live", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		/**
		 * 与给定的使用者操作此请求的cookie。 
		 * 提供给使用者的映射是"实时的"，因此使用者可以用来{@link  plain MultiValueMap＃set（Object，Object）覆盖}现有的标头值，{<@link> plain MultiValueMap＃remove（Object ）删除}值，或使用其他任何{@link  MultiValueMap}方法。 
		 *  
		 * @param  cookies消费一个使用Cookies映射的函数
		 * @return 此构建器
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return the same instance
		 */
		/**
		 * 设置{@code  If-Modified-Since}标头的值。 
		 *  <p>日期应指定为格林尼治标准时间1970年1月1日以来的毫秒数。 
		 *  
		 * @param  ifModifiedSince头文件的新值
		 * @return 
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return the same instance
		 */
		/**
		 * 设置{@code  If-None-Match}标头的值。 
		 *  
		 * @param  ifNone与同一实例的标头
		 * @return 的新值匹配
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return the same instance
		 */
		/**
		 * 在给定名称下添加给定的单个标头值。 
		 *  
		 * @param  headerName标头名称
		 * @param  headerValues标头值
		 * @return 同一实例
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Manipulate the request's headers with the given consumer. The
		 * headers provided to the consumer are "live", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		/**
		 * 使用给定的使用者处理请求的标头。 
		 * 提供给使用者的标头是"活动的"，因此使用者可以用来{@link 纯HttpHeaders＃set（String，String）覆盖}现有标头值{@link 纯HttpHeaders＃remove（Object ）删除}值，或使用其他任何{@link  HttpHeaders}方法。 
		 *  
		 * @param  headers消费一个使用{@code  HttpHeaders} 
		 * @return 此构建器的函数
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this builder
		 */
		/**
		 * 将具有给定名称的属性设置为给定值。 
		 *  
		 * @param 名称要添加的属性的名称
		 * @param 值要添加的属性的值
		 * @return 此构建器
		 */
		S attribute(String name, Object value);

		/**
		 * Manipulate the request attributes with the given consumer. The attributes provided to
		 * the consumer are "live", so that the consumer can be used to inspect attributes,
		 * remove attributes, or use any of the other map-provided methods.
		 * @param attributesConsumer a function that consumes the attributes
		 * @return this builder
		 */
		/**
		 * 使用给定的使用者处理请求属性。 
		 * 提供给使用者的属性是"活动的"，因此可以使用使用者检查属性，删除属性或使用任何其他地图提供的方法。 
		 *  
		 * @param  attributes消费一个使用属性的函数
		 * @return 此构建器
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the exchange without a request body.
		 * @return spec for decoding the response
		 */
		/**
		 * 在没有请求主体的情况下执行交换。 
		 *  
		 * @return 规范，用于解码响应
		 */
		ResponseSpec exchange();
	}


	/**
	 * Specification for providing body of a request.
	 */
	/**
	 * 提供请求正文的规范。 
	 * 
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {
		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return the same instance
		 * @see HttpHeaders#setContentLength(long)
		 */
		/**
		 * 按照{@code  Content-Length}标头指定的内容，以字节为单位设置正文的长度。 
		 *  
		 * @param  contentLength内容长度
		 * @return 同一实例
		 * @see  HttpHeaders＃setContentLength（long）
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return the same instance
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		/**
		 * 设置主体的{@link  plain MediaType媒体类型}，如{@code  Content-Type}标头所指定。 
		 *  
		 * @param  contentType内容类型
		 * @return 相同实例
		 * @see  HttpHeaders＃setContentType（MediaType）
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Set the body to the given {@code Object} value. This method invokes the
		 * {@link WebClient.RequestBodySpec#bodyValue(Object) bodyValue} method
		 * on the underlying {@code WebClient}.
		 * @param body the value to write to the request body
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		/**
		 * 将主体设置为给定的{@code  Object}值。 
		 * 此方法在基础{@code  WebClient}上调用{@link  WebClient.RequestBodySpec＃bodyValue（Object）bodyValue}方法。 
		 *  
		 * @param 正文写入请求主体
		 * @return 规范的值，以进一步声明请求@5.2起
		 */
		RequestHeadersSpec<?> bodyValue(Object body);

		/**
		 * Set the body from the given {@code Publisher}. Shortcut for
		 * {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromPublisher Publisher inserter}.
		 * @param publisher the request body data
		 * @param elementClass the class of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return spec for further declaration of the request
		 */
		/**
		 * 从给定的{@code  Publisher}设置正文。 
		 *  {@link  #body（BodyInserter）}的快捷方式，带有{@link  plain BodyInserters＃fromPublisher Publisher插入程序}。 
		 *  
		 * @param 发布者请求正文数据
		 * @param  elementClass发布者中包含的元素类别
		 * @param  <T>发布者中包含的元素类型
		 * @param  <S> { @code  Publisher} 
		 * @return 规范以进一步声明请求
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(S publisher, Class<T> elementClass);

		/**
		 * Variant of {@link #body(Publisher, Class)} that allows providing
		 * element type information with generics.
		 * @param publisher the request body data
		 * @param elementTypeRef the type reference of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		/**
		 * {@link  #body（Publisher，Class）}的变体，它允许提供具有泛型的元素类型信息。 
		 *  
		 * @param 发布者请求正文数据
		 * @param  elementTypeRef发布者中包含的元素的类型引用
		 * @param  <T>发布者中包含的元素的类型
		 * @param  <S> {@code  Publisher} 
		 * @return 规范，用于自5.2开始的请求的进一步声明
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(
				S publisher, ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, Class)} method on the
		 * underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementClass the class of elements contained in the producer
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		/**
		 * 设置给定生产者的身体。 
		 * 此方法在基础{@code  WebClient}上调用{@link  WebClient.RequestBodySpec＃body（Object，Class）}方法。 
		 *  
		 * @param 生产者生产者写入请求。 
		 * 它必须是{@link  Publisher}或通过{@link  ReactiveAdapterRegistry}适应{@code  Publisher}的其他生产者
		 * @param  elementClass生产者
		 * @return 规范中包含的元素类从5.2开始，用于进一步声明请求
		 */
		RequestHeadersSpec<?> body(Object producer, Class<?> elementClass);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, ParameterizedTypeReference)}
		 * method on the underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementTypeRef the type reference of elements contained in the producer
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		/**
		 * 设置给定生产者的身体。 
		 * 此方法在基础{@code  WebClient}上调用{@link  WebClient.RequestBodySpec＃body（Object，ParameterizedTypeReference）}方法。 
		 *  
		 * @param 生产者生产者写入请求。 
		 * 它必须是{@link  Publisher}或通过{@link  ReactiveAdapterRegistry}适应{@code  Publisher}的其他生产者
		 * @param  elementTypeRef生产者
		 * @return 中包含的元素的类型引用自5.2起开始进一步声明请求的规范
		 */
		RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef);

		/**
		 * Set the body of the request to the given {@code BodyInserter}.
		 * This method invokes the
		 * {@link WebClient.RequestBodySpec#body(BodyInserter)} method on the
		 * underlying {@code WebClient}.
		 * @param inserter the body inserter to use
		 * @return spec for further declaration of the request
		 * @see org.springframework.web.reactive.function.BodyInserters
		 */
		/**
		 * 将请求的主体设置为给定的{@code  BodyInserter}。 
		 * 此方法在基础{@code  WebClient}上调用{@link  WebClient.RequestBodySpec＃body（BodyInserter）}方法。 
		 *  
		 * @param 插入程序主体插入程序，以使用
		 * @return 规范进一步声明请求
		 * @see  org.springframework.web.reactive.function.BodyInserters
		 */
		RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter);

		/**
		 * Shortcut for {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromValue value inserter}.
		 * As of 5.2 this method delegates to {@link #bodyValue(Object)}.
		 * @deprecated as of Spring Framework 5.2 in favor of {@link #bodyValue(Object)}
		 */
		/**
		 * {@link  #body（BodyInserter）}与{@link  plain BodyInserters＃fromValue值插入器}的快捷方式。 
		 * 从5.2开始，此方法委托给{@link  #bodyValue（Object）}。 
		 * 自Spring Framework 5.2起已弃用@，推荐使用{@link  #bodyValue（Object）}
		 */
		@Deprecated
		RequestHeadersSpec<?> syncBody(Object body);
	}


	/**
	 * Specification for providing request headers and the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	/**
	 * 提供请求标头和请求URI的规范。 
	 *  
	 * @param  <S>对规范类型的自引用
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {
	}

	/**
	 * Specification for providing the body and the URI of a request.
	 */
	/**
	 * 提供请求正文和URI的规范。 
	 * 
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


	/**
	 * Chained API for applying assertions to a response.
	 */
	/**
	 * 用于将断言应用于响应的链式API。 
	 * 
	 */
	interface ResponseSpec {

		/**
		 * Assertions on the response status.
		 */
		/**
		 * 关于响应状态的断言。 
		 * 
		 */
		StatusAssertions expectStatus();

		/**
		 * Assertions on the headers of the response.
		 */
		/**
		 * 在响应的标头上声明。 
		 * 
		 */
		HeaderAssertions expectHeader();

		/**
		 * Consume and decode the response body to a single object of type
		 * {@code <B>} and then apply assertions.
		 * @param bodyType the expected body type
		 */
		/**
		 * 使用响应主体并将其解码为{@code  <B>}类型的单个对象，然后应用断言。 
		 *  
		 * @param  bodyType期望的身体类型
		 */
		<B> BodySpec<B, ?> expectBody(Class<B> bodyType);

		/**
		 * Alternative to {@link #expectBody(Class)} that accepts information
		 * about a target type with generics.
		 */
		/**
		 * 替代{@link  #expectBody（Class）}的替代方法，该方法接受有关具有泛型的目标类型的信息。 
		 * 
		 */
		<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);

		/**
		 * Consume and decode the response body to {@code List<E>} and then apply
		 * List-specific assertions.
		 * @param elementType the expected List element type
		 */
		/**
		 * 使用响应主体并将其解码到{@code  List <E>}，然后应用特定于列表的断言。 
		 *  
		 * @param  elementType预期的List元素类型
		 */
		<E> ListBodySpec<E> expectBodyList(Class<E> elementType);

		/**
		 * Alternative to {@link #expectBodyList(Class)} that accepts information
		 * about a target type with generics.
		 */
		/**
		 * 替代{@link  #expectBodyList（Class）}的替代方法，该方法接受有关具有泛型的目标类型的信息。 
		 * 
		 */
		<E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType);

		/**
		 * Consume and decode the response body to {@code byte[]} and then apply
		 * assertions on the raw content (e.g. isEmpty, JSONPath, etc.)
		 */
		/**
		 * 使用响应主体并将其解码为{@code  byte []}，然后将声明应用于原始内容（例如isEmpty，JSONPath等）
		 */
		BodyContentSpec expectBody();

		/**
		 * Exit the chained API and consume the response body externally. This
		 * is useful for testing infinite streams (e.g. SSE) where you need to
		 * to assert decoded objects as they come and then cancel at some point
		 * when test objectives are met. Consider using {@code StepVerifier}
		 * from {@literal "reactor-test"} to assert the {@code Flux<T>} stream
		 * of decoded objects.
		 *
		 * <p><strong>Note:</strong> Do not use this option for cases where there
		 * is no content (e.g. 204, 4xx) or you're not interested in the content.
		 * For such cases you can use {@code expectBody().isEmpty()} or
		 * {@code expectBody(Void.class)} which ensures that resources are
		 * released regardless of whether the response has content or not.
		 */
		/**
		 * 退出链接的API并从外部使用响应主体。 
		 * 这对于测试无限流（例如SSE）很有用，在这种情况下，您需要在解码对象到达时声明它们，然后在达到测试目标时在某个时候取消。 
		 * 考虑使用{@literal"reactor-test"}中的{@code  StepVerifier}来声明{@code  Flux <T>}解码对象流。 
		 *  <p> <strong>注意</ strong>：在没有内容（例如204、4xx）或您对内容不感兴趣的情况下，请勿使用此选项。 
		 * 在这种情况下，您可以使用{@code  ExpectBody（）。 
		 * isEmpty（）}或{@code  ExpectBody（Void.class）}来确保释放资源，而不管响应是否包含内容。 
		 * 
		 */
		<T> FluxExchangeResult<T> returnResult(Class<T> elementClass);

		/**
		 * Alternative to {@link #returnResult(Class)} that accepts information
		 * about a target type with generics.
		 */
		/**
		 * 替代{@link  #returnResult（Class）}的替代方法，该方法接受有关具有泛型的目标类型的信息。 
		 * 
		 */
		<T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);
	}


	/**
	 * Spec for expectations on the response body decoded to a single Object.
	 *
	 * @param <S> a self reference to the spec type
	 * @param <B> the body type
	 */
	/**
	 * 规范，将对响应主体的期望解码为单个对象。 
	 *  
	 * @param  <S>对规范类型的自引用
	 * @param  <B>主体类型
	 */
	interface BodySpec<B, S extends BodySpec<B, S>> {

		/**
		 * Assert the extracted body is equal to the given value.
		 */
		/**
		 * 断言提取的主体等于给定值。 
		 * 
		 */
		<T extends S> T isEqualTo(B expected);

		/**
		 * Assert the extracted body with a {@link Matcher}.
		 * @since 5.1
		 */
		/**
		 * 使用{@link  Matcher}声明提取的正文。 
		 *  @5.1起
		 */
		<T extends S> T value(Matcher<B> matcher);

		/**
		 * Transform the extracted the body with a function, e.g. extracting a
		 * property, and assert the mapped value with a {@link Matcher}.
		 * @since 5.1
		 */
		/**
		 * 转换提取的身体与功能，例如提取属性，并使用{@link  Matcher}声明映射的值。 
		 *  @5.1起
		 */
		<T extends S, R> T value(Function<B, R> bodyMapper, Matcher<R> matcher);

		/**
		 * Assert the extracted body with a {@link Consumer}.
		 * @since 5.1
		 */
		/**
		 * 使用{@link  Consumer}声明提取的正文。 
		 *  @5.1起
		 */
		<T extends S> T value(Consumer<B> consumer);

		/**
		 * Assert the exchange result with the given {@link Consumer}.
		 */
		/**
		 * 与给定的{@link 消费者}声明交换结果。 
		 * 
		 */
		<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * decoded response content.
		 */
		/**
		 * 退出链接的API，并返回带有已解码响应内容的{@code  ExchangeResult}。 
		 * 
		 */
		EntityExchangeResult<B> returnResult();
	}


	/**
	 * Spec for expectations on the response body decoded to a List.
	 *
	 * @param <E> the body list element type
	 */
	/**
	 * 对响应主体的期望的规范已解码为列表。 
	 *  
	 * @param  <E>正文列表元素类型
	 */
	interface ListBodySpec<E> extends BodySpec<List<E>, ListBodySpec<E>> {

		/**
		 * Assert the extracted list of values is of the given size.
		 * @param size the expected size
		 */
		/**
		 * 断言所提取的值列表具有给定的大小。 
		 *  
		 * @param 大小预期大小
		 */
		ListBodySpec<E> hasSize(int size);

		/**
		 * Assert the extracted list of values contains the given elements.
		 * @param elements the elements to check
		 */
		/**
		 * 断言提取的值列表包含给定的元素。 
		 *  
		 * @param 元素要检查的元素
		 */
		@SuppressWarnings("unchecked")
		ListBodySpec<E> contains(E... elements);

		/**
		 * Assert the extracted list of values doesn't contain the given elements.
		 * @param elements the elements to check
		 */
		/**
		 * 断言所提取的值列表不包含给定的元素。 
		 *  
		 * @param 元素要检查的元素
		 */
		@SuppressWarnings("unchecked")
		ListBodySpec<E> doesNotContain(E... elements);
	}


	/**
	 * Spec for expectations on the response body content.
	 */
	/**
	 * 规范对响应正文内容的期望。 
	 * 
	 */
	interface BodyContentSpec {

		/**
		 * Assert the response body is empty and return the exchange result.
		 */
		/**
		 * 声明响应主体为空并返回交换结果。 
		 * 
		 */
		EntityExchangeResult<Void> isEmpty();

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * "lenient" comparison verifying the same attribute-value pairs.
		 * <p>Use of this option requires the
		 * <a href="https://jsonassert.skyscreamer.org/">JSONassert</a> library
		 * on to be on the classpath.
		 * @param expectedJson the expected JSON content.
		 */
		/**
		 * 将预期和实际响应内容解析为JSON，并执行"宽大"比较，以验证相同的属性值对。 
		 *  <p>使用此选项要求<a href="https://jsonassert.skyscreamer.org/"> JSONassert </a>库位于类路径上。 
		 *  
		 * @param  ExpectedJson期望的JSON内容。 
		 * 
		 */
		BodyContentSpec json(String expectedJson);

		/**
		 * Parse expected and actual response content as XML and assert that
		 * the two are "similar", i.e. they contain the same elements and
		 * attributes regardless of order.
		 * <p>Use of this method requires the
		 * <a href="https://github.com/xmlunit/xmlunit">XMLUnit</a> library on
		 * the classpath.
		 * @param expectedXml the expected JSON content.
		 * @since 5.1
		 * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)
		 */
		/**
		 * 将预期的和实际的响应内容解析为XML，并断言两者是"相似的"，即它们包含相同的元素和属性，而不管顺序如何。 
		 *  <p>使用此方法需要在类路径上使用<a href="https://github.com/xmlunit/xmlunit"> XMLUnit </a>库。 
		 *  
		 * @param  ExpectedXml期望的JSON内容。 
		 *  @since 5.1 
		 * @see  org.springframework.test.util.XmlExpectationsHelper＃assertXmlEqual（String，String）
		 */
		BodyContentSpec xml(String expectedXml);

		/**
		 * Access to response body assertions using a
		 * <a href="https://github.com/jayway/JsonPath">JsonPath</a> expression
		 * to inspect a specific subset of the body.
		 * <p>The JSON path expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the JsonPath expression
		 * @param args arguments to parameterize the expression
		 */
		/**
		 * 使用<a href="https://github.com/jayway/JsonPath"> JsonPath </a>表达式访问响应主体断言，以检查主体的特定子集。 
		 *  <p> JSON路径表达式可以是使用{@link  String＃format}中定义的格式说明符的参数化字符串。 
		 *  
		 * @param 表达式JsonPath表达式
		 * @param  args参数将表达式参数化
		 */
		JsonPathAssertions jsonPath(String expression, Object... args);

		/**
		 * Access to response body assertions using an XPath expression to
		 * inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 * @see #xpath(String, Map, Object...)
		 */
		/**
		 * 使用XPath表达式访问响应主体断言以检查主体的特定子集。 
		 *  <p>使用{@link  String＃format}中定义的格式说明符，XPath表达式可以是参数化的字符串。 
		 *  
		 * @param 表达式XPath表达式
		 * @param  args参数以参数化表达式@since 5.1 
		 * @see  #xpath（String，Map，Object ...）
		 */
		default XpathAssertions xpath(String expression, Object... args) {
			return xpath(expression, null, args);
		}

		/**
		 * Access to response body assertions with specific namespaces using an
		 * XPath expression to inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param namespaces namespaces to use
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 */
		/**
		 * 使用XPath表达式检查具有特定名称空间的响应主体断言，以检查主体的特定子集。 
		 *  <p>使用{@link  String＃format}中定义的格式说明符，XPath表达式可以是参数化的字符串。 
		 *  
		 * @param 表达式XPath表达式
		 * @param 命名空间命名空间使用
		 * @param  args参数对表达式进行参数化，自5.1起
		 */
		XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);

		/**
		 * Assert the response body content with the given {@link Consumer}.
		 * @param consumer the consumer for the response body; the input
		 * {@code byte[]} may be {@code null} if there was no response body.
		 */
		/**
		 * 使用给定的{@link 消费者}声明响应正文内容。 
		 *  
		 * @param 消费者消费者为响应主体； 
		 * 如果没有响应正文，则输入{@code  byte []}可以为{@code  null}。 
		 * 
		 */
		BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * raw response content.
		 */
		/**
		 * 退出链接的API，并返回带有原始响应内容的{@code  ExchangeResult}。 
		 * 
		 */
		EntityExchangeResult<byte[]> returnResult();
	}

}
