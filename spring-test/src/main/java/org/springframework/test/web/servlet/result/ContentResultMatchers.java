/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.web.servlet.result;

import java.nio.charset.StandardCharsets;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;

import org.hamcrest.Matcher;
import org.w3c.dom.Node;

import org.springframework.http.MediaType;
import org.springframework.test.util.JsonExpectationsHelper;
import org.springframework.test.util.XmlExpectationsHelper;
import org.springframework.test.web.servlet.ResultMatcher;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.springframework.test.util.AssertionErrors.assertEquals;
import static org.springframework.test.util.AssertionErrors.assertNotNull;
import static org.springframework.test.util.AssertionErrors.assertTrue;

/**
 * Factory for response content assertions.
 *
 * <p>An instance of this class is typically accessed via
 * {@link MockMvcResultMatchers#content}.
 *
 * @author Rossen Stoyanchev
 * @since 3.2
 */
/**
 * 响应内容断言的工厂。 
 *  <p>通常通过{@link  MockMvcResultMatchers＃content}访问此类的实例。 
 *  @author  Rossen Stoyanchev @从3.2开始
 */
public class ContentResultMatchers {

	private final XmlExpectationsHelper xmlHelper;

	private final JsonExpectationsHelper jsonHelper;


	/**
	 * Protected constructor.
	 * Use {@link MockMvcResultMatchers#content()}.
	 */
	/**
	 * 受保护的构造函数。 
	 * 使用{@link  MockMvcResultMatchers＃content（）}。 
	 * 
	 */
	protected ContentResultMatchers() {
		this.xmlHelper = new XmlExpectationsHelper();
		this.jsonHelper = new JsonExpectationsHelper();
	}


	/**
	 * Assert the ServletResponse content type. The given content type must
	 * fully match including type, sub-type, and parameters. For checking
	 * only the type and sub-type see {@link #contentTypeCompatibleWith(String)}.
	 */
	/**
	 * 声明ServletResponse内容类型。 
	 * 给定的内容类型必须完全匹配，包括类型，子类型和参数。 
	 * 要仅检查类型和子类型，请参见{@link  #contentTypeCompatibleWith（String）}。 
	 * 
	 */
	public ResultMatcher contentType(String contentType) {
		return contentType(MediaType.parseMediaType(contentType));
	}

	/**
	 * Assert the ServletResponse content type after parsing it as a MediaType.
	 * The given content type must fully match including type, sub-type, and
	 * parameters. For checking only the type and sub-type see
	 * {@link #contentTypeCompatibleWith(MediaType)}.
	 */
	/**
	 * 在将其解析为MediaType之后，声明ServletResponse内容类型。 
	 * 给定的内容类型必须完全匹配，包括类型，子类型和参数。 
	 * 要仅检查类型和子类型，请参见{@link  #contentTypeCompatibleWith（MediaType）}。 
	 * 
	 */
	public ResultMatcher contentType(MediaType contentType) {
		return result -> {
			String actual = result.getResponse().getContentType();
			assertNotNull("Content type not set", actual);
			assertEquals("Content type", contentType, MediaType.parseMediaType(actual));
		};
	}

	/**
	 * Assert the ServletResponse content type is compatible with the given
	 * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.
	 */
	/**
	 * 断言ServletResponse内容类型与{@link  MediaType＃isCompatibleWith（MediaType）}定义的给定内容类型兼容。 
	 * 
	 */
	public ResultMatcher contentTypeCompatibleWith(String contentType) {
		return contentTypeCompatibleWith(MediaType.parseMediaType(contentType));
	}

	/**
	 * Assert the ServletResponse content type is compatible with the given
	 * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.
	 */
	/**
	 * 断言ServletResponse内容类型与{@link  MediaType＃isCompatibleWith（MediaType）}定义的给定内容类型兼容。 
	 * 
	 */
	public ResultMatcher contentTypeCompatibleWith(MediaType contentType) {
		return result -> {
			String actual = result.getResponse().getContentType();
			assertNotNull("Content type not set", actual);
			MediaType actualContentType = MediaType.parseMediaType(actual);
			assertTrue("Content type [" + actual + "] is not compatible with [" + contentType + "]",
					actualContentType.isCompatibleWith(contentType));
		};
	}

	/**
	 * Assert the character encoding in the ServletResponse.
	 * @see HttpServletResponse#getCharacterEncoding()
	 */
	/**
	 * 在ServletResponse中声明字符编码。 
	 *  
	 * @see  HttpServletResponse＃getCharacterEncoding（）
	 */
	public ResultMatcher encoding(String characterEncoding) {
		return result -> {
			String actual = result.getResponse().getCharacterEncoding();
			assertEquals("Character encoding", characterEncoding, actual);
		};
	}

	/**
	 * Assert the response body content with a Hamcrest {@link Matcher}.
	 * <pre class="code">
	 * mockMvc.perform(get("/path"))
	 *   .andExpect(content().string(containsString("text")));
	 * </pre>
	 */
	/**
	 * 使用Hamcrest {@link  Matcher}声明响应正文内容。 
	 *  <pre class ="code"> mockMvc.perform（get（"/ path"））.andExpect（content（）。 
	 * string（containsString（"text"））））; </ pre>
	 */
	public ResultMatcher string(Matcher<? super String> matcher) {
		return result -> assertThat("Response content", result.getResponse().getContentAsString(), matcher);
	}

	/**
	 * Assert the response body content as a String.
	 */
	/**
	 * 将响应主体内容声明为字符串。 
	 * 
	 */
	public ResultMatcher string(String expectedContent) {
		return result -> assertEquals("Response content", expectedContent, result.getResponse().getContentAsString());
	}

	/**
	 * Assert the response body content as a byte array.
	 */
	/**
	 * 将响应正文内容声明为字节数组。 
	 * 
	 */
	public ResultMatcher bytes(byte[] expectedContent) {
		return result -> assertEquals("Response content", expectedContent, result.getResponse().getContentAsByteArray());
	}

	/**
	 * Parse the response content and the given string as XML and assert the two
	 * are "similar" - i.e. they contain the same elements and attributes
	 * regardless of order.
	 * <p>Use of this matcher requires the <a
	 * href="http://xmlunit.sourceforge.net/">XMLUnit</a> library.
	 * @param xmlContent the expected XML content
	 * @see MockMvcResultMatchers#xpath(String, Object...)
	 * @see MockMvcResultMatchers#xpath(String, Map, Object...)
	 */
	/**
	 * 将响应内容和给定的字符串解析为XML，并断言两者是"相似的"-即它们包含相同的元素和属性，而不管顺序如何。 
	 *  <p>使用此匹配器需要<a href="http://xmlunit.sourceforge.net/"> XMLUnit </a>库。 
	 *  
	 * @param  xmlContent预期的XML内容
	 * @see  MockMvcResultMatchers＃xpath（String，Object ...）
	 * @see  MockMvcResultMatchers＃xpath（String，Map，Object ...）
	 */
	public ResultMatcher xml(String xmlContent) {
		return result -> {
			String content = result.getResponse().getContentAsString();
			this.xmlHelper.assertXmlEqual(xmlContent, content);
		};
	}

	/**
	 * Parse the response content as {@link Node} and apply the given Hamcrest
	 * {@link Matcher}.
	 */
	/**
	 * 将响应内容解析为{@link  Node}并应用给定的Hamcrest {@link  Matcher}。 
	 * 
	 */
	public ResultMatcher node(Matcher<? super Node> matcher) {
		return result -> {
			String content = result.getResponse().getContentAsString();
			this.xmlHelper.assertNode(content, matcher);
		};
	}

	/**
	 * Parse the response content as {@link DOMSource} and apply the given
	 * Hamcrest {@link Matcher}.
	 * @see <a href="https://code.google.com/p/xml-matchers/">xml-matchers</a>
	 */
	/**
	 * 将响应内容解析为{@link  DOMSource}并应用给定的Hamcrest {@link  Matcher}。 
	 *  
	 * @see  <a href="https://code.google.com/p/xml-matchers/"> xml-matchers </a>
	 */
	public ResultMatcher source(Matcher<? super Source> matcher) {
		return result -> {
			String content = result.getResponse().getContentAsString();
			this.xmlHelper.assertSource(content, matcher);
		};
	}

	/**
	 * Parse the expected and actual strings as JSON and assert the two
	 * are "similar" - i.e. they contain the same attribute-value pairs
	 * regardless of formatting with a lenient checking (extensible, and non-strict array
	 * ordering).
	 * @param jsonContent the expected JSON content
	 * @since 4.1
	 */
	/**
	 * 将期望的字符串和实际的字符串解析为JSON，并断言这两个字符串是"相似的"-即它们包含相同的属性值对，而不管采用宽松的检查格式（可扩展且非严格的数组排序）。 
	 *  
	 * @param  jsonContent自4.1开始的预期JSON内容
	 */
	public ResultMatcher json(String jsonContent) {
		return json(jsonContent, false);
	}

	/**
	 * Parse the response content and the given string as JSON and assert the two are "similar" -
	 * i.e. they contain the same attribute-value pairs regardless of formatting.
	 * <p>Can compare in two modes, depending on {@code strict} parameter value:
	 * <ul>
	 * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>
	 * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>
	 * </ul>
	 * <p>Use of this matcher requires the <a
	 * href="https://jsonassert.skyscreamer.org/">JSONassert</a> library.
	 * @param jsonContent the expected JSON content
	 * @param strict enables strict checking
	 * @since 4.2
	 */
	/**
	 * 将响应内容和给定的字符串解析为JSON，并断言两者是"相似的"-即，无论格式如何，它们都包含相同的属性值对。 
	 *  <p>可以根据{@code  strict}参数值在两种模式下进行比较：<ul> <li> {<@code> true}：严格检查。 
	 * 不可扩展，且数组排序严格。 
	 * </ li> <li> {<@code> false}：宽松的检查。 
	 * 可扩展的非严格数组排序。 
	 * </ li> </ ul> <p>使用此匹配器需要<a href="https://jsonassert.skyscreamer.org/"> JSONassert </a>库。 
	 *  
	 * @param  jsonContent预期的JSON内容
	 * @param  strict启用严格检查，自4.2起
	 */
	public ResultMatcher json(String jsonContent, boolean strict) {
		return result -> {
			String content = result.getResponse().getContentAsString(StandardCharsets.UTF_8);
			this.jsonHelper.assertJsonEqual(jsonContent, content, strict);
		};
	}

}
