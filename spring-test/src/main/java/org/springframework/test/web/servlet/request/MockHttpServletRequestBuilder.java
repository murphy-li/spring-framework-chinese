/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.web.servlet.request;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletRequest;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpSession;

import org.springframework.beans.Mergeable;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.converter.FormHttpMessageConverter;
import org.springframework.lang.Nullable;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.util.Assert;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.FlashMap;
import org.springframework.web.servlet.FlashMapManager;
import org.springframework.web.servlet.support.SessionFlashMapManager;
import org.springframework.web.util.UriComponentsBuilder;
import org.springframework.web.util.UriUtils;
import org.springframework.web.util.UrlPathHelper;

/**
 * Default builder for {@link MockHttpServletRequest} required as input to
 * perform requests in {@link MockMvc}.
 *
 * <p>Application tests will typically access this builder through the static
 * factory methods in {@link MockMvcRequestBuilders}.
 *
 * <p>This class is not open for extension. To apply custom initialization to
 * the created {@code MockHttpServletRequest}, please use the
 * {@link #with(RequestPostProcessor)} extension point.
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @author Sam Brannen
 * @author Kamill Sokol
 * @since 3.2
 */
/**
 * 需要输入{@link  MockHttpServletRequest}的默认生成器作为在{@link  MockMvc}中执行请求的输入。 
 *  <p>应用程序测试通常将通过{@link  MockMvcRequestBuilders}中的静态工厂方法访问此构建器。 
 *  <p>该课程未开放扩展。 
 * 要将自定义初始化应用于创建的{@code  MockHttpServletRequest}，请使用{@link  #with（RequestPostProcessor）}扩展点。 
 *  @author  Rossen Stoyanchev @author  Juergen Hoeller @author  Arjen Poutsma @author  Sam Brannen @author 凯米尔·索科尔（Kamill Sokol）自3.2起
 */
public class MockHttpServletRequestBuilder
		implements ConfigurableSmartRequestBuilder<MockHttpServletRequestBuilder>, Mergeable {

	private static final UrlPathHelper urlPathHelper = new UrlPathHelper();


	private final String method;

	private final URI url;

	private String contextPath = "";

	private String servletPath = "";

	@Nullable
	private String pathInfo = "";

	@Nullable
	private Boolean secure;

	@Nullable
	private Principal principal;

	@Nullable
	private MockHttpSession session;

	@Nullable
	private String characterEncoding;

	@Nullable
	private byte[] content;

	@Nullable
	private String contentType;

	private final MultiValueMap<String, Object> headers = new LinkedMultiValueMap<>();

	private final MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();

	private final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<>();

	private final List<Cookie> cookies = new ArrayList<>();

	private final List<Locale> locales = new ArrayList<>();

	private final Map<String, Object> requestAttributes = new LinkedHashMap<>();

	private final Map<String, Object> sessionAttributes = new LinkedHashMap<>();

	private final Map<String, Object> flashAttributes = new LinkedHashMap<>();

	private final List<RequestPostProcessor> postProcessors = new ArrayList<>();


	/**
	 * Package private constructor. To get an instance, use static factory
	 * methods in {@link MockMvcRequestBuilders}.
	 * <p>Although this class cannot be extended, additional ways to initialize
	 * the {@code MockHttpServletRequest} can be plugged in via
	 * {@link #with(RequestPostProcessor)}.
	 * @param httpMethod the HTTP method (GET, POST, etc)
	 * @param url a URL template; the resulting URL will be encoded
	 * @param vars zero or more URI variables
	 */
	/**
	 * 包私有构造函数。 
	 * 要获取实例，请在{@link  MockMvcRequestBuilders}中使用静态工厂方法。 
	 *  <p>尽管不能扩展此类，但可以通过{@link  #with（RequestPostProcessor）}插入初始化{@code  MockHttpServletRequest}的其他方法。 
	 *  
	 * @param  httpMethod HTTP方法（GET，POST等）
	 * @param  url URL模板； 
	 * 结果网址将被编码为
	 * @param  vars零个或多个URI变量
	 */
	MockHttpServletRequestBuilder(HttpMethod httpMethod, String url, Object... vars) {
		this(httpMethod.name(), initUri(url, vars));
	}

	private static URI initUri(String url, Object[] vars) {
		Assert.notNull(url, "'url' must not be null");
		Assert.isTrue(url.startsWith("/") || url.startsWith("http://") || url.startsWith("https://"), "" +
				"'url' should start with a path or be a complete HTTP URL: " + url);
		return UriComponentsBuilder.fromUriString(url).buildAndExpand(vars).encode().toUri();
	}

	/**
	 * Alternative to {@link #MockHttpServletRequestBuilder(HttpMethod, String, Object...)}
	 * with a pre-built URI.
	 * @param httpMethod the HTTP method (GET, POST, etc)
	 * @param url the URL
	 * @since 4.0.3
	 */
	/**
	 * 带有预构建URI的{@link  #MockHttpServletRequestBuilder（HttpMethod，String，Object ...）}的替代方法。 
	 *  
	 * @param  httpMethod HTTP方法（GET，POST等）
	 * @param  url URL @since 4.0.3起
	 */
	MockHttpServletRequestBuilder(HttpMethod httpMethod, URI url) {
		this(httpMethod.name(), url);
	}

	/**
	 * Alternative constructor for custom HTTP methods.
	 * @param httpMethod the HTTP method (GET, POST, etc)
	 * @param url the URL
	 * @since 4.3
	 */
	/**
	 * 自定义HTTP方法的备用构造函数。 
	 *  
	 * @param  httpMethod HTTP方法（GET，POST等）
	 * @param  URL URL @since 4.3
	 */
	MockHttpServletRequestBuilder(String httpMethod, URI url) {
		Assert.notNull(httpMethod, "'httpMethod' is required");
		Assert.notNull(url, "'url' is required");
		this.method = httpMethod;
		this.url = url;
	}


	/**
	 * Specify the portion of the requestURI that represents the context path.
	 * The context path, if specified, must match to the start of the request URI.
	 * <p>In most cases, tests can be written by omitting the context path from
	 * the requestURI. This is because most applications don't actually depend
	 * on the name under which they're deployed. If specified here, the context
	 * path must start with a "/" and must not end with a "/".
	 * @see javax.servlet.http.HttpServletRequest#getContextPath()
	 */
	/**
	 * 指定requestURI的代表上下文路径的部分。 
	 * 上下文路径（如果指定）必须与请求URI的开头匹配。 
	 *  <p>在大多数情况下，可以通过从requestURI中省略上下文路径来编写测试。 
	 * 这是因为大多数应用程序实际上并不依赖于其部署名称。 
	 * 如果在此处指定，则上下文路径必须以"/"开头，并且不能以"/"结尾。 
	 *  
	 * @see  javax.servlet.http.HttpServletRequest＃getContextPath（）
	 */
	public MockHttpServletRequestBuilder contextPath(String contextPath) {
		if (StringUtils.hasText(contextPath)) {
			Assert.isTrue(contextPath.startsWith("/"), "Context path must start with a '/'");
			Assert.isTrue(!contextPath.endsWith("/"), "Context path must not end with a '/'");
		}
		this.contextPath = contextPath;
		return this;
	}

	/**
	 * Specify the portion of the requestURI that represents the path to which
	 * the Servlet is mapped. This is typically a portion of the requestURI
	 * after the context path.
	 * <p>In most cases, tests can be written by omitting the servlet path from
	 * the requestURI. This is because most applications don't actually depend
	 * on the prefix to which a servlet is mapped. For example if a Servlet is
	 * mapped to {@code "/main/*"}, tests can be written with the requestURI
	 * {@code "/accounts/1"} as opposed to {@code "/main/accounts/1"}.
	 * If specified here, the servletPath must start with a "/" and must not
	 * end with a "/".
	 * @see javax.servlet.http.HttpServletRequest#getServletPath()
	 */
	/**
	 * 指定requestURI的一部分，该部分代表Servlet映射到的路径。 
	 * 这通常是上下文路径后面的requestURI的一部分。 
	 *  <p>在大多数情况下，可以通过从requestURI中省略servlet路径来编写测试。 
	 * 这是因为大多数应用程序实际上并不依赖于servlet映射到的前缀。 
	 * 例如，如果将Servlet映射到{@code "/ main"}，则可以使用requestURI {@code "/ accounts / 1"}而不是{@code "/ main /帐户/ 1"}。 
	 * 如果在此处指定，则ServletPath必须以"/"开头，并且不能以"/"结尾。 
	 *  
	 * @see  javax.servlet.http.HttpServletRequest＃getServletPath（）
	 */
	public MockHttpServletRequestBuilder servletPath(String servletPath) {
		if (StringUtils.hasText(servletPath)) {
			Assert.isTrue(servletPath.startsWith("/"), "Servlet path must start with a '/'");
			Assert.isTrue(!servletPath.endsWith("/"), "Servlet path must not end with a '/'");
		}
		this.servletPath = servletPath;
		return this;
	}

	/**
	 * Specify the portion of the requestURI that represents the pathInfo.
	 * <p>If left unspecified (recommended), the pathInfo will be automatically derived
	 * by removing the contextPath and the servletPath from the requestURI and using any
	 * remaining part. If specified here, the pathInfo must start with a "/".
	 * <p>If specified, the pathInfo will be used as-is.
	 * @see javax.servlet.http.HttpServletRequest#getPathInfo()
	 */
	/**
	 * 指定requestURI中代表pathInfo的部分。 
	 *  <p>如果未指定（推荐），则将通过从requestURI中删除contextPath和servletPath并使用任何其余部分来自动派生pathInfo。 
	 * 如果在此处指定，则pathInfo必须以"/"开头。 
	 *  <p>如果指定，pathInfo将按原样使用。 
	 *  
	 * @see  javax.servlet.http.HttpServletRequest＃getPathInfo（）
	 */
	public MockHttpServletRequestBuilder pathInfo(@Nullable String pathInfo) {
		if (StringUtils.hasText(pathInfo)) {
			Assert.isTrue(pathInfo.startsWith("/"), "Path info must start with a '/'");
		}
		this.pathInfo = pathInfo;
		return this;
	}

	/**
	 * Set the secure property of the {@link ServletRequest} indicating use of a
	 * secure channel, such as HTTPS.
	 * @param secure whether the request is using a secure channel
	 */
	/**
	 * 设置{@link  ServletRequest}的安全属性，指示使用安全通道，例如HTTPS。 
	 *  
	 * @param 确保请求是否使用安全通道
	 */
	public MockHttpServletRequestBuilder secure(boolean secure){
		this.secure = secure;
		return this;
	}

	/**
	 * Set the character encoding of the request.
	 * @param encoding the character encoding
	 */
	/**
	 * 设置请求的字符编码。 
	 *  
	 * @param 编码字符编码
	 */
	public MockHttpServletRequestBuilder characterEncoding(String encoding) {
		this.characterEncoding = encoding;
		return this;
	}

	/**
	 * Set the request body.
	 * <p>If content is provided and {@link #contentType(MediaType)} is set to
	 * {@code application/x-www-form-urlencoded}, the content will be parsed
	 * and used to populate the {@link #param(String, String...) request
	 * parameters} map.
	 * @param content the body content
	 */
	/**
	 * 设置请求正文。 
	 *  <p>如果提供了内容并将{@link  #contentType（MediaType）}设置为{@code  application / x-www-form-urlencoded}，则内容将被解析并用于填充{@link  #param（String，String ...）请求参数}映射。 
	 *  
	 * @param 满足正文内容
	 */
	public MockHttpServletRequestBuilder content(byte[] content) {
		this.content = content;
		return this;
	}

	/**
	 * Set the request body as a UTF-8 String.
	 * <p>If content is provided and {@link #contentType(MediaType)} is set to
	 * {@code application/x-www-form-urlencoded}, the content will be parsed
	 * and used to populate the {@link #param(String, String...) request
	 * parameters} map.
	 * @param content the body content
	 */
	/**
	 * 将请求主体设置为UTF-8字符串。 
	 *  <p>如果提供了内容并将{@link  #contentType（MediaType）}设置为{@code  application / x-www-form-urlencoded}，则内容将被解析并用于填充{@link  #param（String，String ...）请求参数}映射。 
	 *  
	 * @param 满足正文内容
	 */
	public MockHttpServletRequestBuilder content(String content) {
		this.content = content.getBytes(StandardCharsets.UTF_8);
		return this;
	}

	/**
	 * Set the 'Content-Type' header of the request.
	 * <p>If content is provided and {@code contentType} is set to
	 * {@code application/x-www-form-urlencoded}, the content will be parsed
	 * and used to populate the {@link #param(String, String...) request
	 * parameters} map.
	 * @param contentType the content type
	 */
	/**
	 * 设置请求的"Content-Type"标头。 
	 *  <p>如果提供了内容，并且{@code  contentType}设置为{@code  application / x-www-form-urlencoded}，则内容将被解析并用于填充{@link ＃ param（String，String ...）请求参数}映射。 
	 *  
	 * @param  contentType内容类型
	 */
	public MockHttpServletRequestBuilder contentType(MediaType contentType) {
		Assert.notNull(contentType, "'contentType' must not be null");
		this.contentType = contentType.toString();
		return this;
	}

	/**
	 * Set the 'Content-Type' header of the request as a raw String value,
	 * possibly not even well formed (for testing purposes).
	 * @param contentType the content type
	 * @since 4.1.2
	 */
	/**
	 * 将请求的"Content-Type"标头设置为原始String值，可能甚至格式不正确（出于测试目的）。 
	 *  
	 * @param  contentType自4.1.2起的内容类型
	 */
	public MockHttpServletRequestBuilder contentType(String contentType) {
		Assert.notNull(contentType, "'contentType' must not be null");
		this.contentType = contentType;
		return this;
	}

	/**
	 * Set the 'Accept' header to the given media type(s).
	 * @param mediaTypes one or more media types
	 */
	/**
	 * 将"接受"标头设置为给定的媒体类型。 
	 *  
	 * @param  mediaTypes一种或多种媒体类型
	 */
	public MockHttpServletRequestBuilder accept(MediaType... mediaTypes) {
		Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty");
		this.headers.set("Accept", MediaType.toString(Arrays.asList(mediaTypes)));
		return this;
	}

	/**
	 * Set the 'Accept' header using raw String values, possibly not even well
	 * formed (for testing purposes).
	 * @param mediaTypes one or more media types; internally joined as
	 * comma-separated String
	 */
	/**
	 * 使用原始String值设置"Accept"标头，可能甚至格式不正确（出于测试目的）。 
	 *  
	 * @param  mediaTypes一种或多种媒体类型； 
	 * 内部连接为逗号分隔的字符串
	 */
	public MockHttpServletRequestBuilder accept(String... mediaTypes) {
		Assert.notEmpty(mediaTypes, "'mediaTypes' must not be empty");
		this.headers.set("Accept", String.join(", ", mediaTypes));
		return this;
	}

	/**
	 * Add a header to the request. Values are always added.
	 * @param name the header name
	 * @param values one or more header values
	 */
	/**
	 * 向请求添加标头。 
	 * 总是添加值。 
	 *  
	 * @param 命名标头名称
	 * @param 值一个或多个标头值
	 */
	public MockHttpServletRequestBuilder header(String name, Object... values) {
		addToMultiValueMap(this.headers, name, values);
		return this;
	}

	/**
	 * Add all headers to the request. Values are always added.
	 * @param httpHeaders the headers and values to add
	 */
	/**
	 * 将所有标头添加到请求。 
	 * 总是添加值。 
	 *  
	 * @param  httpHeaders要添加的标题和值
	 */
	public MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders) {
		httpHeaders.forEach(this.headers::addAll);
		return this;
	}

	/**
	 * Add a request parameter to {@link MockHttpServletRequest#getParameterMap()}.
	 * <p>In the Servlet API, a request parameter may be parsed from the query
	 * string and/or from the body of an {@code application/x-www-form-urlencoded}
	 * request. This method simply adds to the request parameter map. You may
	 * also use add Servlet request parameters by specifying the query or form
	 * data through one of the following:
	 * <ul>
	 * <li>Supply a URL with a query to {@link MockMvcRequestBuilders}.
	 * <li>Add query params via {@link #queryParam} or {@link #queryParams}.
	 * <li>Provide {@link #content} with {@link #contentType}
	 * {@code application/x-www-form-urlencoded}.
	 * </ul>
	 * @param name the parameter name
	 * @param values one or more values
	 */
	/**
	 * 将请求参数添加到{@link  MockHttpServletRequest＃getParameterMap（）}。 
	 *  <p>在Servlet API中，可以从查询字符串和/或{@code  application / x-www-form-urlencoded}请求的正文中解析请求参数。 
	 * 此方法只是添加到请求参数映射中。 
	 * 您还可以通过以下方式之一指定查询或表单数据来使用添加Servlet请求参数：<ul> <li>为查询提供URL到{@link  MockMvcRequestBuilders}。 
	 *  <li>通过{@link  #queryParam}或{@link  #queryParams}添加查询参数。 
	 *  <li>使用{@link  #contentType} {@code  application / x-www-form-urlencoded}提供{@link  #content}。 
	 *  </ ul> 
	 * @param 命名参数名称
	 * @param 值一个或多个值
	 */
	public MockHttpServletRequestBuilder param(String name, String... values) {
		addToMultiValueMap(this.parameters, name, values);
		return this;
	}

	/**
	 * Variant of {@link #param(String, String...)} with a {@link MultiValueMap}.
	 * @param params the parameters to add
	 * @since 4.2.4
	 */
	/**
	 * {@link  #param（String，String ...）}与{@link  MultiValueMap}的变体。 
	 *  
	 * @param 设置参数以添加@since 4.2.4起
	 */
	public MockHttpServletRequestBuilder params(MultiValueMap<String, String> params) {
		params.forEach((name, values) -> {
			for (String value : values) {
				this.parameters.add(name, value);
			}
		});
		return this;
	}

	/**
	 * Append to the query string and also add to the
	 * {@link #param(String, String...) request parameters} map. The parameter
	 * name and value are encoded when they are added to the query string.
	 * @param name the parameter name
	 * @param values one or more values
	 * @since 5.2.2
	 */
	/**
	 * 附加到查询字符串，还添加到{@link  #param（String，String ...）请求参数}映射。 
	 * 参数名称和值在添加到查询字符串时会进行编码。 
	 *  
	 * @param 命名参数名称
	 * @param 值一个或多个值@5.2.2起
	 */
	public MockHttpServletRequestBuilder queryParam(String name, String... values) {
		param(name, values);
		this.queryParams.addAll(name, Arrays.asList(values));
		return this;
	}

	/**
	 * Append to the query string and also add to the
	 * {@link #params(MultiValueMap)}  request parameters} map. The parameter
	 * name and value are encoded when they are added to the query string.
	 * @param params the parameters to add
	 * @since 5.2.2
	 */
	/**
	 * 附加到查询字符串，还添加到{@link  #params（MultiValueMap）}请求参数}映射。 
	 * 参数名称和值在添加到查询字符串时会进行编码。 
	 *  
	 * @param 设置参数以添加@since 5.2.2起
	 */
	public MockHttpServletRequestBuilder queryParams(MultiValueMap<String, String> params) {
		params(params);
		this.queryParams.addAll(params);
		return this;
	}

	/**
	 * Add the given cookies to the request. Cookies are always added.
	 * @param cookies the cookies to add
	 */
	/**
	 * 将给定的cookie添加到请求中。 
	 *  Cookies总是被添加。 
	 *  
	 * @param  cookie要添加的cookie
	 */
	public MockHttpServletRequestBuilder cookie(Cookie... cookies) {
		Assert.notEmpty(cookies, "'cookies' must not be empty");
		this.cookies.addAll(Arrays.asList(cookies));
		return this;
	}

	/**
	 * Add the specified locales as preferred request locales.
	 * @param locales the locales to add
	 * @since 4.3.6
	 * @see #locale(Locale)
	 */
	/**
	 * 将指定的语言环境添加为首选请求语言环境。 
	 *  
	 * @param 语言环境添加@@since 4.3.6起的语言环境
	 * @see  #locale（Locale）
	 */
	public MockHttpServletRequestBuilder locale(Locale... locales) {
		Assert.notEmpty(locales, "'locales' must not be empty");
		this.locales.addAll(Arrays.asList(locales));
		return this;
	}

	/**
	 * Set the locale of the request, overriding any previous locales.
	 * @param locale the locale, or {@code null} to reset it
	 * @see #locale(Locale...)
	 */
	/**
	 * 设置请求的语言环境，覆盖以前的所有语言环境。 
	 *  
	 * @param 语言环境的语言环境，或{@code  null}对其进行重置
	 * @see  #locale（Locale ...）
	 */
	public MockHttpServletRequestBuilder locale(@Nullable Locale locale) {
		this.locales.clear();
		if (locale != null) {
			this.locales.add(locale);
		}
		return this;
	}

	/**
	 * Set a request attribute.
	 * @param name the attribute name
	 * @param value the attribute value
	 */
	/**
	 * 设置请求属性。 
	 *  
	 * @param 命名属性名称
	 * @param 值属性值
	 */
	public MockHttpServletRequestBuilder requestAttr(String name, Object value) {
		addToMap(this.requestAttributes, name, value);
		return this;
	}

	/**
	 * Set a session attribute.
	 * @param name the session attribute name
	 * @param value the session attribute value
	 */
	/**
	 * 设置会话属性。 
	 *  
	 * @param 命名会话属性名称
	 * @param 值会话属性值
	 */
	public MockHttpServletRequestBuilder sessionAttr(String name, Object value) {
		addToMap(this.sessionAttributes, name, value);
		return this;
	}

	/**
	 * Set session attributes.
	 * @param sessionAttributes the session attributes
	 */
	/**
	 * 设置会话属性。 
	 *  
	 * @param  sessionAttributes会话属性
	 */
	public MockHttpServletRequestBuilder sessionAttrs(Map<String, Object> sessionAttributes) {
		Assert.notEmpty(sessionAttributes, "'sessionAttributes' must not be empty");
		sessionAttributes.forEach(this::sessionAttr);
		return this;
	}

	/**
	 * Set an "input" flash attribute.
	 * @param name the flash attribute name
	 * @param value the flash attribute value
	 */
	/**
	 * 设置"输入"Flash属性。 
	 *  
	 * @param 命名flash属性名称
	 * @param 值flash属性值
	 */
	public MockHttpServletRequestBuilder flashAttr(String name, Object value) {
		addToMap(this.flashAttributes, name, value);
		return this;
	}

	/**
	 * Set flash attributes.
	 * @param flashAttributes the flash attributes
	 */
	/**
	 * 设置Flash属性。 
	 *  
	 * @param  flashAttributes Flash属性
	 */
	public MockHttpServletRequestBuilder flashAttrs(Map<String, Object> flashAttributes) {
		Assert.notEmpty(flashAttributes, "'flashAttributes' must not be empty");
		flashAttributes.forEach(this::flashAttr);
		return this;
	}

	/**
	 * Set the HTTP session to use, possibly re-used across requests.
	 * <p>Individual attributes provided via {@link #sessionAttr(String, Object)}
	 * override the content of the session provided here.
	 * @param session the HTTP session
	 */
	/**
	 * 设置要使用的HTTP会话，该HTTP会话可能会在请求中重复使用。 
	 * 通过{@link  #sessionAttr（String，Object）}提供的<p>各个属性将覆盖此处提供的会话的内容。 
	 *  
	 * @param 会话HTTP会话
	 */
	public MockHttpServletRequestBuilder session(MockHttpSession session) {
		Assert.notNull(session, "'session' must not be null");
		this.session = session;
		return this;
	}

	/**
	 * Set the principal of the request.
	 * @param principal the principal
	 */
	/**
	 * 设置请求的主体。 
	 *  
	 * @param 委托人委托人
	 */
	public MockHttpServletRequestBuilder principal(Principal principal) {
		Assert.notNull(principal, "'principal' must not be null");
		this.principal = principal;
		return this;
	}

	/**
	 * An extension point for further initialization of {@link MockHttpServletRequest}
	 * in ways not built directly into the {@code MockHttpServletRequestBuilder}.
	 * Implementation of this interface can have builder-style methods themselves
	 * and be made accessible through static factory methods.
	 * @param postProcessor a post-processor to add
	 */
	/**
	 * 一个扩展点，用于以不直接内置在{@code  MockHttpServletRequestBuilder}中的方式进一步初始化{@link  MockHttpServletRequest}。 
	 * 该接口的实现本身可以具有生成器样式的方法，并且可以通过静态工厂方法进行访问。 
	 *  
	 * @param  postProcessor一个要添加的后处理器
	 */
	@Override
	public MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor) {
		Assert.notNull(postProcessor, "postProcessor is required");
		this.postProcessors.add(postProcessor);
		return this;
	}


	/**
	 * {@inheritDoc}
	 * @return always returns {@code true}.
	 */
	/**
	 * {@inheritDoc} 
	 * @return 始终返回{@code  true}。 
	 * 
	 */
	@Override
	public boolean isMergeEnabled() {
		return true;
	}

	/**
	 * Merges the properties of the "parent" RequestBuilder accepting values
	 * only if not already set in "this" instance.
	 * @param parent the parent {@code RequestBuilder} to inherit properties from
	 * @return the result of the merge
	 */
	/**
	 * 仅在尚未在"此"实例中设置的情况下，合并"父"RequestBuilder接受值的属性。 
	 *  
	 * @param 父级父级{@code  RequestBuilder}继承
	 * @return 合并结果的属性
	 */
	@Override
	public Object merge(@Nullable Object parent) {
		if (parent == null) {
			return this;
		}
		if (!(parent instanceof MockHttpServletRequestBuilder)) {
			throw new IllegalArgumentException("Cannot merge with [" + parent.getClass().getName() + "]");
		}
		MockHttpServletRequestBuilder parentBuilder = (MockHttpServletRequestBuilder) parent;

		if (!StringUtils.hasText(this.contextPath)) {
			this.contextPath = parentBuilder.contextPath;
		}
		if (!StringUtils.hasText(this.servletPath)) {
			this.servletPath = parentBuilder.servletPath;
		}
		if ("".equals(this.pathInfo)) {
			this.pathInfo = parentBuilder.pathInfo;
		}

		if (this.secure == null) {
			this.secure = parentBuilder.secure;
		}
		if (this.principal == null) {
			this.principal = parentBuilder.principal;
		}
		if (this.session == null) {
			this.session = parentBuilder.session;
		}

		if (this.characterEncoding == null) {
			this.characterEncoding = parentBuilder.characterEncoding;
		}
		if (this.content == null) {
			this.content = parentBuilder.content;
		}
		if (this.contentType == null) {
			this.contentType = parentBuilder.contentType;
		}

		for (Map.Entry<String, List<Object>> entry : parentBuilder.headers.entrySet()) {
			String headerName = entry.getKey();
			if (!this.headers.containsKey(headerName)) {
				this.headers.put(headerName, entry.getValue());
			}
		}
		for (Map.Entry<String, List<String>> entry : parentBuilder.parameters.entrySet()) {
			String paramName = entry.getKey();
			if (!this.parameters.containsKey(paramName)) {
				this.parameters.put(paramName, entry.getValue());
			}
		}
		for (Map.Entry<String, List<String>> entry : parentBuilder.queryParams.entrySet()) {
			String paramName = entry.getKey();
			if (!this.queryParams.containsKey(paramName)) {
				this.queryParams.put(paramName, entry.getValue());
			}
		}
		for (Cookie cookie : parentBuilder.cookies) {
			if (!containsCookie(cookie)) {
				this.cookies.add(cookie);
			}
		}
		for (Locale locale : parentBuilder.locales) {
			if (!this.locales.contains(locale)) {
				this.locales.add(locale);
			}
		}

		for (Map.Entry<String, Object> entry : parentBuilder.requestAttributes.entrySet()) {
			String attributeName = entry.getKey();
			if (!this.requestAttributes.containsKey(attributeName)) {
				this.requestAttributes.put(attributeName, entry.getValue());
			}
		}
		for (Map.Entry<String, Object> entry : parentBuilder.sessionAttributes.entrySet()) {
			String attributeName = entry.getKey();
			if (!this.sessionAttributes.containsKey(attributeName)) {
				this.sessionAttributes.put(attributeName, entry.getValue());
			}
		}
		for (Map.Entry<String, Object> entry : parentBuilder.flashAttributes.entrySet()) {
			String attributeName = entry.getKey();
			if (!this.flashAttributes.containsKey(attributeName)) {
				this.flashAttributes.put(attributeName, entry.getValue());
			}
		}

		this.postProcessors.addAll(0, parentBuilder.postProcessors);

		return this;
	}

	private boolean containsCookie(Cookie cookie) {
		for (Cookie cookieToCheck : this.cookies) {
			if (ObjectUtils.nullSafeEquals(cookieToCheck.getName(), cookie.getName())) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Build a {@link MockHttpServletRequest}.
	 */
	/**
	 * 构建一个{@link  MockHttpServletRequest}。 
	 * 
	 */
	@Override
	public final MockHttpServletRequest buildRequest(ServletContext servletContext) {
		MockHttpServletRequest request = createServletRequest(servletContext);

		request.setAsyncSupported(true);
		request.setMethod(this.method);

		String requestUri = this.url.getRawPath();
		request.setRequestURI(requestUri);

		if (this.url.getScheme() != null) {
			request.setScheme(this.url.getScheme());
		}
		if (this.url.getHost() != null) {
			request.setServerName(this.url.getHost());
		}
		if (this.url.getPort() != -1) {
			request.setServerPort(this.url.getPort());
		}

		updatePathRequestProperties(request, requestUri);

		if (this.secure != null) {
			request.setSecure(this.secure);
		}
		if (this.principal != null) {
			request.setUserPrincipal(this.principal);
		}
		if (this.session != null) {
			request.setSession(this.session);
		}

		request.setCharacterEncoding(this.characterEncoding);
		request.setContent(this.content);
		request.setContentType(this.contentType);

		this.headers.forEach((name, values) -> {
			for (Object value : values) {
				request.addHeader(name, value);
			}
		});

		if (!ObjectUtils.isEmpty(this.content) &&
				!this.headers.containsKey(HttpHeaders.CONTENT_LENGTH) &&
				!this.headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {

			request.addHeader(HttpHeaders.CONTENT_LENGTH, this.content.length);
		}

		String query = this.url.getRawQuery();
		if (!this.queryParams.isEmpty()) {
			String s = UriComponentsBuilder.newInstance().queryParams(this.queryParams).build().encode().getQuery();
			query = StringUtils.isEmpty(query) ? s : query + "&" + s;
		}
		if (query != null) {
			request.setQueryString(query);
		}
		addRequestParams(request, UriComponentsBuilder.fromUri(this.url).build().getQueryParams());

		this.parameters.forEach((name, values) -> {
			for (String value : values) {
				request.addParameter(name, value);
			}
		});

		if (this.content != null && this.content.length > 0) {
			String requestContentType = request.getContentType();
			if (requestContentType != null) {
				try {
					MediaType mediaType = MediaType.parseMediaType(requestContentType);
					if (MediaType.APPLICATION_FORM_URLENCODED.includes(mediaType)) {
						addRequestParams(request, parseFormData(mediaType));
					}
				}
				catch (Exception ex) {
					// Must be invalid, ignore..
				}
			}
		}

		if (!ObjectUtils.isEmpty(this.cookies)) {
			request.setCookies(this.cookies.toArray(new Cookie[0]));
		}
		if (!ObjectUtils.isEmpty(this.locales)) {
			request.setPreferredLocales(this.locales);
		}

		this.requestAttributes.forEach(request::setAttribute);
		this.sessionAttributes.forEach((name, attribute) -> {
			HttpSession session = request.getSession();
			Assert.state(session != null, "No HttpSession");
			session.setAttribute(name, attribute);
		});

		FlashMap flashMap = new FlashMap();
		flashMap.putAll(this.flashAttributes);
		FlashMapManager flashMapManager = getFlashMapManager(request);
		flashMapManager.saveOutputFlashMap(flashMap, request, new MockHttpServletResponse());

		return request;
	}

	/**
	 * Create a new {@link MockHttpServletRequest} based on the supplied
	 * {@code ServletContext}.
	 * <p>Can be overridden in subclasses.
	 */
	/**
	 * 根据提供的{@code  ServletContext}创建一个新的{@link  MockHttpServletRequest}。 
	 *  <p>可以在子类中覆盖。 
	 * 
	 */
	protected MockHttpServletRequest createServletRequest(ServletContext servletContext) {
		return new MockHttpServletRequest(servletContext);
	}

	/**
	 * Update the contextPath, servletPath, and pathInfo of the request.
	 */
	/**
	 * 更新请求的contextPath，servletPath和pathInfo。 
	 * 
	 */
	private void updatePathRequestProperties(MockHttpServletRequest request, String requestUri) {
		if (!requestUri.startsWith(this.contextPath)) {
			throw new IllegalArgumentException(
					"Request URI [" + requestUri + "] does not start with context path [" + this.contextPath + "]");
		}
		request.setContextPath(this.contextPath);
		request.setServletPath(this.servletPath);

		if ("".equals(this.pathInfo)) {
			if (!requestUri.startsWith(this.contextPath + this.servletPath)) {
				throw new IllegalArgumentException(
						"Invalid servlet path [" + this.servletPath + "] for request URI [" + requestUri + "]");
			}
			String extraPath = requestUri.substring(this.contextPath.length() + this.servletPath.length());
			this.pathInfo = (StringUtils.hasText(extraPath) ?
					urlPathHelper.decodeRequestString(request, extraPath) : null);
		}
		request.setPathInfo(this.pathInfo);
	}

	private void addRequestParams(MockHttpServletRequest request, MultiValueMap<String, String> map) {
		map.forEach((key, values) -> values.forEach(value -> {
			value = (value != null ? UriUtils.decode(value, StandardCharsets.UTF_8) : null);
			request.addParameter(UriUtils.decode(key, StandardCharsets.UTF_8), value);
		}));
	}

	private MultiValueMap<String, String> parseFormData(MediaType mediaType) {
		HttpInputMessage message = new HttpInputMessage() {
			@Override
			public InputStream getBody() {
				return (content != null ? new ByteArrayInputStream(content) : StreamUtils.emptyInput());
			}
			@Override
			public HttpHeaders getHeaders() {
				HttpHeaders headers = new HttpHeaders();
				headers.setContentType(mediaType);
				return headers;
			}
		};

		try {
			return new FormHttpMessageConverter().read(null, message);
		}
		catch (IOException ex) {
			throw new IllegalStateException("Failed to parse form data in request body", ex);
		}
	}

	private FlashMapManager getFlashMapManager(MockHttpServletRequest request) {
		FlashMapManager flashMapManager = null;
		try {
			ServletContext servletContext = request.getServletContext();
			WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);
			flashMapManager = wac.getBean(DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);
		}
		catch (IllegalStateException | NoSuchBeanDefinitionException ex) {
			// ignore
		}
		return (flashMapManager != null ? flashMapManager : new SessionFlashMapManager());
	}

	@Override
	public MockHttpServletRequest postProcessRequest(MockHttpServletRequest request) {
		for (RequestPostProcessor postProcessor : this.postProcessors) {
			request = postProcessor.postProcessRequest(request);
		}
		return request;
	}


	private static void addToMap(Map<String, Object> map, String name, Object value) {
		Assert.hasLength(name, "'name' must not be empty");
		Assert.notNull(value, "'value' must not be null");
		map.put(name, value);
	}

	private static <T> void addToMultiValueMap(MultiValueMap<String, T> map, String name, T[] values) {
		Assert.hasLength(name, "'name' must not be empty");
		Assert.notEmpty(values, "'values' must not be empty");
		for (T value : values) {
			map.add(name, value);
		}
	}

}
