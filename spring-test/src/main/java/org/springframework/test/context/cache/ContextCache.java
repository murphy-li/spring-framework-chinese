/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.context.cache;

import org.springframework.context.ApplicationContext;
import org.springframework.lang.Nullable;
import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
import org.springframework.test.context.MergedContextConfiguration;

/**
 * {@code ContextCache} defines the SPI for caching Spring
 * {@link ApplicationContext ApplicationContexts} within the
 * <em>Spring TestContext Framework</em>.
 *
 * <p>A {@code ContextCache} maintains a cache of {@code ApplicationContexts}
 * keyed by {@link MergedContextConfiguration} instances, potentially configured
 * with a {@linkplain ContextCacheUtils#retrieveMaxCacheSize maximum size} and
 * a custom eviction policy.
 *
 * <h3>Rationale</h3>
 * <p>Context caching can have significant performance benefits if context
 * initialization is complex. Although the initialization of a Spring context
 * itself is typically very quick, some beans in a context &mdash; for example,
 * an embedded database or a {@code LocalContainerEntityManagerFactoryBean} for
 * working with JPA &mdash; may take several seconds to initialize. Hence it
 * often makes sense to perform that initialization only once per test suite or
 * JVM process.
 *
 * @author Sam Brannen
 * @author Juergen Hoeller
 * @since 4.2
 * @see ContextCacheUtils#retrieveMaxCacheSize()
 */
/**
 * {@code  ContextCache}定义了用于在<em> Spring TestContext Framework </ em>中缓存Spring {@link  ApplicationContext ApplicationContexts}的SPI。 
 *  <p> {<@code> ContextCache}维护由{@link  MergedContextConfiguration}实例键控的{@code  ApplicationContexts}的缓存，可能配置为{@link  plain ContextCacheUtils＃retrieveMaxCacheSize最大大小}和自定义搬迁政策。 
 *  <h3> Rationale </ h3> <p>如果上下文初始化很复杂，则上下文缓存可以显着提高性能。 
 * 尽管Spring上下文本身的初始化通常非常快，但是上下文中的某些Bean（例如，嵌入式数据库或用于JPA的{@code  LocalContainerEntityManagerFactoryBean}）可能需要花费几秒钟的时间来初始化。 
 * 因此，通常每个测试套件或JVM进程仅执行一次初始化通常是有意义的。 
 *  @author  Sam Brannen @author  Juergen Hoeller @从4.2起
 * @see  ContextCacheUtils＃retrieveMaxCacheSize（）
 */
public interface ContextCache {

	/**
	 * The name of the logging category used for reporting {@code ContextCache}
	 * statistics.
	 */
	/**
	 * 用于报告{@code  ContextCache}统计信息的日志记录类别的名称。 
	 * 
	 */
	String CONTEXT_CACHE_LOGGING_CATEGORY = "org.springframework.test.context.cache";

	/**
	 * The default maximum size of the context cache: {@value}.
	 * @since 4.3
	 * @see #MAX_CONTEXT_CACHE_SIZE_PROPERTY_NAME
	 */
	/**
	 * 上下文高速缓存的默认最大大小：{@value}。 
	 *  @始于4.3 
	 * @see  #MAX_CONTEXT_CACHE_SIZE_PROPERTY_NAME
	 */
	int DEFAULT_MAX_CONTEXT_CACHE_SIZE = 32;

	/**
	 * System property used to configure the maximum size of the {@link ContextCache}
	 * as a positive integer. May alternatively be configured via the
	 * {@link org.springframework.core.SpringProperties} mechanism.
	 * <p>Note that implementations of {@code ContextCache} are not required to
	 * actually support a maximum cache size. Consult the documentation of the
	 * corresponding implementation for details.
	 * @since 4.3
	 * @see #DEFAULT_MAX_CONTEXT_CACHE_SIZE
	 */
	/**
	 * 用于将{@link  ContextCache}的最大大小配置为正整数的系统属性。 
	 * 也可以通过{@link  org.springframework.core.SpringProperties}机制进行配置。 
	 *  <p>请注意，{<@code> ContextCache}的实现实际上不需要支持最大缓存大小。 
	 * 有关详细信息，请查阅相应实现的文档。 
	 *  @始于4.3 
	 * @see  #DEFAULT_MAX_CONTEXT_CACHE_SIZE
	 */
	String MAX_CONTEXT_CACHE_SIZE_PROPERTY_NAME = "spring.test.context.cache.maxSize";


	/**
	 * Determine whether there is a cached context for the given key.
	 * @param key the context key (never {@code null})
	 * @return {@code true} if the cache contains a context with the given key
	 */
	/**
	 * 确定是否存在给定密钥的缓存上下文。 
	 *  
	 * @param 键为上下文键（永远不为{<@@code> null}）
	 * @return  {@code  true}（如果缓存包含具有给定键的上下文）
	 */
	boolean contains(MergedContextConfiguration key);

	/**
	 * Obtain a cached {@code ApplicationContext} for the given key.
	 * <p>The {@linkplain #getHitCount() hit} and {@linkplain #getMissCount() miss}
	 * counts must be updated accordingly.
	 * @param key the context key (never {@code null})
	 * @return the corresponding {@code ApplicationContext} instance, or {@code null}
	 * if not found in the cache
	 * @see #remove
	 */
	/**
	 * 获取给定密钥的缓存的{@code  ApplicationContext}。 
	 *  <p>必须相应地更新{@link  plain #getHitCount（）hit}和{@link  plain #getMissCount（）miss}计数。 
	 *  
	 * @param 键为上下文键（永远为{@code  null}）
	 * @return 相应的{@code  ApplicationContext}实例，如果在缓存中未找到，则为{@code  null} <
	 * @see >＃删除
	 */
	@Nullable
	ApplicationContext get(MergedContextConfiguration key);

	/**
	 * Explicitly add an {@code ApplicationContext} instance to the cache
	 * under the given key, potentially honoring a custom eviction policy.
	 * @param key the context key (never {@code null})
	 * @param context the {@code ApplicationContext} instance (never {@code null})
	 */
	/**
	 * 在给定键下将{@code  ApplicationContext}实例显式添加到缓存中，可能会遵循自定义逐出策略。 
	 *  
	 * @param 键为上下文键（永远不为{@code  null}）
	 * @param 上下文为{@code  ApplicationContext}实例（永不为<< @code> null}）
	 */
	void put(MergedContextConfiguration key, ApplicationContext context);

	/**
	 * Remove the context with the given key from the cache and explicitly
	 * {@linkplain org.springframework.context.ConfigurableApplicationContext#close() close}
	 * it if it is an instance of {@code ConfigurableApplicationContext}.
	 * <p>Generally speaking, this method should be called to properly evict
	 * a context from the cache (e.g., due to a custom eviction policy) or if
	 * the state of a singleton bean has been modified, potentially affecting
	 * future interaction with the context.
	 * <p>In addition, the semantics of the supplied {@code HierarchyMode} must
	 * be honored. See the Javadoc for {@link HierarchyMode} for details.
	 * @param key the context key; never {@code null}
	 * @param hierarchyMode the hierarchy mode; may be {@code null} if the context
	 * is not part of a hierarchy
	 */
	/**
	 * 从缓存中删除具有给定键的上下文，如果它是{@code  ConfigurableApplicationContext}的实例，则显式{@link  plain org.springframework.context.ConfigurableApplicationContext＃close（）close}将其删除。 
	 *  <p>通常来说，应调用此方法以从高速缓存中适当退出上下文（例如，由于自定义逐出策略），或者如果单例bean的状态已被修改，可能会影响将来与该上下文的交互。 
	 *  <p>此外，必须遵守提供的{@code  HierarchyMode}的语义。 
	 * 有关详细信息，请参见JavaDoc for {@link  HierarchyMode}。 
	 *  
	 * @param 键为上下文键； 
	 * 从不{@code  null} 
	 * @param  architectureMode层次结构模式； 
	 * 如果上下文不是层次结构的一部分，则可以为{@code  null}
	 */
	void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode);

	/**
	 * Determine the number of contexts currently stored in the cache.
	 * <p>If the cache contains more than {@code Integer.MAX_VALUE} elements,
	 * this method must return {@code Integer.MAX_VALUE}.
	 */
	/**
	 * 确定当前存储在缓存中的上下文数。 
	 *  <p>如果缓存包含多个{@code  Integer.MAX_VALUE}元素，则此方法必须返回{@code  Integer.MAX_VALUE}。 
	 * 
	 */
	int size();

	/**
	 * Determine the number of parent contexts currently tracked within the cache.
	 */
	/**
	 * 确定当前在缓存中跟踪的父上下文的数量。 
	 * 
	 */
	int getParentContextCount();

	/**
	 * Get the overall hit count for this cache.
	 * <p>A <em>hit</em> is any access to the cache that returns a non-null
	 * context for the queried key.
	 */
	/**
	 * 获取此缓存的总体命中数。 
	 *  <p> <em> hit </ em>是对缓存的任何访问，该访问将为查询的键返回非空上下文。 
	 * 
	 */
	int getHitCount();

	/**
	 * Get the overall miss count for this cache.
	 * <p>A <em>miss</em> is any access to the cache that returns a {@code null}
	 * context for the queried key.
	 */
	/**
	 * 获取此缓存的总体未命中数。 
	 *  <p> <em> miss </ em>是对缓存的任何访问，该访问将为查询的键返回{@code  null}上下文。 
	 * 
	 */
	int getMissCount();

	/**
	 * Reset all state maintained by this cache including statistics.
	 * @see #clear()
	 * @see #clearStatistics()
	 */
	/**
	 * 重置此缓存维护的所有状态，包括统计信息。 
	 *  
	 * @see  #clear（）
	 * @see  #clearStatistics（）
	 */
	void reset();

	/**
	 * Clear all contexts from the cache, clearing context hierarchy information as well.
	 */
	/**
	 * 从缓存中清除所有上下文，并清除上下文层次结构信息。 
	 * 
	 */
	void clear();

	/**
	 * Clear hit and miss count statistics for the cache (i.e., reset counters to zero).
	 */
	/**
	 * 清除缓存的命中和未命中计数统计信息（即，将计数器重置为零）。 
	 * 
	 */
	void clearStatistics();

	/**
	 * Log the statistics for this {@code ContextCache} at {@code DEBUG} level
	 * using the {@value #CONTEXT_CACHE_LOGGING_CATEGORY} logging category.
	 * <p>The following information should be logged.
	 * <ul>
	 * <li>name of the concrete {@code ContextCache} implementation</li>
	 * <li>{@linkplain #size}</li>
	 * <li>{@linkplain #getParentContextCount() parent context count}</li>
	 * <li>{@linkplain #getHitCount() hit count}</li>
	 * <li>{@linkplain #getMissCount() miss count}</li>
	 * <li>any other information useful for monitoring the state of this cache</li>
	 * </ul>
	 */
	/**
	 * 使用{@value #CONTEXT_CACHE_LOGGING_CATEGORY}日志记录类别在{@code  DEBUG}级别记录此{@code  ContextCache}的统计信息。 
	 *  <p>应记录以下信息。 
	 *  <ul> <li>具体{@code  ContextCache}实现的名称</ li> <li> {<@link> plain #size} </ li> <li> {<@link> plain #getParentContextCount（ ）父级上下文计数} </ li> <li> {<@link> plain #getHitCount（）命中数} </ li> <li> {<@link> plain #getMissCount（）未命中数} </ li> < li>可用于监视此缓存状态的其他任何信息</ li> </ ul>
	 */
	void logStatistics();

}
