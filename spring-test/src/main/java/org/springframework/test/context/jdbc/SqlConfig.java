/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2016的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.context.jdbc;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * {@code @SqlConfig} defines metadata that is used to determine how to parse
 * and execute SQL scripts configured via the {@link Sql @Sql} annotation.
 *
 * <h3>Configuration Scope</h3>
 * <p>When declared as a class-level annotation on an integration test class,
 * {@code @SqlConfig} serves as <strong><em>global</em></strong> configuration
 * for all SQL scripts within the test class hierarchy. When declared directly
 * via the {@link Sql#config config} attribute of the {@code @Sql} annotation,
 * {@code @SqlConfig} serves as <strong><em>local</em></strong> configuration
 * for the SQL scripts declared within the enclosing {@code @Sql} annotation.
 *
 * <h3>Default Values</h3>
 * <p>Every attribute in {@code @SqlConfig} has an <em>implicit</em> default value
 * which is documented in the javadocs of the corresponding attribute. Due to the
 * rules defined for annotation attributes in the Java Language Specification, it
 * is unfortunately not possible to assign a value of {@code null} to an annotation
 * attribute. Thus, in order to support overrides of <em>inherited</em> global
 * configuration, {@code @SqlConfig} attributes have an <em>explicit</em>
 * {@code default} value of either {@code ""} for Strings, <code>{}</code> for
 * arrays, or {@code DEFAULT} for Enums. This approach allows local declarations
 * of {@code @SqlConfig} to selectively override individual attributes from global
 * declarations of {@code @SqlConfig} by providing a value other than {@code ""},
 * <code>{}</code>, or {@code DEFAULT}.
 *
 * <h3>Inheritance and Overrides</h3>
 * <p>Global {@code @SqlConfig} attributes are <em>inherited</em> whenever local
 * {@code @SqlConfig} attributes do not supply an explicit value other than
 * {@code ""}, <code>{}</code>, or {@code DEFAULT}. Explicit local configuration
 * therefore <em>overrides</em> global configuration.
 *
 * @author Sam Brannen
 * @author Tadaya Tsuyukubo
 * @since 4.1
 * @see Sql
 */
/**
 * {@code  @SqlConfig}定义用于确定如何解析和执行通过{@link  Sql @Sql}注解配置的SQL脚本的元数据。 
 *  <h3>配置范围</ h3> <p>在集成测试类上声明为类级注释时，{<@code> @SqlConfig}用作<strong> <em> global </ em> </ strong >配置测试类层次结构中的所有SQL脚本。 
 * 通过{@code  @Sql}注解的{@link  Sql＃config config}属性直接声明时，{<@code> @SqlConfig}用作<strong> <em> local </ em> < / strong>配置，用于在封闭的{@code  @Sql}注解中声明的SQL脚本。 
 *  <h3>默认值</ h3> <p> {<@code> @SqlConfig}中的每个属性都有一个<em>隐式</ em>默认值，该默认值记录在相应属性的javadocs中。 
 * 由于Java语言规范中为注释属性定义了规则，因此，无法为注释属性分配{@code  null}的值。 
 * 因此，为了支持覆盖<em>继承的</ em>全局配置，{@code  @SqlConfig}属性的<em> explicit </ em> {@code 默认}值为{@code ""}用于字符串，<code> {} </ code>用于数组，或{@code  DEFAULT}用于枚举。 
 * 这种方法允许{@code  @SqlConfig}的本地声明通过提供除{@code ""}，<code> { } </ code>或{@code  DEFAULT}。 
 *  <h3>继承和替代</ h3> <p>只要本地{@code  @SqlConfig}属性未提供其他任何显式值，就会继承<em> </ em>全局{@code  @SqlConfig}属性而不是{@code ""}，<code> {} </ code>或{@code  DEFAULT}。 
 * 因此，显式的本地配置会<em>覆盖</ em>全局配置。 
 *  @author  Sam Brannen @author  Tadaya Tsuyukubo @从4.1开始
 * @see  Sql
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface SqlConfig {

	/**
	 * The bean name of the {@link javax.sql.DataSource} against which the
	 * scripts should be executed.
	 * <p>The name is only required if there is more than one bean of type
	 * {@code DataSource} in the test's {@code ApplicationContext}. If there
	 * is only one such bean, it is not necessary to specify a bean name.
	 * <p>Defaults to an empty string, requiring that one of the following is
	 * true:
	 * <ol>
	 * <li>An explicit bean name is defined in a global declaration of
	 * {@code @SqlConfig}.
	 * <li>The data source can be retrieved from the transaction manager
	 * by using reflection to invoke a public method named
	 * {@code getDataSource()} on the transaction manager.
	 * <li>There is only one bean of type {@code DataSource} in the test's
	 * {@code ApplicationContext}.</li>
	 * <li>The {@code DataSource} to use is named {@code "dataSource"}.</li>
	 * </ol>
	 * @see org.springframework.test.context.transaction.TestContextTransactionUtils#retrieveDataSource
	 */
	/**
	 * {@link  javax.sql.DataSource}的bean名称，应针对其执行脚本。 
	 *  <p>仅当测试的{@code  ApplicationContext}中有多个类型为{@code  DataSource}的bean时才需要名称。 
	 * 如果只有一个这样的bean，则无需指定bean名称。 
	 *  <p>默认为空字符串，要求满足以下条件之一：<ol> <li>在{@code  @SqlConfig}的全局声明中定义了显式bean名称。 
	 *  <li>可以使用反射在事务管理器上调用名为{@code  getDataSource（）}的公共方法，从事务管理器中检索数据源。 
	 *  <li>在测试的{@code  ApplicationContext}中只有一个类型为{@code  DataSource}的bean。 
	 * </ li> <li>要使用的{@code  DataSource}被命名为{<@code>"dataSource"}。 
	 * </ li> </ ol> 
	 * @see  org.springframework.test.context.transaction.TestContextTransactionUtils＃retrieveDataSource
	 */
	String dataSource() default "";

	/**
	 * The bean name of the {@link org.springframework.transaction.PlatformTransactionManager
	 * PlatformTransactionManager} that should be used to drive transactions.
	 * <p>The name is only used if there is more than one bean of type
	 * {@code PlatformTransactionManager} in the test's {@code ApplicationContext}.
	 * If there is only one such bean, it is not necessary to specify a bean name.
	 * <p>Defaults to an empty string, requiring that one of the following is
	 * true:
	 * <ol>
	 * <li>An explicit bean name is defined in a global declaration of
	 * {@code @SqlConfig}.
	 * <li>There is only one bean of type {@code PlatformTransactionManager} in
	 * the test's {@code ApplicationContext}.</li>
	 * <li>{@link org.springframework.transaction.annotation.TransactionManagementConfigurer
	 * TransactionManagementConfigurer} has been implemented to specify which
	 * {@code PlatformTransactionManager} bean should be used for annotation-driven
	 * transaction management.</li>
	 * <li>The {@code PlatformTransactionManager} to use is named
	 * {@code "transactionManager"}.</li>
	 * </ol>
	 * @see org.springframework.test.context.transaction.TestContextTransactionUtils#retrieveTransactionManager
	 */
	/**
	 * {@link  org.springframework.transaction.PlatformTransactionManager PlatformTransactionManager}的bean名称应用于驱动事务。 
	 *  <p>仅当测试的{@code  ApplicationContext}中有多个类型为{@code  PlatformTransactionManager}的bean时，才使用该名称。 
	 * 如果只有一个这样的bean，则无需指定bean名称。 
	 *  <p>默认为空字符串，要求满足以下条件之一：<ol> <li>在{@code  @SqlConfig}的全局声明中定义了显式bean名称。 
	 *  <li>测试的{@code  ApplicationContext}中只有一个类型为{@code  PlatformTransactionManager}的bean。 
	 * </ li> <li> {<@link> org.springframework.transaction.annotation.TransactionManagementConfigurer TransactionManagementConfigurer }已实现，以指定应使用哪个{@code  PlatformTransactionManager} bean进行注释驱动的事务管理。 
	 * </ li> <li>要使用的{@code  PlatformTransactionManager}名为{@code "transactionManager"}。 
	 * </ li> </ ol> 
	 * @see  org.springframework.test.context.transaction.TestContextTransactionUtils＃retrieveTransactionManager
	 */
	String transactionManager() default "";

	/**
	 * The <em>mode</em> to use when determining whether SQL scripts should be
	 * executed within a transaction.
	 * <p>Defaults to {@link TransactionMode#DEFAULT DEFAULT}.
	 * <p>Can be set to {@link TransactionMode#ISOLATED} to ensure that the SQL
	 * scripts are executed in a new, isolated transaction that will be immediately
	 * committed.
	 * @see TransactionMode
	 */
	/**
	 * 在确定是否应在事务内执行SQL脚本时使用的<em> mode </ em>。 
	 *  <p>默认为{@link  TransactionMode＃DEFAULT DEFAULT}。 
	 * 可以将<p>设置为{@link  TransactionMode＃ISOLATED}，以确保SQL脚本在将立即提交的新的隔离事务中执行。 
	 *  
	 * @see  TransactionMode
	 */
	TransactionMode transactionMode() default TransactionMode.DEFAULT;

	/**
	 * The encoding for the supplied SQL scripts, if different from the platform
	 * encoding.
	 * <p>An empty string denotes that the platform encoding should be used.
	 */
	/**
	 * 提供的SQL脚本的编码（如果与平台编码不同）。 
	 *  <p>空字符串表示应使用平台编码。 
	 * 
	 */
	String encoding() default "";

	/**
	 * The character string used to separate individual statements within the
	 * SQL scripts.
	 * <p>Implicitly defaults to {@code ";"} if not specified and falls back to
	 * {@code "\n"} as a last resort.
	 * <p>May be set to
	 * {@link org.springframework.jdbc.datasource.init.ScriptUtils#EOF_STATEMENT_SEPARATOR}
	 * to signal that each script contains a single statement without a
	 * separator.
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#DEFAULT_STATEMENT_SEPARATOR
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#EOF_STATEMENT_SEPARATOR
	 */
	/**
	 * 用于在SQL脚本中分隔各个语句的字符串。 
	 *  <p>如果未指定，则默认默认为{@code ";"}，并退回到{@code "\ n"}作为最后的选择。 
	 * 可以将<p>设置为{@link  org.springframework.jdbc.datasource.init.ScriptUtils＃EOF_STATEMENT_SEPARATOR}，以表示每个脚本包含一个不带分隔符的语句。 
	 *  
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃DEFAULT_STATEMENT_SEPARATOR 
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃EOF_STATEMENT_SEPARATOR
	 */
	String separator() default "";

	/**
	 * The prefix that identifies single-line comments within the SQL scripts.
	 * <p>Implicitly defaults to {@code "--"}.
	 * <p>This attribute may <strong>not</strong> be used in conjunction with
	 * {@link #commentPrefixes commentPrefixes}, but it may be used instead of
	 * {@link #commentPrefixes commentPrefixes}.
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#DEFAULT_COMMENT_PREFIX
	 * @see #commentPrefixes
	 */
	/**
	 * 标识SQL脚本中单行注释的前缀。 
	 *  <p>默认为{@code "-"}。 
	 *  <p>此属性可能<strong>不</ strong>不能与{@link  #commentPrefixes commentPrefixes}结合使用，但可以代替{@link  #commentPrefixes commentPrefixes}使用。 
	 *  
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃DEFAULT_COMMENT_PREFIX 
	 * @see  #commentPrefixes
	 */
	String commentPrefix() default "";

	/**
	 * The prefixes that identify single-line comments within the SQL scripts.
	 * <p>Implicitly defaults to {@code ["--"]}.
	 * <p>This attribute may <strong>not</strong> be used in conjunction with
	 * {@link #commentPrefix commentPrefix}, but it may be used instead of
	 * {@link #commentPrefix commentPrefix}.
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#DEFAULT_COMMENT_PREFIXES
	 * @see #commentPrefix
	 * @since 5.2
	 */
	/**
	 * 在SQL脚本中标识单行注释的前缀。 
	 *  <p>默认为{@code  ["-"]}。 
	 *  <p>此属性可能<strong>不</ strong>不能与{@link  #commentPrefix commentPrefix}结合使用，但可以代替{@link  #commentPrefix commentPrefix}使用。 
	 *  
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃DEFAULT_COMMENT_PREFIXES 
	 * @see  #commentPrefix @since 5.2起
	 */
	String[] commentPrefixes() default {};

	/**
	 * The start delimiter that identifies block comments within the SQL scripts.
	 * <p>Implicitly defaults to {@code "/*"}.
	 * @see #blockCommentEndDelimiter
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#DEFAULT_BLOCK_COMMENT_START_DELIMITER
	 */
	/**
	 * 起始分隔符，用于标识SQL脚本中的块注释。 
	 *  <p>默认为{@code ""}。 
	 *  
	 * @see  #blockCommentEndDelimiter 
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃DEFAULT_BLOCK_COMMENT_START_DELIMITER
	 */
	String blockCommentStartDelimiter() default "";

	/**
	 * The end delimiter that identifies block comments within the SQL scripts.
	 * <p>Implicitly defaults to <code>"*&#47;"</code>.
	 * @see #blockCommentStartDelimiter
	 * @see org.springframework.jdbc.datasource.init.ScriptUtils#DEFAULT_BLOCK_COMMENT_END_DELIMITER
	 */
	/**
	 * 结束分隔符，用于标识SQL脚本中的块注释。 
	 *  <p>默认为<code>"/"</ code>。 
	 *  
	 * @see  #blockCommentStartDelimiter 
	 * @see  org.springframework.jdbc.datasource.init.ScriptUtils＃DEFAULT_BLOCK_COMMENT_END_DELIMITER
	 */
	String blockCommentEndDelimiter() default "";

	/**
	 * The <em>mode</em> to use when an error is encountered while executing an
	 * SQL statement.
	 * <p>Defaults to {@link ErrorMode#DEFAULT DEFAULT}.
	 * @see ErrorMode
	 */
	/**
	 * 在执行SQL语句时遇到错误时使用的<em> mode </ em>。 
	 *  <p>默认为{@link  ErrorMode＃DEFAULT DEFAULT}。 
	 *  
	 * @see 错误模式
	 */
	ErrorMode errorMode() default ErrorMode.DEFAULT;


	/**
	 * Enumeration of <em>modes</em> that dictate whether SQL scripts should be
	 * executed within a transaction and what the transaction propagation behavior
	 * should be.
	 */
	/**
	 * <em>模式</ em>的枚举规定了是否应在事务中执行SQL脚本以及事务应具有的传播行为。 
	 * 
	 */
	enum TransactionMode {

		/**
		 * Indicates that the <em>default</em> transaction mode should be used.
		 * <p>The meaning of <em>default</em> depends on the context in which
		 * {@code @SqlConfig} is declared:
		 * <ul>
		 * <li>If {@code @SqlConfig} is declared <strong>only</strong> locally,
		 * the default transaction mode is {@link #INFERRED}.</li>
		 * <li>If {@code @SqlConfig} is declared globally, the default transaction
		 * mode is {@link #INFERRED}.</li>
		 * <li>If {@code @SqlConfig} is declared globally <strong>and</strong>
		 * locally, the default transaction mode for the local declaration is
		 * inherited from the global declaration.</li>
		 * </ul>
		 */
		/**
		 * 指示应使用<em> default </ em>交易模式。 
		 *  <p> <em> default </ em>的含义取决于声明{@code  @SqlConfig}的上下文：<ul> <li>如果声明了{@code  @SqlConfig} <strong >仅在本地</ strong>，默认事务处理模式为{@link  #INFERRED}。 
		 * </ li> <li>如果全局声明了{@code  @SqlConfig}，则默认事务处理模式为{<@link> #INFERRED}。 
		 * </ li> <li>如果在全局范围内<strong>和</ strong>声明了{@code  @SqlConfig}，则本地声明的默认事务处理模式将从全局声明继承。 
		 *  </ li> </ ul>
		 */
		DEFAULT,

		/**
		 * Indicates that the transaction mode to use when executing SQL
		 * scripts should be <em>inferred</em> using the rules listed below.
		 * In the context of these rules, the term "<em>available</em>"
		 * means that the bean for the data source or transaction manager
		 * is either explicitly specified via a corresponding annotation
		 * attribute in {@code @SqlConfig} or discoverable via conventions. See
		 * {@link org.springframework.test.context.transaction.TestContextTransactionUtils TestContextTransactionUtils}
		 * for details on the conventions used to discover such beans in
		 * the {@code ApplicationContext}.
		 *
		 * <h4>Inference Rules</h4>
		 * <ol>
		 * <li>If neither a transaction manager nor a data source is
		 * available, an exception will be thrown.
		 * <li>If a transaction manager is not available but a data source
		 * is available, SQL scripts will be executed directly against the
		 * data source without a transaction.
		 * <li>If a transaction manager is available:
		 * <ul>
		 * <li>If a data source is not available, an attempt will be made
		 * to retrieve it from the transaction manager by using reflection
		 * to invoke a public method named {@code getDataSource()} on the
		 * transaction manager. If the attempt fails, an exception will be
		 * thrown.
		 * <li>Using the resolved transaction manager and data source, SQL
		 * scripts will be executed within an existing transaction if
		 * present; otherwise, scripts will be executed in a new transaction
		 * that will be immediately committed. An <em>existing</em>
		 * transaction will typically be managed by the
		 * {@link org.springframework.test.context.transaction.TransactionalTestExecutionListener TransactionalTestExecutionListener}.
		 * </ul>
		 * </ol>
		 * @see #ISOLATED
		 * @see org.springframework.test.context.transaction.TestContextTransactionUtils#retrieveDataSource
		 * @see org.springframework.test.context.transaction.TestContextTransactionUtils#retrieveTransactionManager
		 */
		/**
		 * 指示应使用以下列出的规则<em>推断</ em>来执行SQL脚本时要使用的事务处理模式。 
		 * 在这些规则的上下文中，术语"<em>可用</ em>"表示用于数据源或事务管理器的bean是通过{@code  @SqlConfig}中的相应注释属性显式指定的，或者是discoverable通过惯例。 
		 * 有关在{@code  ApplicationContext}中用于发现此类bean的约定的详细信息，请参见{@link  org.springframework.test.context.transaction.TestContextTransactionUtils TestContextTransactionUtils}。 
		 *  <h4>推理规则</ h4> <ol> <li>如果事务管理器和数据源均不可用，则将引发异常。 
		 *  <li>如果没有事务管理器，但是有数据源，则将直接对数据源执行SQL脚本，而不进行事务处理。 
		 *  <li>如果有事务管理器可用：<ul> <li>如果数据源不可用，将尝试通过使用反射调用名为{@code 的公共方法，从事务管理器中检索它。 
		 * 交易管理器上的getDataSource（）}。 
		 * 如果尝试失败，将引发异常。 
		 *  <li>使用已解析的事务管理器和数据源，将在现有事务中执行SQL脚本（如果存在）； 
		 * 否则，脚本将在将立即提交的新事务中执行。 
		 *  <em>现有</ em>事务通常由{@link  org.springframework.test.context.transaction.TransactionalTestExecutionListener TransactionalTestExecutionListener}管理。 
		 *  </ ul> </ ol> 
		 * @see  #ISOLATED 
		 * @see  org.springframework.test.context.transaction.TestContextTransactionUtils＃retrieveDataSource 
		 * @see  org.springframework.test.context.transaction.TestContextTransactionUtils＃retrieveTransactionManager
		 */
		INFERRED,

		/**
		 * Indicates that SQL scripts should always be executed in a new,
		 * <em>isolated</em> transaction that will be immediately committed.
		 * <p>In contrast to {@link #INFERRED}, this mode requires the
		 * presence of a transaction manager <strong>and</strong> a data
		 * source.
		 */
		/**
		 * 表示SQL脚本应始终在将立即提交的新的<em> isolated </ em>事务中执行。 
		 *  <p>与{@link  #INFERRED}相比，此模式需要事务管理器<strong>和</ strong>。 
		 * 
		 */
		ISOLATED
	}


	/**
	 * Enumeration of <em>modes</em> that dictate how errors are handled while
	 * executing SQL statements.
	 */
	/**
	 * <em>模式</ em>的枚举，指示执行SQL语句时如何处理错误。 
	 * 
	 */
	enum ErrorMode {

		/**
		 * Indicates that the <em>default</em> error mode should be used.
		 * <p>The meaning of <em>default</em> depends on the context in which
		 * {@code @SqlConfig} is declared:
		 * <ul>
		 * <li>If {@code @SqlConfig} is declared <strong>only</strong> locally,
		 * the default error mode is {@link #FAIL_ON_ERROR}.</li>
		 * <li>If {@code @SqlConfig} is declared globally, the default error
		 * mode is {@link #FAIL_ON_ERROR}.</li>
		 * <li>If {@code @SqlConfig} is declared globally <strong>and</strong>
		 * locally, the default error mode for the local declaration is
		 * inherited from the global declaration.</li>
		 * </ul>
		 */
		/**
		 * 指示应使用<em> default </ em>错误模式。 
		 *  <p> <em> default </ em>的含义取决于声明{@code  @SqlConfig}的上下文：<ul> <li>如果声明了{@code  @SqlConfig} <strong >仅本地</ strong>，默认错误模式为{@link  #FAIL_ON_ERROR}。 
		 * </ li> <li>如果全局声明了{@code  @SqlConfig}，则默认错误模式为{<@链接> #FAIL_ON_ERROR}。 
		 * </ li> <li>如果{@code  @SqlConfig}在全局<strong>和</ strong>中进行了全局声明，则本地声明的默认错误模式将从全局声明中继承。 
		 *  </ li> </ ul>
		 */
		DEFAULT,

		/**
		 * Indicates that script execution will fail if an error is encountered.
		 * In other words, no errors should be ignored.
		 * <p>This is effectively the default error mode so that if a script
		 * is accidentally executed, it will fail fast if any SQL statement in
		 * the script results in an error.
		 * @see #CONTINUE_ON_ERROR
		 */
		/**
		 * 表示如果遇到错误，脚本执行将失败。 
		 * 换句话说，不应忽略任何错误。 
		 *  <p>这实际上是默认的错误模式，因此，如果脚本被意外执行，则如果脚本中的任何SQL语句导致错误，它将迅速失败。 
		 *  
		 * @see  #CONTINUE_ON_ERROR
		 */
		FAIL_ON_ERROR,

		/**
		 * Indicates that all errors in SQL scripts should be logged but not
		 * propagated as exceptions.
		 * <p>{@code CONTINUE_ON_ERROR} is the logical <em>opposite</em> of
		 * {@code FAIL_ON_ERROR} and a <em>superset</em> of {@code IGNORE_FAILED_DROPS}.
		 * @see #FAIL_ON_ERROR
		 * @see #IGNORE_FAILED_DROPS
		 */
		/**
		 * 指示应记录SQL脚本中的所有错误，但不要将其传播为异常。 
		 *  <p> {<@code> CONTINUE_ON_ERROR}是{@code  FAIL_ON_ERROR}的逻辑<em>相反</ em>和{@code  IGNORE_FAILED_DROPS}的<em>超集</ em>。 
		 *  
		 * @see  #FAIL_ON_ERROR 
		 * @see  #IGNORE_FAILED_DROPS
		 */
		CONTINUE_ON_ERROR,

		/**
		 * Indicates that failed SQL {@code DROP} statements can be ignored.
		 * <p>This is useful for a non-embedded database whose SQL dialect does
		 * not support an {@code IF EXISTS} clause in a {@code DROP} statement.
		 * @see #CONTINUE_ON_ERROR
		 */
		/**
		 * 指示失败的SQL {@code  DROP}语句可以忽略。 
		 *  <p>对于其SQL方言不支持{@code  DROP}语句中的{@code  IF EXISTS}子句的非嵌入式数据库很有用。 
		 *  
		 * @see  #CONTINUE_ON_ERROR
		 */
		IGNORE_FAILED_DROPS
	}

}
