/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.context.support;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.ContextConfigurationAttributes;
import org.springframework.test.context.ContextHierarchy;
import org.springframework.test.context.SmartContextLoader;
import org.springframework.test.util.MetaAnnotationUtils.AnnotationDescriptor;
import org.springframework.test.util.MetaAnnotationUtils.UntypedAnnotationDescriptor;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import static org.springframework.core.annotation.AnnotationUtils.getAnnotation;
import static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;
import static org.springframework.test.util.MetaAnnotationUtils.findAnnotationDescriptor;
import static org.springframework.test.util.MetaAnnotationUtils.findAnnotationDescriptorForTypes;

/**
 * Utility methods for resolving {@link ContextConfigurationAttributes} from the
 * {@link ContextConfiguration @ContextConfiguration} and
 * {@link ContextHierarchy @ContextHierarchy} annotations for use with
 * {@link SmartContextLoader SmartContextLoaders}.
 *
 * @author Sam Brannen
 * @since 3.1
 * @see SmartContextLoader
 * @see ContextConfigurationAttributes
 * @see ContextConfiguration
 * @see ContextHierarchy
 */
/**
 * 从{@link  ContextConfiguration @ContextConfiguration}和{@link  ContextHierarchy @ContextHierarchy}注解中解析{@link  ContextConfigurationAttributes}的实用程序方法，可与{@link  SmartContextLoader SmartContextLoaders}一起使用。 
 *  @author  Sam Brannen @since 3.1 
 * @see  SmartContextLoader 
 * @see  ContextConfigurationAttributes 
 * @see  ContextConfiguration 
 * @see  ContextHierarchy
 */
abstract class ContextLoaderUtils {

	static final String GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX = "ContextHierarchyLevel#";

	private static final Log logger = LogFactory.getLog(ContextLoaderUtils.class);


	/**
	 * Resolve the list of lists of {@linkplain ContextConfigurationAttributes context
	 * configuration attributes} for the supplied {@linkplain Class test class} and its
	 * superclasses, taking into account context hierarchies declared via
	 * {@link ContextHierarchy @ContextHierarchy} and
	 * {@link ContextConfiguration @ContextConfiguration}.
	 * <p>The outer list represents a top-down ordering of context configuration
	 * attributes, where each element in the list represents the context configuration
	 * declared on a given test class in the class hierarchy. Each nested list
	 * contains the context configuration attributes declared either via a single
	 * instance of {@code @ContextConfiguration} on the particular class or via
	 * multiple instances of {@code @ContextConfiguration} declared within a
	 * single {@code @ContextHierarchy} instance on the particular class.
	 * Furthermore, each nested list maintains the order in which
	 * {@code @ContextConfiguration} instances are declared.
	 * <p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and
	 * {@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of
	 * {@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>
	 * be taken into consideration. If these flags need to be honored, that must be
	 * handled manually when traversing the nested lists returned by this method.
	 * @param testClass the class for which to resolve the context hierarchy attributes
	 * (must not be {@code null})
	 * @return the list of lists of configuration attributes for the specified class;
	 * never {@code null}
	 * @throws IllegalArgumentException if the supplied class is {@code null}; or if
	 * neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is
	 * <em>present</em> on the supplied class
	 * @throws IllegalStateException if a test class or composed annotation
	 * in the class hierarchy declares both {@code @ContextConfiguration} and
	 * {@code @ContextHierarchy} as top-level annotations.
	 * @since 3.2.2
	 * @see #buildContextHierarchyMap(Class)
	 * @see #resolveContextConfigurationAttributes(Class)
	 */
	/**
	 * 考虑到通过{@link  ContextHierarchy @ContextHierarchy}声明的上下文层次结构，为提供的{@link  plain类测试类}及其超类解析{@link  plain ContextConfigurationAttributes上下文配置属性}的列表列表和{@link  ContextConfiguration @ContextConfiguration}。 
	 *  <p>外部列表表示上下文配置属性的自上而下的顺序，其中列表中的每个元素表示在类层次结构中给定测试类上声明的上下文配置。 
	 * 每个嵌套列表都包含通过特定类上的{@code  @ContextConfiguration}的单个实例或通过在单个{@code  @中声明的{@code  @ContextConfiguration}的多个实例声明的上下文配置属性。 
	 * 特定类上的ContextHierarchy}实例。 
	 * 此外，每个嵌套列表都维护声明{@code  @ContextConfiguration}实例的顺序。 
	 *  <p>请注意，{<@link> ContextConfiguration @ContextConfiguration}标志的{@link  ContextConfiguration＃inheritLocationsInheritLocations}和{@link  ContextConfiguration＃inheritInitializers（）InheritInitializers}标志将<strong>不</ strong>考虑在内。 
	 * 如果需要遵守这些标志，则在遍历此方法返回的嵌套列表时必须手动处理。 
	 *  
	 * @param  testClass为其解析上下文层次结构属性的类（不得为{@code  null}）。 
	 * @
	 * @return>指定类的配置属性列表； 
	 * 如果提供的类为{@code  null}，则永远不会{@code  null} 
	 * @throws  IllegalArgumentException;或如果提供的类
	 * @throws  IllegalStateException上的{@code  @ContextConfiguration}和{@code  @ContextHierarchy}都不存在<em> </ em>，如果测试类或类层次结构中的组合注释声明了{@code  @ContextConfiguration}和{@code  @ContextHierarchy}都作为顶级注释。 
	 *  @since 3.2.2 
	 * @see  #buildContextHierarchyMap（Class）
	 * @see  #resolveContextConfigurationAttributes（Class）
	 */
	@SuppressWarnings("unchecked")
	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {
		Assert.notNull(testClass, "Class must not be null");

		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class;
		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class;
		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<>();

		UntypedAnnotationDescriptor desc =
				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType);
		Assert.notNull(desc, () -> String.format(
					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",
					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()));

		while (desc != null) {
			Class<?> rootDeclaringClass = desc.getRootDeclaringClass();
			Class<?> declaringClass = desc.getDeclaringClass();

			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass);
			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass);

			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {
				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +
						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +
						"or composed annotation.", declaringClass.getName());
				logger.error(msg);
				throw new IllegalStateException(msg);
			}

			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<>();

			if (contextConfigDeclaredLocally) {
				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(
						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass());
				convertContextConfigToConfigAttributesAndAddToList(
						contextConfiguration, rootDeclaringClass, configAttributesList);
			}
			else if (contextHierarchyDeclaredLocally) {
				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType);
				if (contextHierarchy != null) {
					for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {
						convertContextConfigToConfigAttributesAndAddToList(
								contextConfiguration, rootDeclaringClass, configAttributesList);
					}
				}
			}
			else {
				// This should theoretically never happen...
				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +
						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName());
				logger.error(msg);
				throw new IllegalStateException(msg);
			}

			hierarchyAttributes.add(0, configAttributesList);
			desc = findAnnotationDescriptorForTypes(
					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType);
		}

		return hierarchyAttributes;
	}

	/**
	 * Build a <em>context hierarchy map</em> for the supplied {@linkplain Class
	 * test class} and its superclasses, taking into account context hierarchies
	 * declared via {@link ContextHierarchy @ContextHierarchy} and
	 * {@link ContextConfiguration @ContextConfiguration}.
	 * <p>Each value in the map represents the consolidated list of {@linkplain
	 * ContextConfigurationAttributes context configuration attributes} for a
	 * given level in the context hierarchy (potentially across the test class
	 * hierarchy), keyed by the {@link ContextConfiguration#name() name} of the
	 * context hierarchy level.
	 * <p>If a given level in the context hierarchy does not have an explicit
	 * name (i.e., configured via {@link ContextConfiguration#name}), a name will
	 * be generated for that hierarchy level by appending the numerical level to
	 * the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.
	 * @param testClass the class for which to resolve the context hierarchy map
	 * (must not be {@code null})
	 * @return a map of context configuration attributes for the context hierarchy,
	 * keyed by context hierarchy level name; never {@code null}
	 * @throws IllegalArgumentException if the lists of context configuration
	 * attributes for each level in the {@code @ContextHierarchy} do not define
	 * unique context configuration within the overall hierarchy.
	 * @since 3.2.2
	 * @see #resolveContextHierarchyAttributes(Class)
	 */
	/**
	 * 考虑到通过{@link  ContextHierarchy @ContextHierarchy}和{<@link）声明的上下文层次结构，为提供的{@link  plain类测试类}及其超类构建<em>上下文层次结构图</ em> > ContextConfiguration @ContextConfiguration}。 
	 *  <p>映射中的每个值代表由{@link  ContextConfiguration键控的上下文层次结构中的给定级别（可能跨越测试类层次结构）的{@link  plain ContextConfigurationAttributes上下文配置属性}的合并列表。 
	 * 上下文层次结构级别的#name（）name}。 
	 *  <p>如果上下文层次结构中的给定级别没有明确的名称（即，通过{@link  ContextConfiguration＃name}配置），则会通过将数字级别附加到{而为该层次结构级别生成一个名称。 
	 *  @link  #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}。 
	 *  
	 * @param  testClass为其解析上下文层次结构映射的类（必须不为{@code  null}）。 
	 * 如果{@code  @ContextHierarchy}中每个级别的上下文配置属性列表未在整个层次结构中定义唯一的上下文配置，则永远不要{@code  null} 
	 * @throws  IllegalArgumentException。 
	 *  @since 3.2.2 
	 * @see  #resolveContextHierarchyAttributes（Class）
	 */
	static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {
		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<>();
		int hierarchyLevel = 1;

		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {
			for (ContextConfigurationAttributes configAttributes : configAttributesList) {
				String name = configAttributes.getName();

				// Assign a generated name?
				if (!StringUtils.hasText(name)) {
					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel;
				}

				// Encountered a new context hierarchy level?
				if (!map.containsKey(name)) {
					hierarchyLevel++;
					map.put(name, new ArrayList<>());
				}

				map.get(name).add(configAttributes);
			}
		}

		// Check for uniqueness
		Set<List<ContextConfigurationAttributes>> set = new HashSet<>(map.values());
		if (set.size() != map.size()) {
			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +
					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",
					testClass.getName());
			logger.error(msg);
			throw new IllegalStateException(msg);
		}

		return map;
	}

	/**
	 * Resolve the list of {@linkplain ContextConfigurationAttributes context
	 * configuration attributes} for the supplied {@linkplain Class test class} and its
	 * superclasses.
	 * <p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and
	 * {@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of
	 * {@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>
	 * be taken into consideration. If these flags need to be honored, that must be
	 * handled manually when traversing the list returned by this method.
	 * @param testClass the class for which to resolve the configuration attributes
	 * (must not be {@code null})
	 * @return the list of configuration attributes for the specified class, ordered
	 * <em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy);
	 * never {@code null}
	 * @throws IllegalArgumentException if the supplied class is {@code null} or if
	 * {@code @ContextConfiguration} is not <em>present</em> on the supplied class
	 */
	/**
	 * 为提供的{@link  plain Class测试类}及其超类解析{@link  plain ContextConfigurationAttributes上下文配置属性}的列表。 
	 *  <p>请注意，{<@link> ContextConfiguration @ContextConfiguration}标志的{@link  ContextConfiguration＃inheritLocationsInheritLocations}和{@link  ContextConfiguration＃inheritInitializers（）InheritInitializers}标志将<strong>不</ strong>考虑在内。 
	 * 如果需要遵守这些标志，则在遍历此方法返回的列表时必须手动处理。 
	 *  
	 * @param  testClass要为其解析配置属性的类（不得为{@code  null}）
	 * @return 指定类的配置属性列表，按顺序<em>自下而上</ em >（即，就像我们遍历类层次结构一样）； 
	 * 如果提供的类为{@code  null}或提供的类上不存在{@code  @ContextConfiguration}，则永远不会发生{@code  null} 
	 * @throws  IllegalArgumentException
	 */
	static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {
		Assert.notNull(testClass, "Class must not be null");

		List<ContextConfigurationAttributes> attributesList = new ArrayList<>();
		Class<ContextConfiguration> annotationType = ContextConfiguration.class;

		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType);
		Assert.notNull(descriptor, () -> String.format(
					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",
					annotationType.getName(), testClass.getName()));

		while (descriptor != null) {
			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),
					descriptor.getRootDeclaringClass(), attributesList);
			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType);
		}

		return attributesList;
	}

	/**
	 * Convenience method for creating a {@link ContextConfigurationAttributes}
	 * instance from the supplied {@link ContextConfiguration} annotation and
	 * declaring class and then adding the attributes to the supplied list.
	 */
	/**
	 * 从提供的{@link  ContextConfiguration}注解创建{@link  ContextConfigurationAttributes}实例并声明类，然后将属性添加到提供的列表的便捷方法。 
	 * 
	 */
	private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,
			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {

		if (logger.isTraceEnabled()) {
			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",
					contextConfiguration, declaringClass.getName()));
		}
		ContextConfigurationAttributes attributes =
				new ContextConfigurationAttributes(declaringClass, contextConfiguration);
		if (logger.isTraceEnabled()) {
			logger.trace("Resolved context configuration attributes: " + attributes);
		}
		attributesList.add(attributes);
	}

}
