/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.test.context.jdbc;

import java.lang.reflect.Array;
import java.util.Arrays;

import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.style.ToStringCreator;
import org.springframework.jdbc.datasource.init.ScriptUtils;
import org.springframework.lang.Nullable;
import org.springframework.test.context.jdbc.SqlConfig.ErrorMode;
import org.springframework.test.context.jdbc.SqlConfig.TransactionMode;
import org.springframework.util.Assert;

/**
 * {@code MergedSqlConfig} encapsulates the <em>merged</em> {@link SqlConfig @SqlConfig}
 * attributes declared locally via {@link Sql#config} and globally as a class-level annotation.
 *
 * <p>Explicit local configuration attributes override global configuration attributes.
 *
 * @author Sam Brannen
 * @since 4.1
 * @see SqlConfig
 */
/**
 * {@code  MergedSqlConfig}封装了<em> merged </ em> {@link  SqlConfig @SqlConfig}属性，这些属性是通过{@link  Sql＃config}在本地声明的，并在全局范围内作为类级注释。 
 *  <p>显式的本地配置属性将覆盖全局配置属性。 
 *  @author  Sam Brannen @从4.1开始
 * @see  SqlConfig
 */
class MergedSqlConfig {

	private static final String COMMENT_PREFIX = "commentPrefix";

	private static final String COMMENT_PREFIXES = "commentPrefixes";


	private final String dataSource;

	private final String transactionManager;

	private final TransactionMode transactionMode;

	private final String encoding;

	private final String separator;

	private final String[] commentPrefixes;

	private final String blockCommentStartDelimiter;

	private final String blockCommentEndDelimiter;

	private final ErrorMode errorMode;


	/**
	 * Construct a {@code MergedSqlConfig} instance by merging the configuration
	 * from the supplied local (potentially method-level) {@code @SqlConfig} annotation
	 * with class-level configuration discovered on the supplied {@code testClass}.
	 * <p>Local configuration overrides class-level configuration.
	 * <p>If the test class is not annotated with {@code @SqlConfig}, no merging
	 * takes place and the local configuration is used "as is".
	 */
	/**
	 * 通过将提供的本地（可能是方法级别）{<@code> @SqlConfig}注解中的配置与在提供的{@code  testClass}上发现的类级别配置进行合并，构造一个{@code  MergedSqlConfig}实例。 
	 *  <p>本地配置将覆盖类级别的配置。 
	 *  <p>如果测试类未使用{@code  @SqlConfig}进行注释，则不会进行合并，并且本地配置将按"原样"使用。 
	 * 
	 */
	MergedSqlConfig(SqlConfig localSqlConfig, Class<?> testClass) {
		Assert.notNull(localSqlConfig, "Local @SqlConfig must not be null");
		Assert.notNull(testClass, "testClass must not be null");

		AnnotationAttributes mergedAttributes = mergeAttributes(localSqlConfig, testClass);

		this.dataSource = mergedAttributes.getString("dataSource");
		this.transactionManager = mergedAttributes.getString("transactionManager");
		this.transactionMode = getEnum(mergedAttributes, "transactionMode", TransactionMode.DEFAULT,
				TransactionMode.INFERRED);
		this.encoding = mergedAttributes.getString("encoding");
		this.separator = getString(mergedAttributes, "separator", ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
		this.commentPrefixes = getCommentPrefixes(mergedAttributes);
		this.blockCommentStartDelimiter = getString(mergedAttributes, "blockCommentStartDelimiter",
				ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER);
		this.blockCommentEndDelimiter = getString(mergedAttributes, "blockCommentEndDelimiter",
				ScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);
		this.errorMode = getEnum(mergedAttributes, "errorMode", ErrorMode.DEFAULT, ErrorMode.FAIL_ON_ERROR);
	}

	private AnnotationAttributes mergeAttributes(SqlConfig localSqlConfig, Class<?> testClass) {
		AnnotationAttributes localAttributes = AnnotationUtils.getAnnotationAttributes(localSqlConfig, false, false);

		// Enforce comment prefix aliases within the local @SqlConfig.
		enforceCommentPrefixAliases(localAttributes);

		// Get global attributes, if any.
		AnnotationAttributes globalAttributes = AnnotatedElementUtils.findMergedAnnotationAttributes(
				testClass, SqlConfig.class.getName(), false, false);

		// Use local attributes only?
		if (globalAttributes == null) {
			return localAttributes;
		}

		// Enforce comment prefix aliases within the global @SqlConfig.
		enforceCommentPrefixAliases(globalAttributes);

		for (String key : globalAttributes.keySet()) {
			Object value = localAttributes.get(key);
			if (isExplicitValue(value)) {
				// Override global attribute with local attribute.
				globalAttributes.put(key, value);

				// Ensure comment prefix aliases are honored during the merge.
				if (key.equals(COMMENT_PREFIX) && isEmptyArray(localAttributes.get(COMMENT_PREFIXES))) {
					globalAttributes.put(COMMENT_PREFIXES, value);
				}
				else if (key.equals(COMMENT_PREFIXES) && isEmptyString(localAttributes.get(COMMENT_PREFIX))) {
					globalAttributes.put(COMMENT_PREFIX, value);
				}
			}
		}
		return globalAttributes;
	}

	/**
	 * Get the bean name of the {@link javax.sql.DataSource}.
	 * @see SqlConfig#dataSource()
	 */
	/**
	 * 获取{@link  javax.sql.DataSource}的bean名称。 
	 *  
	 * @see  SqlConfig＃dataSource（）
	 */
	String getDataSource() {
		return this.dataSource;
	}

	/**
	 * Get the bean name of the {@link org.springframework.transaction.PlatformTransactionManager}.
	 * @see SqlConfig#transactionManager()
	 */
	/**
	 * 获取{@link  org.springframework.transaction.PlatformTransactionManager}的bean名称。 
	 *  
	 * @see  SqlConfig＃transactionManager（）
	 */
	String getTransactionManager() {
		return this.transactionManager;
	}

	/**
	 * Get the {@link TransactionMode}.
	 * @see SqlConfig#transactionMode()
	 */
	/**
	 * 获取{@link  TransactionMode}。 
	 *  
	 * @see  SqlConfig＃transactionMode（）
	 */
	TransactionMode getTransactionMode() {
		return this.transactionMode;
	}

	/**
	 * Get the encoding for the SQL scripts, if different from the platform
	 * encoding.
	 * @see SqlConfig#encoding()
	 */
	/**
	 * 如果与平台编码不同，请获取SQL脚本的编码。 
	 *  
	 * @see  SqlConfig＃encoding（）
	 */
	String getEncoding() {
		return this.encoding;
	}

	/**
	 * Get the character string used to separate individual statements within the
	 * SQL scripts.
	 * @see SqlConfig#separator()
	 */
	/**
	 * 获取用于分隔SQL脚本中的各个语句的字符串。 
	 *  
	 * @see  SqlConfig＃separator（）
	 */
	String getSeparator() {
		return this.separator;
	}

	/**
	 * Get the prefixes that identify single-line comments within the SQL scripts.
	 * @see SqlConfig#commentPrefixes()
	 * @since 5.2
	 */
	/**
	 * 获取标识SQL脚本中单行注释的前缀。 
	 *  
	 * @see  SqlConfig＃commentPrefixes（）@从5.2开始
	 */
	String[] getCommentPrefixes() {
		return this.commentPrefixes;
	}

	/**
	 * Get the start delimiter that identifies block comments within the SQL scripts.
	 * @see SqlConfig#blockCommentStartDelimiter()
	 */
	/**
	 * 获取标识SQL脚本中的块注释的开始定界符。 
	 *  
	 * @see  SqlConfig＃blockCommentStartDelimiter（）
	 */
	String getBlockCommentStartDelimiter() {
		return this.blockCommentStartDelimiter;
	}

	/**
	 * Get the end delimiter that identifies block comments within the SQL scripts.
	 * @see SqlConfig#blockCommentEndDelimiter()
	 */
	/**
	 * 获取标识SQL脚本中块注释的结尾定界符。 
	 *  
	 * @see  SqlConfig＃blockCommentEndDelimiter（）
	 */
	String getBlockCommentEndDelimiter() {
		return this.blockCommentEndDelimiter;
	}

	/**
	 * Get the {@link ErrorMode}.
	 * @see SqlConfig#errorMode()
	 */
	/**
	 * 获取{@link  ErrorMode}。 
	 *  
	 * @see  SqlConfig＃errorMode（）
	 */
	ErrorMode getErrorMode() {
		return this.errorMode;
	}

	/**
	 * Provide a String representation of the merged SQL script configuration.
	 */
	/**
	 * 提供合并的SQL脚本配置的String表示形式。 
	 * 
	 */
	@Override
	public String toString() {
		return new ToStringCreator(this)
				.append("dataSource", this.dataSource)
				.append("transactionManager", this.transactionManager)
				.append("transactionMode", this.transactionMode)
				.append("encoding", this.encoding)
				.append("separator", this.separator)
				.append("commentPrefixes", this.commentPrefixes)
				.append("blockCommentStartDelimiter", this.blockCommentStartDelimiter)
				.append("blockCommentEndDelimiter", this.blockCommentEndDelimiter)
				.append("errorMode", this.errorMode)
				.toString();
	}


	private static <E extends Enum<?>> E getEnum(AnnotationAttributes attributes, String attributeName,
			E inheritedOrDefaultValue, E defaultValue) {

		E value = attributes.getEnum(attributeName);
		if (value == inheritedOrDefaultValue) {
			value = defaultValue;
		}
		return value;
	}

	private static String getString(AnnotationAttributes attributes, String attributeName, String defaultValue) {
		String value = attributes.getString(attributeName);
		if ("".equals(value)) {
			value = defaultValue;
		}
		return value;
	}

	private static void enforceCommentPrefixAliases(AnnotationAttributes attributes) {
		String commentPrefix = attributes.getString(COMMENT_PREFIX);
		String[] commentPrefixes = attributes.getStringArray(COMMENT_PREFIXES);

		boolean explicitCommentPrefix = !commentPrefix.isEmpty();
		boolean explicitCommentPrefixes = (commentPrefixes.length != 0);
		Assert.isTrue(!(explicitCommentPrefix && explicitCommentPrefixes),
			"You may declare the 'commentPrefix' or 'commentPrefixes' attribute in @SqlConfig but not both");

		if (explicitCommentPrefix) {
			Assert.hasText(commentPrefix, "@SqlConfig(commentPrefix) must contain text");
			attributes.put(COMMENT_PREFIXES, new String[] { commentPrefix });
		}
		else if (explicitCommentPrefixes) {
			for (String prefix : commentPrefixes) {
				Assert.hasText(prefix, "@SqlConfig(commentPrefixes) must not contain empty prefixes");
			}
			attributes.put(COMMENT_PREFIX, commentPrefixes);
		}
		else {
			// We know commentPrefixes is an empty array, so make sure commentPrefix
			// is set to that as well in order to honor the alias contract.
			attributes.put(COMMENT_PREFIX, commentPrefixes);
		}
	}

	private static String[] getCommentPrefixes(AnnotationAttributes attributes) {
		String[] commentPrefix = attributes.getStringArray(COMMENT_PREFIX);
		String[] commentPrefixes = attributes.getStringArray(COMMENT_PREFIXES);

		Assert.state(Arrays.equals(commentPrefix, commentPrefixes),
			"Failed to properly handle 'commentPrefix' and 'commentPrefixes' aliases");

		return (commentPrefixes.length != 0 ? commentPrefixes : ScriptUtils.DEFAULT_COMMENT_PREFIXES);
	}

	/**
	 * Determine if the supplied value is an explicit value (i.e., not a default).
	 */
	/**
	 * 确定提供的值是否为显式值（即不是默认值）。 
	 * 
	 */
	private static boolean isExplicitValue(@Nullable Object value) {
		return !(isEmptyString(value) ||
				isEmptyArray(value) ||
				value == TransactionMode.DEFAULT ||
				value == ErrorMode.DEFAULT);
	}

	private static boolean isEmptyString(@Nullable Object value) {
		return (value instanceof String && ((String) value).isEmpty());
	}

	private static boolean isEmptyArray(@Nullable Object value) {
		return (value != null && value.getClass().isArray() && Array.getLength(value) == 0);
	}

}
