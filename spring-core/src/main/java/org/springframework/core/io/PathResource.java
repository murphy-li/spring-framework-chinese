/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.io;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URL;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * {@link Resource} implementation for {@link java.nio.file.Path} handles,
 * performing all operations and transformations via the {@code Path} API.
 * Supports resolution as a {@link File} and also as a {@link URL}.
 * Implements the extended {@link WritableResource} interface.
 *
 * <p>Note: As of 5.1, {@link java.nio.file.Path} support is also available
 * in {@link FileSystemResource#FileSystemResource(Path) FileSystemResource},
 * applying Spring's standard String-based path transformations but
 * performing all operations via the {@link java.nio.file.Files} API.
 * This {@code PathResource} is effectively a pure {@code java.nio.path.Path}
 * based alternative with different {@code createRelative} behavior.
 *
 * @author Philippe Marschall
 * @author Juergen Hoeller
 * @since 4.0
 * @see java.nio.file.Path
 * @see java.nio.file.Files
 * @see FileSystemResource
 */
/**
 * {@link  java.nio.file.Path}的{@link  Resource}实现通过{@code  Path} API执行所有操作和转换。 
 * 支持解析为{@link  File}和{@link  URL}。 
 * 实现扩展的{@link  WritableResource}接口。 
 *  <p>注意：从5.1版本开始，{<@link> FileSystemResource＃FileSystemResource（Path）FileSystemResource}中也提供了{@link  java.nio.file.Path}支持，应用了Spring的标准基于字符串的路径转换，但是通过{@link  java.nio.file.Files} API执行所有操作。 
 * 这个{@code  PathResource}实际上是一个基于纯{@code  java.nio.path.Path}的替代方案，具有不同的{@code  createRelative}行为。 
 *  @author  Philippe Marschall @author  Juergen Hoeller @始于4.0 
 * @see  java.nio.file.Path 
 * @see  java.nio.file.Files 
 * @see  FileSystemResource
 */
public class PathResource extends AbstractResource implements WritableResource {

	private final Path path;


	/**
	 * Create a new PathResource from a Path handle.
	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources
	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>
	 * the given root: e.g. Paths.get("C:/dir1/"), relative path "dir2" -> "C:/dir1/dir2"!
	 * @param path a Path handle
	 */
	/**
	 * 从路径句柄创建一个新的PathResource。 
	 *  <p>注意：与{@link  FileSystemResource}不同，当通过{@link  #createRelative}构建相对资源时，相对路径将在给定的根<i>下</ i>下构建： Paths.get（"C：/ dir1 /"），相对路径"dir2"->"C：/ dir1 / dir2"！ 
	 *  
	 * @param 路径路径句柄
	 */
	public PathResource(Path path) {
		Assert.notNull(path, "Path must not be null");
		this.path = path.normalize();
	}

	/**
	 * Create a new PathResource from a Path handle.
	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources
	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>
	 * the given root: e.g. Paths.get("C:/dir1/"), relative path "dir2" -> "C:/dir1/dir2"!
	 * @param path a path
	 * @see java.nio.file.Paths#get(String, String...)
	 */
	/**
	 * 从路径句柄创建一个新的PathResource。 
	 *  <p>注意：与{@link  FileSystemResource}不同，当通过{@link  #createRelative}构建相对资源时，相对路径将在给定的根<i>下</ i>下构建： Paths.get（"C：/ dir1 /"），相对路径"dir2"->"C：/ dir1 / dir2"！ 
	 *  
	 * @param 路径路径
	 * @see  java.nio.file.Paths＃get（String，String ...）
	 */
	public PathResource(String path) {
		Assert.notNull(path, "Path must not be null");
		this.path = Paths.get(path).normalize();
	}

	/**
	 * Create a new PathResource from a Path handle.
	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources
	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>
	 * the given root: e.g. Paths.get("C:/dir1/"), relative path "dir2" -> "C:/dir1/dir2"!
	 * @param uri a path URI
	 * @see java.nio.file.Paths#get(URI)
	 */
	/**
	 * 从路径句柄创建一个新的PathResource。 
	 *  <p>注意：与{@link  FileSystemResource}不同，当通过{@link  #createRelative}构建相对资源时，相对路径将在给定的根<i>下</ i>下构建： Paths.get（"C：/ dir1 /"），相对路径"dir2"->"C：/ dir1 / dir2"！ 
	 *  
	 * @param  uri路径URI 
	 * @see  java.nio.file.Paths＃get（URI）
	 */
	public PathResource(URI uri) {
		Assert.notNull(uri, "URI must not be null");
		this.path = Paths.get(uri).normalize();
	}


	/**
	 * Return the file path for this resource.
	 */
	/**
	 * 返回此资源的文件路径。 
	 * 
	 */
	public final String getPath() {
		return this.path.toString();
	}

	/**
	 * This implementation returns whether the underlying file exists.
	 * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)
	 */
	/**
	 * 此实现返回基础文件是否存在。 
	 *  
	 * @see  java.nio.file.Files＃exists（路径，java.nio.file.LinkOption ...）
	 */
	@Override
	public boolean exists() {
		return Files.exists(this.path);
	}

	/**
	 * This implementation checks whether the underlying file is marked as readable
	 * (and corresponds to an actual file with content, not to a directory).
	 * @see java.nio.file.Files#isReadable(Path)
	 * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)
	 */
	/**
	 * 此实现检查基础文件是否标记为可读（并且对应于带有内容的实际文件，而不是目录）。 
	 *  
	 * @see  java.nio.file.Files＃isReadable（Path）
	 * @see  java.nio.file.Files＃isDirectory（Path，java.nio.file.LinkOption ...）
	 */
	@Override
	public boolean isReadable() {
		return (Files.isReadable(this.path) && !Files.isDirectory(this.path));
	}

	/**
	 * This implementation opens a InputStream for the underlying file.
	 * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)
	 */
	/**
	 * 此实现为基础文件打开InputStream。 
	 *  
	 * @see  java.nio.file.spi.FileSystemProvider＃newInputStream（Path，OpenOption ...）
	 */
	@Override
	public InputStream getInputStream() throws IOException {
		if (!exists()) {
			throw new FileNotFoundException(getPath() + " (no such file or directory)");
		}
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + " (is a directory)");
		}
		return Files.newInputStream(this.path);
	}

	/**
	 * This implementation checks whether the underlying file is marked as writable
	 * (and corresponds to an actual file with content, not to a directory).
	 * @see java.nio.file.Files#isWritable(Path)
	 * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)
	 */
	/**
	 * 此实现检查基础文件是否标记为可写（并且对应于带有内容的实际文件，而不是目录）。 
	 *  
	 * @see  java.nio.file.Files＃isWritable（Path）
	 * @see  java.nio.file.Files＃isDirectory（Path，java.nio.file.LinkOption ...）
	 */
	@Override
	public boolean isWritable() {
		return (Files.isWritable(this.path) && !Files.isDirectory(this.path));
	}

	/**
	 * This implementation opens a OutputStream for the underlying file.
	 * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)
	 */
	/**
	 * 此实现为基础文件打开一个OutputStream。 
	 *  
	 * @see  java.nio.file.spi.FileSystemProvider＃newOutputStream（Path，OpenOption ...）
	 */
	@Override
	public OutputStream getOutputStream() throws IOException {
		if (Files.isDirectory(this.path)) {
			throw new FileNotFoundException(getPath() + " (is a directory)");
		}
		return Files.newOutputStream(this.path);
	}

	/**
	 * This implementation returns a URL for the underlying file.
	 * @see java.nio.file.Path#toUri()
	 * @see java.net.URI#toURL()
	 */
	/**
	 * 此实现返回基础文件的URL。 
	 *  
	 * @see  java.nio.file.Path＃toUri（）
	 * @see  java.net.URI＃toURL（）
	 */
	@Override
	public URL getURL() throws IOException {
		return this.path.toUri().toURL();
	}

	/**
	 * This implementation returns a URI for the underlying file.
	 * @see java.nio.file.Path#toUri()
	 */
	/**
	 * 此实现返回基础文件的URI。 
	 *  
	 * @see  java.nio.file.Path＃toUri（）
	 */
	@Override
	public URI getURI() throws IOException {
		return this.path.toUri();
	}

	/**
	 * This implementation always indicates a file.
	 */
	/**
	 * 此实现始终指示一个文件。 
	 * 
	 */
	@Override
	public boolean isFile() {
		return true;
	}

	/**
	 * This implementation returns the underlying File reference.
	 */
	/**
	 * 此实现返回基础的File引用。 
	 * 
	 */
	@Override
	public File getFile() throws IOException {
		try {
			return this.path.toFile();
		}
		catch (UnsupportedOperationException ex) {
			// Only paths on the default file system can be converted to a File:
			// Do exception translation for cases where conversion is not possible.
			throw new FileNotFoundException(this.path + " cannot be resolved to absolute file path");
		}
	}

	/**
	 * This implementation opens a Channel for the underlying file.
	 * @see Files#newByteChannel(Path, OpenOption...)
	 */
	/**
	 * 此实现为基础文件打开一个Channel。 
	 *  
	 * @see  Files＃newByteChannel（Path，OpenOption ...）
	 */
	@Override
	public ReadableByteChannel readableChannel() throws IOException {
		try {
			return Files.newByteChannel(this.path, StandardOpenOption.READ);
		}
		catch (NoSuchFileException ex) {
			throw new FileNotFoundException(ex.getMessage());
		}
	}

	/**
	 * This implementation opens a Channel for the underlying file.
	 * @see Files#newByteChannel(Path, OpenOption...)
	 */
	/**
	 * 此实现为基础文件打开一个Channel。 
	 *  
	 * @see  Files＃newByteChannel（Path，OpenOption ...）
	 */
	@Override
	public WritableByteChannel writableChannel() throws IOException {
		return Files.newByteChannel(this.path, StandardOpenOption.WRITE);
	}

	/**
	 * This implementation returns the underlying file's length.
	 */
	/**
	 * 此实现返回基础文件的长度。 
	 * 
	 */
	@Override
	public long contentLength() throws IOException {
		return Files.size(this.path);
	}

	/**
	 * This implementation returns the underlying File's timestamp.
	 * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)
	 */
	/**
	 * 此实现返回基础文件的时间戳。 
	 *  
	 * @see  java.nio.file.Files＃getLastModifiedTime（路径，java.nio.file.LinkOption ...）
	 */
	@Override
	public long lastModified() throws IOException {
		// We can not use the superclass method since it uses conversion to a File and
		// only a Path on the default file system can be converted to a File...
		return Files.getLastModifiedTime(this.path).toMillis();
	}

	/**
	 * This implementation creates a PathResource, applying the given path
	 * relative to the path of the underlying file of this resource descriptor.
	 * @see java.nio.file.Path#resolve(String)
	 */
	/**
	 * 此实现创建一个PathResource，将给定的路径相对于此资源描述符的基础文件的路径应用。 
	 *  
	 * @see  java.nio.file.Path＃resolve（字符串）
	 */
	@Override
	public Resource createRelative(String relativePath) {
		return new PathResource(this.path.resolve(relativePath));
	}

	/**
	 * This implementation returns the name of the file.
	 * @see java.nio.file.Path#getFileName()
	 */
	/**
	 * 此实现返回文件的名称。 
	 *  
	 * @see  java.nio.file.Path＃getFileName（）
	 */
	@Override
	public String getFilename() {
		return this.path.getFileName().toString();
	}

	@Override
	public String getDescription() {
		return "path [" + this.path.toAbsolutePath() + "]";
	}


	/**
	 * This implementation compares the underlying Path references.
	 */
	/**
	 * 此实现比较底层的Path引用。 
	 * 
	 */
	@Override
	public boolean equals(@Nullable Object other) {
		return (this == other || (other instanceof PathResource &&
				this.path.equals(((PathResource) other).path)));
	}

	/**
	 * This implementation returns the hash code of the underlying Path reference.
	 */
	/**
	 * 此实现返回基础Path引用的哈希码。 
	 * 
	 */
	@Override
	public int hashCode() {
		return this.path.hashCode();
	}

}
