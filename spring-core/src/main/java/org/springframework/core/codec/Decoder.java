/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.codec;

import java.util.List;
import java.util.Map;

import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.MonoProcessor;

import org.springframework.core.ResolvableType;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.MimeType;

/**
 * Strategy for decoding a {@link DataBuffer} input stream into an output stream
 * of elements of type {@code <T>}.
 *
 * @author Sebastien Deleuze
 * @author Rossen Stoyanchev
 * @since 5.0
 * @param <T> the type of elements in the output stream
 */
/**
 * 将{@link  DataBuffer}输入流解码为类型为{@code  <T>}的元素的输出流的策略。 
 *  @author  Sebastien Deleuze @author  Rossen Stoyanchev @从5.0开始
 * @param  <T>输出流中元素的类型
 */
public interface Decoder<T> {

	/**
	 * Whether the decoder supports the given target element type and the MIME
	 * type of the source stream.
	 * @param elementType the target element type for the output stream
	 * @param mimeType the mime type associated with the stream to decode
	 * (can be {@code null} if not specified)
	 * @return {@code true} if supported, {@code false} otherwise
	 */
	/**
	 * 解码器是否支持给定的目标元素类型和源流的MIME类型。 
	 *  
	 * @param  elementType输出流的目标元素类型
	 * @param  mimeType与要解码的流关联的mime类型（如果未指定，可以为{@code  null}）
	 * @return  {@code 如果支持，则为true}，否则为{@code  false}
	 */
	boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType);

	/**
	 * Decode a {@link DataBuffer} input stream into a Flux of {@code T}.
	 * @param inputStream the {@code DataBuffer} input stream to decode
	 * @param elementType the expected type of elements in the output stream;
	 * this type must have been previously passed to the {@link #canDecode}
	 * method and it must have returned {@code true}.
	 * @param mimeType the MIME type associated with the input stream (optional)
	 * @param hints additional information about how to do encode
	 * @return the output stream with decoded elements
	 */
	/**
	 * 将{@link  DataBuffer}输入流解码为{@code  T}的流量。 
	 *  
	 * @param  inputStream {@code  DataBuffer}输入流以解码
	 * @param  elementType输出流中期望的元素类型； 
	 * 此类型必须事先已传递给{@link  #canDecode}方法，并且必须已返回{@code  true}。 
	 *  
	 * @param  mimeType与输入流关联的MIME类型（可选）
	 * @param 提示有关如何对具有解码元素的输出流进行编码的其他信息。 
	 * 
	 */
	Flux<T> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);

	/**
	 * Decode a {@link DataBuffer} input stream into a Mono of {@code T}.
	 * @param inputStream the {@code DataBuffer} input stream to decode
	 * @param elementType the expected type of elements in the output stream;
	 * this type must have been previously passed to the {@link #canDecode}
	 * method and it must have returned {@code true}.
	 * @param mimeType the MIME type associated with the input stream (optional)
	 * @param hints additional information about how to do encode
	 * @return the output stream with the decoded element
	 */
	/**
	 * 将{@link  DataBuffer}输入流解码为{@code  T}的Mono。 
	 *  
	 * @param  inputStream {@code  DataBuffer}输入流以解码
	 * @param  elementType输出流中期望的元素类型； 
	 * 此类型必须事先已传递给{@link  #canDecode}方法，并且必须已返回{@code  true}。 
	 *  
	 * @param  mimeType与输入流关联的MIME类型（可选）
	 * @param 提示有关如何对具有解码元素的输出流进行编码的其他信息。 
	 * 
	 */
	Mono<T> decodeToMono(Publisher<DataBuffer> inputStream, ResolvableType elementType,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints);

	/**
	 * Decode a data buffer to an Object of type T. This is useful for scenarios,
	 * that distinct messages (or events) are decoded and handled individually,
	 * in fully aggregated form.
	 * @param buffer the {@code DataBuffer} to decode
	 * @param targetType the expected output type
	 * @param mimeType the MIME type associated with the data
	 * @param hints additional information about how to do encode
	 * @return the decoded value, possibly {@code null}
	 * @since 5.2
	 */
	/**
	 * 将数据缓冲区解码为类型T的对象。 
	 * 这对于以下情况很有用：以完全聚合的形式分别解码和处理不同的消息（或事件）。 
	 *  
	 * @param 缓冲{@code  DataBuffer}以解码
	 * @param  targetType预期的输出类型
	 * @param  mimeType与数据关联的MIME类型
	 * @param 提示有关如何进行编码的其他信息<@返回>解码值，可能为{@code  null} @5.2开始
	 */
	@Nullable
	default T decode(DataBuffer buffer, ResolvableType targetType,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) throws DecodingException {

		MonoProcessor<T> processor = MonoProcessor.create();
		decodeToMono(Mono.just(buffer), targetType, mimeType, hints).subscribeWith(processor);

		Assert.state(processor.isTerminated(), "DataBuffer decoding should have completed.");
		Throwable ex = processor.getError();
		if (ex != null) {
			throw (ex instanceof CodecException ? (CodecException) ex :
					new DecodingException("Failed to decode: " + ex.getMessage(), ex));
		}
		return processor.peek();
	}

	/**
	 * Return the list of MIME types this decoder supports.
	 */
	/**
	 * 返回此解码器支持的MIME类型的列表。 
	 * 
	 */
	List<MimeType> getDecodableMimeTypes();

}
