/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2015的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * {@code @AliasFor} is an annotation that is used to declare aliases for
 * annotation attributes.
 *
 * <h3>Usage Scenarios</h3>
 * <ul>
 * <li><strong>Explicit aliases within an annotation</strong>: within a single
 * annotation, {@code @AliasFor} can be declared on a pair of attributes to
 * signal that they are interchangeable aliases for each other.</li>
 * <li><strong>Explicit alias for attribute in meta-annotation</strong>: if the
 * {@link #annotation} attribute of {@code @AliasFor} is set to a different
 * annotation than the one that declares it, the {@link #attribute} is
 * interpreted as an alias for an attribute in a meta-annotation (i.e., an
 * explicit meta-annotation attribute override). This enables fine-grained
 * control over exactly which attributes are overridden within an annotation
 * hierarchy. In fact, with {@code @AliasFor} it is even possible to declare
 * an alias for the {@code value} attribute of a meta-annotation.</li>
 * <li><strong>Implicit aliases within an annotation</strong>: if one or
 * more attributes within an annotation are declared as attribute overrides
 * for the same meta-annotation attribute (either directly or transitively),
 * those attributes will be treated as a set of <em>implicit</em> aliases
 * for each other, resulting in behavior analogous to that for explicit
 * aliases within an annotation.</li>
 * </ul>
 *
 * <h3>Usage Requirements</h3>
 * <p>Like with any annotation in Java, the mere presence of {@code @AliasFor}
 * on its own will not enforce alias semantics. For alias semantics to be
 * enforced, annotations must be <em>loaded</em> via {@link MergedAnnotations}.
 *
 * <h3>Implementation Requirements</h3>
 * <ul>
 * <li><strong>Explicit aliases within an annotation</strong>:
 * <ol>
 * <li>Each attribute that makes up an aliased pair should be annotated with
 * {@code @AliasFor}, and either {@link #attribute} or {@link #value} must
 * reference the <em>other</em> attribute in the pair. Since Spring Framework
 * 5.2.1 it is technically possible to annotate only one of the attributes in an
 * aliased pair; however, it is recommended to annotate both attributes in an
 * aliased pair for better documentation as well as compatibility with previous
 * versions of the Spring Framework.</li>
 * <li>Aliased attributes must declare the same return type.</li>
 * <li>Aliased attributes must declare a default value.</li>
 * <li>Aliased attributes must declare the same default value.</li>
 * <li>{@link #annotation} should not be declared.</li>
 * </ol>
 * </li>
 * <li><strong>Explicit alias for attribute in meta-annotation</strong>:
 * <ol>
 * <li>The attribute that is an alias for an attribute in a meta-annotation
 * must be annotated with {@code @AliasFor}, and {@link #attribute} must
 * reference the attribute in the meta-annotation.</li>
 * <li>Aliased attributes must declare the same return type.</li>
 * <li>{@link #annotation} must reference the meta-annotation.</li>
 * <li>The referenced meta-annotation must be <em>meta-present</em> on the
 * annotation class that declares {@code @AliasFor}.</li>
 * </ol>
 * </li>
 * <li><strong>Implicit aliases within an annotation</strong>:
 * <ol>
 * <li>Each attribute that belongs to a set of implicit aliases must be
 * annotated with {@code @AliasFor}, and {@link #attribute} must reference
 * the same attribute in the same meta-annotation (either directly or
 * transitively via other explicit meta-annotation attribute overrides
 * within the annotation hierarchy).</li>
 * <li>Aliased attributes must declare the same return type.</li>
 * <li>Aliased attributes must declare a default value.</li>
 * <li>Aliased attributes must declare the same default value.</li>
 * <li>{@link #annotation} must reference an appropriate meta-annotation.</li>
 * <li>The referenced meta-annotation must be <em>meta-present</em> on the
 * annotation class that declares {@code @AliasFor}.</li>
 * </ol>
 * </li>
 * </ul>
 *
 * <h3>Example: Explicit Aliases within an Annotation</h3>
 * <p>In {@code @ContextConfiguration}, {@code value} and {@code locations}
 * are explicit aliases for each other.
 *
 * <pre class="code"> public &#064;interface ContextConfiguration {
 *
 *    &#064;AliasFor("locations")
 *    String[] value() default {};
 *
 *    &#064;AliasFor("value")
 *    String[] locations() default {};
 *
 *    // ...
 * }</pre>
 *
 * <h3>Example: Explicit Alias for Attribute in Meta-annotation</h3>
 * <p>In {@code @XmlTestConfig}, {@code xmlFiles} is an explicit alias for
 * {@code locations} in {@code @ContextConfiguration}. In other words,
 * {@code xmlFiles} overrides the {@code locations} attribute in
 * {@code @ContextConfiguration}.
 *
 * <pre class="code"> &#064;ContextConfiguration
 * public &#064;interface XmlTestConfig {
 *
 *    &#064;AliasFor(annotation = ContextConfiguration.class, attribute = "locations")
 *    String[] xmlFiles();
 * }</pre>
 *
 * <h3>Example: Implicit Aliases within an Annotation</h3>
 * <p>In {@code @MyTestConfig}, {@code value}, {@code groovyScripts}, and
 * {@code xmlFiles} are all explicit meta-annotation attribute overrides for
 * the {@code locations} attribute in {@code @ContextConfiguration}. These
 * three attributes are therefore also implicit aliases for each other.
 *
 * <pre class="code"> &#064;ContextConfiguration
 * public &#064;interface MyTestConfig {
 *
 *    &#064;AliasFor(annotation = ContextConfiguration.class, attribute = "locations")
 *    String[] value() default {};
 *
 *    &#064;AliasFor(annotation = ContextConfiguration.class, attribute = "locations")
 *    String[] groovyScripts() default {};
 *
 *    &#064;AliasFor(annotation = ContextConfiguration.class, attribute = "locations")
 *    String[] xmlFiles() default {};
 * }</pre>
 *
 * <h3>Example: Transitive Implicit Aliases within an Annotation</h3>
 * <p>In {@code @GroovyOrXmlTestConfig}, {@code groovy} is an explicit
 * override for the {@code groovyScripts} attribute in {@code @MyTestConfig};
 * whereas, {@code xml} is an explicit override for the {@code locations}
 * attribute in {@code @ContextConfiguration}. Furthermore, {@code groovy}
 * and {@code xml} are transitive implicit aliases for each other, since they
 * both effectively override the {@code locations} attribute in
 * {@code @ContextConfiguration}.
 *
 * <pre class="code"> &#064;MyTestConfig
 * public &#064;interface GroovyOrXmlTestConfig {
 *
 *    &#064;AliasFor(annotation = MyTestConfig.class, attribute = "groovyScripts")
 *    String[] groovy() default {};
 *
 *    &#064;AliasFor(annotation = ContextConfiguration.class, attribute = "locations")
 *    String[] xml() default {};
 * }</pre>
 *
 * <h3>Spring Annotations Supporting Attribute Aliases</h3>
 * <p>As of Spring Framework 4.2, several annotations within core Spring
 * have been updated to use {@code @AliasFor} to configure their internal
 * attribute aliases. Consult the Javadoc for individual annotations as well
 * as the reference manual for details.
 *
 * @author Sam Brannen
 * @since 4.2
 * @see MergedAnnotations
 * @see SynthesizedAnnotation
 */
/**
 * {<<<< @@code >>>> @AliasFor}是一个注释，用于为注释属性声明别名。 
 *  <h3>使用场景</ h3> <ul> <li> <strong>注释中的显式别名</ strong>：在单个注释中，可以声明{<<<< @code >>>> @AliasFor} </ li> <li> <strong>元注释中属性的显式别名</ strong>：如果{<<<< @link >> {<<<< @@>>>> >> @AliasFor}的>> #annotation}属性设置为与声明它的注释不同的注释，{<<<< @link >>>> #attribute}为解释为元注释中属性的别名（即，显式的元注释属性覆盖）。 
 * 这样就可以精确地控制在注释层次结构中哪些属性被覆盖。 
 * 实际上，使用{<<<<< @@>> >>>> @AliasFor}，甚至可以为元注释的{<<<< @@>> >>>> value}属性声明别名。 
 * </ li> <li> <strong>注释中的隐式别名</ strong>：如果将注释中的一个或多个属性声明为同一元注释属性（直接或传递）的属性替代，则将处理这些属性作为彼此的一组<em>隐式</ em>别名，导致行为类似于注释中显式别名的行为。 
 * </ li> </ ul> <h3>使用要求</ h3> <p>像Java中的任何注释一样，仅{{<<<< @@code >>>> @@AliasFor}本身的存在就不会强制使用别名语义。 
 * 为了强制实施别名语义，必须通过{<<<< @@link >>>> MergedAnnotations} <em>加载</ em>注释。 
 *  <h3>实施要求</ h3> <ul> <li> <strong>注释中的显式别名</ strong>：<ol> <li>组成别名对的每个属性都应使用{<<< <@code >>>> @@AliasFor}，并且{<<<< @@link >>>> #attribute}或{<<<< @@link >>>> #value}必须引用<em> other <配对中的/ em>属性。 
 * 从Spring Framework 5.2.1开始，从技术上讲，可以仅对别名对中的一个属性进行注释。 
 * 但是，建议使用别名对对这两个属性进行注释，以获取更好的文档，并与Spring Framework的早期版本兼容。 
 * </ li> <li>别名的属性必须声明相同的返回类型。 
 * </ li> <li >别名属性必须声明一个默认值。 
 * </ li> <li>别名属性必须声明相同的默认值。 
 * </ li> <li> {<<<< @@>>>> #annotation} </ li> </ ol> </ li> <li> <strong>元注释中属性的显式别名</ strong>：<ol> <li>作为元属性中属性别名的属性-annotation必须使用{<<<< @@code >>>> @@AliasFor}进行注释，并且{<<<< @link >>>> #attribute}必须在元注释中引用该属性。 
 * </ li> <li>别名属性必须声明相同的返回类型。 
 * </ li> <li> {<<<< @@link >>>> #annotation}必须引用元注释。 
 * </ li> <li>所引用的元-annotation必须在声明{<<<< @@code >>>> @AliasFor}的注释类上为<em> meta-present </ em>。 
 * </ li> </ ol> </ li> <li> <strong>注释中的隐式别名</ strong>：<ol> <li>属于一组隐式别名的每个属性都必须使用{<<<< @@code >>>进行注释> @AliasFor}和{<<<< @link >>>> #attribute}必须在相同的元注释中引用相同的属性（通过注释层次结构直接或通过其他显式的元注释属性替代传递）。 
 *  </ li> <li>别名属性必须声明相同的返回类型。 
 * </ li> <li>别名属性必须声明默认值。 
 * </ li> <li>别名属性必须声明相同的默认值。 
 * </ li > <li> {<<<< @@link >>>> #annotation}必须引用适当的元注释。 
 * </ li> <li>引用的元注释必须为<em> meta-present </ em>在声明{<<<< @@>> >>>> @AliasFor}的注释类上。 
 * </ li> </ ol> </ li> </ ul> <h3>示例：注释中的显式别名</ h3 > <p>在{<<<< @@>> >>>> @ContextConfiguration}中，{<<<< @@>>>>>>值}和{<<<< @@>>>>>>位置是显式别名F或彼此。 
 *  <pre class ="code"> public @interface ContextConfiguration {@AliasFor（"locations"）String [] value（）default {}; @AliasFor（"value"）String [] location（）默认{}; // ...} </ pre> <h3>示例：元注释中属性的显式别名</ h3> <p>在{<<<< @@code >>>> @XmlTestConfig}中，{<<< <@code >>>> xmlFiles}是{<<<<< @@code >>>> @ContextConfiguration}中{{<<<< @@code >>>>个位置}的显式别名。 
 * 换句话说，{<<<<< @code >>>> xmlFiles}会覆盖{<<<<< @code >>>> @ContextConfiguration}中的{<<<< @@>>>>>>位置属性
 */
/**
 * <pre class ="code"> @ContextConfiguration public @interface XmlTestConfig {@AliasFor（annotation = ContextConfiguration.class，attribute ="locations"）String [] xmlFiles（）; } </ pre> <h3>示例：注释中的隐式别名</ h3> <p>在{<<<< @code >>>> @MyTestConfig}中，{<<<< @@code >>>>值}，{<<<<< @code >>>> groovyScripts}和{<<<< @code >>>> xmlFiles}都是{<<<<< @code >>>的显式元注释属性替代{<<<< @@>>>>>> @ContextConfiguration}中的>位置}属性
 */
/**
 * 因此，这三个属性也是彼此的隐式别名
 */
/**
 * <pre class ="code"> @ContextConfiguration public @interface MyTestConfig {@AliasFor（annotation = ContextConfiguration.class，attribute ="locations"）String [] value（）default {}; @AliasFor（annotation = ContextConfiguration.class，attribute ="locations"）String [] groovyScripts（）默认{}; @AliasFor（annotation = ContextConfiguration.class，attribute ="locations"）String [] xmlFiles（）默认{}; } </ pre> <h3>示例：注释中的传递性隐式别名</ h3> <p>在{<< @code >> @GroovyOrXmlTestConfig}中，{<< @code >> groovy}是对{<<< @code >> @MyTestConfig}中的{<< @code >> groovyScripts}属性； 
 * 而{<< @code >> xml}是{<< @code >> @ContextConfiguration}中的{<< @code >> locations}属性的显式替代。 
 * 此外，{<< @code >> groovy}和{<< @code >> xml}彼此是传递的隐式别名，因为它们都有效地覆盖了{<< @代码>> @ContextConfiguration}。 
 *  <pre class ="code"> @MyTestConfig public @interface GroovyOrXmlTestConfig {@AliasFor（annotation = MyTestConfig.class，attribute ="groovyScripts"）String [] groovy（）default {}; @AliasFor（annotation = ContextConfiguration.class，attribute ="locations"）String [] xml（）默认{}; } </ pre> <h3>支持属性别名的Spring注释</ h3> <p>从Spring Framework 4.2开始，核心Spring中的多个注释已更新为使用{<< @code >> @AliasFor}来配置其内部属性别名。 
 * 有关单个注释，请查阅Javadoc； 
 * 有关详细信息，请参考参考手册。 
 *  << @author >> Sam Brannen @从4.2起<< 
 * @see >> MergedAnnotations << 
 * @see >> SynthesizedAnnotation
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface AliasFor {

	/**
	 * Alias for {@link #attribute}.
	 * <p>Intended to be used instead of {@link #attribute} when {@link #annotation}
	 * is not declared &mdash; for example: {@code @AliasFor("value")} instead of
	 * {@code @AliasFor(attribute = "value")}.
	 */
	/**
	 * {@link  #attribute}的别名。 
	 *  <p>打算在未声明{@link  #annotation}时代替{@link  #attribute}使用-例如：{@code  @AliasFor（"value"）}代替{@code  @AliasFor（attribute ="value"）}。 
	 * 
	 */
	@AliasFor("attribute")
	String value() default "";

	/**
	 * The name of the attribute that <em>this</em> attribute is an alias for.
	 * @see #value
	 */
	/**
	 * <em>此</ em>属性是其别名的属性名称。 
	 *  
	 * @see ＃值
	 */
	@AliasFor("value")
	String attribute() default "";

	/**
	 * The type of annotation in which the aliased {@link #attribute} is declared.
	 * <p>Defaults to {@link Annotation}, implying that the aliased attribute is
	 * declared in the same annotation as <em>this</em> attribute.
	 */
	/**
	 * 声明别名{@link  #attribute}的注释类型。 
	 *  <p>默认为{@link 注释}，这意味着别名属性在与<em> this </ em>属性相同的注释中声明。 
	 * 
	 */
	Class<? extends Annotation> annotation() default Annotation.class;

}
