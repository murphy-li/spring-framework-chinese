/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.annotation.Inherited;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.function.Predicate;
import java.util.stream.Stream;

import org.springframework.lang.Nullable;

/**
 * Provides access to a collection of merged annotations, usually obtained
 * from a source such as a {@link Class} or {@link Method}.
 *
 * <p>Each merged annotation represents a view where the attribute values may be
 * "merged" from different source values, typically:
 *
 * <ul>
 * <li>Explicit and Implicit {@link AliasFor @AliasFor} declarations on one or
 * more attributes within the annotation</li>
 * <li>Explicit {@link AliasFor @AliasFor} declarations for a meta-annotation</li>
 * <li>Convention based attribute aliases for a meta-annotation</li>
 * <li>From a meta-annotation declaration</li>
 * </ul>
 *
 * <p>For example, a {@code @PostMapping} annotation might be defined as follows:
 *
 * <pre class="code">
 * &#064;Retention(RetentionPolicy.RUNTIME)
 * &#064;RequestMapping(method = RequestMethod.POST)
 * public &#064;interface PostMapping {
 *
 *     &#064;AliasFor(attribute = "path")
 *     String[] value() default {};
 *
 *     &#064;AliasFor(attribute = "value")
 *     String[] path() default {};
 * }
 * </pre>
 *
 * <p>If a method is annotated with {@code @PostMapping("/home")} it will contain
 * merged annotations for both {@code @PostMapping} and the meta-annotation
 * {@code @RequestMapping}. The merged view of the {@code @RequestMapping}
 * annotation will contain the following attributes:
 *
 * <p><table border="1">
 * <tr>
 * <th>Name</th>
 * <th>Value</th>
 * <th>Source</th>
 * </tr>
 * <tr>
 * <td>value</td>
 * <td>"/home"</td>
 * <td>Declared in {@code @PostMapping}</td>
 * </tr>
 * <tr>
 * <td>path</td>
 * <td>"/home"</td>
 * <td>Explicit {@code @AliasFor}</td>
 * </tr>
 * <tr>
 * <td>method</td>
 * <td>RequestMethod.POST</td>
 * <td>Declared in meta-annotation</td>
 * </tr>
 * </table>
 *
 * <p>{@link MergedAnnotations} can be obtained {@linkplain #from(AnnotatedElement)
 * from} any Java {@link AnnotatedElement}. They may also be used for sources that
 * don't use reflection (such as those that directly parse bytecode).
 *
 * <p>Different {@linkplain SearchStrategy search strategies} can be used to locate
 * related source elements that contain the annotations to be aggregated. For
 * example, {@link SearchStrategy#TYPE_HIERARCHY} will search both superclasses and
 * implemented interfaces.
 *
 * <p>From a {@link MergedAnnotations} instance you can either
 * {@linkplain #get(String) get} a single annotation, or {@linkplain #stream()
 * stream all annotations} or just those that match {@linkplain #stream(String)
 * a specific type}. You can also quickly tell if an annotation
 * {@linkplain #isPresent(String) is present}.
 *
 * <p>Here are some typical examples:
 *
 * <pre class="code">
 * // is an annotation present or meta-present?
 * mergedAnnotations.isPresent(ExampleAnnotation.class);
 *
 * // get the merged "value" attribute of ExampleAnnotation (either directly or
 * // meta-present)
 * mergedAnnotations.get(ExampleAnnotation.class).getString("value");
 *
 * // get all meta-annotations but no directly present annotations
 * mergedAnnotations.stream().filter(MergedAnnotation::isMetaPresent);
 *
 * // get all ExampleAnnotation declarations (including any meta-annotations) and
 * // print the merged "value" attributes
 * mergedAnnotations.stream(ExampleAnnotation.class)
 *     .map(mergedAnnotation -&gt; mergedAnnotation.getString("value"))
 *     .forEach(System.out::println);
 * </pre>
 *
 * @author Phillip Webb
 * @author Sam Brannen
 * @since 5.2
 * @see MergedAnnotation
 * @see MergedAnnotationCollectors
 * @see MergedAnnotationPredicates
 * @see MergedAnnotationSelectors
 */
/**
 * 提供对合并注释的集合的访问，这些注释通常是从{@link  Class}或{@link  Method}之类的来源获得的。 
 *  <p>每个合并的注释表示一个视图，其中属性值可以从不同的源值"合并"，通常是：<ul> <li>显式和隐式{@link  AliasFor @AliasFor}声明，用于一个或多个属性注释</ li> <li>元注释的显式{@link  AliasFor @AliasFor}声明</ li> <li>元注释基于公约的属性别名</ li> <li>从元注释声明</ li> </ ul> <p>例如，可以按以下方式定义{@code  @PostMapping}注释：<pre class ="code"> @Retention（RetentionPolicy.RUNTIME）@RequestMapping（method = RequestMethod.POST）public @interface PostMapping {@AliasFor（attribute ="path"）String [] value（）default {}; @AliasFor（attribute ="value"）String [] path（）默认{}; } </ pre> <p>如果用{@code  @PostMapping（"/ home"）}注释方法，则它将包含{@code  @PostMapping}和元注释{@code  @RequestMapping}。 
 *  {@code  @RequestMapping}注解的合并视图将包含以下属性：<p> <table border ="1"> <tr> <th> Name </ th> <th> Value </ th> <th> Source </ th> </ tr> <tr> <td> value </ td> <td>"/ home"</ td> <td>在{@code  @PostMapping}中声明</ td > </ tr> <tr> <td>路径</ td> <td>"/ home"</ td> <td>显式{@code  @AliasFor} </ td> </ tr> <tr> <td>方法</ td> <td> RequestMethod.POST </ td> <td>在元注释中声明</ td> </ tr> </ table> <p> {<@link> MergedAnnotations}可以从任何Java {@link  AnnotatedElement}中获得{@link  plain #from（AnnotatedElement）。 
 * 它们也可以用于不使用反射的源（例如直接解析字节码的源）。 
 *  <p>不同的{@link  plain SearchStrategy搜索策略}可以用于查找包含要聚合的注释的相关源元素。 
 * 例如，{<@link> SearchStrategy＃TYPE_HIERARCHY}将同时搜索超类和已实现的接口。 
 *  <p>从{@link  MergedAnnotations}实例中，您可以{@link  plain #get（String）获取}单个注释，或{@link  plain #stream（）流所有注释}或仅与{@link  plain #stream（String）特定类型}匹配的那些。 
 * 您还可以快速判断是否存在注释{@link  plain #isPresent（String）}。 
 *  <p>以下是一些典型示例：<pre class ="code"> //是否存在注释或元注释？ mergedAnnotations.isPresent（ExampleAnnotation.class）; //获取ExampleAnnotation的合并后的"value"属性（直接或元表示）mergedAnnotations.get（ExampleAnnotation.class）.getString（"value"）; //获取所有元注释，但不直接显示注释mergedAnnotations.stream（）。 
 * filter（MergedAnnotation :: isMetaPresent）; //获取所有ExampleAnnotation声明（包括任何元注释）并//打印合并的"值"属性mergedAnnotations.stream（ExampleAnnotation.class）.map（mergedAnnotation-> mergedAnnotation.getString（"value"））.forEach（System .out :: println）; </ pre> @author  Phillip Webb @author  Sam Brannen @since 5.2 
 * @see  MergedAnnotation 
 * @see  MergedAnnotationCollectors 
 * @see  MergedAnnotationPredicates 
 * @see  MergedAnnotationSelectors
 */
public interface MergedAnnotations extends Iterable<MergedAnnotation<Annotation>> {

	/**
	 * Determine if the specified annotation is either directly present or
	 * meta-present.
	 * <p>Equivalent to calling {@code get(annotationType).isPresent()}.
	 * @param annotationType the annotation type to check
	 * @return {@code true} if the annotation is present
	 */
	/**
	 * 确定指定的注释是直接存在还是元存在。 
	 *  <p>等效于调用{@code  get（annotationType）.isPresent（）}。 
	 *  
	 * @param 注解键入注解类型以检查
	 * @return  {@code  true}是否存在注解
	 */
	<A extends Annotation> boolean isPresent(Class<A> annotationType);

	/**
	 * Determine if the specified annotation is either directly present or
	 * meta-present.
	 * <p>Equivalent to calling {@code get(annotationType).isPresent()}.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to check
	 * @return {@code true} if the annotation is present
	 */
	/**
	 * 确定指定的注释是直接存在还是元存在。 
	 *  <p>等效于调用{@code  get（annotationType）.isPresent（）}。 
	 *  
	 * @param 注解键入注释类型的标准类名，以检查
	 * @return  {@code  true}是否存在注释
	 */
	boolean isPresent(String annotationType);

	/**
	 * Determine if the specified annotation is directly present.
	 * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.
	 * @param annotationType the annotation type to check
	 * @return {@code true} if the annotation is directly present
	 */
	/**
	 * 确定是否直接存在指定的注释。 
	 *  <p>等效于调用{@code  get（annotationType）.isDirectlyPresent（）}。 
	 *  
	 * @param 注解键入注解类型以检查
	 * @return  {@code  true}是否直接存在注解
	 */
	<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);

	/**
	 * Determine if the specified annotation is directly present.
	 * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to check
	 * @return {@code true} if the annotation is directly present
	 */
	/**
	 * 确定是否直接存在指定的注释。 
	 *  <p>等效于调用{@code  get（annotationType）.isDirectlyPresent（）}。 
	 *  
	 * @param 注解键入注释类型的标准类名，以检查
	 * @return  {@code  true}是否直接存在注释
	 */
	boolean isDirectlyPresent(String annotationType);

	/**
	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching
	 * annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the annotation type to get
	 * @return a {@link MergedAnnotation} instance
	 */
	/**
	 * 获取与指定类型的注解或元注解相匹配的{@link  plain MergedAnnotationSelectors＃nearest（）最近的}，如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注解键入注解类型以获取
	 * @return 一个{@link  MergedAnnotation}实例
	 */
	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType);

	/**
	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching
	 * annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the annotation type to get
	 * @param predicate a predicate that must match, or {@code null} if only
	 * type matching is required
	 * @return a {@link MergedAnnotation} instance
	 * @see MergedAnnotationPredicates
	 */
	/**
	 * 获取与指定类型的注解或元注解相匹配的{@link  plain MergedAnnotationSelectors＃nearest（）最近的}，如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注释键入注释类型以获取必须匹配的谓词
	 * @param 谓词； 
	 * 如果仅需要类型匹配，则返回{@code  null} 
	 * @return 一个{@link  MergedAnnotation}实例<@查看> MergedAnnotationPredicates
	 */
	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,
			@Nullable Predicate<? super MergedAnnotation<A>> predicate);

	/**
	 * Get a matching annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the annotation type to get
	 * @param predicate a predicate that must match, or {@code null} if only
	 * type matching is required
	 * @param selector a selector used to choose the most appropriate annotation
	 * within an aggregate, or {@code null} to select the
	 * {@linkplain MergedAnnotationSelectors#nearest() nearest}
	 * @return a {@link MergedAnnotation} instance
	 * @see MergedAnnotationPredicates
	 * @see MergedAnnotationSelectors
	 */
	/**
	 * 获取指定类型的匹配注释或元注释； 
	 * 如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注记键入注释类型以获取必须匹配的谓词
	 * @param 谓词，如果仅需要类型匹配，则为{@code  null} 
	 * @param 选择器用于在其中选择最合适注释的选择器一个聚合，或{@code  null}以选择{@link  plain MergedAnnotationSelectors＃nearest（）最近的} 
	 * @return 一个{@link  MergedAnnotation}实例
	 * @see  MergedAnnotationPredicates 
	 * @see  MergedAnnotationSelectors
	 */
	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,
			@Nullable Predicate<? super MergedAnnotation<A>> predicate,
			@Nullable MergedAnnotationSelector<A> selector);

	/**
	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching
	 * annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to get
	 * @return a {@link MergedAnnotation} instance
	 */
	/**
	 * 获取与指定类型的注解或元注解相匹配的{@link  plain MergedAnnotationSelectors＃nearest（）最近的}，如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注解键入注解类型的完全限定的类名称，以获取
	 * @return  {@link  MergedAnnotation}实例
	 */
	<A extends Annotation> MergedAnnotation<A> get(String annotationType);

	/**
	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching
	 * annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to get
	 * @param predicate a predicate that must match, or {@code null} if only
	 * type matching is required
	 * @return a {@link MergedAnnotation} instance
	 * @see MergedAnnotationPredicates
	 */
	/**
	 * 获取与指定类型的注解或元注解相匹配的{@link  plain MergedAnnotationSelectors＃nearest（）最近的}，如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注解键入注释类型的完全限定的类名，以获取
	 * @param 谓词必须匹配的谓词； 
	 * 如果仅需要类型匹配，则返回{@code  null} <{return> a {<@link > MergedAnnotation}实例
	 * @see  MergedAnnotationPredicates
	 */
	<A extends Annotation> MergedAnnotation<A> get(String annotationType,
			@Nullable Predicate<? super MergedAnnotation<A>> predicate);

	/**
	 * Get a matching annotation or meta-annotation of the specified type, or
	 * {@link MergedAnnotation#missing()} if none is present.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to get
	 * @param predicate a predicate that must match, or {@code null} if only
	 * type matching is required
	 * @param selector a selector used to choose the most appropriate annotation
	 * within an aggregate, or {@code null} to select the
	 * {@linkplain MergedAnnotationSelectors#nearest() nearest}
	 * @return a {@link MergedAnnotation} instance
	 * @see MergedAnnotationPredicates
	 * @see MergedAnnotationSelectors
	 */
	/**
	 * 获取指定类型的匹配注释或元注释； 
	 * 如果不存在，则获取{@link  MergedAnnotation＃missing（）}。 
	 *  
	 * @param 注解键入注释类型的完全限定的类名称，以获取
	 * @param 谓词必须匹配的谓词； 
	 * 如果仅需要类型匹配，则返回{@code  null} 
	 * @param 选择器在集合中选择最合适的注释，或者选择{@code  null}以选择{@link  plain MergedAnnotationSelectors＃nearest（）最接近的} 
	 * @return 一个{@link  MergedAnnotation}实例
	 * @see  MergedAnnotationPredicates 
	 * @see  MergedAnnotationSelectors
	 */
	<A extends Annotation> MergedAnnotation<A> get(String annotationType,
			@Nullable Predicate<? super MergedAnnotation<A>> predicate,
			@Nullable MergedAnnotationSelector<A> selector);

	/**
	 * Stream all annotations and meta-annotations that match the specified
	 * type. The resulting stream follows the same ordering rules as
	 * {@link #stream()}.
	 * @param annotationType the annotation type to match
	 * @return a stream of matching annotations
	 */
	/**
	 * 流匹配指定类型的所有注释和元注释。 
	 * 生成的流遵循与{@link  #stream（）}相同的排序规则。 
	 *  
	 * @param 注释键入注释类型以匹配
	 * @return 匹配注释流
	 */
	<A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType);

	/**
	 * Stream all annotations and meta-annotations that match the specified
	 * type. The resulting stream follows the same ordering rules as
	 * {@link #stream()}.
	 * @param annotationType the fully qualified class name of the annotation type
	 * to match
	 * @return a stream of matching annotations
	 */
	/**
	 * 流匹配指定类型的所有注释和元注释。 
	 * 生成的流遵循与{@link  #stream（）}相同的排序规则。 
	 *  
	 * @param 注解键入注解类型的完全限定的类名以匹配
	 * @return 匹配注解流
	 */
	<A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType);

	/**
	 * Stream all annotations and meta-annotations contained in this collection.
	 * The resulting stream is ordered first by the
	 * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then
	 * by the annotation distance (with the closest annotations first). This ordering
	 * means that, for most use-cases, the most suitable annotations appear
	 * earliest in the stream.
	 * @return a stream of annotations
	 */
	/**
	 * 流式传输此集合中包含的所有注释和元注释。 
	 * 生成的流首先按{@link  plain MergedAnnotation＃getAggregateIndex（）聚合索引}排序，然后按注释距离排序（首先是最接近的注释）。 
	 * 这种顺序意味着，对于大多数用例而言，最合适的注释最早出现在流中。 
	 *  
	 * @return 注解流
	 */
	Stream<MergedAnnotation<Annotation>> stream();


	/**
	 * Create a new {@link MergedAnnotations} instance containing all
	 * annotations and meta-annotations from the specified element. The
	 * resulting instance will not include any inherited annotations. If you
	 * want to include those as well you should use
	 * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate
	 * {@link SearchStrategy}.
	 * @param element the source element
	 * @return a {@link MergedAnnotations} instance containing the element's
	 * annotations
	 */
	/**
	 * 创建一个新的{@link  MergedAnnotations}实例，其中包含指定元素中的所有注释和元注释。 
	 * 结果实例将不包含任何继承的注释。 
	 * 如果还希望包含这些内容，则应将{@link  #from（AnnotatedElement，SearchStrategy）}与适当的{@link  SearchStrategy}一起使用。 
	 *  
	 * @param 元素是源元素
	 * @return 的{@link  MergedAnnotations}实例，其中包含元素的注释
	 */
	static MergedAnnotations from(AnnotatedElement element) {
		return from(element, SearchStrategy.DIRECT);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance containing all
	 * annotations and meta-annotations from the specified element and,
	 * depending on the {@link SearchStrategy}, related inherited elements.
	 * @param element the source element
	 * @param searchStrategy the search strategy to use
	 * @return a {@link MergedAnnotations} instance containing the merged
	 * element annotations
	 */
	/**
	 * 创建一个新的{@link  MergedAnnotations}实例，该实例包含指定元素中的所有注释和元注释，并取决于{@link  SearchStrategy}的相关继承元素。 
	 *  
	 * @param 元素源元素
	 * @param  searchStrategy搜索策略以使用
	 * @return 包含合并元素注释的{@link  MergedAnnotations}实例
	 */
	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy) {
		return from(element, searchStrategy, RepeatableContainers.standardRepeatables());
	}

	/**
	 * Create a new {@link MergedAnnotations} instance containing all
	 * annotations and meta-annotations from the specified element and,
	 * depending on the {@link SearchStrategy}, related inherited elements.
	 * @param element the source element
	 * @param searchStrategy the search strategy to use
	 * @param repeatableContainers the repeatable containers that may be used by
	 * the element annotations or the meta-annotations
	 * @return a {@link MergedAnnotations} instance containing the merged
	 * element annotations
	 */
	/**
	 * 创建一个新的{@link  MergedAnnotations}实例，该实例包含指定元素中的所有注释和元注释，并取决于{@link  SearchStrategy}的相关继承元素。 
	 *  
	 * @param 元素源元素
	 * @param  searchStrategy搜索策略以使用
	 * @param  repeatableContainers元素注释或元注释可能使用的可重复容器
	 * @return  a {@link  MergedAnnotations包含合并元素注解的实例
	 */
	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,
			RepeatableContainers repeatableContainers) {

		return TypeMappedAnnotations.from(element, searchStrategy, repeatableContainers, AnnotationFilter.PLAIN);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance containing all
	 * annotations and meta-annotations from the specified element and,
	 * depending on the {@link SearchStrategy}, related inherited elements.
	 * @param element the source element
	 * @param searchStrategy the search strategy to use
	 * @param repeatableContainers the repeatable containers that may be used by
	 * the element annotations or the meta-annotations
	 * @param annotationFilter an annotation filter used to restrict the
	 * annotations considered
	 * @return a {@link MergedAnnotations} instance containing the merged
	 * element annotations
	 */
	/**
	 * 创建一个新的{@link  MergedAnnotations}实例，该实例包含指定元素中的所有注释和元注释，并取决于{@link  SearchStrategy}的相关继承元素。 
	 *  
	 * @param 元素源元素
	 * @param  searchStrategy搜索策略以使用
	 * @param  repeatableContainers元素注解或元注解可能使用的可重复容器
	 * @param 注解用于限制的注解过滤器注释被视为
	 * @return 一个{@link  MergedAnnotations}实例，其中包含合并的元素注释
	 */
	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,
			RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {

		return TypeMappedAnnotations.from(element, searchStrategy, repeatableContainers, annotationFilter);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance from the specified
	 * annotations.
	 * @param annotations the annotations to include
	 * @return a {@link MergedAnnotations} instance containing the annotations
	 * @see #from(Object, Annotation...)
	 */
	/**
	 * 从指定的注释中创建一个新的{@link  MergedAnnotations}实例。 
	 *  
	 * @param 注解注解以包括
	 * @return 一个包含注解的{@link  MergedAnnotations}实例
	 * @see  #from（Object，Annotation ...）
	 */
	static MergedAnnotations from(Annotation... annotations) {
		return from(annotations, annotations);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance from the specified
	 * annotations.
	 * @param source the source for the annotations. This source is used only
	 * for information and logging. It does not need to <em>actually</em>
	 * contain the specified annotations, and it will not be searched.
	 * @param annotations the annotations to include
	 * @return a {@link MergedAnnotations} instance containing the annotations
	 * @see #from(Annotation...)
	 * @see #from(AnnotatedElement)
	 */
	/**
	 * 从指定的注释中创建一个新的{@link  MergedAnnotations}实例。 
	 *  
	 * @param 来源注释的来源。 
	 * 此源仅用于信息和日志记录。 
	 * 它不需要<em>实际上</ em>包含指定的注释，并且不会进行搜索。 
	 *  
	 * @param 注释注释以包含
	 * @return 一个包含注释的{@link  MergedAnnotations}实例
	 * @see  #from（Annotation ...）
	 * @see  #from（AnnotatedElement）
	 */
	static MergedAnnotations from(Object source, Annotation... annotations) {
		return from(source, annotations, RepeatableContainers.standardRepeatables());
	}

	/**
	 * Create a new {@link MergedAnnotations} instance from the specified
	 * annotations.
	 * @param source the source for the annotations. This source is used only
	 * for information and logging. It does not need to <em>actually</em>
	 * contain the specified annotations, and it will not be searched.
	 * @param annotations the annotations to include
	 * @param repeatableContainers the repeatable containers that may be used by
	 * meta-annotations
	 * @return a {@link MergedAnnotations} instance containing the annotations
	 */
	/**
	 * 从指定的注释中创建一个新的{@link  MergedAnnotations}实例。 
	 *  
	 * @param 来源注释的来源。 
	 * 此源仅用于信息和日志记录。 
	 * 它不需要<em>实际上</ em>包含指定的注释，并且不会进行搜索。 
	 *  
	 * @param 注解注释，以包括
	 * @param  repeatableContainers可重复使用的容器，可由元注解使用
	 * @return 包含注解的{@link  MergedAnnotations}实例
	 */
	static MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers) {
		return TypeMappedAnnotations.from(source, annotations, repeatableContainers, AnnotationFilter.PLAIN);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance from the specified
	 * annotations.
	 * @param source the source for the annotations. This source is used only
	 * for information and logging. It does not need to <em>actually</em>
	 * contain the specified annotations, and it will not be searched.
	 * @param annotations the annotations to include
	 * @param repeatableContainers the repeatable containers that may be used by
	 * meta-annotations
	 * @param annotationFilter an annotation filter used to restrict the
	 * annotations considered
	 * @return a {@link MergedAnnotations} instance containing the annotations
	 */
	/**
	 * 从指定的注释中创建一个新的{@link  MergedAnnotations}实例。 
	 *  
	 * @param 来源注释的来源。 
	 * 此源仅用于信息和日志记录。 
	 * 它不需要<em>实际上</ em>包含指定的注释，并且不会进行搜索。 
	 *  
	 * @param 注解注释，以包括
	 * @param  repeatableContainers元注释可以使用的可重复容器
	 * @param 注解过滤器，用于限制被视为
	 * @return 的注解的注释过滤器<@
	 * @return> a {@link  MergedAnnotations }包含注释的实例
	 */
	static MergedAnnotations from(Object source, Annotation[] annotations,
			RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {

		return TypeMappedAnnotations.from(source, annotations, repeatableContainers, annotationFilter);
	}

	/**
	 * Create a new {@link MergedAnnotations} instance from the specified
	 * collection of directly present annotations. This method allows a
	 * {@link MergedAnnotations} instance to be created from annotations that
	 * are not necessarily loaded using reflection. The provided annotations
	 * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}
	 * and must have a {@link MergedAnnotation#getAggregateIndex() aggregate
	 * index} of {@code 0}.
	 * <p>
	 * The resulting {@link MergedAnnotations} instance will contain both the
	 * specified annotations, and any meta-annotations that can be read using
	 * reflection.
	 * @param annotations the annotations to include
	 * @return a {@link MergedAnnotations} instance containing the annotations
	 * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)
	 */
	/**
	 * 从指定的直接显示的注释集合中创建一个新的{@link  MergedAnnotations}实例。 
	 * 此方法允许从不一定使用反射加载的注释中创建{@link  MergedAnnotations}实例。 
	 * 提供的注释必须全部为{@link  MergedAnnotation＃isDirectlyPresent（）直接存在}，并且必须具有{@code  0}的{@link  MergedAnnotation＃getAggregateIndex（）聚合索引}。 
	 *  <p>生成的{@link  MergedAnnotations}实例将包含指定的注释以及可以使用反射读取的任何元注释。 
	 *  
	 * @param 注解注解以包括
	 * @return 一个包含注解的{@link  MergedAnnotations}实例
	 * @see  MergedAnnotation＃of（ClassLoader，Object，Class，java.util.Map）
	 */
	static MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {
		return MergedAnnotationsCollection.of(annotations);
	}


	/**
	 * Search strategies supported by
	 * {@link MergedAnnotations#from(AnnotatedElement, SearchStrategy)}.
	 *
	 * <p>Each strategy creates a different set of aggregates that will be
	 * combined to create the final {@link MergedAnnotations}.
	 */
	/**
	 * {@link  MergedAnnotations＃from（AnnotatedElement，SearchStrategy）}支持的搜索策略。 
	 *  <p>每个策略都会创建一组不同的聚合，这些聚合将被组合以创建最终的{@link  MergedAnnotations}。 
	 * 
	 */
	enum SearchStrategy {

		/**
		 * Find only directly declared annotations, without considering
		 * {@link Inherited @Inherited} annotations and without searching
		 * superclasses or implemented interfaces.
		 */
		/**
		 * 仅查找直接声明的注释，而不考虑{@link  Inherited @Inherited}注释，并且不搜索超类或已实现的接口。 
		 * 
		 */
		DIRECT,

		/**
		 * Find all directly declared annotations as well as any
		 * {@link Inherited @Inherited} superclass annotations. This strategy
		 * is only really useful when used with {@link Class} types since the
		 * {@link Inherited @Inherited} annotation is ignored for all other
		 * {@linkplain AnnotatedElement annotated elements}. This strategy does
		 * not search implemented interfaces.
		 */
		/**
		 * 查找所有直接声明的注释以及任何{@link  Inherited @Inherited}超类注释。 
		 * 该策略仅在与{@link  Class}类型一起使用时才真正有用，因为对于所有其他{@link  plain AnnotatedElement带注释的元素}，将忽略{@link  Inherited @Inherited}注释。 
		 * 此策略不搜索已实现的接口。 
		 * 
		 */
		INHERITED_ANNOTATIONS,

		/**
		 * Find all directly declared and superclass annotations. This strategy
		 * is similar to {@link #INHERITED_ANNOTATIONS} except the annotations
		 * do not need to be meta-annotated with {@link Inherited @Inherited}.
		 * This strategy does not search implemented interfaces.
		 */
		/**
		 * 查找所有直接声明和超类的注释。 
		 * 此策略与{@link  #INHERITED_ANNOTATIONS}相似，不同之处在于注释不需要使用{@link  Inherited @Inherited}进行元注释。 
		 * 此策略不搜索已实现的接口。 
		 * 
		 */
		SUPERCLASS,

		/**
		 * Perform a full search of the entire type hierarchy, including
		 * superclasses and implemented interfaces. Superclass annotations do
		 * not need to be meta-annotated with {@link Inherited @Inherited}.
		 */
		/**
		 * 对整个类型层次结构进行完整搜索，包括超类和已实现的接口。 
		 * 超类注释不需要使用{@link  Inherited @Inherited}进行元注释。 
		 * 
		 */
		TYPE_HIERARCHY,

		/**
		 * Perform a full search of the entire type hierarchy on the source
		 * <em>and</em> any enclosing classes. This strategy is similar to
		 * {@link #TYPE_HIERARCHY} except that {@linkplain Class#getEnclosingClass()
		 * enclosing classes} are also searched. Superclass annotations do not
		 * need to be meta-annotated with {@link Inherited @Inherited}. When
		 * searching a {@link Method} source, this strategy is identical to
		 * {@link #TYPE_HIERARCHY}.
		 */
		/**
		 * 在源<em>和</ em>上的所有封闭类上执行整个类型层次结构的完整搜索。 
		 * 该策略与{@link  #TYPE_HIERARCHY}相似，不同之处在于，还搜索了{@link  plain Class＃getEnclosingClass（）封闭类}。 
		 * 超类注释不需要使用{@link  Inherited @Inherited}进行元注释。 
		 * 搜索{@link 方法}源时，此策略与{@link  #TYPE_HIERARCHY}相同。 
		 * 
		 */
		TYPE_HIERARCHY_AND_ENCLOSING_CLASSES
	}

}
