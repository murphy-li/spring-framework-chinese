/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.MergedAnnotation.Adapt;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.lang.Nullable;
import org.springframework.util.MultiValueMap;

/**
 * General utility methods for finding annotations, meta-annotations, and
 * repeatable annotations on {@link AnnotatedElement AnnotatedElements}.
 *
 * <p>{@code AnnotatedElementUtils} defines the public API for Spring's
 * meta-annotation programming model with support for <em>annotation attribute
 * overrides</em>. If you do not need support for annotation attribute
 * overrides, consider using {@link AnnotationUtils} instead.
 *
 * <p>Note that the features of this class are not provided by the JDK's
 * introspection facilities themselves.
 *
 * <h3>Annotation Attribute Overrides</h3>
 * <p>Support for meta-annotations with <em>attribute overrides</em> in
 * <em>composed annotations</em> is provided by all variants of the
 * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},
 * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},
 * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},
 * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}
 * methods.
 *
 * <h3>Find vs. Get Semantics</h3>
 * <p>The search algorithms used by methods in this class follow either
 * <em>find</em> or <em>get</em> semantics. Consult the javadocs for each
 * individual method for details on which search algorithm is used.
 *
 * <p><strong>Get semantics</strong> are limited to searching for annotations
 * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared
 * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared
 * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}.
 *
 * <p><strong>Find semantics</strong> are much more exhaustive, providing
 * <em>get semantics</em> plus support for the following:
 *
 * <ul>
 * <li>Searching on interfaces, if the annotated element is a class
 * <li>Searching on superclasses, if the annotated element is a class
 * <li>Resolving bridged methods, if the annotated element is a method
 * <li>Searching on methods in interfaces, if the annotated element is a method
 * <li>Searching on methods in superclasses, if the annotated element is a method
 * </ul>
 *
 * <h3>Support for {@code @Inherited}</h3>
 * <p>Methods following <em>get semantics</em> will honor the contract of Java's
 * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally
 * declared annotations (including custom composed annotations) will be favored over
 * inherited annotations. In contrast, methods following <em>find semantics</em>
 * will completely ignore the presence of {@code @Inherited} since the <em>find</em>
 * search algorithm manually traverses type and method hierarchies and thereby
 * implicitly supports annotation inheritance without a need for {@code @Inherited}.
 *
 * @author Phillip Webb
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 4.0
 * @see AliasFor
 * @see AnnotationAttributes
 * @see AnnotationUtils
 * @see BridgeMethodResolver
 */
/**
 * 在{@link  AnnotatedElement AnnotatedElements}上查找注解，元注解和可重复注解的通用实用程序方法。 
 *  <p> {<@code> AnnotatedElementUtils}定义了Spring的元注释编程模型的公共API，并支持<em>注释属性覆盖</ em>。 
 * 如果不需要注释属性覆盖的支持，请考虑改用{@link  AnnotationUtils}。 
 *  <p>请注意，此类的功能不是JDK的自省功能本身提供的。 
 *  <h3>注释属性覆盖</ h3> <p>所有由{@code 的变体提供的对<em>组合注释</ em>中具有<em>属性覆盖</ em>的元注释的支持getMergedAnnotationAttributes（）}，{<@code> getMergedAnnotation（）}，{<@code> getAllMergedAnnotations（）}，{<@code> getMergedRepeatableAnnotations（）}，{<@code> findMergedAnnotationAttributes（）}，{<@code> findMergedAnnotation（）}，{<@code> findAllMergedAnnotations（）}和{@code  findMergedRepeatableAnnotations（）}方法。 
 *  <h3>查找与获取语义</ h3> <p>此类中的方法使用的搜索算法遵循<em> find </ em>或<em> get </ em>语义。 
 * 有关每种搜索方法的详细信息，请查阅javadocs。 
 *  <p> <strong>获取语义</ strong>仅限于搜索在{@code  AnnotatedElement}（即在本地声明或{@link  plain java .lang.annotation.InheritedInherited}）或在{@code  AnnotatedElement}的注释层次结构<em>上方</ em>中声明。 
 *  <p> <strong>查找语义</ strong>要详尽得多，提供<em> get语义</ em>并支持以下内容：<ul> <li>如果带注释的元素是类，则在接口上搜索<li>如果带注释的元素是类，则搜索超类。 
 * <li>如果通过注释的元素是方法，则解析桥接的方法。 
 * <li>如果带注释的元素是方法，则搜索接口中的方法。 
 * <li>搜索方法在超类中，如果带注释的元素是方法</ ul> <h3>支持{@code  @Inherited} </ h3> <p>遵循<em> get语义</ em>的方法将遵循Java的{@link  java.lang.annotation.Inherited @Inherited}注解，除了本地声明的注解（包括自定义组成的注解）比继承的注解更受青睐。 
 * 相反，遵循<em> find语义</ em>的方法将完全忽略{@code  @Inherited}的存在，因为<em> find </ em>搜索算法手动遍历类型和方法层次结构，从而隐式支持注释继承，无需{@code  @Inherited}。 
 *  @author  Phillip Webb @author  Juergen Hoeller @author  Sam Brannen @since 4.0 
 * @see  AliasFor 
 * @see  AnnotationAttributes 
 * @see  AnnotationUtils 
 * @see  BridgeMethodResolver
 */
public abstract class AnnotatedElementUtils {

	/**
	 * Build an adapted {@link AnnotatedElement} for the given annotations,
	 * typically for use with other methods on {@link AnnotatedElementUtils}.
	 * @param annotations the annotations to expose through the {@code AnnotatedElement}
	 * @since 4.3
	 */
	/**
	 * 为给定的注释构建一个适应的{@link  AnnotatedElement}，通常与{@link  AnnotatedElementUtils}上的其他方法一起使用。 
	 *  
	 * @param 注解通过{@code  AnnotatedElement} @4.3开始公开的注解
	 */
	public static AnnotatedElement forAnnotations(Annotation... annotations) {
		return new AnnotatedElementForAnnotations(annotations);
	}

	/**
	 * Get the fully qualified class names of all meta-annotation types
	 * <em>present</em> on the annotation (of the specified {@code annotationType})
	 * on the supplied {@link AnnotatedElement}.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type on which to find meta-annotations
	 * @return the names of all meta-annotations present on the annotation,
	 * or {@code null} if not found
	 * @since 4.2
	 * @see #getMetaAnnotationTypes(AnnotatedElement, String)
	 * @see #hasMetaAnnotationTypes
	 */
	/**
	 * 在提供的{@link  AnnotatedElement}上的注释（指定的{@code 注解类型}的注解中，获取所有元注解类型<em> present </ em>的全限定类名。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释类型要在其上查找元注释的注释类型
	 * @return 注释中存在的所有元注释的名称，如果找不到，则为{@code  null} @since 4.2 
	 * @see  #getMetaAnnotationTypes（AnnotatedElement，String）
	 * @see  #hasMetaAnnotationTypes
	 */
	public static Set<String> getMetaAnnotationTypes(AnnotatedElement element,
			Class<? extends Annotation> annotationType) {

		return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));
	}

	/**
	 * Get the fully qualified class names of all meta-annotation
	 * types <em>present</em> on the annotation (of the specified
	 * {@code annotationName}) on the supplied {@link AnnotatedElement}.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation
	 * type on which to find meta-annotations
	 * @return the names of all meta-annotations present on the annotation,
	 * or an empty set if none found
	 * @see #getMetaAnnotationTypes(AnnotatedElement, Class)
	 * @see #hasMetaAnnotationTypes
	 */
	/**
	 * 在提供的{@link  AnnotatedElement}上的注释（指定的{@code 注解名称}）上获取所有元注解类型<em> present </ em>的全限定类名。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称在其上查找元注释的注释类型的完全限定的类名
	 * @return 注释中存在的所有元注释的名称，如果为空则为空没有找到
	 * @see  #getMetaAnnotationTypes（AnnotatedElement，Class）
	 * @see  #hasMetaAnnotationTypes
	 */
	public static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {
		for (Annotation annotation : element.getAnnotations()) {
			if (annotation.annotationType().getName().equals(annotationName)) {
				return getMetaAnnotationTypes(element, annotation);
			}
		}
		return Collections.emptySet();
	}

	private static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {
		if (annotation == null) {
			return Collections.emptySet();
		}
		return getAnnotations(annotation.annotationType()).stream()
				.map(mergedAnnotation -> mergedAnnotation.getType().getName())
				.collect(Collectors.toCollection(LinkedHashSet::new));
	}

	/**
	 * Determine if the supplied {@link AnnotatedElement} is annotated with
	 * a <em>composed annotation</em> that is meta-annotated with an
	 * annotation of the specified {@code annotationType}.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the meta-annotation type to find
	 * @return {@code true} if a matching meta-annotation is present
	 * @since 4.2.3
	 * @see #getMetaAnnotationTypes
	 */
	/**
	 * 确定提供的{@link  AnnotatedElement}是否被<em>组成的注释</ em>注释，该注释被指定的{@code 注解类型}的注解进行元注释。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入元注释类型以查找
	 * @return  {@code  true}（如果存在匹配的元注释）（自4.2.3起）
	 * @see  #getMetaAnnotationTypes
	 */
	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {
		return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);
	}

	/**
	 * Determine if the supplied {@link AnnotatedElement} is annotated with a
	 * <em>composed annotation</em> that is meta-annotated with an annotation
	 * of the specified {@code annotationName}.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the
	 * meta-annotation type to find
	 * @return {@code true} if a matching meta-annotation is present
	 * @see #getMetaAnnotationTypes
	 */
	/**
	 * 确定提供的{@link  AnnotatedElement}是否用<em>组成的注释</ em>注释，该注释使用指定的{@code 注解名称}的注解进行元注解。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名元注释类型的完全限定的类名，以找到
	 * @return  {@code  true}（如果存在匹配的元注释）
	 * @see ＃ getMetaAnnotationTypes
	 */
	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {
		return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);
	}

	/**
	 * Determine if an annotation of the specified {@code annotationType}
	 * is <em>present</em> on the supplied {@link AnnotatedElement} or
	 * within the annotation hierarchy <em>above</em> the specified element.
	 * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}
	 * will return a non-null value.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 * @since 4.2.3
	 * @see #hasAnnotation(AnnotatedElement, Class)
	 */
	/**
	 * 确定是否在提供的{@link  AnnotatedElement}上或指定元素的<em>上方</ em>内，<em>存在</ em>指定的{@code 注解类型}的注释。 
	 *  <p>如果此方法返回{@code  true}，则{@link  #getMergedAnnotationAttributes}将返回非空值。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入注释类型以查找
	 * @return  {@code  true}（如果存在匹配的注释，则自4.2.3起）
	 * @see  #hasAnnotation（AnnotatedElement，Class ）
	 */
	public static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {
			return element.isAnnotationPresent(annotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return getAnnotations(element).isPresent(annotationType);
	}

	/**
	 * Determine if an annotation of the specified {@code annotationName} is
	 * <em>present</em> on the supplied {@link AnnotatedElement} or within the
	 * annotation hierarchy <em>above</em> the specified element.
	 * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}
	 * will return a non-null value.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 */
	/**
	 * 确定是否在提供的{@link  AnnotatedElement}上或指定元素的<em>上方</ em>内<em>存在指定的{@code 注解名称}的注解。 
	 *  <p>如果此方法返回{@code  true}，则{@link  #getMergedAnnotationAttributes}将返回非空值。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，如果存在匹配的注解，则找到
	 * @return  {@code  true}
	 */
	public static boolean isAnnotated(AnnotatedElement element, String annotationName) {
		return getAnnotations(element).isPresent(annotationName);
	}

	/**
	 * Get the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次中，获取指定注释层次中指定的{@code 注解类型}的第一个注释，并将该注释的属性与<em> matching </ em>属性合并来自注释层次结构较低级别中的注释。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法委托给{@link  #getMergedAnnotationAttributes（AnnotatedElement，String）}。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入注释类型以找到
	 * @return 合并的{@code  AnnotationAttributes}； 
	 * 如果未找到，则为{@code  null} @自4.2起
	 * @see  #getMergedAnnotationAttributes（AnnotatedElement，String，boolean，boolean）
	 * @see  #findMergedAnnotationAttributes（AnnotatedElement，String，boolean，boolean）
	 * @see  #getMergedAnnotation（AnnotatedElement，Class）
	 * @see  #findMergedAnnotation（AnnotatedElement，
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(
			AnnotatedElement element, Class<? extends Annotation> annotationType) {

		MergedAnnotation<?> mergedAnnotation = getAnnotations(element)
				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());
		return getAnnotationAttributes(mergedAnnotation, false, false);
	}

	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},
	 * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)
	 */
	/**
	 * 在提供的{@code 元素}上方的</ em>注释层次结构中，获取指定的{@code 注解名称}的第一个注释，并将该注释的属性与<em> matching </ em>属性合并来自注释层次结构较低级别中的注释。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法委托给{@link  #getMergedAnnotationAttributes（AnnotatedElement，String，boolean，boolean）}，为{@code  classValuesAsString}和{@code  nestedAnnotationsAsMap}提供{@code  false}。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，用于查找
	 * @return 合并的{@code  AnnotationAttributes}，如果找不到，则为{<@@code> null} @自4.2起@AnnotatedElement，字符串）
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName) {

		return getMergedAnnotationAttributes(element, annotationName, false, false);
	}

	/**
	 * Get the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>Attributes from lower levels in the annotation hierarchy override attributes
	 * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are
	 * fully supported, both within a single annotation and within the annotation hierarchy.
	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by
	 * this method will stop searching the annotation hierarchy once the first annotation
	 * of the specified {@code annotationName} has been found. As a consequence,
	 * additional annotations of the specified {@code annotationName} will be ignored.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances
	 * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	/**
	 * 在提供的{@code 元素}上方的</ em>注释层次结构中，获取指定的{@code 注解名称}的第一个注释，并将该注释的属性与<em> matching </ em>属性合并来自注释层次结构较低级别中的注释。 
	 *  <p>注释层次结构中较低级别的属性会覆盖较高级别中的同名属性，并且在单个注释内和注释层次结构中都完全支持{@link  AliasFor @AliasFor}语义。 
	 *  <p>与{@link  #getAllAnnotationAttributes}相比，一旦找到指定的{@code 注解名称}的第一个注解，此方法使用的搜索算法将停止搜索注解层次。 
	 * 因此，指定的{@code 注解名称}的其他注解将被忽略。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，以查找
	 * @param  classValuesAsString是将Class引用转换为String还是将其保留为Class引用
	 * @param  nestedAnnotationsAsMap是否将嵌套的Annotation实例转换为{@code  AnnotationAttributes}映射，或将其保留为Annotation实例
	 * @return 合并的{@code  AnnotationAttributes}； 
	 * 如果找不到{{@@code> null}，则从4.2开始请参阅> #findMergedAnnotation（AnnotatedElement，Class）<@请参阅#findMergedAnnotationAttributes（AnnotatedElement，字符串，布尔值，布尔值）<@请参阅> #getAllAnnotationAttributes（AnnotatedElement，字符串，布尔值，布尔值）
	 */
	@Nullable
	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		MergedAnnotation<?> mergedAnnotation = getAnnotations(element)
				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());
		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);
	}

	/**
	 * Get the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element},
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy, and synthesize
	 * the result back into an annotation of the specified {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次中，获取指定注释层次中指定的{@code 注解类型}的第一个注释，将该注释的属性与<em> matching </ em>属性合并从注解层次结构较低级别的注解中提取结果，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入注释类型以找到
	 * @return 合并，合成的{@code 注释}； 
	 * 如果未找到，则为{@code  null} @自4.2起<参见> #findMergedAnnotation（AnnotatedElement，Class）
	 */
	@Nullable
	public static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {
			return element.getDeclaredAnnotation(annotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return getAnnotations(element)
				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())
				.synthesize(MergedAnnotation::isPresent).orElse(null);
	}

	/**
	 * Get <strong>all</strong> annotations of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方</ em>的注释层次结构中，获取指定的{@code 注解类型}的<strong>所有</ strong>注解； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不{@code  null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @return 所有合并，合成的集合{已找到@code  Annotations}，如果未找到@，则返回一个空集@since 4.3 
	 * @see  #getMergedAnnotation（AnnotatedElement，Class）
	 * @see  #getAllAnnotationAttributes（AnnotatedElement，String）
	 * @see  #findAllMergedAnnotations（AnnotatedElement，类）
	 */
	public static <A extends Annotation> Set<A> getAllMergedAnnotations(
			AnnotatedElement element, Class<A> annotationType) {

		return getAnnotations(element).stream(annotationType)
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Get <strong>all</strong> annotations of the specified {@code annotationTypes}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the
	 * annotation hierarchy and synthesize the results back into an annotation
	 * of the corresponding {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationTypes the annotation types to find
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 5.1
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方</ em>的注释层次结构中，获取指定的{@code 注解类型}的<strong>所有</ strong>注解； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回对应的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素（带注释的元素）（永远不为{@code  null}）
	 * @param 注解键入注释类型以查找
	 * @return 找到的所有合并，合成的{@code  Annotations}的集合，或空集，如果没有找到，因为@5.1起@
	 * @see> #getAllMergedAnnotations（AnnotatedElement，Class）
	 */
	public static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,
			Set<Class<? extends Annotation>> annotationTypes) {

		return getAnnotations(element).stream()
				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>The container type that holds the repeatable annotations will be looked up
	 * via {@link java.lang.annotation.Repeatable}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的</ em>注释层次结构中，获取指定的{@code 注解类型}的所有<em>可重复的注释</ em>； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 *  <p>将通过{@link  java.lang.annotation.Repeatable}查找包含可重复注释的容器类型。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不{<@@code> null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @return 所有合并的可重复元素的集合{@code  Annotations}； 
	 * 如果未找到，则为空集
	 * @throws  IllegalArgumentException如果{@code 元素}或{@code 注解类型}为{@code  null}，或者容器类型无法解析，因为4.3起
	 * @see  #getMergedAnnotation（AnnotatedElement，Class）
	 * @see  #getAllMergedAnnotations（AnnotatedElement，Class）
	 * @see  #getMergedRepeatableAnnotations（AnnotatedElement，Class，Class）
	 */
	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(
			AnnotatedElement element, Class<A> annotationType) {

		return getMergedRepeatableAnnotations(element, annotationType, null);
	}

	/**
	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @param containerType the type of the container that holds the annotations;
	 * may be {@code null} if the container type should be looked up via
	 * {@link java.lang.annotation.Repeatable}
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @throws AnnotationConfigurationException if the supplied {@code containerType}
	 * is not a valid container annotation for the supplied {@code annotationType}
	 * @since 4.3
	 * @see #getMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的</ em>注释层次结构中，获取指定的{@code 注解类型}的所有<em>可重复的注释</ em>； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不（<{@@code> null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @param  containerType容纳容器的类型注释； 
	 * 如果应该通过{@link  java.lang.annotation.Repeatable} 
	 * @return 查找所有合并的可重复{@code  Annotations}的集合来查找容器类型，则可以为{@code  null}，如果未找到任何内容，则返回一个空集
	 * @throws  IllegalArgumentException如果{@code 元素}或{@code 注记类型}为{@code  null}，或者如果无法解析容器类型，则返回IllegalArgumentException > AnnotationConfigurationException如果提供的{@code 容器类型}不是所提供的{@code 注解类型}的有效容器注释@since 4.3 
	 * @see  #getMergedAnnotation（AnnotatedElement，Class）
	 * @see  #getAllMergedAnnotations（AnnotatedElement ，班级）
	 */
	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(
			AnnotatedElement element, Class<A> annotationType,
			@Nullable Class<? extends Annotation> containerType) {

		return getRepeatableAnnotations(element, containerType, annotationType)
				.stream(annotationType)
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Get the annotation attributes of <strong>all</strong> annotations of the specified
	 * {@code annotationName} in the annotation hierarchy above the supplied
	 * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.
	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},
	 * this method does <em>not</em> support attribute overrides.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation
	 * attributes from all annotations found, or {@code null} if not found
	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	/**
	 * 在提供的{@link  AnnotatedElement}上方的注释层次结构中，获取指定{{@@code>注解名称}的<strong>所有</ strong>注解的注释属性，并将结果存储在{@link  MultiValueMap中}。 
	 *  <p>注意：与{@link  #getMergedAnnotationAttributes（AnnotatedElement，String）}相比，此方法<em> not </ em>不支持属性覆盖。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，以找到
	 * @return 以属性名称为键的{@link  MultiValueMap}，其中包含找到的所有注解的注解属性，或{@code  null}（如果未找到）
	 * @see  #getAllAnnotationAttributes（AnnotatedElement，String，boolean，boolean）
	 */
	@Nullable
	public static MultiValueMap<String, Object> getAllAnnotationAttributes(
			AnnotatedElement element, String annotationName) {

		return getAllAnnotationAttributes(element, annotationName, false, false);
	}

	/**
	 * Get the annotation attributes of <strong>all</strong> annotations of
	 * the specified {@code annotationName} in the annotation hierarchy above
	 * the supplied {@link AnnotatedElement} and store the results in a
	 * {@link MultiValueMap}.
	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},
	 * this method does <em>not</em> support attribute overrides.
	 * <p>This method follows <em>get semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation
	 * attributes from all annotations found, or {@code null} if not found
	 */
	/**
	 * 在提供的{@link  AnnotatedElement}上方的注释层次结构中，获取指定{{@@code>注解名称}的<strong>所有</ strong>注解的注解属性，并将结果存储在{@link  MultiValueMap中}。 
	 *  <p>注意：与{@link  #getMergedAnnotationAttributes（AnnotatedElement，String）}相比，此方法<em> not </ em>不支持属性覆盖。 
	 *  <p>此方法遵循<em> get语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，以查找
	 * @param  classValuesAsString是将Class引用转换为String还是将其保留为Class引用
	 * @param  nestedAnnotationsAsMap是否将嵌套的Annotation实例转换为{@code  AnnotationAttributes}映射，或将其保留为Annotation实例
	 * @return 以属性名称为键的{@link  MultiValueMap}，其中包含找到的所有注释中的注释属性，或{<@代码> null}（如果找不到）
	 */
	@Nullable
	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,
			String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {

		Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);
		return getAnnotations(element).stream(annotationName)
				.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))
				.map(MergedAnnotation::withNonMergedAttributes)
				.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));
	}

	/**
	 * Determine if an annotation of the specified {@code annotationType}
	 * is <em>available</em> on the supplied {@link AnnotatedElement} or
	 * within the annotation hierarchy <em>above</em> the specified element.
	 * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}
	 * will return a non-null value.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return {@code true} if a matching annotation is present
	 * @since 4.3
	 * @see #isAnnotated(AnnotatedElement, Class)
	 */
	/**
	 * 确定所提供的{@link  AnnotatedElement}上或指定元素上方<em> </ em>内指定的{@code 注记类型}的注记是否可用。 
	 *  <p>如果此方法返回{@code  true}，则{@link  #findMergedAnnotationAttributes}将返回非空值。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入注释类型以查找
	 * @return  {@code  true}（如果存在匹配的注释）@自4.3起@
	 * @see> #isAnnotated（AnnotatedElement，Class）
	 */
	public static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {
			return element.isAnnotationPresent(annotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return findAnnotations(element).isPresent(annotationType);
	}

	/**
	 * Find the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>Attributes from lower levels in the annotation hierarchy override
	 * attributes of the same name from higher levels, and
	 * {@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm
	 * used by this method will stop searching the annotation hierarchy once the
	 * first annotation of the specified {@code annotationType} has been found.
	 * As a consequence, additional annotations of the specified
	 * {@code annotationType} will be ignored.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @param classValuesAsString whether to convert Class references into
	 * Strings or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次结构中，找到注释层次结构中指定的{@code 注解类型}的第一个注释，并将该注释的属性与<em> matching </ em>属性合并来自注释层次结构较低级别中的注释。 
	 *  <p>注释层次结构中较低级别的属性会覆盖较高级别中的同名属性，并且在单个注释内和注释层次结构中都完全支持{@link  AliasFor @AliasFor}语义。 
	 *  <p>与{@link  #getAllAnnotationAttributes}相比，一旦找到指定的{@code 注记类型}的第一个注释，此方法使用的搜索算法将停止搜索注释层次。 
	 * 结果，将忽略指定的{@code 注解类型}的其他注解。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释类型注释类型以查找
	 * @param  classValuesAsString是将Class引用转换为字符串还是将其保留为Class引用
	 * @param  nestedAnnotationsAsMap是否将嵌套的Annotation实例转换为{ @code  AnnotationAttributes}映射或将其保留为Annotation实例
	 * @return 合并的{@code  AnnotationAttributes}，如果未找到，则为{@code  null} @since 4.2 
	 * @see  #findMergedAnnotation（AnnotatedElement ，Class）
	 * @see  #getMergedAnnotationAttributes（AnnotatedElement，String，boolean，boolean）
	 */
	@Nullable
	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,
			Class<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		MergedAnnotation<?> mergedAnnotation = findAnnotations(element)
				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());
		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);
	}

	/**
	 * Find the first annotation of the specified {@code annotationName} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element} and
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy.
	 * <p>Attributes from lower levels in the annotation hierarchy override
	 * attributes of the same name from higher levels, and
	 * {@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search
	 * algorithm used by this method will stop searching the annotation
	 * hierarchy once the first annotation of the specified
	 * {@code annotationName} has been found. As a consequence, additional
	 * annotations of the specified {@code annotationName} will be ignored.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationName the fully qualified class name of the annotation type to find
	 * @param classValuesAsString whether to convert Class references into Strings or to
	 * preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into
	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances
	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found
	 * @since 4.2
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 */
	/**
	 * 在所提供的{@code 元素}上方的注释层次中，在指定的注释层次中找到指定的{@code 注解名称}的第一个注释，并将该注释的属性与<em> matching </ em>属性合并来自注释层次结构较低级别中的注释。 
	 *  <p>注释层次结构中较低级别的属性会覆盖较高级别中的同名属性，并且在单个注释内和注释层次结构中都完全支持{@link  AliasFor @AliasFor}语义。 
	 *  <p>与{@link  #getAllAnnotationAttributes}相比，一旦找到指定的{@code 注解名称}的第一个注解，此方法使用的搜索算法将停止搜索注解层次。 
	 * 因此，指定的{@code 注解名称}的其他注解将被忽略。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注解名称注解类型的完全限定的类名，以查找
	 * @param  classValuesAsString是将Class引用转换为String还是将其保留为Class引用
	 * @param  nestedAnnotationsAsMap是否将嵌套的Annotation实例转换为{@code  AnnotationAttributes}映射，或将其保留为Annotation实例
	 * @return 合并的{@code  AnnotationAttributes}； 
	 * 如果找不到{{@@code> null}，则从4.2开始@请参阅> #findMergedAnnotation（AnnotatedElement，Class）<@请参阅#getMergedAnnotationAttributes（AnnotatedElement，字符串，布尔值，布尔值）
	 */
	@Nullable
	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,
			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		MergedAnnotation<?> mergedAnnotation = findAnnotations(element)
				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());
		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);
	}

	/**
	 * Find the first annotation of the specified {@code annotationType} within
	 * the annotation hierarchy <em>above</em> the supplied {@code element},
	 * merge that annotation's attributes with <em>matching</em> attributes from
	 * annotations in lower levels of the annotation hierarchy, and synthesize
	 * the result back into an annotation of the specified {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both
	 * within a single annotation and within the annotation hierarchy.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element
	 * @param annotationType the annotation type to find
	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found
	 * @since 4.2
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)
	 * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次中，找到注释层次结构中指定的{@code 注解类型}的第一个注释，将该注释的属性与<em> matching </ em>属性合并从注解层次结构较低级别的注解中提取结果，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素和带注释的元素
	 * @param 注释键入注释类型以找到
	 * @return 合并，合成的{@code 注释}； 
	 * 如果未找到，则为{@code  null} @自4.2起<请参见> #findAllMergedAnnotations（AnnotatedElement，Class）<@请参见> #findMergedAnnotationAttributes（AnnotatedElement，String，boolean，boolean）<@请参见#getMergedAnnotationAttributes（AnnotatedElement，Class）
	 */
	@Nullable
	public static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {
			return element.getDeclaredAnnotation(annotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return findAnnotations(element)
				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())
				.synthesize(MergedAnnotation::isPresent).orElse(null);
	}

	/**
	 * Find <strong>all</strong> annotations of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在所提供的{@code 元素}的注释层次中<em>上方</ em>内找到指定的{@code 注解类型}的<strong>所有</ strong>注解； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不{<@@code> null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @return 所有合并的，合成的{找到@code  Annotations}，或者如果没有找到@，则返回一个空集@since 4.3 
	 * @see  #findMergedAnnotation（AnnotatedElement，Class）
	 * @see  #getAllMergedAnnotations（AnnotatedElement，Class）
	 */
	public static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {
		return findAnnotations(element).stream(annotationType)
				.sorted(highAggregateIndexesFirst())
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Find <strong>all</strong> annotations of the specified {@code annotationTypes}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the
	 * annotation hierarchy and synthesize the results back into an annotation
	 * of the corresponding {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationTypes the annotation types to find
	 * @return the set of all merged, synthesized {@code Annotations} found,
	 * or an empty set if none were found
	 * @since 5.1
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}的注释层次中<em>上方</ em>中找到指定的{@code 注解类型}的<strong>所有</ strong>注解； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回对应的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素（带注释的元素）（永远不为{@code  null}）
	 * @param 注解键入注释类型以查找
	 * @return 找到的所有合并，合成的{@code  Annotations}的集合，或如果未找到@@5.1开始的空集#findAllMergedAnnotations（AnnotatedElement，Class）
	 */
	public static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {
		return findAnnotations(element).stream()
				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))
				.sorted(highAggregateIndexesFirst())
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>The container type that holds the repeatable annotations will be looked up
	 * via {@link java.lang.annotation.Repeatable}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次中，找到指定的{@code 注解类型}的所有<em>可重复的注释</ em>； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 *  <p>将通过{@link  java.lang.annotation.Repeatable}查找包含可重复注释的容器类型。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不{<@@code> null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @return 所有合并的可重复元素的集合{@code  Annotations}； 
	 * 如果未找到，则为空集
	 * @throws  IllegalArgumentException如果{@code 元素}或{@code 注解类型}为{@code  null}，或者容器类型无法解析，因为4.3起
	 * @see  #findMergedAnnotation（AnnotatedElement，Class）
	 * @see  #findAllMergedAnnotations（AnnotatedElement，Class）
	 * @see  #findMergedRepeatableAnnotations（AnnotatedElement，Class，Class）
	 */
	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,
			Class<A> annotationType) {

		return findMergedRepeatableAnnotations(element, annotationType, null);
	}

	/**
	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}
	 * within the annotation hierarchy <em>above</em> the supplied {@code element};
	 * and for each annotation found, merge that annotation's attributes with
	 * <em>matching</em> attributes from annotations in lower levels of the annotation
	 * hierarchy and synthesize the results back into an annotation of the specified
	 * {@code annotationType}.
	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a
	 * single annotation and within annotation hierarchies.
	 * <p>This method follows <em>find semantics</em> as described in the
	 * {@linkplain AnnotatedElementUtils class-level javadoc}.
	 * @param element the annotated element (never {@code null})
	 * @param annotationType the annotation type to find (never {@code null})
	 * @param containerType the type of the container that holds the annotations;
	 * may be {@code null} if the container type should be looked up via
	 * {@link java.lang.annotation.Repeatable}
	 * @return the set of all merged repeatable {@code Annotations} found,
	 * or an empty set if none were found
	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}
	 * is {@code null}, or if the container type cannot be resolved
	 * @throws AnnotationConfigurationException if the supplied {@code containerType}
	 * is not a valid container annotation for the supplied {@code annotationType}
	 * @since 4.3
	 * @see #findMergedAnnotation(AnnotatedElement, Class)
	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)
	 */
	/**
	 * 在提供的{@code 元素}上方的注释层次中，找到指定的{@code 注解类型}的所有<em>可重复的注释</ em>； 
	 * 对于找到的每个注释，将该注释的属性与<em> matching </ em>属性合并，这些属性来自注释层次结构较低级别中的注释，然后将结果综合回到指定的{@code 注解类型}的注解中。 
	 * 在单个注解和注解层次结构中，完全支持<p> {<@link> AliasFor @AliasFor}语义。 
	 *  <p>此方法遵循<em>查找语义</ em>，如{@link  plain AnnotatedElementUtils类级javadoc}中所述。 
	 *  
	 * @param 元素带注释的元素（从不（<{@@code> null}）
	 * @param 注释键入要查找的注释类型（从不（<{@code> null}）
	 * @param  containerType容纳容器的类型注释； 
	 * 如果应该通过{@link  java.lang.annotation.Repeatable} 
	 * @return 查找所有合并的可重复{@code  Annotations}的集合来查找容器类型，则可以为{@code  null}，如果未找到任何内容，则返回一个空集
	 * @throws  IllegalArgumentException如果{@code 元素}或{@code 注记类型}为{@code  null}，或者如果无法解析容器类型，则返回IllegalArgumentException > AnnotationConfigurationException如果所提供的{@code  containerType}不是所提供的{@code 注解类型}的有效容器注释@since 4.3 
	 * @see  #findMergedAnnotation（AnnotatedElement，Class）
	 * @see  #findAllMergedAnnotations（AnnotatedElement ，班级）
	 */
	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,
			Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {

		return findRepeatableAnnotations(element, containerType, annotationType)
				.stream(annotationType)
				.sorted(highAggregateIndexesFirst())
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	private static MergedAnnotations getAnnotations(AnnotatedElement element) {
		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());
	}

	private static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,
			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {

		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);
		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);
	}

	private static MergedAnnotations findAnnotations(AnnotatedElement element) {
		return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());
	}

	private static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,
			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {

		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);
		return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);
	}

	@Nullable
	private static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {
		return (map.isEmpty() ? null : map);
	}

	private static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {
		return Comparator.<MergedAnnotation<A>> comparingInt(
				MergedAnnotation::getAggregateIndex).reversed();
	}

	@Nullable
	private static AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation,
			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		if (!annotation.isPresent()) {
			return null;
		}
		return annotation.asAnnotationAttributes(
				Adapt.values(classValuesAsString, nestedAnnotationsAsMap));
	}


	/**
	 * Adapted {@link AnnotatedElement} that hold specific annotations.
	 */
	/**
	 * 修改后的{@link  AnnotatedElement}包含特定注释。 
	 * 
	 */
	private static class AnnotatedElementForAnnotations implements AnnotatedElement {

		private final Annotation[] annotations;

		AnnotatedElementForAnnotations(Annotation... annotations) {
			this.annotations = annotations;
		}

		@Override
		@SuppressWarnings("unchecked")
		@Nullable
		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
			for (Annotation annotation : this.annotations) {
				if (annotation.annotationType() == annotationClass) {
					return (T) annotation;
				}
			}
			return null;
		}

		@Override
		public Annotation[] getAnnotations() {
			return this.annotations.clone();
		}

		@Override
		public Annotation[] getDeclaredAnnotations() {
			return this.annotations.clone();
		}

	}

}
