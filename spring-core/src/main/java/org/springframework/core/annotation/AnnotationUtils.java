/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;
import org.springframework.core.annotation.MergedAnnotation.Adapt;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.lang.Nullable;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * General utility methods for working with annotations, handling meta-annotations,
 * bridge methods (which the compiler generates for generic declarations) as well
 * as super methods (for optional <em>annotation inheritance</em>).
 *
 * <p>Note that most of the features of this class are not provided by the
 * JDK's introspection facilities themselves.
 *
 * <p>As a general rule for runtime-retained application annotations (e.g. for
 * transaction control, authorization, or service exposure), always use the
 * lookup methods on this class (e.g. {@link #findAnnotation(Method, Class)} or
 * {@link #getAnnotation(Method, Class)}) instead of the plain annotation lookup
 * methods in the JDK. You can still explicitly choose between a <em>get</em>
 * lookup on the given class level only ({@link #getAnnotation(Method, Class)})
 * and a <em>find</em> lookup in the entire inheritance hierarchy of the given
 * method ({@link #findAnnotation(Method, Class)}).
 *
 * <h3>Terminology</h3>
 * The terms <em>directly present</em>, <em>indirectly present</em>, and
 * <em>present</em> have the same meanings as defined in the class-level
 * javadoc for {@link AnnotatedElement} (in Java 8).
 *
 * <p>An annotation is <em>meta-present</em> on an element if the annotation
 * is declared as a meta-annotation on some other annotation which is
 * <em>present</em> on the element. Annotation {@code A} is <em>meta-present</em>
 * on another annotation if {@code A} is either <em>directly present</em> or
 * <em>meta-present</em> on the other annotation.
 *
 * <h3>Meta-annotation Support</h3>
 * <p>Most {@code find*()} methods and some {@code get*()} methods in this class
 * provide support for finding annotations used as meta-annotations. Consult the
 * javadoc for each method in this class for details. For fine-grained support for
 * meta-annotations with <em>attribute overrides</em> in <em>composed annotations</em>,
 * consider using {@link AnnotatedElementUtils}'s more specific methods instead.
 *
 * <h3>Attribute Aliases</h3>
 * <p>All public methods in this class that return annotations, arrays of
 * annotations, or {@link AnnotationAttributes} transparently support attribute
 * aliases configured via {@link AliasFor @AliasFor}. Consult the various
 * {@code synthesizeAnnotation*(..)} methods for details.
 *
 * <h3>Search Scope</h3>
 * <p>The search algorithms used by methods in this class stop searching for
 * an annotation once the first annotation of the specified type has been
 * found. As a consequence, additional annotations of the specified type will
 * be silently ignored.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Mark Fisher
 * @author Chris Beams
 * @author Phillip Webb
 * @author Oleg Zhurakousky
 * @since 2.0
 * @see AliasFor
 * @see AnnotationAttributes
 * @see AnnotatedElementUtils
 * @see BridgeMethodResolver
 * @see java.lang.reflect.AnnotatedElement#getAnnotations()
 * @see java.lang.reflect.AnnotatedElement#getAnnotation(Class)
 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotations()
 */
/**
 * 用于处理注释，处理元注释，桥接方法（编译器为通用声明生成的）的通用实用程序方法以及超级方法（用于可选的<em> annotation继承</ em>）。 
 *  <p>请注意，此类的大多数功能不是JDK的自省功能本身提供的。 
 *  <p>作为运行时保留的应用程序注释的一般规则（例如，用于事务控制，授权或服务公开），请始终在此类上使用查找方法（例如{@link  #findAnnotation（Method，Class）}或{@link  #getAnnotation（Method，Class）}），而不是JDK中的普通注释查找方法。 
 * 您仍然可以在仅在给定类级别的<em> get </ em>查找（{@link  #getAnnotation（Method，Class）}）和<em> find </ em>查找之间进行显式选择。 
 * 给定方法的整个继承层次结构（{@link  #findAnnotation（Method，Class）}）。 
 *  <h3>术语</ h3>术语<em>直接存在</ em>，<em>间接存在</ em>和<em> present </ em>的含义与类级别中定义的含义相同{@link  AnnotatedElement}的javadoc（在Java 8中）。 
 *  <p>如果注释被声明为元素上<em> present </ em>上其他注释的元注释，则注释在元素上<em> meta-present </ em>。 
 * 如果{@code  A}是<em>直接存在</ em>或<em>元存在</ em>，则注释{@code  A}是另一个注释中的<em>元存在</ em>。 
 *  em>在另一个注释上。 
 *  <h3>元注释支持</ h3> <p>此类中的大多数{@code  find（）}方法和某些{@code  get（）}方法为查找用作元注释的注释提供了支持。 
 * 有关此类的每种方法，请查阅javadoc。 
 * 为了对在<em>组成的注释</ em>中具有<em>属性覆盖</ em>的元注释提供细粒度的支持，请考虑改用{@link  AnnotatedElementUtils}的更具体方法。 
 *  <h3>属性别名</ h3> <p>此类中的所有返回注释，注释数组或{@link  AnnotationAttributes}的公共方法都透明地支持通过{@link  AliasFor @AliasFor}配置的属性别名。 
 * 有关详细信息，请查阅各种{@code  synthesizeAnnotation（..）}方法。 
 *  <h3>搜索范围</ h3> <p>在找到指定类型的第一个注释后，此类中的方法使用的搜索算法将停止搜索注释。 
 * 因此，指定类型的其他注释将被静默忽略。 
 *  @author  Rob Harrop @author  Juergen Hoeller @author  Sam Brannen @author  Mark Fisher @author  Chris Beams @author  Phillip Webb @author  Oleg Zhurakousky @从2.0起
 * @see  AliasFor 
 * @see  AnnotationAttributes 
 * @see  AnnotatedElementUtils 
 * @see  BridgeMethodResolver 
 * @see  java.lang.reflect.AnnotatedElement＃getAnnotations（）
 * @see  java.lang.reflect.AnnotatedElement＃getAnnotation（Class）
 * @see  java.lang.reflect.AnnotatedElement＃getDeclaredAnnotations（）
 */
public abstract class AnnotationUtils {

	/**
	 * The attribute name for annotations with a single element.
	 */
	/**
	 * 具有单个元素的注释的属性名称。 
	 * 
	 */
	public static final String VALUE = MergedAnnotation.VALUE;

	private static final AnnotationFilter JAVA_LANG_ANNOTATION_FILTER =
			AnnotationFilter.packages("java.lang.annotation");

	private static final Map<Class<? extends Annotation>, Map<String, DefaultValueHolder>> defaultValuesCache =
			new ConcurrentReferenceHashMap<>();


	/**
	 * Determine whether the given class is a candidate for carrying one of the specified
	 * annotations (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationTypes the searchable annotation types
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 * @see #isCandidateClass(Class, Class)
	 * @see #isCandidateClass(Class, String)
	 */
	/**
	 * 确定给定的类是否适合携带指定的注释之一（在类型，方法或字段级别）。 
	 *  
	 * @param 使类自省
	 * @param 注解类型如果可以知道该类在任何级别都没有此类注解，则对可搜索的注释类型进行
	 * @return  {@code  false}； 
	 * 否则为{@code  true}。 
	 * 如果此处返回{@code  true}，则调用者通常将执行完整的方法/字段自省。 
	 *  @since 5.2 
	 * @see  #isCandidateClass（Class，Class）
	 * @see  #isCandidateClass（Class，String）
	 */
	public static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {
		for (Class<? extends Annotation> annotationType : annotationTypes) {
			if (isCandidateClass(clazz, annotationType)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Determine whether the given class is a candidate for carrying the specified annotation
	 * (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationType the searchable annotation type
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 * @see #isCandidateClass(Class, String)
	 */
	/**
	 * 确定给定的类是否适合携带指定的注释（在类型，方法或字段级别）。 
	 *  
	 * @param 使类自省
	 * @param 注释键入可搜索的注释类型
	 * @return  {@code  false}（如果已知该类在任何级别都没有此类注释）； 
	 * 否则为{@code  true}。 
	 * 如果此处返回{@code  true}，则调用者通常将执行完整的方法/字段自省。 
	 *  @since 5.2 
	 * @see  #isCandidateClass（Class，String）
	 */
	public static boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType) {
		return isCandidateClass(clazz, annotationType.getName());
	}

	/**
	 * Determine whether the given class is a candidate for carrying the specified annotation
	 * (at type, method or field level).
	 * @param clazz the class to introspect
	 * @param annotationName the fully-qualified name of the searchable annotation type
	 * @return {@code false} if the class is known to have no such annotations at any level;
	 * {@code true} otherwise. Callers will usually perform full method/field introspection
	 * if {@code true} is being returned here.
	 * @since 5.2
	 * @see #isCandidateClass(Class, Class)
	 */
	/**
	 * 确定给定的类是否适合携带指定的注释（在类型，方法或字段级别）。 
	 *  
	 * @param 使该类自省
	 * @param 注解名如果可知的类在任何级别都没有此类注解，则为可搜索的注解类型的全限定名
	 * @return  {@code  false}； 
	 * 否则为{@code  true}。 
	 * 如果此处返回{@code  true}，则调用者通常将执行完整的方法/字段自省。 
	 *  @since 5.2 
	 * @see  #isCandidateClass（Class，Class）
	 */
	public static boolean isCandidateClass(Class<?> clazz, String annotationName) {
		if (annotationName.startsWith("java.")) {
			return true;
		}
		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {
			return false;
		}
		return true;
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the supplied
	 * annotation: either the given annotation itself or a direct meta-annotation
	 * thereof.
	 * <p>Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use one of the
	 * {@code find*()} methods instead.
	 * @param annotation the Annotation to check
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 4.0
	 */
	/**
	 * 从提供的注解中获取{@code  notationType}的单个{@link 注解}：给定注解本身或其直接元注解。 
	 *  <p>请注意，此方法仅支持单个级别的元注释。 
	 * 为了支持任意级别的元注释，请改用{@code  find（）}方法之一。 
	 *  
	 * @param 注释注释以检查
	 * @param 注释键入要查找的注释类型，本地和作为元注释
	 * @return 第一个匹配的注释； 
	 * 如果找不到，则为{@code  null} @自4.0
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	public static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (annotationType.isInstance(annotation)) {
			return synthesizeAnnotation((A) annotation, annotationType);
		}
		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...
		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {
			return null;
		}
		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())
				.get(annotationType).withNonMergedAttributes()
				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the supplied
	 * {@link AnnotatedElement}, where the annotation is either <em>present</em> or
	 * <em>meta-present</em> on the {@code AnnotatedElement}.
	 * <p>Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use
	 * {@link #findAnnotation(AnnotatedElement, Class)} instead.
	 * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 3.1
	 */
	/**
	 * 从提供的{@link  AnnotatedElement}中获得{@code 注解类型}的单个{@link 注解}，其中注解为<em> present </ em>或<em> meta-present < / <em>上的{@code  AnnotatedElement}。 
	 *  <p>请注意，此方法仅支持单个级别的元注释。 
	 * 为了支持任意级别的元注释，请改用{@link  #findAnnotation（AnnotatedElement，Class）}。 
	 *  
	 * @param  annotatedElement从中获取注释的{@code  AnnotatedElement} 
	 * @param 注释键入要在本地和作为元注释
	 * @return 的第一个匹配注释查找的注释类型，或者{ @code  null}（如果未找到）@3.1
	 */
	@Nullable
	public static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {
			return annotatedElement.getAnnotation(annotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())
				.get(annotationType).withNonMergedAttributes()
				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);
	}

	private static <A extends Annotation> boolean isSingleLevelPresent(MergedAnnotation<A> mergedAnnotation) {
		int distance = mergedAnnotation.getDistance();
		return (distance == 0 || distance == 1);
	}

	/**
	 * Get a single {@link Annotation} of {@code annotationType} from the
	 * supplied {@link Method}, where the annotation is either <em>present</em>
	 * or <em>meta-present</em> on the method.
	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * <p>Note that this method supports only a single level of meta-annotations.
	 * For support for arbitrary levels of meta-annotations, use
	 * {@link #findAnnotation(Method, Class)} instead.
	 * @param method the method to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the first matching annotation, or {@code null} if not found
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)
	 * @see #getAnnotation(AnnotatedElement, Class)
	 */
	/**
	 * 从提供的{@link 方法}获取{{@@link>注释类型}的单个{@link 注释}，其中注释为<em> present </ em>或<em> meta-present < / em>上的方法。 
	 *  <p>正确处理编译器生成的桥{@link  Method Methods}。 
	 *  <p>请注意，此方法仅支持单个级别的元注释。 
	 * 为了支持任意级别的元注释，请改用{@link  #findAnnotation（Method，Class）}。 
	 *  
	 * @param 方法在
	 * @param 注释上查找注释的方法键入注释类型以查找
	 * @return 第一个匹配的注释，如果找不到，则为{@code  null} 
	 * @see  org.springframework .core.BridgeMethodResolver＃findBridgedMethod（Method）
	 * @see  #getAnnotation（AnnotatedElement，Class）
	 */
	@Nullable
	public static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {
		Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);
		return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);
	}

	/**
	 * Get all {@link Annotation Annotations} that are <em>present</em> on the
	 * supplied {@link AnnotatedElement}.
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * @param annotatedElement the Method, Constructor or Field to retrieve annotations from
	 * @return the annotations found, an empty array, or {@code null} if not
	 * resolvable (e.g. because nested Class values in annotation attributes
	 * failed to resolve at runtime)
	 * @since 4.0.8
	 * @see AnnotatedElement#getAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 获取提供的{@link  AnnotatedElement}上所有<em> </ em>出现的所有{@link 注释注释}。 
	 *  <p>元注释将不被搜索。 
	 *  
	 * @param  annotatedElement从
	 * @return 所找到的注释中检索注释的方法，构造方法或字段，一个空数组或{@code  null}（如果不可解析的话）（例如，由于注释属性中的嵌套Class值无法解析）在运行时）@since 4.0.8起
	 * @see  AnnotatedElement＃getAnnotations（）@从5.2开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	@Nullable
	public static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {
		try {
			return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);
		}
		catch (Throwable ex) {
			handleIntrospectionFailure(annotatedElement, ex);
			return null;
		}
	}

	/**
	 * Get all {@link Annotation Annotations} that are <em>present</em> on the
	 * supplied {@link Method}.
	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * @param method the Method to retrieve annotations from
	 * @return the annotations found, an empty array, or {@code null} if not
	 * resolvable (e.g. because nested Class values in annotation attributes
	 * failed to resolve at runtime)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)
	 * @see AnnotatedElement#getAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 获取提供的{@link 方法}上所有<em>存在</ em>的{@link 注释注释}。 
	 *  <p>正确处理编译器生成的桥{@link  Method Methods}。 
	 *  <p>元注释将不被搜索。 
	 *  
	 * @param 方法用于从
	 * @return 所找到的注释中检索注释的方法，一个空数组或{@code  null}（如果不可解析的话）（例如，由于注释属性中的嵌套Class值在运行时无法解析）
	 * @see  org.springframework.core.BridgeMethodResolver＃findBridgedMethod（Method）
	 * @see  AnnotatedElement＃getAnnotations（）@从5.2开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	@Nullable
	public static Annotation[] getAnnotations(Method method) {
		try {
			return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);
		}
		catch (Throwable ex) {
			handleIntrospectionFailure(method, ex);
			return null;
		}
	}

	/**
	 * Get the <em>repeatable</em> {@linkplain Annotation annotations} of
	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where
	 * such annotations are either <em>present</em>, <em>indirectly present</em>,
	 * or <em>meta-present</em> on the element.
	 * <p>This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
	 * with support for automatic detection of a <em>container annotation</em>
	 * declared via @{@link java.lang.annotation.Repeatable} (when running on
	 * Java 8 or higher) and with additional support for meta-annotations.
	 * <p>Handles both single annotations and annotations nested within a
	 * <em>container annotation</em>.
	 * <p>Correctly handles <em>bridge methods</em> generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>present</em> on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 从提供的{@link  AnnotatedElement}中获取{@code  notificationType}的<em> repeatable </ em> {@link  plain Annotation注释}，其中<em> present </ em >，<em>间接存在</ em>或元素上的<em>元存在</ em>。 
	 *  <p>此方法模仿Java 8的{@link  java.lang.reflect.AnnotatedElement＃getAnnotationsByType（Class）}的功能，并支持自动检测通过@{<声明的<em>容器注释</ em>。 
	 *  @link> java.lang.annotation.Repeatable}（在Java 8或更高版本上运行时），并具有对元注释的额外支持。 
	 *  <p>处理单个注释和嵌套在<em>容器注释</ em>中的注释。 
	 * 如果提供的元素是{@link 方法}，则<p>正确处理由编译器生成的<em> bridge方法</ em>。 
	 * 如果注释不出现在提供的元素上，则将搜索<p>元注释。 
	 *  
	 * @param  annotatedElement要在
	 * @param 注释上查找注释的元素键入注释类型以查找
	 * @return 找到的注释或空集（从{@code  null}开始）4.2起，@
	 * @see > #getRepeatableAnnotations（AnnotatedElement，类，类）
	 * @see  #getDeclaredRepeatableAnnotations（AnnotatedElement，类，类）
	 * @see  AnnotatedElementUtils＃getMergedRepeatableAnnotations（AnnotatedElement，Class）请参见> java.lang.annotation.Repeatable 
	 * @see  java.lang.reflect.AnnotatedElement＃getAnnotationsByType @从5.2开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	public static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class<A> annotationType) {

		return getRepeatableAnnotations(annotatedElement, annotationType, null);
	}

	/**
	 * Get the <em>repeatable</em> {@linkplain Annotation annotations} of
	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where
	 * such annotations are either <em>present</em>, <em>indirectly present</em>,
	 * or <em>meta-present</em> on the element.
	 * <p>This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}
	 * with additional support for meta-annotations.
	 * <p>Handles both single annotations and annotations nested within a
	 * <em>container annotation</em>.
	 * <p>Correctly handles <em>bridge methods</em> generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>present</em> on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @param containerAnnotationType the type of the container that holds
	 * the annotations; may be {@code null} if a container is not supported
	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}
	 * when running on Java 8 or higher
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 从提供的{@link  AnnotatedElement}中获取{@code  notificationType}的<em> repeatable </ em> {@link  plain Annotation注释}，其中<em> present </ em >，<em>间接存在</ em>或元素上的<em>元存在</ em>。 
	 *  <p>此方法模仿Java 8的{@link  java.lang.reflect.AnnotatedElement＃getAnnotationsByType（Class）}的功能，并额外支持元注释。 
	 *  <p>处理单个注释和嵌套在<em>容器注释</ em>中的注释。 
	 * 如果提供的元素是{@link 方法}，则<p>正确处理由编译器生成的<em> bridge方法</ em>。 
	 * 如果注释不出现在提供的元素上，则将搜索<p>元注释。 
	 *  
	 * @param  annotatedElement用于在
	 * @param 注解上查找注释的元素注释类型以查找
	 * @param 上的注释类型containerAnnotationType保存注释的容器的类型； 
	 * 如果不支持容器，或者在Java 8或更高版本上运行，则应该通过@{<@link> java.lang.annotation.Repeatable}查找它，则注释可能为{@code  null}。 
	 * 发现或为空集（从不{<@@code> null}）@4.2开始，
	 * @see  #getRepeatableAnnotations（AnnotatedElement，Class）
	 * @see  #getDeclaredRepeatableAnnotations（AnnotatedElement，Class）
	 * @see  #getDeclaredRepeatableAnnotations（AnnotatedElement，Class） ，Class）
	 * @see  AnnotatedElementUtils＃getMergedRepeatableAnnotations（AnnotatedElement，Class，Class）
	 * @see  org.springframework.core.BridgeMethodResolver＃findBridgedMethod 
	 * @see  java.lang.annotation.Repeatable 
	 * @see  java.lang.reflect .AnnotatedElement＃getAnnotationsByType从5.2版开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	public static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {

		RepeatableContainers repeatableContainers = (containerAnnotationType != null ?
				RepeatableContainers.of(annotationType, containerAnnotationType) :
				RepeatableContainers.standardRepeatables());

		return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)
				.stream(annotationType)
				.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))
				.map(MergedAnnotation::withNonMergedAttributes)
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}
	 * of {@code annotationType} from the supplied {@link AnnotatedElement},
	 * where such annotations are either <em>directly present</em>,
	 * <em>indirectly present</em>, or <em>meta-present</em> on the element.
	 * <p>This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
	 * with support for automatic detection of a <em>container annotation</em>
	 * declared via @{@link java.lang.annotation.Repeatable} (when running on
	 * Java 8 or higher) and with additional support for meta-annotations.
	 * <p>Handles both single annotations and annotations nested within a
	 * <em>container annotation</em>.
	 * <p>Correctly handles <em>bridge methods</em> generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>present</em> on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 从提供的{@link  AnnotatedElement}中获取{@code  notificationType}的声明的<em>可重复</ em> {@link  plain Annotation注释}，其中这些注释要么直接存在<em> < / em>，<em>间接存在</ em>或<em>元存在</ em>。 
	 *  <p>此方法模仿Java 8的{@link  java.lang.reflect.AnnotatedElement＃getDeclaredAnnotationsByType（Class）}的功能，并支持自动检测通过@{<声明的<em>容器注释</ em>。 
	 *  @link> java.lang.annotation.Repeatable}（在Java 8或更高版本上运行时），并具有对元注释的额外支持。 
	 *  <p>处理单个注释和嵌套在<em>容器注释</ em>中的注释。 
	 * 如果提供的元素是{@link 方法}，则<p>正确处理由编译器生成的<em> bridge方法</ em>。 
	 * 如果注释不出现在提供的元素上，则将搜索<p>元注释。 
	 *  
	 * @param  annotatedElement要在
	 * @param 注释上查找注释的元素键入注释类型以查找
	 * @return 找到的注释或空集（从{@code  null}开始）4.2起，@
	 * @see > #getRepeatableAnnotations（AnnotatedElement，Class）
	 * @see  #getRepeatableAnnotations（AnnotatedElement，Class，Class）
	 * @see  #getDeclaredRepeatableAnnotations（AnnotatedElement，Class，Class）
	 * @see  AnnotatedElementUtils＃getMergedRepeatableAnnotations（AnnotatedElement，Class）
	 * @see  org.springframework.core.BridgeMethodResolver＃findBridgedMethod 
	 * @see  java.lang.annotation.Repeatable 
	 * @see  java.lang.reflect.AnnotatedElement＃getDeclaredAnnotationsByType @5.2版弃用，因为它已被{@link  MergedAnnotations取代} API
	 */
	@Deprecated
	public static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class<A> annotationType) {

		return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);
	}

	/**
	 * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}
	 * of {@code annotationType} from the supplied {@link AnnotatedElement},
	 * where such annotations are either <em>directly present</em>,
	 * <em>indirectly present</em>, or <em>meta-present</em> on the element.
	 * <p>This method mimics the functionality of Java 8's
	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}
	 * with additional support for meta-annotations.
	 * <p>Handles both single annotations and annotations nested within a
	 * <em>container annotation</em>.
	 * <p>Correctly handles <em>bridge methods</em> generated by the
	 * compiler if the supplied element is a {@link Method}.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>present</em> on the supplied element.
	 * @param annotatedElement the element to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @param containerAnnotationType the type of the container that holds
	 * the annotations; may be {@code null} if a container is not supported
	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}
	 * when running on Java 8 or higher
	 * @return the annotations found or an empty set (never {@code null})
	 * @since 4.2
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)
	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)
	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)
	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod
	 * @see java.lang.annotation.Repeatable
	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 从提供的{@link  AnnotatedElement}中获取{@code  notificationType}的声明的<em>可重复</ em> {@link  plain Annotation注释}，其中这些注释要么直接存在<em> < / em>，<em>间接存在</ em>或<em>元存在</ em>。 
	 *  <p>此方法模仿Java 8的{@link  java.lang.reflect.AnnotatedElement＃getDeclaredAnnotationsByType（Class）}的功能，并提供对元注释的额外支持。 
	 *  <p>处理单个注释和嵌套在<em>容器注释</ em>中的注释。 
	 * 如果提供的元素是{@link 方法}，则<p>正确处理由编译器生成的<em> bridge方法</ em>。 
	 * 如果注释不出现在提供的元素上，则将搜索<p>元注释。 
	 *  
	 * @param  annotatedElement用于在
	 * @param 注解上查找注释的元素注释类型以查找
	 * @param 上的注释类型containerAnnotationType保存注释的容器的类型； 
	 * 如果不支持容器，或者在Java 8或更高版本上运行，则应该通过@{<@link> java.lang.annotation.Repeatable}查找它，则注释可能为{@code  null}。 
	 * 发现或为空集（从不{<@@code> null}）@since自4.2开始
	 * @see  #getRepeatableAnnotations（AnnotatedElement，Class）
	 * @see  #getRepeatableAnnotations（AnnotatedElement，Class，Class）
	 * @see  #getDeclaredRepeatableAnnotations（AnnotatedElement ，Class）
	 * @see  AnnotatedElementUtils＃getMergedRepeatableAnnotations（AnnotatedElement，Class，Class）
	 * @see  org.springframework.core.BridgeMethodResolver＃findBridgedMethod 
	 * @see  java.lang.annotation.Repeatable 
	 * @see  java.lang.reflect .AnnotatedElement＃getDeclaredAnnotationsByType从5.2版开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	public static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,
			Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {

		RepeatableContainers repeatableContainers = containerAnnotationType != null ?
				RepeatableContainers.of(annotationType, containerAnnotationType) :
				RepeatableContainers.standardRepeatables();

		return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)
				.stream(annotationType)
				.map(MergedAnnotation::withNonMergedAttributes)
				.collect(MergedAnnotationCollectors.toAnnotationSet());
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the
	 * supplied {@link AnnotatedElement}.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>directly present</em> on the supplied element.
	 * <p><strong>Warning</strong>: this method operates generically on
	 * annotated elements. In other words, this method does not execute
	 * specialized search algorithms for classes or methods. If you require
	 * the more specific semantics of {@link #findAnnotation(Class, Class)}
	 * or {@link #findAnnotation(Method, Class)}, invoke one of those methods
	 * instead.
	 * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation
	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation
	 * @return the first matching annotation, or {@code null} if not found
	 * @since 4.2
	 */
	/**
	 * 在提供的{@link  AnnotatedElement}上找到{@code 注解类型}的单个{@link 注解}。 
	 * 如果注释不是直接在提供的元素上出现<em> </ em>，则将搜索<p>元注释。 
	 *  <p> <strong>警告</ strong>：此方法通常对带注释的元素起作用。 
	 * 换句话说，此方法不会为类或方法执行专门的搜索算法。 
	 * 如果您需要{@link  #findAnnotation（Class，Class）}或{@link  #findAnnotation（Method，Class）}的更具体的语义，请改为调用这些方法之一。 
	 *  
	 * @param  annotatedElement在其上查找注释的{@code  AnnotatedElement} 
	 * @param 注释键入要在本地和作为元注释
	 * @return 查找的第一个匹配注释的注释类型，或者{ @code  null}（如果未找到）@4.2
	 */
	@Nullable
	public static <A extends Annotation> A findAnnotation(
			AnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {

		if (annotationType == null) {
			return null;
		}

		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {
			return annotatedElement.getDeclaredAnnotation(annotationType);
		}

		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())
				.get(annotationType).withNonMergedAttributes()
				.synthesize(MergedAnnotation::isPresent).orElse(null);
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the supplied
	 * {@link Method}, traversing its super methods (i.e. from superclasses and
	 * interfaces) if the annotation is not <em>directly present</em> on the given
	 * method itself.
	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
	 * <p>Meta-annotations will be searched if the annotation is not
	 * <em>directly present</em> on the method.
	 * <p>Annotations on methods are not inherited by default, so we need to handle
	 * this explicitly.
	 * @param method the method to look for annotations on
	 * @param annotationType the annotation type to look for
	 * @return the first matching annotation, or {@code null} if not found
	 * @see #getAnnotation(Method, Class)
	 */
	/**
	 * 在提供的{@link 方法}上找到{{@@link>注释类型}的单个{@link 注释}，如果注释不直接存在，则遍历其超级方法（即从超类和接口）。 
	 *  </ em>。 
	 *  <p>正确处理编译器生成的桥{@link  Method Methods}。 
	 * 如果注释不是直接在方法上出现<em> </ em>，则将搜索<p>元注释。 
	 *  <p>默认情况下不会继承方法的注释，因此我们需要显式地处理它。 
	 *  
	 * @param 方法在
	 * @param 注释上查找注释的方法键入注释类型以查找
	 * @return 第一个匹配的注释，如果找不到，则为{@code  null} 
	 * @see  #getAnnotation（方法，类）
	 */
	@Nullable
	public static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {
		if (annotationType == null) {
			return null;
		}

		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {
			return method.getDeclaredAnnotation(annotationType);
		}

		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())
				.get(annotationType).withNonMergedAttributes()
				.synthesize(MergedAnnotation::isPresent).orElse(null);
	}

	/**
	 * Find a single {@link Annotation} of {@code annotationType} on the
	 * supplied {@link Class}, traversing its interfaces, annotations, and
	 * superclasses if the annotation is not <em>directly present</em> on
	 * the given class itself.
	 * <p>This method explicitly handles class-level annotations which are not
	 * declared as {@link java.lang.annotation.Inherited inherited} <em>as well
	 * as meta-annotations and annotations on interfaces</em>.
	 * <p>The algorithm operates as follows:
	 * <ol>
	 * <li>Search for the annotation on the given class and return it if found.
	 * <li>Recursively search through all annotations that the given class declares.
	 * <li>Recursively search through all interfaces that the given class declares.
	 * <li>Recursively search through the superclass hierarchy of the given class.
	 * </ol>
	 * <p>Note: in this context, the term <em>recursively</em> means that the search
	 * process continues by returning to step #1 with the current interface,
	 * annotation, or superclass as the class to look for annotations on.
	 * @param clazz the class to look for annotations on
	 * @param annotationType the type of annotation to look for
	 * @return the first matching annotation, or {@code null} if not found
	 */
	/**
	 * 在提供的{@link 类}上找到{{@@link>注释类型}的单个{@link 注释}，遍历其接口，注释和超类（如果注释不是直接存在的）。 
	 *  >在给定类本身上。 
	 *  <p>此方法显式处理未声明为{@link  java.lang.annotation.InheritedInherited} <em>的类级注释以及接口上的元注释和注释</ em>。 
	 *  <p>该算法的操作如下：<ol> <li>在给定类上搜索注释，如果找到，则将其返回。 
	 *  <li>递归搜索给定类声明的所有注释。 
	 *  <li>递归搜索给定类声明的所有接口。 
	 *  <li>递归搜索给定类的超类层次结构。 
	 *  </ ol> <p>注意：在这种情况下，术语<em>递归</ em>表示搜索过程通过返回步骤＃1继续进行，当前界面，注释或超类作为要查找的类注释已开启。 
	 *  
	 * @param 吸引类，以在
	 * @param 注释上查找注释键入注释的类型以查找
	 * @return 第一个匹配的注释，如果找不到，则为{@code  null}
	 */
	@Nullable
	public static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {
		if (annotationType == null) {
			return null;
		}

		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(annotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {
			A annotation = clazz.getDeclaredAnnotation(annotationType);
			if (annotation != null) {
				return annotation;
			}
			// For backwards compatibility, perform a superclass search with plain annotations
			// even if not marked as @Inherited: e.g. a findAnnotation search for @Deprecated
			Class<?> superclass = clazz.getSuperclass();
			if (superclass == null || superclass == Object.class) {
				return null;
			}
			return findAnnotation(superclass, annotationType);
		}

		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())
				.get(annotationType).withNonMergedAttributes()
				.synthesize(MergedAnnotation::isPresent).orElse(null);
	}

	/**
	 * Find the first {@link Class} in the inheritance hierarchy of the
	 * specified {@code clazz} (including the specified {@code clazz} itself)
	 * on which an annotation of the specified {@code annotationType} is
	 * <em>directly present</em>.
	 * <p>If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked; the inheritance hierarchy for interfaces will
	 * not be traversed.
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * <p>The standard {@link Class} API does not provide a mechanism for
	 * determining which class in an inheritance hierarchy actually declares
	 * an {@link Annotation}, so we need to handle this explicitly.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on (may be {@code null})
	 * @return the first {@link Class} in the inheritance hierarchy that
	 * declares an annotation of the specified {@code annotationType},
	 * or {@code null} if not found
	 * @see Class#isAnnotationPresent(Class)
	 * @see Class#getDeclaredAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 在指定的{@code  clazz}（包括指定的{@code  clazz}本身）的继承层次结构中找到第一个{@link  Class} }是<em>直接存在的</ em>。 
	 *  <p>如果提供的{@code  clazz}是一个接口，则仅会检查该接口本身； 
	 * 否则，将检查该接口。 
	 * 接口的继承层次结构将不会被遍历。 
	 *  <p>元注释将不被搜索。 
	 *  <p>标准的{@link 类} API没有提供一种机制来确定继承层次结构中的哪个类实际上声明了{@link 注释}，因此我们需要显式地处理它。 
	 *  
	 * @param 注解键入注释类型以查找
	 * @param  clazz类以检查其上的注解（可能是{@code  null}）
	 * @return 第一个{@link  Class}继承层次结构，它声明指定的{@code 注解类型}的注释，如果未找到，则声明{@code  null} 
	 * @see  Class＃isAnnotationPresent（Class）
	 * @see  Class＃getDeclaredAnnotations（）@的5.2版本，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	@Nullable
	public static Class<?> findAnnotationDeclaringClass(
			Class<? extends Annotation> annotationType, @Nullable Class<?> clazz) {

		if (clazz == null) {
			return null;
		}

		return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS)
				.get(annotationType, MergedAnnotation::isDirectlyPresent)
				.getSource();
	}

	/**
	 * Find the first {@link Class} in the inheritance hierarchy of the
	 * specified {@code clazz} (including the specified {@code clazz} itself)
	 * on which at least one of the specified {@code annotationTypes} is
	 * <em>directly present</em>.
	 * <p>If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked; the inheritance hierarchy for interfaces will
	 * not be traversed.
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * <p>The standard {@link Class} API does not provide a mechanism for
	 * determining which class in an inheritance hierarchy actually declares
	 * one of several candidate {@linkplain Annotation annotations}, so we
	 * need to handle this explicitly.
	 * @param annotationTypes the annotation types to look for
	 * @param clazz the class to check for the annotation on (may be {@code null})
	 * @return the first {@link Class} in the inheritance hierarchy that
	 * declares an annotation of at least one of the specified
	 * {@code annotationTypes}, or {@code null} if not found
	 * @since 3.2.2
	 * @see Class#isAnnotationPresent(Class)
	 * @see Class#getDeclaredAnnotations()
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 在指定的{@code  clazz}（包括指定的{@code  clazz}本身）的继承层次结构中找到第一个{@link  Class}注解类型<em>直接存在</ em>。 
	 *  <p>如果提供的{@code  clazz}是一个接口，则仅会检查该接口本身； 
	 * 否则，将检查该接口。 
	 * 接口的继承层次结构将不会被遍历。 
	 *  <p>元注释将不被搜索。 
	 *  <p>标准的{@link 类} API没有提供一种机制来确定继承层次结构中的哪个类实际上声明了多个候选{@link  plain Annotation注解}中的一个，因此我们需要显式地进行处理。 
	 *  
	 * @param 注解类型键入注解类型以查找
	 * @param 使类在其上检查注解（可能是{@code  null}）
	 * @return 的第一个{@link  Class}继承层次结构，声明至少指定的{@code 注解类型}之一的注解； 
	 * 如果未找到，则声明{@code  null} @自3.2.2起。 
	 * 
	 * @see  Class＃isAnnotationPresent（Class）<
	 * @see > Class＃getDeclaredAnnotations（）@从5.2开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	@Nullable
	public static Class<?> findAnnotationDeclaringClassForTypes(
			List<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {

		if (clazz == null) {
			return null;
		}

		return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS)
				.stream()
				.filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent))
				.map(MergedAnnotation::getSource)
				.findFirst().orElse(null);
	}

	/**
	 * Determine whether an annotation of the specified {@code annotationType}
	 * is declared locally (i.e. <em>directly present</em>) on the supplied
	 * {@code clazz}.
	 * <p>The supplied {@link Class} may represent any type.
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * <p>Note: This method does <strong>not</strong> determine if the annotation
	 * is {@linkplain java.lang.annotation.Inherited inherited}.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on
	 * @return {@code true} if an annotation of the specified {@code annotationType}
	 * is <em>directly present</em>
	 * @see java.lang.Class#getDeclaredAnnotations()
	 * @see java.lang.Class#getDeclaredAnnotation(Class)
	 */
	/**
	 * 确定是否在提供的{@code  clazz}上本地声明（即直接存在<em> </ em>）指定的{@code  notificationType}的注释。 
	 *  <p>提供的{@link 类}可以代表任何类型。 
	 *  <p>元注释将不被搜索。 
	 *  <p>注意：此方法<strong>不会</ strong>确定注释是否为{@link  plain java.lang.annotation.InheritedInherited}。 
	 *  
	 * @param 注解键入注解类型以查找
	 * @param ，如果指定的{@code 注解类型}的注解为<，请在类中检查
	 * @return  {@code  true}上的注解< em>直接存在</ em> 
	 * @see  java.lang.Class＃getDeclaredAnnotations（）
	 * @see  java.lang.Class＃getDeclaredAnnotation（Class）
	 */
	public static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {
		return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();
	}

	/**
	 * Determine whether an annotation of the specified {@code annotationType}
	 * is <em>present</em> on the supplied {@code clazz} and is
	 * {@linkplain java.lang.annotation.Inherited inherited}
	 * (i.e. not <em>directly present</em>).
	 * <p>Meta-annotations will <em>not</em> be searched.
	 * <p>If the supplied {@code clazz} is an interface, only the interface
	 * itself will be checked. In accordance with standard meta-annotation
	 * semantics in Java, the inheritance hierarchy for interfaces will not
	 * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}
	 * for the {@code @Inherited} meta-annotation for further details regarding
	 * annotation inheritance.
	 * @param annotationType the annotation type to look for
	 * @param clazz the class to check for the annotation on
	 * @return {@code true} if an annotation of the specified {@code annotationType}
	 * is <em>present</em> and <em>inherited</em>
	 * @see Class#isAnnotationPresent(Class)
	 * @see #isAnnotationDeclaredLocally(Class, Class)
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 确定所提供的{@code  clazz}上的<em> present </ em>是否为指定的{@code 注解类型}的注解，并且是否为{@link 纯java.lang.annotation.Inherited继承的} （即不是<em>直接存在</ em>）。 
	 *  <p>元注释将不被搜索。 
	 *  <p>如果提供的{@code  clazz}是一个接口，则仅会检查该接口本身。 
	 * 根据Java中的标准元注释语义，将不会遍历接口的继承层次结构。 
	 * 有关注释继承的更多详细信息，请参见{@code  @Inherited}元注释的{@link  plain java.lang.annotation.Inherited javadoc}。 
	 *  
	 * @param 注解键入注解类型，以查找
	 * @param 使类在
	 * @return  {@code  true}上检查注解，如果指定的{@code 注解类型}的注解为< em> present </ em>和<em>继承</ em> 
	 * @see  Class＃isAnnotationPresent（Class）
	 * @see  #isAnnotationDeclaredLocally（Class，Class）@自5.2起不推荐使用，因为它已被{@link  MergedAnnotations} API
	 */
	@Deprecated
	public static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {
		return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)
				.stream(annotationType)
				.filter(MergedAnnotation::isDirectlyPresent)
				.findFirst().orElseGet(MergedAnnotation::missing)
				.getAggregateIndex() > 0;
	}

	/**
	 * Determine if an annotation of type {@code metaAnnotationType} is
	 * <em>meta-present</em> on the supplied {@code annotationType}.
	 * @param annotationType the annotation type to search on
	 * @param metaAnnotationType the type of meta-annotation to search for
	 * @return {@code true} if such an annotation is meta-present
	 * @since 4.2.1
	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API
	 */
	/**
	 * 确定类型{@code  metaAnnotationType}的注释在提供的{@code 注解类型}上是否为<em>元存在</ em>。 
	 *  
	 * @param 注释键入要在
	 * @param 上搜索的注释类型metaAnnotationType如果要注释的是元存在的，则要搜索
	 * @return  {@code  true}的元注释的类型@自4.2.1起@从5.2开始不推荐使用，因为它已被{@link  MergedAnnotations} API取代
	 */
	@Deprecated
	public static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,
			@Nullable Class<? extends Annotation> metaAnnotationType) {

		if (metaAnnotationType == null) {
			return false;
		}
		// Shortcut: directly present on the element, with no merging needed?
		if (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||
				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {
			return annotationType.isAnnotationPresent(metaAnnotationType);
		}
		// Exhaustive retrieval of merged annotations...
		return MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,
				RepeatableContainers.none()).isPresent(metaAnnotationType);
	}

	/**
	 * Determine if the supplied {@link Annotation} is defined in the core JDK
	 * {@code java.lang.annotation} package.
	 * @param annotation the annotation to check
	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package
	 */
	/**
	 * 确定是否在核心JDK {@code  java.lang.annotation}包中定义了提供的{@link 注释}。 
	 *  
	 * @param 注解注解以检查
	 * @return  {@code  true}是否在{@code  java.lang.annotation}包中
	 */
	public static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {
		return (annotation != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotation));
	}

	/**
	 * Determine if the {@link Annotation} with the supplied name is defined
	 * in the core JDK {@code java.lang.annotation} package.
	 * @param annotationType the name of the annotation type to check
	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package
	 * @since 4.2
	 */
	/**
	 * 确定是否在核心JDK {@code  java.lang.annotation}包中定义了具有提供名称的{@link 注释}。 
	 *  
	 * @param 注解键入注解类型的名称以检查
	 * @return  {@code  true}，如果注解位于{@code  java.lang.annotation}包中，自4.2起
	 */
	public static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {
		return (annotationType != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));
	}

	/**
	 * Check the declared attributes of the given annotation, in particular covering
	 * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for
	 * {@code Class} values (instead of early {@code Class.getAnnotations() failure}.
	 * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}
	 * won't failure either (when attempted later on).
	 * @param annotation the annotation to validate
	 * @throws IllegalStateException if a declared {@code Class} attribute could not be read
	 * @since 4.3.15
	 * @see Class#getAnnotations()
	 * @see #getAnnotationAttributes(Annotation)
	 */
	/**
	 * 检查给定注解的声明属性，尤其是检查{{@code> Class}值的Google App Engine迟到{@code  TypeNotPresentExceptionProxy}的情况（而不是早期的{@code  Class.getAnnotations（）失败}） 。 
	 * <p>此方法未失败表示{@link  #getAnnotationAttributes（Annotation）}也不会失败（稍后尝试）。 
	 * 
	 * @param 注释该注释以验证
	 * @throws  IllegalStateException（如果已声明）从4.3.15开始，无法读取{@code  Class}属性
	 * @see  Class＃getAnnotations（）
	 * @see  #getAnnotationAttributes（Annotation）
	 */
	public static void validateAnnotation(Annotation annotation) {
		AttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);
	}

	/**
	 * Retrieve the given annotation's attributes as a {@link Map}, preserving all
	 * attribute types.
	 * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
	 * set to {@code false}.
	 * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.
	 * However, the {@code Map} signature has been preserved for binary compatibility.
	 * @param annotation the annotation to retrieve the attributes for
	 * @return the Map of annotation attributes, with attribute names as keys and
	 * corresponding attribute values as values (never {@code null})
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)
	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	/**
	 * 以{@link  Map}的形式获取给定注释的属性，并保留所有属性类型。 
	 *  <p>等效于将{@code  classValuesAsString}和{@code  nestedAnnotationsAsMap}参数设置为{@code  false}的{{@link> #getAnnotationAttributes（Annotation，boolean，boolean）}。 
	 *  <p>注意：此方法实际上返回一个{@link  AnnotationAttributes}实例。 
	 * 但是，{<@code> Map}签名已保留，以实现二进制兼容性。 
	 *  
	 * @param 注释注释，以获取注释属性映射
	 * @return 的属性，属性名称作为键，相应的属性值作为值（从不<< @code> null}）
	 * @see  #getAnnotationAttributes（ AnnotatedElement，Annotation）
	 * @see  #getAnnotationAttributes（Annotation，boolean，boolean）
	 * @see  #getAnnotationAttributes（AnnotatedElement，Annotation，boolean，boolean）
	 */
	public static Map<String, Object> getAnnotationAttributes(Annotation annotation) {
		return getAnnotationAttributes(null, annotation);
	}

	/**
	 * Retrieve the given annotation's attributes as a {@link Map}.
	 * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}
	 * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.
	 * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.
	 * However, the {@code Map} signature has been preserved for binary compatibility.
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @return the Map of annotation attributes, with attribute names as keys and
	 * corresponding attribute values as values (never {@code null})
	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)
	 */
	/**
	 * 以{@link  Map}的形式获取给定注释的属性。 
	 *  <p>等效于将{@code  nestedAnnotationsAsMap}参数设置为{@code  false}的{{@link> #getAnnotationAttributes（Annotation，boolean，boolean）}}。 
	 *  <p>注意：此方法实际上返回一个{@link  AnnotationAttributes}实例。 
	 * 但是，{<@code> Map}签名已保留，以实现二进制兼容性。 
	 *  
	 * @param 注解注解以获取
	 * @param  classValuesAsString的属性，是将Class引用转换为String（与{@link  org.springframework.core.type.AnnotationMetadata}兼容）还是将其保留为Class引用
	 * @return 注释属性的映射，以属性名称作为键，并以相应的属性值作为值（从不{@code  null}）
	 * @see  #getAnnotationAttributes（Annotation，boolean，boolean）
	 */
	public static Map<String, Object> getAnnotationAttributes(
			Annotation annotation, boolean classValuesAsString) {

		return getAnnotationAttributes(annotation, classValuesAsString, false);
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * <p>This method provides fully recursive annotation reading capabilities on par with
	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested annotations into
	 * {@link AnnotationAttributes} maps (for compatibility with
	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as
	 * {@code Annotation} instances
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 3.1.1
	 */
	/**
	 * 检索给定注解的属性作为{@link  AnnotationAttributes}映射。 
	 *  <p>此方法提供了与基于反射的{@link  org.springframework.core.type.StandardAnnotationMetadata}相当的完全递归注释读取功能。 
	 *  
	 * @param 注解注解以获取
	 * @param  classValuesAsString的属性，是将Class引用转换为String（与{@link  org.springframework.core.type.AnnotationMetadata}兼容）还是将其保留为Class引用
	 * @param  nestedAnnotationsAsMap是将嵌套的注释转换为{@link  AnnotationAttributes}映射（以与{@link  org.springframework.core.type.AnnotationMetadata}兼容）还是将其保留为{@code 从3.1.1版本开始，Annotation}实例
	 * @return 以属性名称作为键并将对应的属性值作为值（从不{<@@code> null}）的注释属性（专用Map）@3.1.1开始
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		return getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}
	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters
	 * set to {@code false}.
	 * @param annotatedElement the element that is annotated with the supplied annotation;
	 * may be {@code null} if unknown
	 * @param annotation the annotation to retrieve the attributes for
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 4.2
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	/**
	 * 检索给定注解的属性作为{@link  AnnotationAttributes}映射。 
	 *  <p>等效于将{@code  classValuesAsString}和{@code  nestedAnnotationsAsMap}参数设置为{@code  false}的{{@link> #getAnnotationAttributes（AnnotatedElement，Annotation，boolean，boolean）} 。 
	 *  
	 * @param  annotatedElement用提供的注释注释的元素； 
	 * 如果未知的
	 * @param 注释，则注释可以为
	 * @return 的注释属性（一个专用的Map），以属性名称作为键，而对应的属性值作为值（从不{@code  null}）@since 4.2 
	 * @see  #getAnnotationAttributes（AnnotatedElement，Annotation，boolean，boolean）
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			@Nullable AnnotatedElement annotatedElement, Annotation annotation) {

		return getAnnotationAttributes(annotatedElement, annotation, false, false);
	}

	/**
	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.
	 * <p>This method provides fully recursive annotation reading capabilities on par with
	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.
	 * @param annotatedElement the element that is annotated with the supplied annotation;
	 * may be {@code null} if unknown
	 * @param annotation the annotation to retrieve the attributes for
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @param nestedAnnotationsAsMap whether to convert nested annotations into
	 * {@link AnnotationAttributes} maps (for compatibility with
	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as
	 * {@code Annotation} instances
	 * @return the annotation attributes (a specialized Map) with attribute names as keys
	 * and corresponding attribute values as values (never {@code null})
	 * @since 4.2
	 */
	/**
	 * 检索给定注解的属性作为{@link  AnnotationAttributes}映射。 
	 *  <p>此方法提供了与基于反射的{@link  org.springframework.core.type.StandardAnnotationMetadata}相当的完全递归注释读取功能。 
	 *  
	 * @param  annotatedElement用提供的注释注释的元素； 
	 * 如果未知的
	 * @param 注解，则该注解可以为{@code  null}，该注解用于检索
	 * @param  classValuesAsString的属性，是否将Class引用转换为字符串（与{@link  org.springframework.core兼容。 
	 *  type.AnnotationMetadata}）还是将其保留为类引用
	 * @param  nestedAnnotationsAsMap是否将嵌套的注释转换为{@link  AnnotationAttributes}映射（以与{@link  org.springframework.core.type.AnnotationMetadata}兼容）或将其保存为{@code  Annotation}实例
	 * @return 注释属性（专用Map），其属性名称为键，而对应的属性值作为值（从{@code  null}开始）4.2
	 */
	public static AnnotationAttributes getAnnotationAttributes(
			@Nullable AnnotatedElement annotatedElement, Annotation annotation,
			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {

		Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);
		return MergedAnnotation.from(annotatedElement, annotation)
				.withNonMergedAttributes()
				.asMap(mergedAnnotation ->
						new AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);
	}

	/**
	 * Register the annotation-declared default values for the given attributes,
	 * if available.
	 * @param attributes the annotation attributes to process
	 * @since 4.3.2
	 */
	/**
	 * 如果可用，请为给定属性注册注释声明的默认值。 
	 *  
	 * @param 为注释属性赋予属性，以处理自4.3.2起
	 */
	public static void registerDefaultValues(AnnotationAttributes attributes) {
		Class<? extends Annotation> annotationType = attributes.annotationType();
		if (annotationType != null && Modifier.isPublic(annotationType.getModifiers()) &&
				!AnnotationFilter.PLAIN.matches(annotationType)) {
			Map<String, DefaultValueHolder> defaultValues = getDefaultValues(annotationType);
			defaultValues.forEach(attributes::putIfAbsent);
		}
	}

	private static Map<String, DefaultValueHolder> getDefaultValues(
			Class<? extends Annotation> annotationType) {

		return defaultValuesCache.computeIfAbsent(annotationType,
				AnnotationUtils::computeDefaultValues);
	}

	private static Map<String, DefaultValueHolder> computeDefaultValues(
			Class<? extends Annotation> annotationType) {

		AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);
		if (!methods.hasDefaultValueMethod()) {
			return Collections.emptyMap();
		}
		Map<String, DefaultValueHolder> result = new LinkedHashMap<>(methods.size());
		if (!methods.hasNestedAnnotation()) {
			// Use simpler method if there are no nested annotations
			for (int i = 0; i < methods.size(); i++) {
				Method method = methods.get(i);
				Object defaultValue = method.getDefaultValue();
				if (defaultValue != null) {
					result.put(method.getName(), new DefaultValueHolder(defaultValue));
				}
			}
		}
		else {
			// If we have nested annotations, we need them as nested maps
			AnnotationAttributes attributes = MergedAnnotation.of(annotationType)
					.asMap(annotation ->
							new AnnotationAttributes(annotation.getType(), true), Adapt.ANNOTATION_TO_MAP);
			for (Map.Entry<String, Object> element : attributes.entrySet()) {
				result.put(element.getKey(), new DefaultValueHolder(element.getValue()));
			}
		}
		return result;
	}

	/**
	 * Post-process the supplied {@link AnnotationAttributes}, preserving nested
	 * annotations as {@code Annotation} instances.
	 * <p>Specifically, this method enforces <em>attribute alias</em> semantics
	 * for annotation attributes that are annotated with {@link AliasFor @AliasFor}
	 * and replaces default value placeholders with their original default values.
	 * @param annotatedElement the element that is annotated with an annotation or
	 * annotation hierarchy from which the supplied attributes were created;
	 * may be {@code null} if unknown
	 * @param attributes the annotation attributes to post-process
	 * @param classValuesAsString whether to convert Class references into Strings (for
	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})
	 * or to preserve them as Class references
	 * @since 4.3.2
	 * @see #getDefaultValue(Class, String)
	 */
	/**
	 * 对提供的{@link  AnnotationAttributes}进行后处理，将嵌套的注释保留为{@code  Annotation}实例。 
	 *  <p>具体来说，此方法对使用{@link  AliasFor @AliasFor}注释的注释属性强制使用<em>属性别名</ em>语义，并将默认值占位符替换为其原始默认值。 
	 *  
	 * @param  annotatedElement用注释或注释层次结构注释的元素，从中创建提供的属性； 
	 * 如果未知的
	 * @param 将注释属性赋予后处理
	 * @param  classValuesAsString是否将Class引用转换为字符串（与{@link  org.springframework.core兼容），则可以为{@code  null}。 
	 *  type.AnnotationMetadata}）或将其保存为类引用（自4.3.2起）
	 * @see  #getDefaultValue（Class，String）
	 */
	public static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,
			@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {

		if (attributes == null) {
			return;
		}
		if (!attributes.validated) {
			Class<? extends Annotation> annotationType = attributes.annotationType();
			if (annotationType == null) {
				return;
			}
			AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);
			for (int i = 0; i < mapping.getMirrorSets().size(); i++) {
				MirrorSet mirrorSet = mapping.getMirrorSets().get(i);
				int resolved = mirrorSet.resolve(attributes.displayName, attributes,
						AnnotationUtils::getAttributeValueForMirrorResolution);
				if (resolved != -1) {
					Method attribute = mapping.getAttributes().get(resolved);
					Object value = attributes.get(attribute.getName());
					for (int j = 0; j < mirrorSet.size(); j++) {
						Method mirror = mirrorSet.get(j);
						if (mirror != attribute) {
							attributes.put(mirror.getName(),
									adaptValue(annotatedElement, value, classValuesAsString));
						}
					}
				}
			}
		}
		for (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {
			String attributeName = attributeEntry.getKey();
			Object value = attributeEntry.getValue();
			if (value instanceof DefaultValueHolder) {
				value = ((DefaultValueHolder) value).defaultValue;
				attributes.put(attributeName,
						adaptValue(annotatedElement, value, classValuesAsString));
			}
		}
	}

	private static Object getAttributeValueForMirrorResolution(Method attribute, Object attributes) {
		Object result = ((AnnotationAttributes) attributes).get(attribute.getName());
		return (result instanceof DefaultValueHolder ? ((DefaultValueHolder) result).defaultValue : result);
	}

	@Nullable
	private static Object adaptValue(
			@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {

		if (classValuesAsString) {
			if (value instanceof Class) {
				return ((Class<?>) value).getName();
			}
			if (value instanceof Class[]) {
				Class<?>[] classes = (Class<?>[]) value;
				String[] names = new String[classes.length];
				for (int i = 0; i < classes.length; i++) {
					names[i] = classes[i].getName();
				}
				return names;
			}
		}
		if (value instanceof Annotation) {
			Annotation annotation = (Annotation) value;
			return MergedAnnotation.from(annotatedElement, annotation).synthesize();
		}
		if (value instanceof Annotation[]) {
			Annotation[] annotations = (Annotation[]) value;
			Annotation[] synthesized = (Annotation[]) Array.newInstance(
					annotations.getClass().getComponentType(), annotations.length);
			for (int i = 0; i < annotations.length; i++) {
				synthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();
			}
			return synthesized;
		}
		return value;
	}

	/**
	 * Retrieve the <em>value</em> of the {@code value} attribute of a
	 * single-element Annotation, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the value
	 * @return the attribute value, or {@code null} if not found unless the attribute
	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},
	 * in which case such an exception will be rethrown
	 * @see #getValue(Annotation, String)
	 */
	/**
	 * 在给定注释实例的情况下，检索单元素注释的{@code  value}属性的<em> value </ em>。 
	 *  
	 * @param 注释从中检索值的注释实例
	 * @return 属性值，或者如果找不到{{@code> null}，除非由于{@link  AnnotationConfigurationException}而无法检索属性值，在这种情况下，将抛出此类异常
	 * @see  #getValue（Annotation，String）
	 */
	@Nullable
	public static Object getValue(Annotation annotation) {
		return getValue(annotation, VALUE);
	}

	/**
	 * Retrieve the <em>value</em> of a named attribute, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the value
	 * @param attributeName the name of the attribute value to retrieve
	 * @return the attribute value, or {@code null} if not found unless the attribute
	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},
	 * in which case such an exception will be rethrown
	 * @see #getValue(Annotation)
	 */
	/**
	 * 给定注释实例，检索命名属性的<em> value </ em>。 
	 *  
	 * @param 注解从中检索值的注解实例
	 * @param  attributeName要检索的属性值的名称
	 * @return 属性值，如果没有找到，则返回{@code  null}，除非属性值由于{@link  AnnotationConfigurationException}而无法检索，在这种情况下，将抛出此类异常
	 * @see  #getValue（Annotation）
	 */
	@Nullable
	public static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {
		if (annotation == null || !StringUtils.hasText(attributeName)) {
			return null;
		}
		try {
			Method method = annotation.annotationType().getDeclaredMethod(attributeName);
			ReflectionUtils.makeAccessible(method);
			return method.invoke(annotation);
		}
		catch (NoSuchMethodException ex) {
			return null;
		}
		catch (InvocationTargetException ex) {
			rethrowAnnotationConfigurationException(ex.getTargetException());
			throw new IllegalStateException("Could not obtain value for annotation attribute '" +
					attributeName + "' in " + annotation, ex);
		}
		catch (Throwable ex) {
			handleIntrospectionFailure(annotation.getClass(), ex);
			return null;
		}
	}

	/**
	 * If the supplied throwable is an {@link AnnotationConfigurationException},
	 * it will be cast to an {@code AnnotationConfigurationException} and thrown,
	 * allowing it to propagate to the caller.
	 * <p>Otherwise, this method does nothing.
	 * @param ex the throwable to inspect
	 */
	/**
	 * 如果提供的throwable是{@link  AnnotationConfigurationException}，它将被强制转换为{@code  AnnotationConfigurationException}并抛出，从而使其传播到调用方。 
	 *  <p>否则，此方法不执行任何操作。 
	 *  
	 * @param  ex throwable检查
	 */
	static void rethrowAnnotationConfigurationException(Throwable ex) {
		if (ex instanceof AnnotationConfigurationException) {
			throw (AnnotationConfigurationException) ex;
		}
	}

	/**
	 * Handle the supplied annotation introspection exception.
	 * <p>If the supplied exception is an {@link AnnotationConfigurationException},
	 * it will simply be thrown, allowing it to propagate to the caller, and
	 * nothing will be logged.
	 * <p>Otherwise, this method logs an introspection failure (in particular for
	 * a {@link TypeNotPresentException}) before moving on, assuming nested
	 * {@code Class} values were not resolvable within annotation attributes and
	 * thereby effectively pretending there were no annotations on the specified
	 * element.
	 * @param element the element that we tried to introspect annotations on
	 * @param ex the exception that we encountered
	 * @see #rethrowAnnotationConfigurationException
	 * @see IntrospectionFailureLogger
	 */
	/**
	 * 处理提供的注释自省异常。 
	 *  <p>如果提供的异常是{@link  AnnotationConfigurationException}，则将引发该异常，使其传播到调用方，并且不会记录任何内容。 
	 *  <p>否则，此方法在继续进行操作之前会记录自省失败（特别是对于{@link  TypeNotPresentException}而言），假设嵌套的{@code  Class}值在注释属性中不可解析，从而有效地假装存在指定元素上没有注释。 
	 *  
	 * @param 元素我们尝试对
	 * @param 上的注释进行内省的元素，除了我们遇到的异常
	 * @see  #rethrowAnnotationConfigurationException 
	 * @see  IntrospectionFailureLogger
	 */
	static void handleIntrospectionFailure(@Nullable AnnotatedElement element, Throwable ex) {
		rethrowAnnotationConfigurationException(ex);
		IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;
		boolean meta = false;
		if (element instanceof Class && Annotation.class.isAssignableFrom((Class<?>) element)) {
			// Meta-annotation or (default) value lookup on an annotation type
			logger = IntrospectionFailureLogger.DEBUG;
			meta = true;
		}
		if (logger.isEnabled()) {
			String message = meta ?
					"Failed to meta-introspect annotation " :
					"Failed to introspect annotations on ";
			logger.log(message + element + ": " + ex);
		}
	}

	/**
	 * Retrieve the <em>default value</em> of the {@code value} attribute
	 * of a single-element Annotation, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the default value
	 * @return the default value, or {@code null} if not found
	 * @see #getDefaultValue(Annotation, String)
	 */
	/**
	 * 在给定注释实例的情况下，检索单元素注释的{@code  value}属性的<em>默认值</ em>。 
	 *  
	 * @param 注解从中检索默认值的注解实例
	 * @return 默认值，如果找不到，则返回{@code  null} 
	 * @see  #getDefaultValue（Annotation，String）
	 */
	@Nullable
	public static Object getDefaultValue(Annotation annotation) {
		return getDefaultValue(annotation, VALUE);
	}

	/**
	 * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.
	 * @param annotation the annotation instance from which to retrieve the default value
	 * @param attributeName the name of the attribute value to retrieve
	 * @return the default value of the named attribute, or {@code null} if not found
	 * @see #getDefaultValue(Class, String)
	 */
	/**
	 * 在给定注释实例的情况下，检索命名属性的<em>默认值</ em>。 
	 *  
	 * @param 注解从中检索默认值的注解实例
	 * @param  attributeName要检索的属性值的名称
	 * @return 命名属性的默认值，如果不是，则为{@code  null}找到
	 * @see  #getDefaultValue（Class，String）
	 */
	@Nullable
	public static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {
		return (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);
	}

	/**
	 * Retrieve the <em>default value</em> of the {@code value} attribute
	 * of a single-element Annotation, given the {@link Class annotation type}.
	 * @param annotationType the <em>annotation type</em> for which the default value should be retrieved
	 * @return the default value, or {@code null} if not found
	 * @see #getDefaultValue(Class, String)
	 */
	/**
	 * 在给定{@link 类注释类型}的情况下，检索单元素注释的{@code  value}属性的<em>默认值</ em>。 
	 *  
	 * @param 注释键入应为其获取默认值的<em>注释类型</ em> 
	 * @return 默认值，如果找不到，则为{@code  null} 
	 * @see  #getDefaultValue（Class ，字符串）
	 */
	@Nullable
	public static Object getDefaultValue(Class<? extends Annotation> annotationType) {
		return getDefaultValue(annotationType, VALUE);
	}

	/**
	 * Retrieve the <em>default value</em> of a named attribute, given the
	 * {@link Class annotation type}.
	 * @param annotationType the <em>annotation type</em> for which the default value should be retrieved
	 * @param attributeName the name of the attribute value to retrieve.
	 * @return the default value of the named attribute, or {@code null} if not found
	 * @see #getDefaultValue(Annotation, String)
	 */
	/**
	 * 在给定{@link 类注释类型}的情况下，检索命名属性的<em>默认值</ em>。 
	 *  
	 * @param 注记类型<em>注释类型</ em>，应为其获取默认值
	 * @param  attributeName要检索的属性值的名称。 
	 *  
	 * @return 命名属性的默认值，如果找不到，则为{<@@code> null} 
	 * @see  #getDefaultValue（Annotation，String）
	 */
	@Nullable
	public static Object getDefaultValue(
			@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {

		if (annotationType == null || !StringUtils.hasText(attributeName)) {
			return null;
		}
		return MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);
	}

	/**
	 * <em>Synthesize</em> an annotation from the supplied {@code annotation}
	 * by wrapping it in a dynamic proxy that transparently enforces
	 * <em>attribute alias</em> semantics for annotation attributes that are
	 * annotated with {@link AliasFor @AliasFor}.
	 * @param annotation the annotation to synthesize
	 * @param annotatedElement the element that is annotated with the supplied
	 * annotation; may be {@code null} if unknown
	 * @return the synthesized annotation if the supplied annotation is
	 * <em>synthesizable</em>; {@code null} if the supplied annotation is
	 * {@code null}; otherwise the supplied annotation unmodified
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 * @see #synthesizeAnnotation(Class)
	 */
	/**
	 * 通过将所提供的{@code 注释}封装在动态代理中，从而对所提供的{@code 注释}进行<em> Synthesize </ em>注释，该代理透明地对由{<@链接> AliasFor @AliasFor}。 
	 *  
	 * @param 注释注释以合成
	 * @param  annotatedElement用提供的注释注释的元素； 
	 * 如果提供的注释是<em> synthesizable </ em>，则可能为{@code  null}（如果未知）。 
	 *  {@code  null}，如果提供的注释为{@code  null}； 
	 * 否则，如果检测到{@code  @AliasFor}的无效配置，则提供的注释未修改的
	 * @throws  AnnotationConfigurationException @自4.2起
	 * @see  #synthesizeAnnotation（Map，Class，AnnotatedElement）
	 * @see  #synthesizeAnnotation（Class）
	 */
	public static <A extends Annotation> A synthesizeAnnotation(
			A annotation, @Nullable AnnotatedElement annotatedElement) {

		if (annotation instanceof SynthesizedAnnotation || AnnotationFilter.PLAIN.matches(annotation)) {
			return annotation;
		}
		return MergedAnnotation.from(annotatedElement, annotation).synthesize();
	}

	/**
	 * <em>Synthesize</em> an annotation from its default attributes values.
	 * <p>This method simply delegates to
	 * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},
	 * supplying an empty map for the source attribute values and {@code null}
	 * for the {@link AnnotatedElement}.
	 * @param annotationType the type of annotation to synthesize
	 * @return the synthesized annotation
	 * @throws IllegalArgumentException if a required attribute is missing
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 */
	/**
	 * 根据其默认属性值<em> Synthesize </ em>进行注释。 
	 *  <p>此方法仅委托给{@link  #synthesizeAnnotation（Map，Class，AnnotatedElement）}，为源属性值提供一个空映射，为{@link  AnnotatedElement}提供{@code  null} 。 
	 *  
	 * @param 注解键入要合成的注解的类型
	 * @return 合成注解
	 * @throws 如果缺少必需的属性，则抛出IllegalArgumentException 
	 * @throws 如果检测到{@code  @AliasFor}的无效配置，则@AnthationConfigurationException @since 4.2 
	 * @see  #synthesizeAnnotation（Map，Class，AnnotatedElement）
	 * @see  #synthesizeAnnotation（Annotation，AnnotatedElement）
	 */
	public static <A extends Annotation> A synthesizeAnnotation(Class<A> annotationType) {
		return synthesizeAnnotation(Collections.emptyMap(), annotationType, null);
	}

	/**
	 * <em>Synthesize</em> an annotation from the supplied map of annotation
	 * attributes by wrapping the map in a dynamic proxy that implements an
	 * annotation of the specified {@code annotationType} and transparently
	 * enforces <em>attribute alias</em> semantics for annotation attributes
	 * that are annotated with {@link AliasFor @AliasFor}.
	 * <p>The supplied map must contain a key-value pair for every attribute
	 * defined in the supplied {@code annotationType} that is not aliased or
	 * does not have a default value. Nested maps and nested arrays of maps
	 * will be recursively synthesized into nested annotations or nested
	 * arrays of annotations, respectively.
	 * <p>Note that {@link AnnotationAttributes} is a specialized type of
	 * {@link Map} that is an ideal candidate for this method's
	 * {@code attributes} argument.
	 * @param attributes the map of annotation attributes to synthesize
	 * @param annotationType the type of annotation to synthesize
	 * @param annotatedElement the element that is annotated with the annotation
	 * corresponding to the supplied attributes; may be {@code null} if unknown
	 * @return the synthesized annotation
	 * @throws IllegalArgumentException if a required attribute is missing or if an
	 * attribute is not of the correct type
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 * @see #synthesizeAnnotation(Class)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)
	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)
	 */
	/**
	 * <em> Synthesize </ em>通过提供的注释属性映射中的注释，将其包装在动态代理中，该代理将实现指定的{@code  notificationType}的注释并透明地强制<em>属性别名</ em >用{@link  AliasFor @AliasFor}注释的注释属性的语义。 
	 *  <p>提供的映射必须为提供的{@code 注解类型}中定义的每个属性都包含一个键-值对，该属性没有别名或没有默认值。 
	 * 嵌套的地图和嵌套的地图数组将分别递归合成嵌套的注释或嵌套的注释数组。 
	 *  <p>请注意，{<@link> AnnotationAttributes}是{@link  Map}的一种特殊类型，它是此方法的{@code  attributes}参数的理想候选者。 
	 *  
	 * @param 将注释属性的地图属性进行合成，以进行合成。 
	 * 
	 * @param 注释键入要进行综合的注释的类型。 
	 * 
	 * @param  annotatedElement用与所提供的属性相对应的注释进行注释的元素； 
	 * 如果未知
	 * @return 合成的注释
	 * @throws  IllegalArgumentException，如果未知，或者属性的类型不正确，则可能为{@code  null}如果属性无效，则{@<throws> AnnotationConfigurationException @code> @AliasFor} @自4.2开始被检测到，注释，布尔值，布尔值）
	 */
	public static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,
			Class<A> annotationType, @Nullable AnnotatedElement annotatedElement) {

		try {
			return MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();
		}
		catch (NoSuchElementException | IllegalStateException ex) {
			throw new IllegalArgumentException(ex);
		}
	}

	/**
	 * <em>Synthesize</em> an array of annotations from the supplied array
	 * of {@code annotations} by creating a new array of the same size and
	 * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,
	 * AnnotatedElement) synthesized} versions of the annotations from the input
	 * array.
	 * @param annotations the array of annotations to synthesize
	 * @param annotatedElement the element that is annotated with the supplied
	 * array of annotations; may be {@code null} if unknown
	 * @return a new array of synthesized annotations, or {@code null} if
	 * the supplied array is {@code null}
	 * @throws AnnotationConfigurationException if invalid configuration of
	 * {@code @AliasFor} is detected
	 * @since 4.2
	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)
	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)
	 */
	/**
	 * 从提供的{@code 注解}数组中<em> Synthesize </ em>注释数组，方法是创建一个大小和类型相同的新数组，并用{@link  plain #synthesizeAnnotation（Annotation， AnnotatedElement）从输入数组合成}版本的注释。 
	 *  
	 * @param 注解注释数组以合成
	 * @param  annotatedElement用提供的注解数组注释的元素； 
	 * 如果未知
	 * @return 一个新的合成注释数组，则可以为{@code  null}； 
	 * 如果提供的数组为{@code  null}，则可以为{@code  null}； 
	 * 如果配置无效，则可以为{
	 * @throws> AnnotationConfigurationException自4.2起就检测到{@code  @AliasFor}的值
	 * @see  #synthesizeAnnotation（Annotation，AnnotatedElement）
	 * @see  #synthesizeAnnotation（Map，Class，AnnotatedElement）
	 */
	static Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {
		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {
			return annotations;
		}
		Annotation[] synthesized = (Annotation[]) Array.newInstance(
				annotations.getClass().getComponentType(), annotations.length);
		for (int i = 0; i < annotations.length; i++) {
			synthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);
		}
		return synthesized;
	}

	/**
	 * Clear the internal annotation metadata cache.
	 * @since 4.3.15
	 */
	/**
	 * 清除内部注释元数据缓存。 
	 *  @自4.3.15起
	 */
	public static void clearCache() {
		AnnotationTypeMappings.clearCache();
		AnnotationsScanner.clearCache();
	}


	/**
	 * Internal holder used to wrap default values.
	 */
	/**
	 * 内部持有人，用于包装默认值。 
	 * 
	 */
	private static class DefaultValueHolder {

		final Object defaultValue;

		public DefaultValueHolder(Object defaultValue) {
			this.defaultValue = defaultValue;
		}

		@Override
		public String toString() {
			return "*" + this.defaultValue;
		}
	}

}
