/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;

/**
 * This class can be used to parse other classes containing constant definitions
 * in public static final members. The {@code asXXXX} methods of this class
 * allow these constant values to be accessed via their string names.
 *
 * <p>Consider class Foo containing {@code public final static int CONSTANT1 = 66;}
 * An instance of this class wrapping {@code Foo.class} will return the constant value
 * of 66 from its {@code asNumber} method given the argument {@code "CONSTANT1"}.
 *
 * <p>This class is ideal for use in PropertyEditors, enabling them to
 * recognize the same names as the constants themselves, and freeing them
 * from maintaining their own mapping.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 16.03.2003
 */
/**
 * 此类可用于解析其他包含公共静态最终成员中的常量定义的类。 
 * 此类的{@code  asXXXX}方法允许通过它们的字符串名称访问这些常量值。 
 *  <p>考虑包含{@code  public final static int CONSTANT1 = 66;}的类Foo，此类包装{@code  Foo.class}的实例将从其{@code 给定参数{@code "CONSTANT1"}的asNumber}方法。 
 *  <p>此类非常适合在PropertyEditor中使用，使它们能够识别与常量本身相同的名称，并使它们免于维护自己的映射。 
 *  @author  Rod Johnson @author  Juergen Hoeller @自2003年3月16日起
 */
public class Constants {

	/** The name of the introspected class. */
	/**
	 * 自省类的名称。 
	 * 
	 */
	private final String className;

	/** Map from String field name to object value. */
	/**
	 * 从字符串字段名称映射到对象值。 
	 * 
	 */
	private final Map<String, Object> fieldCache = new HashMap<>();


	/**
	 * Create a new Constants converter class wrapping the given class.
	 * <p>All <b>public</b> static final variables will be exposed, whatever their type.
	 * @param clazz the class to analyze
	 * @throws IllegalArgumentException if the supplied {@code clazz} is {@code null}
	 */
	/**
	 * 创建一个包装给定类的新的Constants转换器类。 
	 *  <p>所有<b> public </ b>静态最终变量，无论其类型如何，都将公开。 
	 *  
	 * @param 如果提供的{@code  clazz}为{@code  null}，则使类分析
	 * @throws  IllegalArgumentException类。 
	 * 
	 */
	public Constants(Class<?> clazz) {
		Assert.notNull(clazz, "Class must not be null");
		this.className = clazz.getName();
		Field[] fields = clazz.getFields();
		for (Field field : fields) {
			if (ReflectionUtils.isPublicStaticFinal(field)) {
				String name = field.getName();
				try {
					Object value = field.get(null);
					this.fieldCache.put(name, value);
				}
				catch (IllegalAccessException ex) {
					// just leave this field and continue
				}
			}
		}
	}


	/**
	 * Return the name of the analyzed class.
	 */
	/**
	 * 返回所分析类的名称。 
	 * 
	 */
	public final String getClassName() {
		return this.className;
	}

	/**
	 * Return the number of constants exposed.
	 */
	/**
	 * 返回暴露的常量数。 
	 * 
	 */
	public final int getSize() {
		return this.fieldCache.size();
	}

	/**
	 * Exposes the field cache to subclasses:
	 * a Map from String field name to object value.
	 */
	/**
	 * 将字段缓存公开给子类：从字符串字段名称到对象值的映射。 
	 * 
	 */
	protected final Map<String, Object> getFieldCache() {
		return this.fieldCache;
	}


	/**
	 * Return a constant value cast to a Number.
	 * @param code the name of the field (never {@code null})
	 * @return the Number value
	 * @throws ConstantException if the field name wasn't found
	 * or if the type wasn't compatible with Number
	 * @see #asObject
	 */
	/**
	 * 返回转换为数字的常量值。 
	 *  
	 * @param 编码字段名称（从不{<@@code> null}）
	 * @return  Number值
	 * @throws  ConstantException，如果找不到字段名称或类型与Number不兼容
	 * @see  #asObject
	 */
	public Number asNumber(String code) throws ConstantException {
		Object obj = asObject(code);
		if (!(obj instanceof Number)) {
			throw new ConstantException(this.className, code, "not a Number");
		}
		return (Number) obj;
	}

	/**
	 * Return a constant value as a String.
	 * @param code the name of the field (never {@code null})
	 * @return the String value
	 * Works even if it's not a string (invokes {@code toString()}).
	 * @throws ConstantException if the field name wasn't found
	 * @see #asObject
	 */
	/**
	 * 返回一个常量值作为字符串。 
	 *  
	 * @param 对字段名称进行编码（绝不{<@@code> null}）
	 * @return 即使字符串不是字符串，字符串值也有效（调用{@code  toString（）}）。 
	 *  
	 * @throws 如果未找到字段名称，则为ConstantException 
	 * @see  #asObject
	 */
	public String asString(String code) throws ConstantException {
		return asObject(code).toString();
	}

	/**
	 * Parse the given String (upper or lower case accepted) and return
	 * the appropriate value if it's the name of a constant field in the
	 * class that we're analysing.
	 * @param code the name of the field (never {@code null})
	 * @return the Object value
	 * @throws ConstantException if there's no such field
	 */
	/**
	 * 解析给定的String（接受大写或小写），如果它是我们正在分析的类中常量字段的名称，则返回适当的值。 
	 *  
	 * @param 编码字段的名称（不要{<@@code> null}）
	 * @return 对象值
	 * @throws  ConstantException（如果没有这样的字段）
	 */
	public Object asObject(String code) throws ConstantException {
		Assert.notNull(code, "Code must not be null");
		String codeToUse = code.toUpperCase(Locale.ENGLISH);
		Object val = this.fieldCache.get(codeToUse);
		if (val == null) {
			throw new ConstantException(this.className, codeToUse, "not found");
		}
		return val;
	}


	/**
	 * Return all names of the given group of constants.
	 * <p>Note that this method assumes that constants are named
	 * in accordance with the standard Java convention for constant
	 * values (i.e. all uppercase). The supplied {@code namePrefix}
	 * will be uppercased (in a locale-insensitive fashion) prior to
	 * the main logic of this method kicking in.
	 * @param namePrefix prefix of the constant names to search (may be {@code null})
	 * @return the set of constant names
	 */
	/**
	 * 返回给定常量组的所有名称。 
	 *  <p>请注意，此方法假定根据常量值的标准Java约定（即所有大写字母）命名常量。 
	 * 所提供的{@code  namePrefix}在此方法的主要逻辑生效之前将被大写（以不区分语言环境的方式）。 
	 * 
	 * @param  namePrefix要搜索的常量名称的前缀（可以是{<@code > null}）
	 * @return 常量名称集
	 */
	public Set<String> getNames(@Nullable String namePrefix) {
		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "");
		Set<String> names = new HashSet<>();
		for (String code : this.fieldCache.keySet()) {
			if (code.startsWith(prefixToUse)) {
				names.add(code);
			}
		}
		return names;
	}

	/**
	 * Return all names of the group of constants for the
	 * given bean property name.
	 * @param propertyName the name of the bean property
	 * @return the set of values
	 * @see #propertyToConstantNamePrefix
	 */
	/**
	 * 返回给定bean属性名称的常量组的所有名称。 
	 *  
	 * @param  propertyName Bean属性的名称
	 * @return 值集
	 * @see  #propertyToConstantNamePrefix
	 */
	public Set<String> getNamesForProperty(String propertyName) {
		return getNames(propertyToConstantNamePrefix(propertyName));
	}

	/**
	 * Return all names of the given group of constants.
	 * <p>Note that this method assumes that constants are named
	 * in accordance with the standard Java convention for constant
	 * values (i.e. all uppercase). The supplied {@code nameSuffix}
	 * will be uppercased (in a locale-insensitive fashion) prior to
	 * the main logic of this method kicking in.
	 * @param nameSuffix suffix of the constant names to search (may be {@code null})
	 * @return the set of constant names
	 */
	/**
	 * 返回给定常量组的所有名称。 
	 *  <p>请注意，此方法假定根据常量值的标准Java约定（即所有大写字母）命名常量。 
	 * 所提供的{@code  nameSuffix}在此方法的主要逻辑生效之前将被大写（以不区分语言环境的方式）。 
	 * 
	 * @param  nameSuffix要搜索的常量名称的后缀（可以为{<@code > null}）
	 * @return 常量名称集
	 */
	public Set<String> getNamesForSuffix(@Nullable String nameSuffix) {
		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "");
		Set<String> names = new HashSet<>();
		for (String code : this.fieldCache.keySet()) {
			if (code.endsWith(suffixToUse)) {
				names.add(code);
			}
		}
		return names;
	}


	/**
	 * Return all values of the given group of constants.
	 * <p>Note that this method assumes that constants are named
	 * in accordance with the standard Java convention for constant
	 * values (i.e. all uppercase). The supplied {@code namePrefix}
	 * will be uppercased (in a locale-insensitive fashion) prior to
	 * the main logic of this method kicking in.
	 * @param namePrefix prefix of the constant names to search (may be {@code null})
	 * @return the set of values
	 */
	/**
	 * 返回给定常量组的所有值。 
	 *  <p>请注意，此方法假定根据常量值的标准Java约定（即所有大写字母）命名常量。 
	 * 所提供的{@code  namePrefix}在此方法的主要逻辑生效之前将被大写（以不区分语言环境的方式）。 
	 * 
	 * @param  namePrefix要搜索的常量名称的前缀（可以是{<@code > null}）
	 * @return 一组值
	 */
	public Set<Object> getValues(@Nullable String namePrefix) {
		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "");
		Set<Object> values = new HashSet<>();
		this.fieldCache.forEach((code, value) -> {
			if (code.startsWith(prefixToUse)) {
				values.add(value);
			}
		});
		return values;
	}

	/**
	 * Return all values of the group of constants for the
	 * given bean property name.
	 * @param propertyName the name of the bean property
	 * @return the set of values
	 * @see #propertyToConstantNamePrefix
	 */
	/**
	 * 返回给定bean属性名称的常量组的所有值。 
	 *  
	 * @param  propertyName Bean属性的名称
	 * @return 值集
	 * @see  #propertyToConstantNamePrefix
	 */
	public Set<Object> getValuesForProperty(String propertyName) {
		return getValues(propertyToConstantNamePrefix(propertyName));
	}

	/**
	 * Return all values of the given group of constants.
	 * <p>Note that this method assumes that constants are named
	 * in accordance with the standard Java convention for constant
	 * values (i.e. all uppercase). The supplied {@code nameSuffix}
	 * will be uppercased (in a locale-insensitive fashion) prior to
	 * the main logic of this method kicking in.
	 * @param nameSuffix suffix of the constant names to search (may be {@code null})
	 * @return the set of values
	 */
	/**
	 * 返回给定常量组的所有值。 
	 *  <p>请注意，此方法假定根据常量值的标准Java约定（即所有大写字母）命名常量。 
	 * 所提供的{@code  nameSuffix}在此方法的主要逻辑生效之前将被大写（以不区分语言环境的方式）。 
	 * 
	 * @param  nameSuffix要搜索的常量名称的后缀（可以为{<@code > null}）
	 * @return 一组值
	 */
	public Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {
		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "");
		Set<Object> values = new HashSet<>();
		this.fieldCache.forEach((code, value) -> {
			if (code.endsWith(suffixToUse)) {
				values.add(value);
			}
		});
		return values;
	}


	/**
	 * Look up the given value within the given group of constants.
	 * <p>Will return the first match.
	 * @param value constant value to look up
	 * @param namePrefix prefix of the constant names to search (may be {@code null})
	 * @return the name of the constant field
	 * @throws ConstantException if the value wasn't found
	 */
	/**
	 * 在给定的常量组中查找给定的值。 
	 *  <p>将返回第一场比赛。 
	 *  
	 * @param 值要查找的常量值
	 * @param  name要搜索的常量名称的前缀（可以为{@code  null}）
	 * @return 常量字段的名称
	 * @throws  ConstantException如果找不到值
	 */
	public String toCode(Object value, @Nullable String namePrefix) throws ConstantException {
		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : "");
		for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {
			if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {
				return entry.getKey();
			}
		}
		throw new ConstantException(this.className, prefixToUse, value);
	}

	/**
	 * Look up the given value within the group of constants for
	 * the given bean property name. Will return the first match.
	 * @param value constant value to look up
	 * @param propertyName the name of the bean property
	 * @return the name of the constant field
	 * @throws ConstantException if the value wasn't found
	 * @see #propertyToConstantNamePrefix
	 */
	/**
	 * 在给定bean属性名称的常量组中查找给定值。 
	 * 将返回第一个比赛。 
	 *  
	 * @param 值要查找的常量值
	 * @param  propertyName Bean属性的名称
	 * @return 常量字段的名称
	 * @throws 如果没有找到该值的ConstantException 
	 * @see  #propertyToConstantNamePrefix
	 */
	public String toCodeForProperty(Object value, String propertyName) throws ConstantException {
		return toCode(value, propertyToConstantNamePrefix(propertyName));
	}

	/**
	 * Look up the given value within the given group of constants.
	 * <p>Will return the first match.
	 * @param value constant value to look up
	 * @param nameSuffix suffix of the constant names to search (may be {@code null})
	 * @return the name of the constant field
	 * @throws ConstantException if the value wasn't found
	 */
	/**
	 * 在给定的常量组中查找给定的值。 
	 *  <p>将返回第一场比赛。 
	 *  
	 * @param 值要查找的常量值
	 * @param  name要搜索的常量名称的后缀（可以是{@code  null}）
	 * @return 常量字段的名称
	 * @throws  ConstantException如果找不到值
	 */
	public String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {
		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : "");
		for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {
			if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {
				return entry.getKey();
			}
		}
		throw new ConstantException(this.className, suffixToUse, value);
	}


	/**
	 * Convert the given bean property name to a constant name prefix.
	 * <p>Uses a common naming idiom: turning all lower case characters to
	 * upper case, and prepending upper case characters with an underscore.
	 * <p>Example: "imageSize" -> "IMAGE_SIZE"<br>
	 * Example: "imagesize" -> "IMAGESIZE".<br>
	 * Example: "ImageSize" -> "_IMAGE_SIZE".<br>
	 * Example: "IMAGESIZE" -> "_I_M_A_G_E_S_I_Z_E"
	 * @param propertyName the name of the bean property
	 * @return the corresponding constant name prefix
	 * @see #getValuesForProperty
	 * @see #toCodeForProperty
	 */
	/**
	 * 将给定的bean属性名称转换为常量名称前缀。 
	 *  <p>使用常见的命名习惯：将所有小写字母都转换为大写字母，并在大写字母之前加上下划线。 
	 *  <p>示例："imageSize"->"IMAGE_SIZE"<br>示例："imagesize"->"IMAGESIZE"。 
	 * <br>示例："ImageSize"->"_IMAGE_SIZE"。 
	 * <br>示例："IMAGESIZE"- >"_I_M_A_G_E_S_I_Z_E"
	 * @param  propertyName Bean属性的名称
	 * @return 对应的常量名称前缀
	 * @see  #getValuesForProperty 
	 * @see  #toCodeForProperty
	 */
	public String propertyToConstantNamePrefix(String propertyName) {
		StringBuilder parsedPrefix = new StringBuilder();
		for (int i = 0; i < propertyName.length(); i++) {
			char c = propertyName.charAt(i);
			if (Character.isUpperCase(c)) {
				parsedPrefix.append("_");
				parsedPrefix.append(c);
			}
			else {
				parsedPrefix.append(Character.toUpperCase(c));
			}
		}
		return parsedPrefix.toString();
	}


	/**
	 * Exception thrown when the {@link Constants} class is asked for
	 * an invalid constant name.
	 */
	/**
	 * 当{@link 常量}类要求输入无效的常量名称时引发异常。 
	 * 
	 */
	@SuppressWarnings("serial")
	public static class ConstantException extends IllegalArgumentException {

		/**
		 * Thrown when an invalid constant name is requested.
		 * @param className name of the class containing the constant definitions
		 * @param field invalid constant name
		 * @param message description of the problem
		 */
		/**
		 * 请求无效的常量名称时抛出。 
		 *  
		 * @param  className包含常量定义的类的名称
		 * @param 字段无效的常量名称
		 * @param 问题的消息描述
		 */
		public ConstantException(String className, String field, String message) {
			super("Field '" + field + "' " + message + " in class [" + className + "]");
		}

		/**
		 * Thrown when an invalid constant value is looked up.
		 * @param className name of the class containing the constant definitions
		 * @param namePrefix prefix of the searched constant names
		 * @param value the looked up constant value
		 */
		/**
		 * 查找无效的常数值时抛出。 
		 *  
		 * @param  className包含常量定义的类的名称
		 * @param  name搜索的常量名称的前缀前缀
		 * @param 值查找的常量值
		 */
		public ConstantException(String className, String namePrefix, Object value) {
			super("No '" + namePrefix + "' field with value '" + value + "' found in class [" + className + "]");
		}
	}

}
