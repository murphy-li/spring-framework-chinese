/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.StringJoiner;

import org.springframework.core.SerializableTypeWrapper.FieldTypeProvider;
import org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider;
import org.springframework.core.SerializableTypeWrapper.TypeProvider;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
 * Encapsulates a Java {@link java.lang.reflect.Type}, providing access to
 * {@link #getSuperType() supertypes}, {@link #getInterfaces() interfaces}, and
 * {@link #getGeneric(int...) generic parameters} along with the ability to ultimately
 * {@link #resolve() resolve} to a {@link java.lang.Class}.
 *
 * <p>{@code ResolvableTypes} may be obtained from {@link #forField(Field) fields},
 * {@link #forMethodParameter(Method, int) method parameters},
 * {@link #forMethodReturnType(Method) method returns} or
 * {@link #forClass(Class) classes}. Most methods on this class will themselves return
 * {@link ResolvableType ResolvableTypes}, allowing easy navigation. For example:
 * <pre class="code">
 * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;
 *
 * public void example() {
 *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField("myMap"));
 *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;
 *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;
 *     t.getGeneric(0).resolve(); // Integer
 *     t.getGeneric(1).resolve(); // List
 *     t.getGeneric(1); // List&lt;String&gt;
 *     t.resolveGeneric(1, 0); // String
 * }
 * </pre>
 *
 * @author Phillip Webb
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 4.0
 * @see #forField(Field)
 * @see #forMethodParameter(Method, int)
 * @see #forMethodReturnType(Method)
 * @see #forConstructorParameter(Constructor, int)
 * @see #forClass(Class)
 * @see #forType(Type)
 * @see #forInstance(Object)
 * @see ResolvableTypeProvider
 */
/**
 * 封装Java {@link  java.lang.reflect.Type}，提供对{@link  #getSuperType（）超类型}，{<@link> #getInterfaces（）接口}和{@link  #getGeneric（int ...）通用参数}以及最终{@link  #resolve（）resolve}到{@link  java.lang.Class}的能力。 
 *  <p> {<@code> ResolvableTypes}可以从{@link  #forField（Field）字段}，{<@link> #forMethodParameter（Method，int）方法参数}，{<@link> #forMethodReturnType （方法）方法返回}或{@link  #forClass（Class）classes}。 
 * 该类上的大多数方法本身都会返回{@link  ResolvableType ResolvableTypes}，从而可以轻松导航。 
 * 例如：<pre class ="code">私有HashMap <Integer，List <String >> myMap;公共无效example（）{ResolvableType t = ResolvableType.forField（getClass（）。 
 * getDeclaredField（"myMap"）））; t.getSuperType（）; // AbstractMap <Integer，List <String >> t.asMap（）; // Map <Integer，List <String >> t.getGeneric（0）.resolve（）; //整数t.getGeneric（1）.resolve（）; //列出t.getGeneric（1）; // List <String> t.resolveGeneric（1，0）; //字符串} </ pre> @author  Phillip Webb @author  Juergen Hoeller @author  Stephane Nicoll @since 4.0起@
 * @see> #forField（Field）
 * @see  #forMethodParameter（Method，int）
 * @see  #forMethodReturnType（方法）
 * @see  #forConstructorParameter（构造函数，整数）
 * @see  #forClass（类）
 * @see  #forType（类型）
 * @see  #forInstance（Object）
 * @see  ResolvableTypeProvider
 */
@SuppressWarnings("serial")
public class ResolvableType implements Serializable {

	/**
	 * {@code ResolvableType} returned when no value is available. {@code NONE} is used
	 * in preference to {@code null} so that multiple method calls can be safely chained.
	 */
	/**
	 * 如果没有可用值，则返回{@code  ResolvableType}。 
	 * 使用{@code  NONE}优先于{@code  null}，以便可以安全地链接多个方法调用。 
	 * 
	 */
	public static final ResolvableType NONE = new ResolvableType(EmptyType.INSTANCE, null, null, 0);

	private static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0];

	private static final ConcurrentReferenceHashMap<ResolvableType, ResolvableType> cache =
			new ConcurrentReferenceHashMap<>(256);


	/**
	 * The underlying Java type being managed.
	 */
	/**
	 * 被管理的底层Java类型。 
	 * 
	 */
	private final Type type;

	/**
	 * Optional provider for the type.
	 */
	/**
	 * 类型的可选提供程序。 
	 * 
	 */
	@Nullable
	private final TypeProvider typeProvider;

	/**
	 * The {@code VariableResolver} to use or {@code null} if no resolver is available.
	 */
	/**
	 * 要使用的{@code  VariableResolver}或{@code  null}（如果没有可用的解析器）。 
	 * 
	 */
	@Nullable
	private final VariableResolver variableResolver;

	/**
	 * The component type for an array or {@code null} if the type should be deduced.
	 */
	/**
	 * 数组的组件类型； 
	 * 如果应该推导类型，则为{@code  null}。 
	 * 
	 */
	@Nullable
	private final ResolvableType componentType;

	@Nullable
	private final Integer hash;

	@Nullable
	private Class<?> resolved;

	@Nullable
	private volatile ResolvableType superType;

	@Nullable
	private volatile ResolvableType[] interfaces;

	@Nullable
	private volatile ResolvableType[] generics;


	/**
	 * Private constructor used to create a new {@link ResolvableType} for cache key purposes,
	 * with no upfront resolution.
	 */
	/**
	 * 专用构造函数，用于创建新的{@link  ResolvableType}以用于缓存键，没有前期解决方案。 
	 * 
	 */
	private ResolvableType(
			Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {

		this.type = type;
		this.typeProvider = typeProvider;
		this.variableResolver = variableResolver;
		this.componentType = null;
		this.hash = calculateHashCode();
		this.resolved = null;
	}

	/**
	 * Private constructor used to create a new {@link ResolvableType} for cache value purposes,
	 * with upfront resolution and a pre-calculated hash.
	 * @since 4.2
	 */
	/**
	 * 专用构造函数，用于创建新的{@link  ResolvableType}以用于缓存值，具有前期分辨率和预先计算的哈希值。 
	 *  @4.2起
	 */
	private ResolvableType(Type type, @Nullable TypeProvider typeProvider,
			@Nullable VariableResolver variableResolver, @Nullable Integer hash) {

		this.type = type;
		this.typeProvider = typeProvider;
		this.variableResolver = variableResolver;
		this.componentType = null;
		this.hash = hash;
		this.resolved = resolveClass();
	}

	/**
	 * Private constructor used to create a new {@link ResolvableType} for uncached purposes,
	 * with upfront resolution but lazily calculated hash.
	 */
	/**
	 * 私有构造函数用于为未缓存的目的创建新的{@link  ResolvableType}，具有前期解决方案，但哈希计算延迟。 
	 * 
	 */
	private ResolvableType(Type type, @Nullable TypeProvider typeProvider,
			@Nullable VariableResolver variableResolver, @Nullable ResolvableType componentType) {

		this.type = type;
		this.typeProvider = typeProvider;
		this.variableResolver = variableResolver;
		this.componentType = componentType;
		this.hash = null;
		this.resolved = resolveClass();
	}

	/**
	 * Private constructor used to create a new {@link ResolvableType} on a {@link Class} basis.
	 * Avoids all {@code instanceof} checks in order to create a straight {@link Class} wrapper.
	 * @since 4.2
	 */
	/**
	 * 私有构造函数，用于在{@link 类}的基础上创建新的{@link  ResolvableType}。 
	 * 避免所有{@code  instanceof}检查以创建直接的{@link  Class}包装器。 
	 *  @4.2起
	 */
	private ResolvableType(@Nullable Class<?> clazz) {
		this.resolved = (clazz != null ? clazz : Object.class);
		this.type = this.resolved;
		this.typeProvider = null;
		this.variableResolver = null;
		this.componentType = null;
		this.hash = null;
	}


	/**
	 * Return the underling Java {@link Type} being managed.
	 */
	/**
	 * 返回受管理的基础Java {@link  Type}。 
	 * 
	 */
	public Type getType() {
		return SerializableTypeWrapper.unwrap(this.type);
	}

	/**
	 * Return the underlying Java {@link Class} being managed, if available;
	 * otherwise {@code null}.
	 */
	/**
	 * 返回受管理的基础Java {@link  Class}（如果有）； 
	 * 否则为{@code  null}。 
	 * 
	 */
	@Nullable
	public Class<?> getRawClass() {
		if (this.type == this.resolved) {
			return this.resolved;
		}
		Type rawType = this.type;
		if (rawType instanceof ParameterizedType) {
			rawType = ((ParameterizedType) rawType).getRawType();
		}
		return (rawType instanceof Class ? (Class<?>) rawType : null);
	}

	/**
	 * Return the underlying source of the resolvable type. Will return a {@link Field},
	 * {@link MethodParameter} or {@link Type} depending on how the {@link ResolvableType}
	 * was constructed. With the exception of the {@link #NONE} constant, this method will
	 * never return {@code null}. This method is primarily to provide access to additional
	 * type information or meta-data that alternative JVM languages may provide.
	 */
	/**
	 * 返回可解析类型的基础源。 
	 * 将返回{@link 字段}，{<@link>方法参数}或{@link 类型}，​​具体取决于{@link  ResolvableType}的构造方式。 
	 * 除了{@link  #NONE}常量以外，此方法将永远不会返回{@code  null}。 
	 * 此方法主要用于提供对其他JVM语言可能提供的其他类型信息或元数据的访问。 
	 * 
	 */
	public Object getSource() {
		Object source = (this.typeProvider != null ? this.typeProvider.getSource() : null);
		return (source != null ? source : this.type);
	}

	/**
	 * Return this type as a resolved {@code Class}, falling back to
	 * {@link java.lang.Object} if no specific class can be resolved.
	 * @return the resolved {@link Class} or the {@code Object} fallback
	 * @since 5.1
	 * @see #getRawClass()
	 * @see #resolve(Class)
	 */
	/**
	 * 返回此类型作为已解析的{@code  Class}，如果无法解析特定的类，则退回到{@link  java.lang.Object}。 
	 *  
	 * @return 解析的{@link 类}或{@code 对象}后备@自5.1起
	 * @see  #getRawClass（）
	 * @see  #resolve（Class）
	 */
	public Class<?> toClass() {
		return resolve(Object.class);
	}

	/**
	 * Determine whether the given object is an instance of this {@code ResolvableType}.
	 * @param obj the object to check
	 * @since 4.2
	 * @see #isAssignableFrom(Class)
	 */
	/**
	 * 确定给定对象是否是此{@code  ResolvableType}的实例。 
	 *  
	 * @param  obj从4.2开始检查的对象
	 * @see  #isAssignableFrom（Class）
	 */
	public boolean isInstance(@Nullable Object obj) {
		return (obj != null && isAssignableFrom(obj.getClass()));
	}

	/**
	 * Determine whether this {@code ResolvableType} is assignable from the
	 * specified other type.
	 * @param other the type to be checked against (as a {@code Class})
	 * @since 4.2
	 * @see #isAssignableFrom(ResolvableType)
	 */
	/**
	 * 确定是否可以从指定的其他类型分配此{@code  ResolvableType}。 
	 *  
	 * @param 其他要检查的类型（作为{@code 类}）@4.2起@
	 * @see> #isAssignableFrom（ResolvableType）
	 */
	public boolean isAssignableFrom(Class<?> other) {
		return isAssignableFrom(forClass(other), null);
	}

	/**
	 * Determine whether this {@code ResolvableType} is assignable from the
	 * specified other type.
	 * <p>Attempts to follow the same rules as the Java compiler, considering
	 * whether both the {@link #resolve() resolved} {@code Class} is
	 * {@link Class#isAssignableFrom(Class) assignable from} the given type
	 * as well as whether all {@link #getGenerics() generics} are assignable.
	 * @param other the type to be checked against (as a {@code ResolvableType})
	 * @return {@code true} if the specified other type can be assigned to this
	 * {@code ResolvableType}; {@code false} otherwise
	 */
	/**
	 * 确定是否可以从指定的其他类型分配此{@code  ResolvableType}。 
	 *  <p>请考虑遵循与Java编译器相同的规则，请考虑以下两个问题：{@link  #resolve（）解析的} {@code  Class}是否为{@link  Class＃isAssignableFrom（Class）可分配给}给定的类型以及所有{@link  #getGenerics（）泛型}是否可分配。 
	 *  
	 * @param 其他要检查的类型（作为{@code  ResolvableType}）
	 * @return  {@code  true}如果可以将指定的其他类型分配给此{@code  ResolvableType} ; {@code  false}否则
	 */
	public boolean isAssignableFrom(ResolvableType other) {
		return isAssignableFrom(other, null);
	}

	private boolean isAssignableFrom(ResolvableType other, @Nullable Map<Type, Type> matchedBefore) {
		Assert.notNull(other, "ResolvableType must not be null");

		// If we cannot resolve types, we are not assignable
		if (this == NONE || other == NONE) {
			return false;
		}

		// Deal with array by delegating to the component type
		if (isArray()) {
			return (other.isArray() && getComponentType().isAssignableFrom(other.getComponentType()));
		}

		if (matchedBefore != null && matchedBefore.get(this.type) == other.type) {
			return true;
		}

		// Deal with wildcard bounds
		WildcardBounds ourBounds = WildcardBounds.get(this);
		WildcardBounds typeBounds = WildcardBounds.get(other);

		// In the form X is assignable to <? extends Number>
		if (typeBounds != null) {
			return (ourBounds != null && ourBounds.isSameKind(typeBounds) &&
					ourBounds.isAssignableFrom(typeBounds.getBounds()));
		}

		// In the form <? extends Number> is assignable to X...
		if (ourBounds != null) {
			return ourBounds.isAssignableFrom(other);
		}

		// Main assignability check about to follow
		boolean exactMatch = (matchedBefore != null);  // We're checking nested generic variables now...
		boolean checkGenerics = true;
		Class<?> ourResolved = null;
		if (this.type instanceof TypeVariable) {
			TypeVariable<?> variable = (TypeVariable<?>) this.type;
			// Try default variable resolution
			if (this.variableResolver != null) {
				ResolvableType resolved = this.variableResolver.resolveVariable(variable);
				if (resolved != null) {
					ourResolved = resolved.resolve();
				}
			}
			if (ourResolved == null) {
				// Try variable resolution against target type
				if (other.variableResolver != null) {
					ResolvableType resolved = other.variableResolver.resolveVariable(variable);
					if (resolved != null) {
						ourResolved = resolved.resolve();
						checkGenerics = false;
					}
				}
			}
			if (ourResolved == null) {
				// Unresolved type variable, potentially nested -> never insist on exact match
				exactMatch = false;
			}
		}
		if (ourResolved == null) {
			ourResolved = resolve(Object.class);
		}
		Class<?> otherResolved = other.toClass();

		// We need an exact type match for generics
		// List<CharSequence> is not assignable from List<String>
		if (exactMatch ? !ourResolved.equals(otherResolved) : !ClassUtils.isAssignable(ourResolved, otherResolved)) {
			return false;
		}

		if (checkGenerics) {
			// Recursively check each generic
			ResolvableType[] ourGenerics = getGenerics();
			ResolvableType[] typeGenerics = other.as(ourResolved).getGenerics();
			if (ourGenerics.length != typeGenerics.length) {
				return false;
			}
			if (matchedBefore == null) {
				matchedBefore = new IdentityHashMap<>(1);
			}
			matchedBefore.put(this.type, other.type);
			for (int i = 0; i < ourGenerics.length; i++) {
				if (!ourGenerics[i].isAssignableFrom(typeGenerics[i], matchedBefore)) {
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Return {@code true} if this type resolves to a Class that represents an array.
	 * @see #getComponentType()
	 */
	/**
	 * 如果此类型解析为表示数组的Class，则返回{@code  true}。 
	 *  
	 * @see  #getComponentType（）
	 */
	public boolean isArray() {
		if (this == NONE) {
			return false;
		}
		return ((this.type instanceof Class && ((Class<?>) this.type).isArray()) ||
				this.type instanceof GenericArrayType || resolveType().isArray());
	}

	/**
	 * Return the ResolvableType representing the component type of the array or
	 * {@link #NONE} if this type does not represent an array.
	 * @see #isArray()
	 */
	/**
	 * 返回表示数组的组件类型的ResolvableType； 
	 * 如果此类型不表示数组，则返回{@link  #NONE}。 
	 *  
	 * @see  #isArray（）
	 */
	public ResolvableType getComponentType() {
		if (this == NONE) {
			return NONE;
		}
		if (this.componentType != null) {
			return this.componentType;
		}
		if (this.type instanceof Class) {
			Class<?> componentType = ((Class<?>) this.type).getComponentType();
			return forType(componentType, this.variableResolver);
		}
		if (this.type instanceof GenericArrayType) {
			return forType(((GenericArrayType) this.type).getGenericComponentType(), this.variableResolver);
		}
		return resolveType().getComponentType();
	}

	/**
	 * Convenience method to return this type as a resolvable {@link Collection} type.
	 * Returns {@link #NONE} if this type does not implement or extend
	 * {@link Collection}.
	 * @see #as(Class)
	 * @see #asMap()
	 */
	/**
	 * 将此类型作为可解析的{@link  Collection}类型返回的便捷方法。 
	 * 如果此类型不实现或扩展{@link  Collection}，则返回{@link  #NONE}。 
	 *  
	 * @see  #as（Class）
	 * @see  #asMap（）
	 */
	public ResolvableType asCollection() {
		return as(Collection.class);
	}

	/**
	 * Convenience method to return this type as a resolvable {@link Map} type.
	 * Returns {@link #NONE} if this type does not implement or extend
	 * {@link Map}.
	 * @see #as(Class)
	 * @see #asCollection()
	 */
	/**
	 * 将此类型作为可解析的{@link  Map}类型返回的便捷方法。 
	 * 如果此类型未实现或扩展{@link  Map}，则返回{@link  #NONE}。 
	 *  
	 * @see  #as（Class）
	 * @see  #asCollection（）
	 */
	public ResolvableType asMap() {
		return as(Map.class);
	}

	/**
	 * Return this type as a {@link ResolvableType} of the specified class. Searches
	 * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}
	 * hierarchies to find a match, returning {@link #NONE} if this type does not
	 * implement or extend the specified class.
	 * @param type the required type (typically narrowed)
	 * @return a {@link ResolvableType} representing this object as the specified
	 * type, or {@link #NONE} if not resolvable as that type
	 * @see #asCollection()
	 * @see #asMap()
	 * @see #getSuperType()
	 * @see #getInterfaces()
	 */
	/**
	 * 以指定类的{@link  ResolvableType}的形式返回此类型。 
	 * 搜索{@link  #getSuperType（）超类型}和{@link  #getInterfaces（）接口}层次结构以找到匹配项，如果此类型未实现或扩展指定的类，则返回{@link  #NONE} 。 
	 *  
	 * @param 键入所需的类型（通常是缩小的）
	 * @return 表示此对象为指定类型的{@link  ResolvableType}，如果该类型不可解析，则为{@link  #NONE} <
	 * @see > #asCollection（）
	 * @see  #asMap（）
	 * @see  #getSuperType（）
	 * @see  #getInterfaces（）
	 */
	public ResolvableType as(Class<?> type) {
		if (this == NONE) {
			return NONE;
		}
		Class<?> resolved = resolve();
		if (resolved == null || resolved == type) {
			return this;
		}
		for (ResolvableType interfaceType : getInterfaces()) {
			ResolvableType interfaceAsType = interfaceType.as(type);
			if (interfaceAsType != NONE) {
				return interfaceAsType;
			}
		}
		return getSuperType().as(type);
	}

	/**
	 * Return a {@link ResolvableType} representing the direct supertype of this type.
	 * If no supertype is available this method returns {@link #NONE}.
	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.
	 * @see #getInterfaces()
	 */
	/**
	 * 返回表示此类型的直接超类型的{@link  ResolvableType}。 
	 * 如果没有超类型可用，则此方法返回{@link  #NONE}。 
	 *  <p>注意：生成的{@link  ResolvableType}实例可能不是{@link  Serializable}。 
	 *  
	 * @see  #getInterfaces（）
	 */
	public ResolvableType getSuperType() {
		Class<?> resolved = resolve();
		if (resolved == null || resolved.getGenericSuperclass() == null) {
			return NONE;
		}
		ResolvableType superType = this.superType;
		if (superType == null) {
			superType = forType(resolved.getGenericSuperclass(), this);
			this.superType = superType;
		}
		return superType;
	}

	/**
	 * Return a {@link ResolvableType} array representing the direct interfaces
	 * implemented by this type. If this type does not implement any interfaces an
	 * empty array is returned.
	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}.
	 * @see #getSuperType()
	 */
	/**
	 * 返回表示此类型实现的直接接口的{@link  ResolvableType}数组。 
	 * 如果此类型不实现任何接口，则返回一个空数组。 
	 *  <p>注意：生成的{@link  ResolvableType}实例可能不是{@link  Serializable}。 
	 *  
	 * @see  #getSuperType（）
	 */
	public ResolvableType[] getInterfaces() {
		Class<?> resolved = resolve();
		if (resolved == null) {
			return EMPTY_TYPES_ARRAY;
		}
		ResolvableType[] interfaces = this.interfaces;
		if (interfaces == null) {
			Type[] genericIfcs = resolved.getGenericInterfaces();
			interfaces = new ResolvableType[genericIfcs.length];
			for (int i = 0; i < genericIfcs.length; i++) {
				interfaces[i] = forType(genericIfcs[i], this);
			}
			this.interfaces = interfaces;
		}
		return interfaces;
	}

	/**
	 * Return {@code true} if this type contains generic parameters.
	 * @see #getGeneric(int...)
	 * @see #getGenerics()
	 */
	/**
	 * 如果此类型包含通用参数，则返回{@code  true}。 
	 *  
	 * @see  #getGeneric（int ...）
	 * @see  #getGenerics（）
	 */
	public boolean hasGenerics() {
		return (getGenerics().length > 0);
	}

	/**
	 * Return {@code true} if this type contains unresolvable generics only,
	 * that is, no substitute for any of its declared type variables.
	 */
	/**
	 * 如果此类型仅包含不可解析的泛型，即不​​能替代其任何声明的类型变量，则返回{@code  true}。 
	 * 
	 */
	boolean isEntirelyUnresolvable() {
		if (this == NONE) {
			return false;
		}
		ResolvableType[] generics = getGenerics();
		for (ResolvableType generic : generics) {
			if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Determine whether the underlying type has any unresolvable generics:
	 * either through an unresolvable type variable on the type itself
	 * or through implementing a generic interface in a raw fashion,
	 * i.e. without substituting that interface's type variables.
	 * The result will be {@code true} only in those two scenarios.
	 */
	/**
	 * 确定基础类型是否具有任何不可解析的泛型：通过类型本身上的不可解析类型变量或通过以原始方式实现通用接口（即不替换该接口的类型变量）来确定。 
	 * 仅在这两种情况下，结果将为{@code  true}。 
	 * 
	 */
	public boolean hasUnresolvableGenerics() {
		if (this == NONE) {
			return false;
		}
		ResolvableType[] generics = getGenerics();
		for (ResolvableType generic : generics) {
			if (generic.isUnresolvableTypeVariable() || generic.isWildcardWithoutBounds()) {
				return true;
			}
		}
		Class<?> resolved = resolve();
		if (resolved != null) {
			for (Type genericInterface : resolved.getGenericInterfaces()) {
				if (genericInterface instanceof Class) {
					if (forClass((Class<?>) genericInterface).hasGenerics()) {
						return true;
					}
				}
			}
			return getSuperType().hasUnresolvableGenerics();
		}
		return false;
	}

	/**
	 * Determine whether the underlying type is a type variable that
	 * cannot be resolved through the associated variable resolver.
	 */
	/**
	 * 确定基础类型是否是无法通过关联的变量解析器解析的类型变量。 
	 * 
	 */
	private boolean isUnresolvableTypeVariable() {
		if (this.type instanceof TypeVariable) {
			if (this.variableResolver == null) {
				return true;
			}
			TypeVariable<?> variable = (TypeVariable<?>) this.type;
			ResolvableType resolved = this.variableResolver.resolveVariable(variable);
			if (resolved == null || resolved.isUnresolvableTypeVariable()) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Determine whether the underlying type represents a wildcard
	 * without specific bounds (i.e., equal to {@code ? extends Object}).
	 */
	/**
	 * 确定基础类型是否表示没有特定限制的通配符（即等于{@code ？extended Object}）。 
	 * 
	 */
	private boolean isWildcardWithoutBounds() {
		if (this.type instanceof WildcardType) {
			WildcardType wt = (WildcardType) this.type;
			if (wt.getLowerBounds().length == 0) {
				Type[] upperBounds = wt.getUpperBounds();
				if (upperBounds.length == 0 || (upperBounds.length == 1 && Object.class == upperBounds[0])) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Return a {@link ResolvableType} for the specified nesting level.
	 * See {@link #getNested(int, Map)} for details.
	 * @param nestingLevel the nesting level
	 * @return the {@link ResolvableType} type, or {@code #NONE}
	 */
	/**
	 * 返回指定嵌套级别的{@link  ResolvableType}。 
	 * 有关详细信息，请参见{@link  #getNested（int，Map）}。 
	 *  
	 * @param  nestingLevel嵌套级别
	 * @return  {{@link> ResolvableType}类型，或{@code  #NONE}
	 */
	public ResolvableType getNested(int nestingLevel) {
		return getNested(nestingLevel, null);
	}

	/**
	 * Return a {@link ResolvableType} for the specified nesting level.
	 * <p>The nesting level refers to the specific generic parameter that should be returned.
	 * A nesting level of 1 indicates this type; 2 indicates the first nested generic;
	 * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers
	 * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.
	 * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic
	 * for the given level. For example, an index of 0 would refer to a {@code Map} key;
	 * whereas, 1 would refer to the value. If the map does not contain a value for a
	 * specific level the last generic will be used (e.g. a {@code Map} value).
	 * <p>Nesting levels may also apply to array types; for example given
	 * {@code String[]}, a nesting level of 2 refers to {@code String}.
	 * <p>If a type does not {@link #hasGenerics() contain} generics the
	 * {@link #getSuperType() supertype} hierarchy will be considered.
	 * @param nestingLevel the required nesting level, indexed from 1 for the
	 * current type, 2 for the first nested generic, 3 for the second and so on
	 * @param typeIndexesPerLevel a map containing the generic index for a given
	 * nesting level (may be {@code null})
	 * @return a {@link ResolvableType} for the nested level, or {@link #NONE}
	 */
	/**
	 * 返回指定嵌套级别的{@link  ResolvableType}。 
	 *  <p>嵌套级别是指应返回的特定通用参数。 
	 * 嵌套级别1表示此类型； 
	 *  2表示第一个嵌套的泛型； 
	 *  3秒； 
	 * 等等。 
	 * 例如，给定{@code  List <Set <Integer >>}，级别1表示{@code  List}，级别2表示{@code  Set}，级别3表示{@code 整数}。 
	 *  <p> {<@code> typeIndexesPerLevel}映射可用于引用给定级别的特定泛型。 
	 * 例如，索引为0将引用一个{@code  Map}键； 
	 * 而1代表该值。 
	 * 如果地图不包含特定级别的值，则将使用最后一个通用名称（例如{@code  Map}值）。 
	 *  <p>嵌套级别也可能适用于数组类型； 
	 * 例如，给定{@code  String []}，嵌套级别2表示{@code  String}。 
	 *  <p>如果类型不{@link  #hasGenerics（）包含}泛型，则将考虑{@link  #getSuperType（）超类型}层次结构。 
	 *  
	 * @param  nestingLevel所需的嵌套级别，从当前类型的1，从第二个嵌套的泛型的2索引，从第二个嵌套的泛型的3索引，依此类推。 
	 * 
	 * @param  typeIndexesPerLevel一个包含给定嵌套级别的泛型索引的映射（可以为{@code  null}）
	 * @return 嵌套级别的{@link  ResolvableType}，或{@link  #NONE}
	 */
	public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {
		ResolvableType result = this;
		for (int i = 2; i <= nestingLevel; i++) {
			if (result.isArray()) {
				result = result.getComponentType();
			}
			else {
				// Handle derived types
				while (result != ResolvableType.NONE && !result.hasGenerics()) {
					result = result.getSuperType();
				}
				Integer index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);
				index = (index == null ? result.getGenerics().length - 1 : index);
				result = result.getGeneric(index);
			}
		}
		return result;
	}

	/**
	 * Return a {@link ResolvableType} representing the generic parameter for the
	 * given indexes. Indexes are zero based; for example given the type
	 * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the
	 * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;
	 * for example {@code getGeneric(1, 0)} will access the {@code String} from the
	 * nested {@code List}. For convenience, if no indexes are specified the first
	 * generic is returned.
	 * <p>If no generic is available at the specified indexes {@link #NONE} is returned.
	 * @param indexes the indexes that refer to the generic parameter
	 * (may be omitted to return the first generic)
	 * @return a {@link ResolvableType} for the specified generic, or {@link #NONE}
	 * @see #hasGenerics()
	 * @see #getGenerics()
	 * @see #resolveGeneric(int...)
	 * @see #resolveGenerics()
	 */
	/**
	 * 返回代表给定索引的通用参数的{@link  ResolvableType}。 
	 * 索引从零开始； 
	 * 例如，给定类型为{@code  Map <Integer，List <String >>}，{<@code> getGeneric（0）}将访问{@code  Integer}。 
	 * 可以通过指定多个索引来访问嵌套泛型。 
	 * 例如{@code  getGeneric（1，0）}将访问嵌套的{@code  List}中的{@code  String}。 
	 * 为了方便起见，如果未指定索引，则返回第一个泛型。 
	 *  <p>如果指定索引处没有通用名称，则返回{@link  #NONE}。 
	 *  
	 * @param 索引引用泛型参数的索引（可以省略以返回第一个泛型）
	 * @return 一个用于指定泛型的{@link  ResolvableType}或{@link  #NONE} 
	 * @see> #hasGenerics（）
	 * @see  #getGenerics（）
	 * @see  #resolveGeneric（int ...）
	 * @see  #resolveGenerics（）
	 */
	public ResolvableType getGeneric(@Nullable int... indexes) {
		ResolvableType[] generics = getGenerics();
		if (indexes == null || indexes.length == 0) {
			return (generics.length == 0 ? NONE : generics[0]);
		}
		ResolvableType generic = this;
		for (int index : indexes) {
			generics = generic.getGenerics();
			if (index < 0 || index >= generics.length) {
				return NONE;
			}
			generic = generics[index];
		}
		return generic;
	}

	/**
	 * Return an array of {@link ResolvableType ResolvableTypes} representing the generic parameters of
	 * this type. If no generics are available an empty array is returned. If you need to
	 * access a specific generic consider using the {@link #getGeneric(int...)} method as
	 * it allows access to nested generics and protects against
	 * {@code IndexOutOfBoundsExceptions}.
	 * @return an array of {@link ResolvableType ResolvableTypes} representing the generic parameters
	 * (never {@code null})
	 * @see #hasGenerics()
	 * @see #getGeneric(int...)
	 * @see #resolveGeneric(int...)
	 * @see #resolveGenerics()
	 */
	/**
	 * 返回{@link  ResolvableType ResolvableTypes}的数组，表示此类型的通用参数。 
	 * 如果没有可用的泛型，则返回一个空数组。 
	 * 如果您需要访问特定的泛型，请考虑使用{@link  #getGeneric（int ...）}方法，因为该方法允许访问嵌套的泛型并防止{@code  IndexOutOfBoundsExceptions}。 
	 *  
	 * @return 代表通用参数的{@link  ResolvableType ResolvableTypes}数组（永远不{<@@code> null}）
	 * @see  #hasGenerics（）
	 * @see  #getGeneric（int ...）
	 * @see  #resolveGeneric（int ...）
	 * @see  #resolveGenerics（）
	 */
	public ResolvableType[] getGenerics() {
		if (this == NONE) {
			return EMPTY_TYPES_ARRAY;
		}
		ResolvableType[] generics = this.generics;
		if (generics == null) {
			if (this.type instanceof Class) {
				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();
				generics = new ResolvableType[typeParams.length];
				for (int i = 0; i < generics.length; i++) {
					generics[i] = ResolvableType.forType(typeParams[i], this);
				}
			}
			else if (this.type instanceof ParameterizedType) {
				Type[] actualTypeArguments = ((ParameterizedType) this.type).getActualTypeArguments();
				generics = new ResolvableType[actualTypeArguments.length];
				for (int i = 0; i < actualTypeArguments.length; i++) {
					generics[i] = forType(actualTypeArguments[i], this.variableResolver);
				}
			}
			else {
				generics = resolveType().getGenerics();
			}
			this.generics = generics;
		}
		return generics;
	}

	/**
	 * Convenience method that will {@link #getGenerics() get} and
	 * {@link #resolve() resolve} generic parameters.
	 * @return an array of resolved generic parameters (the resulting array
	 * will never be {@code null}, but it may contain {@code null} elements})
	 * @see #getGenerics()
	 * @see #resolve()
	 */
	/**
	 * 方便的方法，该方法将{@link  #getGenerics（）获取}和{@link  #resolve（）解析}通用参数。 
	 *  
	 * @return 一组已解析的泛型参数（结果数组永远不会是{@code  null}，但它可能包含{@code  null}元素}）
	 * @see  #getGenerics（）<
	 * @see > #resolve（）
	 */
	public Class<?>[] resolveGenerics() {
		ResolvableType[] generics = getGenerics();
		Class<?>[] resolvedGenerics = new Class<?>[generics.length];
		for (int i = 0; i < generics.length; i++) {
			resolvedGenerics[i] = generics[i].resolve();
		}
		return resolvedGenerics;
	}

	/**
	 * Convenience method that will {@link #getGenerics() get} and {@link #resolve()
	 * resolve} generic parameters, using the specified {@code fallback} if any type
	 * cannot be resolved.
	 * @param fallback the fallback class to use if resolution fails
	 * @return an array of resolved generic parameters
	 * @see #getGenerics()
	 * @see #resolve()
	 */
	/**
	 * 如果无法解析任何类型，将使用指定的{@code  fallback}使用{@link  #getGenerics（）get}和{@link  #resolve（）resolve}通用参数的便捷方法。 
	 *  
	 * @param 回退如果解析失败将使用的回退类
	 * @return 一组已解析的泛型参数
	 * @see  #getGenerics（）
	 * @see  #resolve（）
	 */
	public Class<?>[] resolveGenerics(Class<?> fallback) {
		ResolvableType[] generics = getGenerics();
		Class<?>[] resolvedGenerics = new Class<?>[generics.length];
		for (int i = 0; i < generics.length; i++) {
			resolvedGenerics[i] = generics[i].resolve(fallback);
		}
		return resolvedGenerics;
	}

	/**
	 * Convenience method that will {@link #getGeneric(int...) get} and
	 * {@link #resolve() resolve} a specific generic parameters.
	 * @param indexes the indexes that refer to the generic parameter
	 * (may be omitted to return the first generic)
	 * @return a resolved {@link Class} or {@code null}
	 * @see #getGeneric(int...)
	 * @see #resolve()
	 */
	/**
	 * 便捷方法将{@link  #getGeneric（int ...）获取}和{@link  #resolve（）解析}一个特定的通用参数。 
	 *  
	 * @param 索引引用泛型参数的索引（可以省略以返回第一个泛型）。 
	 * 
	 * @return 已解析的{@link  Class}或{@code  null} 
	 * @see  #getGeneric （int ...）
	 * @see  #resolve（）
	 */
	@Nullable
	public Class<?> resolveGeneric(int... indexes) {
		return getGeneric(indexes).resolve();
	}

	/**
	 * Resolve this type to a {@link java.lang.Class}, returning {@code null}
	 * if the type cannot be resolved. This method will consider bounds of
	 * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if
	 * direct resolution fails; however, bounds of {@code Object.class} will be ignored.
	 * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}
	 * returns {@code false}, the given type effectively wraps a plain {@code Class},
	 * allowing for plain {@code Class} processing if desirable.
	 * @return the resolved {@link Class}, or {@code null} if not resolvable
	 * @see #resolve(Class)
	 * @see #resolveGeneric(int...)
	 * @see #resolveGenerics()
	 */
	/**
	 * 将此类型解析为{@link  java.lang.Class}，如果无法解析，则返回{@code  null}。 
	 * 如果直接解析失败，此方法将考虑{@link  TypeVariable TypeVariables}和{@link  WildcardType WildcardTypes}的范围； 
	 * 但是，{<@code> Object.class}的边界将被忽略。 
	 *  <p>如果此方法返回非空的{@code  Class}，并且{@link  #hasGenerics（）}返回{@code  false}，则给定类型有效地包装了普通的{@code  Class}，如果需要，允许进行简单的{@code  Class}处理。 
	 *  
	 * @return 解析的{@link 类}，如果无法解析，则为{<@@code> null} 
	 * @see  #resolve（Class）
	 * @see  #resolveGeneric（int ...）
	 * @see  #resolveGenerics（）
	 */
	@Nullable
	public Class<?> resolve() {
		return this.resolved;
	}

	/**
	 * Resolve this type to a {@link java.lang.Class}, returning the specified
	 * {@code fallback} if the type cannot be resolved. This method will consider bounds
	 * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if
	 * direct resolution fails; however, bounds of {@code Object.class} will be ignored.
	 * @param fallback the fallback class to use if resolution fails
	 * @return the resolved {@link Class} or the {@code fallback}
	 * @see #resolve()
	 * @see #resolveGeneric(int...)
	 * @see #resolveGenerics()
	 */
	/**
	 * 将此类型解析为{@link  java.lang.Class}，如果无法解析该类型，则返回指定的{@code  fallback}。 
	 * 如果直接解析失败，此方法将考虑{@link  TypeVariable TypeVariables}和{@link  WildcardType WildcardTypes}的范围； 
	 * 但是，{<@code> Object.class}的边界将被忽略。 
	 *  
	 * @param 回退如果解析失败将使用的回退类
	 * @return 解析的{@link 类}或{@code 回退} 
	 * @see  #resolve（）
	 * @see  #resolveGeneric（ int ...）
	 * @see  #resolveGenerics（）
	 */
	public Class<?> resolve(Class<?> fallback) {
		return (this.resolved != null ? this.resolved : fallback);
	}

	@Nullable
	private Class<?> resolveClass() {
		if (this.type == EmptyType.INSTANCE) {
			return null;
		}
		if (this.type instanceof Class) {
			return (Class<?>) this.type;
		}
		if (this.type instanceof GenericArrayType) {
			Class<?> resolvedComponent = getComponentType().resolve();
			return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);
		}
		return resolveType().resolve();
	}

	/**
	 * Resolve this type by a single level, returning the resolved value or {@link #NONE}.
	 * <p>Note: The returned {@link ResolvableType} should only be used as an intermediary
	 * as it cannot be serialized.
	 */
	/**
	 * 通过单级解析此类型，返回解析的值或{@link  #NONE}。 
	 *  <p>注意：返回的{@link  ResolvableType}只能用作中介，因为无法序列化。 
	 * 
	 */
	ResolvableType resolveType() {
		if (this.type instanceof ParameterizedType) {
			return forType(((ParameterizedType) this.type).getRawType(), this.variableResolver);
		}
		if (this.type instanceof WildcardType) {
			Type resolved = resolveBounds(((WildcardType) this.type).getUpperBounds());
			if (resolved == null) {
				resolved = resolveBounds(((WildcardType) this.type).getLowerBounds());
			}
			return forType(resolved, this.variableResolver);
		}
		if (this.type instanceof TypeVariable) {
			TypeVariable<?> variable = (TypeVariable<?>) this.type;
			// Try default variable resolution
			if (this.variableResolver != null) {
				ResolvableType resolved = this.variableResolver.resolveVariable(variable);
				if (resolved != null) {
					return resolved;
				}
			}
			// Fallback to bounds
			return forType(resolveBounds(variable.getBounds()), this.variableResolver);
		}
		return NONE;
	}

	@Nullable
	private Type resolveBounds(Type[] bounds) {
		if (bounds.length == 0 || bounds[0] == Object.class) {
			return null;
		}
		return bounds[0];
	}

	@Nullable
	private ResolvableType resolveVariable(TypeVariable<?> variable) {
		if (this.type instanceof TypeVariable) {
			return resolveType().resolveVariable(variable);
		}
		if (this.type instanceof ParameterizedType) {
			ParameterizedType parameterizedType = (ParameterizedType) this.type;
			Class<?> resolved = resolve();
			if (resolved == null) {
				return null;
			}
			TypeVariable<?>[] variables = resolved.getTypeParameters();
			for (int i = 0; i < variables.length; i++) {
				if (ObjectUtils.nullSafeEquals(variables[i].getName(), variable.getName())) {
					Type actualType = parameterizedType.getActualTypeArguments()[i];
					return forType(actualType, this.variableResolver);
				}
			}
			Type ownerType = parameterizedType.getOwnerType();
			if (ownerType != null) {
				return forType(ownerType, this.variableResolver).resolveVariable(variable);
			}
		}
		if (this.type instanceof WildcardType) {
			ResolvableType resolved = resolveType().resolveVariable(variable);
			if (resolved != null) {
				return resolved;
			}
		}
		if (this.variableResolver != null) {
			return this.variableResolver.resolveVariable(variable);
		}
		return null;
	}


	@Override
	public boolean equals(@Nullable Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof ResolvableType)) {
			return false;
		}

		ResolvableType otherType = (ResolvableType) other;
		if (!ObjectUtils.nullSafeEquals(this.type, otherType.type)) {
			return false;
		}
		if (this.typeProvider != otherType.typeProvider &&
				(this.typeProvider == null || otherType.typeProvider == null ||
				!ObjectUtils.nullSafeEquals(this.typeProvider.getType(), otherType.typeProvider.getType()))) {
			return false;
		}
		if (this.variableResolver != otherType.variableResolver &&
				(this.variableResolver == null || otherType.variableResolver == null ||
				!ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), otherType.variableResolver.getSource()))) {
			return false;
		}
		if (!ObjectUtils.nullSafeEquals(this.componentType, otherType.componentType)) {
			return false;
		}
		return true;
	}

	@Override
	public int hashCode() {
		return (this.hash != null ? this.hash : calculateHashCode());
	}

	private int calculateHashCode() {
		int hashCode = ObjectUtils.nullSafeHashCode(this.type);
		if (this.typeProvider != null) {
			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.typeProvider.getType());
		}
		if (this.variableResolver != null) {
			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.variableResolver.getSource());
		}
		if (this.componentType != null) {
			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.componentType);
		}
		return hashCode;
	}

	/**
	 * Adapts this {@link ResolvableType} to a {@link VariableResolver}.
	 */
	/**
	 * 将此{@link  ResolvableType}修改为{@link  VariableResolver}。 
	 * 
	 */
	@Nullable
	VariableResolver asVariableResolver() {
		if (this == NONE) {
			return null;
		}
		return new DefaultVariableResolver(this);
	}

	/**
	 * Custom serialization support for {@link #NONE}.
	 */
	/**
	 * 对{@link  #NONE}的自定义序列化支持。 
	 * 
	 */
	private Object readResolve() {
		return (this.type == EmptyType.INSTANCE ? NONE : this);
	}

	/**
	 * Return a String representation of this type in its fully resolved form
	 * (including any generic parameters).
	 */
	/**
	 * 以完全解析的形式（包括所有通用参数）返回此类型的String表示形式。 
	 * 
	 */
	@Override
	public String toString() {
		if (isArray()) {
			return getComponentType() + "[]";
		}
		if (this.resolved == null) {
			return "?";
		}
		if (this.type instanceof TypeVariable) {
			TypeVariable<?> variable = (TypeVariable<?>) this.type;
			if (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {
				// Don't bother with variable boundaries for toString()...
				// Can cause infinite recursions in case of self-references
				return "?";
			}
		}
		if (hasGenerics()) {
			return this.resolved.getName() + '<' + StringUtils.arrayToDelimitedString(getGenerics(), ", ") + '>';
		}
		return this.resolved.getName();
	}


	// Factory methods

	/**
	 * Return a {@link ResolvableType} for the specified {@link Class},
	 * using the full generic type information for assignability checks.
	 * For example: {@code ResolvableType.forClass(MyArrayList.class)}.
	 * @param clazz the class to introspect ({@code null} is semantically
	 * equivalent to {@code Object.class} for typical use cases here)
	 * @return a {@link ResolvableType} for the specified class
	 * @see #forClass(Class, Class)
	 * @see #forClassWithGenerics(Class, Class...)
	 */
	/**
	 * 使用完整的通用类型信息进行可分配性检查，为指定的{@link 类}返回一个{@link  ResolvableType}。 
	 * 例如：{@code  ResolvableType.forClass（MyArrayList.class）}。 
	 *  
	 * @param 对此类进行自省（对于此处的典型用例，{{@@code> null}在语义上等效于{@code  Object.class}）
	 * @return 指定的类
	 * @see  #forClass（Class，Class）
	 * @see  #forClassWithGenerics（Class，Class ...）
	 */
	public static ResolvableType forClass(@Nullable Class<?> clazz) {
		return new ResolvableType(clazz);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Class},
	 * doing assignability checks against the raw class only (analogous to
	 * {@link Class#isAssignableFrom}, which this serves as a wrapper for.
	 * For example: {@code ResolvableType.forRawClass(List.class)}.
	 * @param clazz the class to introspect ({@code null} is semantically
	 * equivalent to {@code Object.class} for typical use cases here)
	 * @return a {@link ResolvableType} for the specified class
	 * @since 4.2
	 * @see #forClass(Class)
	 * @see #getRawClass()
	 */
	/**
	 * 返回指定的{@link 类}的{@link  ResolvableType}，仅对原始类（类似于{@link  Class＃isAssignableFrom}，用作包装器）进行可分配性检查。 
	 * 示例：{@code  ResolvableType.forRawClass（List.class）}。 
	 * 
	 * @param 吸引内省的类（{@code  null}在语义上等效于{@code  Object.class}指定的类别的@{return> a {@link  ResolvableType} @自4.2起
	 * @see  #forClass（Class）
	 * @see  #getRawClass（）
	 */
	public static ResolvableType forRawClass(@Nullable Class<?> clazz) {
		return new ResolvableType(clazz) {
			@Override
			public ResolvableType[] getGenerics() {
				return EMPTY_TYPES_ARRAY;
			}
			@Override
			public boolean isAssignableFrom(Class<?> other) {
				return (clazz == null || ClassUtils.isAssignable(clazz, other));
			}
			@Override
			public boolean isAssignableFrom(ResolvableType other) {
				Class<?> otherClass = other.resolve();
				return (otherClass != null && (clazz == null || ClassUtils.isAssignable(clazz, otherClass)));
			}
		};
	}

	/**
	 * Return a {@link ResolvableType} for the specified base type
	 * (interface or base class) with a given implementation class.
	 * For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.
	 * @param baseType the base type (must not be {@code null})
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified base type backed by the
	 * given implementation class
	 * @see #forClass(Class)
	 * @see #forClassWithGenerics(Class, Class...)
	 */
	/**
	 * 返回具有给定实现类的指定基类型（接口或基类）的{@link  ResolvableType}。 
	 * 例如：{@code  ResolvableType.forClass（List.class，MyArrayList.class）}。 
	 *  
	 * @param  baseType基本类型（不得为{@code  null}）
	 * @param  ImplementationClass实现类
	 * @return 由给定实现支持的指定基本类型的{@link  ResolvableType} class 
	 * @see  #forClass（Class）
	 * @see  #forClassWithGenerics（Class，Class ...）
	 */
	public static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {
		Assert.notNull(baseType, "Base type must not be null");
		ResolvableType asType = forType(implementationClass).as(baseType);
		return (asType == NONE ? forType(baseType) : asType);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics.
	 * @param clazz the class (or interface) to introspect
	 * @param generics the generics of the class
	 * @return a {@link ResolvableType} for the specific class and generics
	 * @see #forClassWithGenerics(Class, ResolvableType...)
	 */
	/**
	 * 使用预先声明的泛型为指定的{@link 类}返回一个{@link  ResolvableType}。 
	 *  
	 * @param 使类（或接口）自省
	 * @param 泛型该类的泛型
	 * @return 适用于特定类的{@link  ResolvableType}泛型
	 * @see  #forClassWithGenerics（Class， ResolvableType ...）
	 */
	public static ResolvableType forClassWithGenerics(Class<?> clazz, Class<?>... generics) {
		Assert.notNull(clazz, "Class must not be null");
		Assert.notNull(generics, "Generics array must not be null");
		ResolvableType[] resolvableGenerics = new ResolvableType[generics.length];
		for (int i = 0; i < generics.length; i++) {
			resolvableGenerics[i] = forClass(generics[i]);
		}
		return forClassWithGenerics(clazz, resolvableGenerics);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics.
	 * @param clazz the class (or interface) to introspect
	 * @param generics the generics of the class
	 * @return a {@link ResolvableType} for the specific class and generics
	 * @see #forClassWithGenerics(Class, Class...)
	 */
	/**
	 * 使用预先声明的泛型为指定的{@link 类}返回一个{@link  ResolvableType}。 
	 *  
	 * @param 使类（或接口）自省
	 * @param 泛型该类的泛型
	 * @return 特定类和泛型的{@link  ResolvableType} 
	 * @see  #forClassWithGenerics（Class，类...）
	 */
	public static ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics) {
		Assert.notNull(clazz, "Class must not be null");
		Assert.notNull(generics, "Generics array must not be null");
		TypeVariable<?>[] variables = clazz.getTypeParameters();
		Assert.isTrue(variables.length == generics.length, "Mismatched number of generics specified");

		Type[] arguments = new Type[generics.length];
		for (int i = 0; i < generics.length; i++) {
			ResolvableType generic = generics[i];
			Type argument = (generic != null ? generic.getType() : null);
			arguments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);
		}

		ParameterizedType syntheticType = new SyntheticParameterizedType(clazz, arguments);
		return forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));
	}

	/**
	 * Return a {@link ResolvableType} for the specified instance. The instance does not
	 * convey generic information but if it implements {@link ResolvableTypeProvider} a
	 * more precise {@link ResolvableType} can be used than the simple one based on
	 * the {@link #forClass(Class) Class instance}.
	 * @param instance the instance
	 * @return a {@link ResolvableType} for the specified instance
	 * @since 4.2
	 * @see ResolvableTypeProvider
	 */
	/**
	 * 返回指定实例的{@link  ResolvableType}。 
	 * 该实例不传达一般信息，但如果实现{@link  ResolvableTypeProvider}，则可以使用比基于{@link  #forClass（Class）Class实例的简单实例更精确的{@link  ResolvableType} }。 
	 *  
	 * @param 实例实例
	 * @return 指定实例的{@link  ResolvableType} @自4.2起
	 * @see  ResolvableTypeProvider
	 */
	public static ResolvableType forInstance(Object instance) {
		Assert.notNull(instance, "Instance must not be null");
		if (instance instanceof ResolvableTypeProvider) {
			ResolvableType type = ((ResolvableTypeProvider) instance).getResolvableType();
			if (type != null) {
				return type;
			}
		}
		return ResolvableType.forClass(instance.getClass());
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Field}.
	 * @param field the source field
	 * @return a {@link ResolvableType} for the specified field
	 * @see #forField(Field, Class)
	 */
	/**
	 * 为指定的{@link 字段}返回一个{@link  ResolvableType}。 
	 *  
	 * @param 字段是源字段
	 * @return 指定字段的{@link  ResolvableType} 
	 * @see  #forField（Field，Class）
	 */
	public static ResolvableType forField(Field field) {
		Assert.notNull(field, "Field must not be null");
		return forType(null, new FieldTypeProvider(field), null);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Field} with a given
	 * implementation.
	 * <p>Use this variant when the class that declares the field includes generic
	 * parameter variables that are satisfied by the implementation class.
	 * @param field the source field
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified field
	 * @see #forField(Field)
	 */
	/**
	 * 通过给定的实现，为指定的{@link 字段}返回一个{@link  ResolvableType}。 
	 *  <p>当声明字段的类包含实现类满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 字段源字段
	 * @param  ImplementationClass实现类
	 * @return 指定字段的{@link  ResolvableType} 
	 * @see  #forField（Field）
	 */
	public static ResolvableType forField(Field field, Class<?> implementationClass) {
		Assert.notNull(field, "Field must not be null");
		ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());
		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Field} with a given
	 * implementation.
	 * <p>Use this variant when the class that declares the field includes generic
	 * parameter variables that are satisfied by the implementation type.
	 * @param field the source field
	 * @param implementationType the implementation type
	 * @return a {@link ResolvableType} for the specified field
	 * @see #forField(Field)
	 */
	/**
	 * 通过给定的实现，为指定的{@link 字段}返回一个{@link  ResolvableType}。 
	 *  <p>当声明字段的类包含实现类型满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 字段源字段
	 * @param 实现类型指定类型的实现类型
	 * @return  a {@link  ResolvableType} 
	 * @see  #forField（Field）
	 */
	public static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {
		Assert.notNull(field, "Field must not be null");
		ResolvableType owner = (implementationType != null ? implementationType : NONE);
		owner = owner.as(field.getDeclaringClass());
		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Field} with the
	 * given nesting level.
	 * @param field the source field
	 * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested
	 * generic type; etc)
	 * @see #forField(Field)
	 */
	/**
	 * 返回具有给定嵌套级别的指定{@link 字段}的{@link  ResolvableType}。 
	 *  
	 * @param 字段，源字段
	 * @param  nestingLevel嵌套级别（1表示外部级别； 
	 *  2表示嵌套的泛型类型； 
	 * 等等）
	 * @see  #forField（Field）
	 */
	public static ResolvableType forField(Field field, int nestingLevel) {
		Assert.notNull(field, "Field must not be null");
		return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Field} with a given
	 * implementation and the given nesting level.
	 * <p>Use this variant when the class that declares the field includes generic
	 * parameter variables that are satisfied by the implementation class.
	 * @param field the source field
	 * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested
	 * generic type; etc)
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified field
	 * @see #forField(Field)
	 */
	/**
	 * 使用给定的实现和给定的嵌套级别，为指定的{@link 字段}返回一个{@link  ResolvableType}。 
	 *  <p>当声明字段的类包含实现类满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 字段，源字段
	 * @param  nestingLevel嵌套级别（1表示外部级别； 
	 *  2表示嵌套的泛型类型； 
	 * 等等）
	 * @param  ImplementationClass实现类
	 * @return  a {@link 指定字段的ResolvableType} 
	 * @see  #forField（Field）
	 */
	public static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {
		Assert.notNull(field, "Field must not be null");
		ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());
		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Constructor} parameter.
	 * @param constructor the source constructor (must not be {@code null})
	 * @param parameterIndex the parameter index
	 * @return a {@link ResolvableType} for the specified constructor parameter
	 * @see #forConstructorParameter(Constructor, int, Class)
	 */
	/**
	 * 为指定的{@link 构造函数}参数返回一个{@link  ResolvableType}。 
	 *  
	 * @param 构造函数为源构造函数（不得为{@code  null}）
	 * @param  parameterIndex参数索引
	 * @return 一个用于指定构造函数参数的{@link  ResolvableType}＃ forConstructorParameter（Constructor，int，Class）
	 */
	public static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {
		Assert.notNull(constructor, "Constructor must not be null");
		return forMethodParameter(new MethodParameter(constructor, parameterIndex));
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Constructor} parameter
	 * with a given implementation. Use this variant when the class that declares the
	 * constructor includes generic parameter variables that are satisfied by the
	 * implementation class.
	 * @param constructor the source constructor (must not be {@code null})
	 * @param parameterIndex the parameter index
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified constructor parameter
	 * @see #forConstructorParameter(Constructor, int)
	 */
	/**
	 * 使用给定的实现为指定的{@link 构造函数}参数返回一个{@link  ResolvableType}。 
	 * 当声明构造函数的类包含实现类满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 构造函数为源构造函数（不得为{@code  null}）
	 * @param  parameterIndex参数索引
	 * @param  ImplementationClass实现类
	 * @return 的{@link  ResolvableType}指定的构造函数参数
	 * @see  #forConstructorParameter（Constructor，int）
	 */
	public static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,
			Class<?> implementationClass) {

		Assert.notNull(constructor, "Constructor must not be null");
		MethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);
		return forMethodParameter(methodParameter);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Method} return type.
	 * @param method the source for the method return type
	 * @return a {@link ResolvableType} for the specified method return
	 * @see #forMethodReturnType(Method, Class)
	 */
	/**
	 * 为指定的{@link 方法}返回类型返回一个{@link  ResolvableType}。 
	 *  
	 * @param 方法方法返回类型的源
	 * @return 一个用于指定方法的{@link  ResolvableType}返回
	 * @see  #forMethodReturnType（Method，Class）
	 */
	public static ResolvableType forMethodReturnType(Method method) {
		Assert.notNull(method, "Method must not be null");
		return forMethodParameter(new MethodParameter(method, -1));
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Method} return type.
	 * Use this variant when the class that declares the method includes generic
	 * parameter variables that are satisfied by the implementation class.
	 * @param method the source for the method return type
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified method return
	 * @see #forMethodReturnType(Method)
	 */
	/**
	 * 为指定的{@link 方法}返回类型返回一个{@link  ResolvableType}。 
	 * 当声明方法的类包含实现类满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 方法方法返回类型的源
	 * @param 实现类实现类
	 * @return 指定方法的{@link  ResolvableType}返回
	 * @see  #forMethodReturnType（Method）
	 */
	public static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {
		Assert.notNull(method, "Method must not be null");
		MethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);
		return forMethodParameter(methodParameter);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Method} parameter.
	 * @param method the source method (must not be {@code null})
	 * @param parameterIndex the parameter index
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @see #forMethodParameter(Method, int, Class)
	 * @see #forMethodParameter(MethodParameter)
	 */
	/**
	 * 为指定的{@link 方法}参数返回一个{@link  ResolvableType}。 
	 *  
	 * @param 方法是源方法（不得为{@code  null}）
	 * @param  parameterIndex参数索引
	 * @return 指定方法参数的一个<< @link> ResolvableType} 
	 * @see ＃ forMethodParameter（Method，int，Class）
	 * @see  #forMethodParameter（MethodParameter）
	 */
	public static ResolvableType forMethodParameter(Method method, int parameterIndex) {
		Assert.notNull(method, "Method must not be null");
		return forMethodParameter(new MethodParameter(method, parameterIndex));
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Method} parameter with a
	 * given implementation. Use this variant when the class that declares the method
	 * includes generic parameter variables that are satisfied by the implementation class.
	 * @param method the source method (must not be {@code null})
	 * @param parameterIndex the parameter index
	 * @param implementationClass the implementation class
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @see #forMethodParameter(Method, int, Class)
	 * @see #forMethodParameter(MethodParameter)
	 */
	/**
	 * 通过给定的实现，为指定的{@link 方法}参数返回一个{@link  ResolvableType}。 
	 * 当声明方法的类包含实现类满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param 方法的源方法（不得为{@code  null}）
	 * @param  parameterIndex参数索引
	 * @param  ImplementationClass实现类
	 * @return 的{@link  ResolvableType}指定的方法参数
	 * @see  #forMethodParameter（Method，int，Class）
	 * @see  #forMethodParameter（MethodParameter）
	 */
	public static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {
		Assert.notNull(method, "Method must not be null");
		MethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);
		return forMethodParameter(methodParameter);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link MethodParameter}.
	 * @param methodParameter the source method parameter (must not be {@code null})
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @see #forMethodParameter(Method, int)
	 */
	/**
	 * 为指定的{@link  MethodParameter}返回一个{@link  ResolvableType}。 
	 *  
	 * @param  methodParameter源方法参数（不得为{@code  null}）
	 * @return 一个用于指定方法参数的{@link  ResolvableType} 
	 * @see  #forMethodParameter（Method，int）
	 */
	public static ResolvableType forMethodParameter(MethodParameter methodParameter) {
		return forMethodParameter(methodParameter, (Type) null);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a
	 * given implementation type. Use this variant when the class that declares the method
	 * includes generic parameter variables that are satisfied by the implementation type.
	 * @param methodParameter the source method parameter (must not be {@code null})
	 * @param implementationType the implementation type
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @see #forMethodParameter(MethodParameter)
	 */
	/**
	 * 返回具有给定实现类型的指定{@link  MethodParameter}的{@link  ResolvableType}。 
	 * 当声明方法的类包含实现类型满足的通用参数变量时，请使用此变体。 
	 *  
	 * @param  methodParameter源方法参数（不得为{@code  null}）
	 * @param  ImplementationType实施类型
	 * @return 指定方法参数的{@link  ResolvableType} 
	 * @see  #forMethodParameter（MethodParameter）
	 */
	public static ResolvableType forMethodParameter(MethodParameter methodParameter,
			@Nullable ResolvableType implementationType) {

		Assert.notNull(methodParameter, "MethodParameter must not be null");
		implementationType = (implementationType != null ? implementationType :
				forType(methodParameter.getContainingClass()));
		ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());
		return forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).
				getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link MethodParameter},
	 * overriding the target type to resolve with a specific given type.
	 * @param methodParameter the source method parameter (must not be {@code null})
	 * @param targetType the type to resolve (a part of the method parameter's type)
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @see #forMethodParameter(Method, int)
	 */
	/**
	 * 为指定的{@link  MethodParameter}返回一个{@link  ResolvableType}，覆盖目标类型以使用特定的给定类型进行解析。 
	 *  
	 * @param  methodParameter源方法参数（不得为{@code  null}）
	 * @param  targetType要解析的类型（方法参数类型的一部分）
	 * @return  a {@link  ResolvableType }，用于指定的方法参数
	 * @see  #forMethodParameter（Method，int）
	 */
	public static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {
		Assert.notNull(methodParameter, "MethodParameter must not be null");
		return forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} at
	 * a specific nesting level, overriding the target type to resolve with a specific
	 * given type.
	 * @param methodParameter the source method parameter (must not be {@code null})
	 * @param targetType the type to resolve (a part of the method parameter's type)
	 * @param nestingLevel the nesting level to use
	 * @return a {@link ResolvableType} for the specified method parameter
	 * @since 5.2
	 * @see #forMethodParameter(Method, int)
	 */
	/**
	 * 在特定的嵌套级别为指定的{@link  MethodParameter}返回一个{@link  ResolvableType}，覆盖目标类型以使用特定的给定类型进行解析。 
	 *  
	 * @param  methodParameter源方法参数（不得为{@code  null}）
	 * @param  targetType要解析的类型（方法参数类型的一部分）
	 * @param  nestingLevel nestingLevel to use 
	 * @return 指定方法参数的{@link  ResolvableType} @自5.2起
	 * @see  #forMethodParameter（Method，int）
	 */
	static ResolvableType forMethodParameter(
			MethodParameter methodParameter, @Nullable Type targetType, int nestingLevel) {

		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
		return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).
				getNested(nestingLevel, methodParameter.typeIndexesPerLevel);
	}

	/**
	 * Return a {@link ResolvableType} as a array of the specified {@code componentType}.
	 * @param componentType the component type
	 * @return a {@link ResolvableType} as an array of the specified component type
	 */
	/**
	 * 返回一个{@link  ResolvableType}作为指定的{@code  componentType}的数组。 
	 *  
	 * @param  componentType组件类型
	 * @return  a {@link  ResolvableType}作为指定组件类型的数组
	 */
	public static ResolvableType forArrayComponent(ResolvableType componentType) {
		Assert.notNull(componentType, "Component type must not be null");
		Class<?> arrayClass = Array.newInstance(componentType.resolve(), 0).getClass();
		return new ResolvableType(arrayClass, null, null, componentType);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Type}.
	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.
	 * @param type the source type (potentially {@code null})
	 * @return a {@link ResolvableType} for the specified {@link Type}
	 * @see #forType(Type, ResolvableType)
	 */
	/**
	 * 为指定的{@link  Type}返回一个{@link  ResolvableType}。 
	 *  <p>注意：生成的{@link  ResolvableType}实例可能不是{@link  Serializable}。 
	 *  
	 * @param 键入源类型（可能为{@code  null}）
	 * @return 指定的{@link  Type}的{@link  ResolvableType} 
	 * @see  #forType（Type，ResolvableType ）
	 */
	public static ResolvableType forType(@Nullable Type type) {
		return forType(type, null, null);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Type} backed by the given
	 * owner type.
	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.
	 * @param type the source type or {@code null}
	 * @param owner the owner type used to resolve variables
	 * @return a {@link ResolvableType} for the specified {@link Type} and owner
	 * @see #forType(Type)
	 */
	/**
	 * 返回由给定所有者类型支持的指定{@link  Type}的{@link  ResolvableType}。 
	 *  <p>注意：生成的{@link  ResolvableType}实例可能不是{@link  Serializable}。 
	 *  
	 * @param 输入源类型或{@code  null} 
	 * @param  owner用于解析变量的所有者类型
	 * @return 指定的{@link 类型}的{@link  ResolvableType}和所有者
	 * @see  #forType（Type）
	 */
	public static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {
		VariableResolver variableResolver = null;
		if (owner != null) {
			variableResolver = owner.asVariableResolver();
		}
		return forType(type, variableResolver);
	}


	/**
	 * Return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}.
	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.
	 * @param typeReference the reference to obtain the source type from
	 * @return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}
	 * @since 4.3.12
	 * @see #forType(Type)
	 */
	/**
	 * 为指定的{@link  ParameterizedTypeReference}返回一个{@link  ResolvableType}。 
	 *  <p>注意：生成的{@link  ResolvableType}实例可能不是{@link  Serializable}。 
	 *  
	 * @param  typeReference引用引用，从指定的{@link  ParameterizedTypeReference}的
	 * @return  a {@link  ResolvableType}获取源类型，从4.3.12开始
	 * @see  #forType（Type）
	 */
	public static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {
		return forType(typeReference.getType(), null, null);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given
	 * {@link VariableResolver}.
	 * @param type the source type or {@code null}
	 * @param variableResolver the variable resolver or {@code null}
	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}
	 */
	/**
	 * 返回由给定的{@link  VariableResolver}支持的指定{@link  Type}的{@link  ResolvableType}。 
	 *  
	 * @param 输入源类型或{@code  null} 
	 * @param  variableResolver变量解析器或{@code  null} 
	 * @return 指定的{<@的{@link  ResolvableType} link>类型}和{@link  VariableResolver}
	 */
	static ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {
		return forType(type, null, variableResolver);
	}

	/**
	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given
	 * {@link VariableResolver}.
	 * @param type the source type or {@code null}
	 * @param typeProvider the type provider or {@code null}
	 * @param variableResolver the variable resolver or {@code null}
	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}
	 */
	/**
	 * 返回由给定的{@link  VariableResolver}支持的指定{@link  Type}的{@link  ResolvableType}。 
	 *  
	 * @param 输入源类型或{@code  null} 
	 * @param  typeProvider输入类型提供者或{@code  null} 
	 * @param  variableResolver变量解析器或{@code  null} <@返回>指定的{@link 类型}和{@link  VariableResolver}的{@link  ResolvableType}
	 */
	static ResolvableType forType(
			@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {

		if (type == null && typeProvider != null) {
			type = SerializableTypeWrapper.forTypeProvider(typeProvider);
		}
		if (type == null) {
			return NONE;
		}

		// For simple Class references, build the wrapper right away -
		// no expensive resolution necessary, so not worth caching...
		if (type instanceof Class) {
			return new ResolvableType(type, typeProvider, variableResolver, (ResolvableType) null);
		}

		// Purge empty entries on access since we don't have a clean-up thread or the like.
		cache.purgeUnreferencedEntries();

		// Check the cache - we may have a ResolvableType which has been resolved before...
		ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);
		ResolvableType cachedType = cache.get(resultType);
		if (cachedType == null) {
			cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);
			cache.put(cachedType, cachedType);
		}
		resultType.resolved = cachedType.resolved;
		return resultType;
	}

	/**
	 * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache.
	 * @since 4.2
	 */
	/**
	 * 清除内部{@code  ResolvableType} / {<@code> SerializableTypeWrapper}缓存。 
	 *  @4.2起
	 */
	public static void clearCache() {
		cache.clear();
		SerializableTypeWrapper.cache.clear();
	}


	/**
	 * Strategy interface used to resolve {@link TypeVariable TypeVariables}.
	 */
	/**
	 * 用于解析{@link  TypeVariable TypeVariables}的策略接口。 
	 * 
	 */
	interface VariableResolver extends Serializable {

		/**
		 * Return the source of the resolver (used for hashCode and equals).
		 */
		/**
		 * 返回解析器的源（用于hashCode和equals）。 
		 * 
		 */
		Object getSource();

		/**
		 * Resolve the specified variable.
		 * @param variable the variable to resolve
		 * @return the resolved variable, or {@code null} if not found
		 */
		/**
		 * 解决指定的变量。 
		 *  
		 * @param 变量要解析的变量
		 * @return 解析的变量； 
		 * 如果找不到，则为{@code  null}
		 */
		@Nullable
		ResolvableType resolveVariable(TypeVariable<?> variable);
	}


	@SuppressWarnings("serial")
	private static class DefaultVariableResolver implements VariableResolver {

		private final ResolvableType source;

		DefaultVariableResolver(ResolvableType resolvableType) {
			this.source = resolvableType;
		}

		@Override
		@Nullable
		public ResolvableType resolveVariable(TypeVariable<?> variable) {
			return this.source.resolveVariable(variable);
		}

		@Override
		public Object getSource() {
			return this.source;
		}
	}


	@SuppressWarnings("serial")
	private static class TypeVariablesVariableResolver implements VariableResolver {

		private final TypeVariable<?>[] variables;

		private final ResolvableType[] generics;

		public TypeVariablesVariableResolver(TypeVariable<?>[] variables, ResolvableType[] generics) {
			this.variables = variables;
			this.generics = generics;
		}

		@Override
		@Nullable
		public ResolvableType resolveVariable(TypeVariable<?> variable) {
			TypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);
			for (int i = 0; i < this.variables.length; i++) {
				TypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);
				if (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {
					return this.generics[i];
				}
			}
			return null;
		}

		@Override
		public Object getSource() {
			return this.generics;
		}
	}


	private static final class SyntheticParameterizedType implements ParameterizedType, Serializable {

		private final Type rawType;

		private final Type[] typeArguments;

		public SyntheticParameterizedType(Type rawType, Type[] typeArguments) {
			this.rawType = rawType;
			this.typeArguments = typeArguments;
		}

		@Override
		public String getTypeName() {
			String typeName = this.rawType.getTypeName();
			if (this.typeArguments.length > 0) {
				StringJoiner stringJoiner = new StringJoiner(", ", "<", ">");
				for (Type argument : this.typeArguments) {
					stringJoiner.add(argument.getTypeName());
				}
				return typeName + stringJoiner;
			}
			return typeName;
		}

		@Override
		@Nullable
		public Type getOwnerType() {
			return null;
		}

		@Override
		public Type getRawType() {
			return this.rawType;
		}

		@Override
		public Type[] getActualTypeArguments() {
			return this.typeArguments;
		}

		@Override
		public boolean equals(@Nullable Object other) {
			if (this == other) {
				return true;
			}
			if (!(other instanceof ParameterizedType)) {
				return false;
			}
			ParameterizedType otherType = (ParameterizedType) other;
			return (otherType.getOwnerType() == null && this.rawType.equals(otherType.getRawType()) &&
					Arrays.equals(this.typeArguments, otherType.getActualTypeArguments()));
		}

		@Override
		public int hashCode() {
			return (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));
		}

		@Override
		public String toString() {
			return getTypeName();
		}
	}


	/**
	 * Internal helper to handle bounds from {@link WildcardType WildcardTypes}.
	 */
	/**
	 * 内部辅助程序，用于处理{@link  WildcardType WildcardTypes}中的范围。 
	 * 
	 */
	private static class WildcardBounds {

		private final Kind kind;

		private final ResolvableType[] bounds;

		/**
		 * Internal constructor to create a new {@link WildcardBounds} instance.
		 * @param kind the kind of bounds
		 * @param bounds the bounds
		 * @see #get(ResolvableType)
		 */
		/**
		 * 内部构造函数，用于创建新的{@link  WildcardBounds}实例。 
		 *  
		 * @param 种边界
		 * @param 种边界
		 * @see  #get（ResolvableType）
		 */
		public WildcardBounds(Kind kind, ResolvableType[] bounds) {
			this.kind = kind;
			this.bounds = bounds;
		}

		/**
		 * Return {@code true} if this bounds is the same kind as the specified bounds.
		 */
		/**
		 * 如果此边界与指定的边界相同，则返回{@code  true}。 
		 * 
		 */
		public boolean isSameKind(WildcardBounds bounds) {
			return this.kind == bounds.kind;
		}

		/**
		 * Return {@code true} if this bounds is assignable to all the specified types.
		 * @param types the types to test against
		 * @return {@code true} if this bounds is assignable to all types
		 */
		/**
		 * 如果此范围可分配给所有指定的类型，则返回{@code  true}。 
		 * 如果此界限可分配给所有类型，则
		 * @param 键入要针对
		 * @return  {@code  true}进行测试的类型
		 */
		public boolean isAssignableFrom(ResolvableType... types) {
			for (ResolvableType bound : this.bounds) {
				for (ResolvableType type : types) {
					if (!isAssignable(bound, type)) {
						return false;
					}
				}
			}
			return true;
		}

		private boolean isAssignable(ResolvableType source, ResolvableType from) {
			return (this.kind == Kind.UPPER ? source.isAssignableFrom(from) : from.isAssignableFrom(source));
		}

		/**
		 * Return the underlying bounds.
		 */
		/**
		 * 返回底层边界。 
		 * 
		 */
		public ResolvableType[] getBounds() {
			return this.bounds;
		}

		/**
		 * Get a {@link WildcardBounds} instance for the specified type, returning
		 * {@code null} if the specified type cannot be resolved to a {@link WildcardType}.
		 * @param type the source type
		 * @return a {@link WildcardBounds} instance or {@code null}
		 */
		/**
		 * 获取指定类型的{@link  WildcardBounds}实例，如果指定类型不能解析为{@link  WildcardType}，则返回{@code  null}。 
		 *  
		 * @param 键入源类型
		 * @return 一个{@link  WildcardBounds}实例或{@code  null}
		 */
		@Nullable
		public static WildcardBounds get(ResolvableType type) {
			ResolvableType resolveToWildcard = type;
			while (!(resolveToWildcard.getType() instanceof WildcardType)) {
				if (resolveToWildcard == NONE) {
					return null;
				}
				resolveToWildcard = resolveToWildcard.resolveType();
			}
			WildcardType wildcardType = (WildcardType) resolveToWildcard.type;
			Kind boundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);
			Type[] bounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());
			ResolvableType[] resolvableBounds = new ResolvableType[bounds.length];
			for (int i = 0; i < bounds.length; i++) {
				resolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);
			}
			return new WildcardBounds(boundsType, resolvableBounds);
		}

		/**
		 * The various kinds of bounds.
		 */
		/**
		 * 各种界限。 
		 * 
		 */
		enum Kind {UPPER, LOWER}
	}


	/**
	 * Internal {@link Type} used to represent an empty value.
	 */
	/**
	 * 内部{@link  Type}用于表示一个空值。 
	 * 
	 */
	@SuppressWarnings("serial")
	static class EmptyType implements Type, Serializable {

		static final Type INSTANCE = new EmptyType();

		Object readResolve() {
			return INSTANCE;
		}
	}

}
