/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.convert;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

import org.springframework.core.MethodParameter;
import org.springframework.core.ResolvableType;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Contextual descriptor about a type to convert from or to.
 * Capable of representing arrays and generic collection types.
 *
 * @author Keith Donald
 * @author Andy Clement
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @author Sam Brannen
 * @author Stephane Nicoll
 * @since 3.0
 * @see ConversionService#canConvert(TypeDescriptor, TypeDescriptor)
 * @see ConversionService#convert(Object, TypeDescriptor, TypeDescriptor)
 */
/**
 * 有关要从或转换为类型的上下文描述符。 
 * 能够表示数组和通用集合类型。 
 *  @author  Keith Donald @author  Andy Clement @author  Juergen Hoeller @author  Phillip Webb @author  Sam Brannen @author  Stephane Nicoll @since 3.0 
 * @see  ConversionService＃canConvert（TypeDescriptor，TypeDescriptor ）
 * @see  ConversionService＃convert（Object，TypeDescriptor，TypeDescriptor）
 */
@SuppressWarnings("serial")
public class TypeDescriptor implements Serializable {

	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];

	private static final Map<Class<?>, TypeDescriptor> commonTypesCache = new HashMap<>(32);

	private static final Class<?>[] CACHED_COMMON_TYPES = {
			boolean.class, Boolean.class, byte.class, Byte.class, char.class, Character.class,
			double.class, Double.class, float.class, Float.class, int.class, Integer.class,
			long.class, Long.class, short.class, Short.class, String.class, Object.class};

	static {
		for (Class<?> preCachedClass : CACHED_COMMON_TYPES) {
			commonTypesCache.put(preCachedClass, valueOf(preCachedClass));
		}
	}


	private final Class<?> type;

	private final ResolvableType resolvableType;

	private final AnnotatedElementAdapter annotatedElement;


	/**
	 * Create a new type descriptor from a {@link MethodParameter}.
	 * <p>Use this constructor when a source or target conversion point is a
	 * constructor parameter, method parameter, or method return value.
	 * @param methodParameter the method parameter
	 */
	/**
	 * 从{@link  MethodParameter}创建一个新的类型描述符。 
	 *  <p>当源或目标转换点是构造函数参数，方法参数或方法返回值时，请使用此构造函数。 
	 *  
	 * @param  methodParameter方法参数
	 */
	public TypeDescriptor(MethodParameter methodParameter) {
		this.resolvableType = ResolvableType.forMethodParameter(methodParameter);
		this.type = this.resolvableType.resolve(methodParameter.getNestedParameterType());
		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?
				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations());
	}

	/**
	 * Create a new type descriptor from a {@link Field}.
	 * <p>Use this constructor when a source or target conversion point is a field.
	 * @param field the field
	 */
	/**
	 * 从{@link 字段}创建一个新的类型描述符。 
	 *  <p>当源或目标转换点是字段时，请使用此构造函数。 
	 *  
	 * @param 字段字段
	 */
	public TypeDescriptor(Field field) {
		this.resolvableType = ResolvableType.forField(field);
		this.type = this.resolvableType.resolve(field.getType());
		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations());
	}

	/**
	 * Create a new type descriptor from a {@link Property}.
	 * <p>Use this constructor when a source or target conversion point is a
	 * property on a Java class.
	 * @param property the property
	 */
	/**
	 * 从{@link 属性}创建一个新的类型描述符。 
	 *  <p>当源或目标转换点是Java类的属性时，请使用此构造函数。 
	 *  
	 * @param 属性属性
	 */
	public TypeDescriptor(Property property) {
		Assert.notNull(property, "Property must not be null");
		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter());
		this.type = this.resolvableType.resolve(property.getType());
		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations());
	}

	/**
	 * Create a new type descriptor from a {@link ResolvableType}.
	 * <p>This constructor is used internally and may also be used by subclasses
	 * that support non-Java languages with extended type systems. It is public
	 * as of 5.1.4 whereas it was protected before.
	 * @param resolvableType the resolvable type
	 * @param type the backing type (or {@code null} if it should get resolved)
	 * @param annotations the type annotations
	 * @since 4.0
	 */
	/**
	 * 从{@link  ResolvableType}创建一个新的类型描述符。 
	 *  <p>此构造函数在内部使用，也可以由支持带有扩展类型系统的非Java语言的子类使用。 
	 * 从5.1.4开始它是公共的，而以前它是受保护的。 
	 *  
	 * @param  resolvableType可解析类型
	 * @param 类型支持类型（如果应该解析，则返回{@code  null}）
	 * @param 注释类型注释@since 4.0
	 */
	public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {
		this.resolvableType = resolvableType;
		this.type = (type != null ? type : resolvableType.toClass());
		this.annotatedElement = new AnnotatedElementAdapter(annotations);
	}


	/**
	 * Variation of {@link #getType()} that accounts for a primitive type by
	 * returning its object wrapper type.
	 * <p>This is useful for conversion service implementations that wish to
	 * normalize to object-based types and not work with primitive types directly.
	 */
	/**
	 * {@link  #getType（）}的变体，它通过返回其对象包装器类型来说明原始类型。 
	 *  <p>这对于希望标准化为基于对象的类型并且不能直接与原始类型一起使用的转换服务实现很有用。 
	 * 
	 */
	public Class<?> getObjectType() {
		return ClassUtils.resolvePrimitiveIfNecessary(getType());
	}

	/**
	 * The type of the backing class, method parameter, field, or property
	 * described by this TypeDescriptor.
	 * <p>Returns primitive types as-is. See {@link #getObjectType()} for a
	 * variation of this operation that resolves primitive types to their
	 * corresponding Object types if necessary.
	 * @see #getObjectType()
	 */
	/**
	 * 此TypeDescriptor描述的支持类，方法参数，字段或属性的类型。 
	 *  <p>照原样返回原始类型。 
	 * 有关此操作的变体，请参见{@link  #getObjectType（）}，该操作可在必要时将原始类型解析为其对应的Object类型。 
	 *  
	 * @see  #getObjectType（）
	 */
	public Class<?> getType() {
		return this.type;
	}

	/**
	 * Return the underlying {@link ResolvableType}.
	 * @since 4.0
	 */
	/**
	 * 返回基础的{@link  ResolvableType}。 
	 *  @始于4.0
	 */
	public ResolvableType getResolvableType() {
		return this.resolvableType;
	}

	/**
	 * Return the underlying source of the descriptor. Will return a {@link Field},
	 * {@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}
	 * was constructed. This method is primarily to provide access to additional
	 * type information or meta-data that alternative JVM languages may provide.
	 * @since 4.0
	 */
	/**
	 * 返回描述符的基础源。 
	 * 根据{@link  TypeDescriptor}的构造方式，将返回{@link 字段}，{<@link>方法参数}或{@link 类型}。 
	 * 此方法主要用于提供对其他JVM语言可能提供的其他类型信息或元数据的访问。 
	 *  @始于4.0
	 */
	public Object getSource() {
		return this.resolvableType.getSource();
	}

	/**
	 * Narrows this {@link TypeDescriptor} by setting its type to the class of the
	 * provided value.
	 * <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor
	 * is returned unchanged.
	 * <p>Designed to be called by binding frameworks when they read property, field,
	 * or method return values. Allows such frameworks to narrow a TypeDescriptor built
	 * from a declared property, field, or method return value type. For example, a field
	 * declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}
	 * if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor
	 * can then be used to convert the HashMap to some other type. Annotation and nested
	 * type context is preserved by the narrowed copy.
	 * @param value the value to use for narrowing this type descriptor
	 * @return this TypeDescriptor narrowed (returns a copy with its type updated to the
	 * class of the provided value)
	 */
	/**
	 * 通过将其{@link  TypeDescriptor}的类型设置为所提供值的类，可以使其变窄。 
	 *  <p>如果值为{@code  null}，则不执行任何缩小操作，并且此TypeDescriptor保持不变。 
	 *  <p>设计为在绑定框架读取属性，字段或方法返回值时由它们调用。 
	 * 允许此类框架缩小从声明的属性，字段或方法返回值类型构建的TypeDescriptor。 
	 * 例如，如果将声明为{@code  java.lang.Object}的字段设置为{@code  java.util.HashMap}，则会缩小为{@code  java.util.HashMap}。 
	 * 值。 
	 * 然后，变窄的TypeDescriptor可用于将HashMap转换为其他类型。 
	 * 注释和嵌套类型上下文由缩小的副本保留。 
	 *  
	 * @param 值用于缩小此类型描述符的值
	 * @return 此TypeDescriptor缩小的（返回副本，其类型更新为提供的值的类）
	 */
	public TypeDescriptor narrow(@Nullable Object value) {
		if (value == null) {
			return this;
		}
		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType());
		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations());
	}

	/**
	 * Cast this {@link TypeDescriptor} to a superclass or implemented interface
	 * preserving annotations and nested type context.
	 * @param superType the super type to cast to (can be {@code null})
	 * @return a new TypeDescriptor for the up-cast type
	 * @throws IllegalArgumentException if this type is not assignable to the super-type
	 * @since 3.2
	 */
	/**
	 * 将此{@link  TypeDescriptor}强制转换为保留注释和嵌套类型上下文的超类或已实现的接口。 
	 *  
	 * @param  superType要转换为超级类型的超级类型（可以为{@code  null}）
	 * @return 向上类型的新TypeDescriptor 
	 * @throws  IllegalArgumentException（如果该类型不能分配给超级类型）输入@since 3.2
	 */
	@Nullable
	public TypeDescriptor upcast(@Nullable Class<?> superType) {
		if (superType == null) {
			return null;
		}
		Assert.isAssignable(superType, getType());
		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations());
	}

	/**
	 * Return the name of this type: the fully qualified class name.
	 */
	/**
	 * 返回此类型的名称：完全限定的类名称。 
	 * 
	 */
	public String getName() {
		return ClassUtils.getQualifiedName(getType());
	}

	/**
	 * Is this type a primitive type?
	 */
	/**
	 * 此类型是原始类型吗？
	 */
	public boolean isPrimitive() {
		return getType().isPrimitive();
	}

	/**
	 * Return the annotations associated with this type descriptor, if any.
	 * @return the annotations, or an empty array if none
	 */
	/**
	 * 返回与此类型描述符关联的注释（如果有）。 
	 *  
	 * @return 注解，如果没有则为空数组
	 */
	public Annotation[] getAnnotations() {
		return this.annotatedElement.getAnnotations();
	}

	/**
	 * Determine if this type descriptor has the specified annotation.
	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels
	 * of meta-annotations.
	 * @param annotationType the annotation type
	 * @return <tt>true</tt> if the annotation is present
	 */
	/**
	 * 确定此类型描述符是否具有指定的注释。 
	 *  <p>从Spring Framework 4.2开始，此方法支持任意级别的元注释。 
	 *  
	 * @param 注释如果存在注释，则键入注释类型
	 * @return  <tt> true </ tt>
	 */
	public boolean hasAnnotation(Class<? extends Annotation> annotationType) {
		if (this.annotatedElement.isEmpty()) {
			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()
			// to return a copy of the array, whereas we can do it more efficiently here.
			return false;
		}
		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType);
	}

	/**
	 * Obtain the annotation of the specified {@code annotationType} that is on this type descriptor.
	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations.
	 * @param annotationType the annotation type
	 * @return the annotation, or {@code null} if no such annotation exists on this type descriptor
	 */
	/**
	 * 获取此类型描述符上指定的{@code 注解类型}的注解。 
	 *  <p>从Spring Framework 4.2开始，此方法支持任意级别的元注释。 
	 *  
	 * @param 注解键入注解类型
	 * @return 注解，如果此类型描述符上不存在此类注解，则为{@code  null}
	 */
	@Nullable
	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {
		if (this.annotatedElement.isEmpty()) {
			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()
			// to return a copy of the array, whereas we can do it more efficiently here.
			return null;
		}
		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType);
	}

	/**
	 * Returns true if an object of this type descriptor can be assigned to the location
	 * described by the given type descriptor.
	 * <p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}
	 * returns {@code true} because a String value can be assigned to a CharSequence variable.
	 * On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}
	 * returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers.
	 * <p>For arrays, collections, and maps, element and key/value types are checked if declared.
	 * For example, a List&lt;String&gt; field value is assignable to a Collection&lt;CharSequence&gt;
	 * field, but List&lt;Number&gt; is not assignable to List&lt;Integer&gt;.
	 * @return {@code true} if this type is assignable to the type represented by the provided
	 * type descriptor
	 * @see #getObjectType()
	 */
	/**
	 * 如果可以将这种类型描述符的对象分配给给定类型描述符描述的位置，则返回true。 
	 *  <p>例如，{<@code> valueOf（String.class）.isAssignableTo（valueOf（CharSequence.class））}返回{@code  true}，因为可以将String值分配给CharSequence变量。 
	 * 另一方面，{<@code> valueOf（Number.class）.isAssignableTo（valueOf（Integer.class））}返回{@code  false}，因为尽管所有整数都是数字，但并非所有数字都是整数。 
	 *  <p>对于数组，集合和映射，如果声明，则检查元素和键/值类型。 
	 * 例如，List <String>字段值可分配给Collection <CharSequence>字段，但List <Number>不可分配给List <Integer>。 
	 *  
	 * @return  {@code  true}，如果此类型可分配给由提供的类型描述符表示的类型
	 * @see  #getObjectType（）
	 */
	public boolean isAssignableTo(TypeDescriptor typeDescriptor) {
		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType());
		if (!typesAssignable) {
			return false;
		}
		if (isArray() && typeDescriptor.isArray()) {
			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());
		}
		else if (isCollection() && typeDescriptor.isCollection()) {
			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());
		}
		else if (isMap() && typeDescriptor.isMap()) {
			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&
				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor());
		}
		else {
			return true;
		}
	}

	private boolean isNestedAssignable(@Nullable TypeDescriptor nestedTypeDescriptor,
			@Nullable TypeDescriptor otherNestedTypeDescriptor) {

		return (nestedTypeDescriptor == null || otherNestedTypeDescriptor == null ||
				nestedTypeDescriptor.isAssignableTo(otherNestedTypeDescriptor));
	}

	/**
	 * Is this type a {@link Collection} type?
	 */
	/**
	 * 此类型是{@link 集合}类型吗？
	 */
	public boolean isCollection() {
		return Collection.class.isAssignableFrom(getType());
	}

	/**
	 * Is this type an array type?
	 */
	/**
	 * 此类型是数组类型吗？
	 */
	public boolean isArray() {
		return getType().isArray();
	}

	/**
	 * If this type is an array, returns the array's component type.
	 * If this type is a {@code Stream}, returns the stream's component type.
	 * If this type is a {@link Collection} and it is parameterized, returns the Collection's element type.
	 * If the Collection is not parameterized, returns {@code null} indicating the element type is not declared.
	 * @return the array component type or Collection element type, or {@code null} if this type is not
	 * an array type or a {@code java.util.Collection} or if its element type is not parameterized
	 * @see #elementTypeDescriptor(Object)
	 */
	/**
	 * 如果此类型是数组，则返回数组的组件类型。 
	 * 如果此类型是{@code  Stream}，则返回流的组件类型。 
	 * 如果此类型是{@link 集合}且已参数化，则返回集合的元素类型。 
	 * 如果未对Collection进行参数化，则返回{@code  null}，指示未声明元素类型。 
	 *  
	 * @return 数组组件类型或Collection元素类型，如果此类型不是数组类型或{@code  java.util.Collection}或未参数化其元素类型，则为{@code  null} 
	 * @see  #elementTypeDescriptor（Object）
	 */
	@Nullable
	public TypeDescriptor getElementTypeDescriptor() {
		if (getResolvableType().isArray()) {
			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations());
		}
		if (Stream.class.isAssignableFrom(getType())) {
			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0));
		}
		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0));
	}

	/**
	 * If this type is a {@link Collection} or an array, creates a element TypeDescriptor
	 * from the provided collection or array element.
	 * <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class
	 * of the provided collection or array element. For example, if this describes a
	 * {@code java.util.List&lt;java.lang.Number&lt;} and the element argument is an
	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}.
	 * If this describes a {@code java.util.List&lt;?&gt;} and the element argument is an
	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}
	 * as well.
	 * <p>Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param element the collection or array element
	 * @return a element type descriptor, narrowed to the type of the provided element
	 * @see #getElementTypeDescriptor()
	 * @see #narrow(Object)
	 */
	/**
	 * 如果此类型是{@link 集合}或数组，请从提供的集合或数组元素中创建元素TypeDescriptor。 
	 *  <p>将{@link  #getElementTypeDescriptor（）elementType}属性缩小为提供的集合或数组元素的类。 
	 * 例如，如果它描述了一个{@code  java.util.List <java.lang.Number <}，并且元素参数是一个{@code  java.lang.Integer}，则返回的TypeDescriptor将是{@code  java.lang.Integer}。 
	 * 如果此描述为{@code  java.util.List <？>}并且element参数为{@code  java.lang.Integer}，则返回的TypeDescriptor将为{@code  java.lang。 
	 * 整数}。 
	 *  <p>注释和嵌套类型上下文将保留在返回的缩小的TypeDescriptor中。 
	 *  
	 * @param 元素集合或数组元素
	 * @return 元素类型描述符，缩小到所提供元素的类型
	 * @see  #getElementTypeDescriptor（）
	 * @see  #narrow（Object）
	 */
	@Nullable
	public TypeDescriptor elementTypeDescriptor(Object element) {
		return narrow(element, getElementTypeDescriptor());
	}

	/**
	 * Is this type a {@link Map} type?
	 */
	/**
	 * 此类型是{@link 地图}类型吗？
	 */
	public boolean isMap() {
		return Map.class.isAssignableFrom(getType());
	}

	/**
	 * If this type is a {@link Map} and its key type is parameterized,
	 * returns the map's key type. If the Map's key type is not parameterized,
	 * returns {@code null} indicating the key type is not declared.
	 * @return the Map key type, or {@code null} if this type is a Map
	 * but its key type is not parameterized
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 */
	/**
	 * 如果此类型是{@link  Map}，并且其键类型已参数化，则返回地图的键类型。 
	 * 如果未对Map的密钥类型进行参数化，则返回{@code  null}，指示未声明密钥类型。 
	 *  
	 * @return  Map密钥类型； 
	 * 如果此类型是Map，但没有参数化，则为{@code  null}； 
	 * 如果此类型不是{@code  java.util，则为
	 * @throws  IllegalStateException。 
	 * 地图}
	 */
	@Nullable
	public TypeDescriptor getMapKeyTypeDescriptor() {
		Assert.state(isMap(), "Not a [java.util.Map]");
		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0));
	}

	/**
	 * If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}
	 * from the provided map key.
	 * <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property
	 * to the class of the provided map key. For example, if this describes a
	 * {@code java.util.Map&lt;java.lang.Number, java.lang.String&lt;} and the key
	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}
	 * and the key argument is a {@code java.lang.Integer}, the returned
	 * TypeDescriptor will be {@code java.lang.Integer} as well.
	 * <p>Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param mapKey the map key
	 * @return the map key type descriptor
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 * @see #narrow(Object)
	 */
	/**
	 * 如果此类型是{@link  Map}，则从提供的地图密钥中创建mapKey {@link  TypeDescriptor}。 
	 *  <p>将{@link  #getMapKeyTypeDescriptor（）mapKeyType}属性缩小为提供的地图关键字的类。 
	 * 例如，如果它描述了一个{@code  java.util.Map <java.lang.Number，java.lang.String <}并且键参数是一个{@code  java.lang.Integer}，则返回的TypeDescriptor将为{@code  java.lang.Integer}。 
	 * 如果此描述为{@code  java.util.Map <?,？>}，并且关键参数为{@code  java.lang.Integer}，则返回的TypeDescriptor将为{@code  java。 
	 *  lang.Integer}。 
	 *  <p>注释和嵌套类型上下文将保留在返回的缩小的TypeDescriptor中。 
	 *  
	 * @param  mapKey映射键
	 * @return 映射键类型描述符
	 * @throws 如果此类型不是{@code  java.util.Map} 
	 * @see  #narrow（Object），则抛出IllegalStateException
	 */
	@Nullable
	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {
		return narrow(mapKey, getMapKeyTypeDescriptor());
	}

	/**
	 * If this type is a {@link Map} and its value type is parameterized,
	 * returns the map's value type.
	 * <p>If the Map's value type is not parameterized, returns {@code null}
	 * indicating the value type is not declared.
	 * @return the Map value type, or {@code null} if this type is a Map
	 * but its value type is not parameterized
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 */
	/**
	 * 如果此类型是{@link  Map}，并且其值类型已参数化，则返回图的值类型。 
	 *  <p>如果未参数化Map的值类型，则返回{@code  null}，指示未声明值类型。 
	 *  
	 * @return  Map值类型； 
	 * 如果此类型是Map，但没有参数化其值类型，则为{@code  null}。 
	 * 如果此类型不是{@code  java.util，则为
	 * @throws  IllegalStateException。 
	 * 地图}
	 */
	@Nullable
	public TypeDescriptor getMapValueTypeDescriptor() {
		Assert.state(isMap(), "Not a [java.util.Map]");
		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1));
	}

	/**
	 * If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}
	 * from the provided map value.
	 * <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property
	 * to the class of the provided map value. For example, if this describes a
	 * {@code java.util.Map&lt;java.lang.String, java.lang.Number&lt;} and the value
	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be
	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}
	 * and the value argument is a {@code java.lang.Integer}, the returned
	 * TypeDescriptor will be {@code java.lang.Integer} as well.
	 * <p>Annotation and nested type context will be preserved in the narrowed
	 * TypeDescriptor that is returned.
	 * @param mapValue the map value
	 * @return the map value type descriptor
	 * @throws IllegalStateException if this type is not a {@code java.util.Map}
	 * @see #narrow(Object)
	 */
	/**
	 * 如果此类型是{@link  Map}，则从提供的地图值中创建mapValue {@link  TypeDescriptor}。 
	 *  <p>将{@link  #getMapValueTypeDescriptor（）mapValueType}属性缩小为提供的地图值的类。 
	 * 例如，如果它描述了一个{@code  java.util.Map <java.lang.String，java.lang.Number <}并且value参数是一个{@code  java.lang.Integer}，则返回的TypeDescriptor将为{@code  java.lang.Integer}。 
	 * 如果此描述为{@code  java.util.Map <?,？>}，并且value参数为{@code  java.lang.Integer}，则返回的TypeDescriptor将为{@code  java。 
	 *  lang.Integer}。 
	 *  <p>注释和嵌套类型上下文将保留在返回的缩小的TypeDescriptor中。 
	 *  
	 * @param  mapValue地图值
	 * @return 地图值类型描述符
	 * @throws 如果此类型不是{@code  java.util.Map} 
	 * @see  #narrow（Object），则抛出IllegalStateException
	 */
	@Nullable
	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {
		return narrow(mapValue, getMapValueTypeDescriptor());
	}

	@Nullable
	private TypeDescriptor narrow(@Nullable Object value, @Nullable TypeDescriptor typeDescriptor) {
		if (typeDescriptor != null) {
			return typeDescriptor.narrow(value);
		}
		if (value != null) {
			return narrow(value);
		}
		return null;
	}

	@Override
	public boolean equals(@Nullable Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof TypeDescriptor)) {
			return false;
		}
		TypeDescriptor otherDesc = (TypeDescriptor) other;
		if (getType() != otherDesc.getType()) {
			return false;
		}
		if (!annotationsMatch(otherDesc)) {
			return false;
		}
		if (isCollection() || isArray()) {
			return ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), otherDesc.getElementTypeDescriptor());
		}
		else if (isMap()) {
			return (ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), otherDesc.getMapKeyTypeDescriptor()) &&
					ObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), otherDesc.getMapValueTypeDescriptor()));
		}
		else {
			return true;
		}
	}

	private boolean annotationsMatch(TypeDescriptor otherDesc) {
		Annotation[] anns = getAnnotations();
		Annotation[] otherAnns = otherDesc.getAnnotations();
		if (anns == otherAnns) {
			return true;
		}
		if (anns.length != otherAnns.length) {
			return false;
		}
		if (anns.length > 0) {
			for (int i = 0; i < anns.length; i++) {
				if (!annotationEquals(anns[i], otherAnns[i])) {
					return false;
				}
			}
		}
		return true;
	}

	private boolean annotationEquals(Annotation ann, Annotation otherAnn) {
		// Annotation.equals is reflective and pretty slow, so let's check identity and proxy type first.
		return (ann == otherAnn || (ann.getClass() == otherAnn.getClass() && ann.equals(otherAnn)));
	}

	@Override
	public int hashCode() {
		return getType().hashCode();
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		for (Annotation ann : getAnnotations()) {
			builder.append("@").append(ann.annotationType().getName()).append(' ');
		}
		builder.append(getResolvableType().toString());
		return builder.toString();
	}


	/**
	 * Create a new type descriptor for an object.
	 * <p>Use this factory method to introspect a source object before asking the
	 * conversion system to convert it to some another type.
	 * <p>If the provided object is {@code null}, returns {@code null}, else calls
	 * {@link #valueOf(Class)} to build a TypeDescriptor from the object's class.
	 * @param source the source object
	 * @return the type descriptor
	 */
	/**
	 * 为对象创建一个新的类型描述符。 
	 *  <p>在要求转换系统将源对象转换为其他类型之前，请使用此工厂方法对源对象进行内部检查。 
	 *  <p>如果提供的对象为{@code  null}，则返回{@code  null}，否则调用{@link  #valueOf（Class）}从该对象的类构建TypeDescriptor。 
	 *  
	 * @param 源源对象
	 * @return 类型描述符
	 */
	@Nullable
	public static TypeDescriptor forObject(@Nullable Object source) {
		return (source != null ? valueOf(source.getClass()) : null);
	}

	/**
	 * Create a new type descriptor from the given type.
	 * <p>Use this to instruct the conversion system to convert an object to a
	 * specific target type, when no type location such as a method parameter or
	 * field is available to provide additional conversion context.
	 * <p>Generally prefer use of {@link #forObject(Object)} for constructing type
	 * descriptors from source objects, as it handles the {@code null} object case.
	 * @param type the class (may be {@code null} to indicate {@code Object.class})
	 * @return the corresponding type descriptor
	 */
	/**
	 * 从给定类型创建一个新的类型描述符。 
	 *  <p>当没有类型位置（例如方法参数或字段）可用于提供其他转换上下文时，使用此命令指示转换系统将对象转换为特定的目标类型。 
	 *  <p>通常更喜欢使用{@link  #forObject（Object）}从源对象构造类型描述符，因为它处理{@code  null}对象的情况。 
	 *  
	 * @param 键入类（可以为{@code  null}表示{@code  Object.class}）
	 * @return 相应的类型描述符
	 */
	public static TypeDescriptor valueOf(@Nullable Class<?> type) {
		if (type == null) {
			type = Object.class;
		}
		TypeDescriptor desc = commonTypesCache.get(type);
		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null));
	}

	/**
	 * Create a new type descriptor from a {@link java.util.Collection} type.
	 * <p>Useful for converting to typed Collections.
	 * <p>For example, a {@code List<String>} could be converted to a
	 * {@code List<EmailAddress>} by converting to a targetType built with this method.
	 * The method call to construct such a {@code TypeDescriptor} would look something
	 * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}
	 * @param collectionType the collection type, which must implement {@link Collection}.
	 * @param elementTypeDescriptor a descriptor for the collection's element type,
	 * used to convert collection elements
	 * @return the collection type descriptor
	 */
	/**
	 * 从{@link  java.util.Collection}类型创建一个新的类型描述符。 
	 *  <p>对于转换为类型化的集合很有用。 
	 *  <p>例如，可以通过将{@code  List <String>}转换为使用此方法构建的targetType来转换为{@code  List <EmailAddress>}。 
	 * 构造这样的{@code  TypeDescriptor}的方法调用类似于：{@code  collection（List.class，TypeDescriptor.valueOf（EmailAddress.class））;} 
	 * @param  collectionType集合类型，必须实现{@link 集合}。 
	 *  
	 * @param  elementTypeDescriptor集合元素类型的描述符，用于转换集合元素
	 * @return 集合类型描述符
	 */
	public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {
		Assert.notNull(collectionType, "Collection type must not be null");
		if (!Collection.class.isAssignableFrom(collectionType)) {
			throw new IllegalArgumentException("Collection type must be a [java.util.Collection]");
		}
		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);
		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);
	}

	/**
	 * Create a new type descriptor from a {@link java.util.Map} type.
	 * <p>Useful for converting to typed Maps.
	 * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;
	 * by converting to a targetType built with this method:
	 * The method call to construct such a TypeDescriptor would look something like:
	 * <pre class="code">
	 * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));
	 * </pre>
	 * @param mapType the map type, which must implement {@link Map}
	 * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys
	 * @param valueTypeDescriptor the map's value type, used to convert map values
	 * @return the map type descriptor
	 */
	/**
	 * 从{@link  java.util.Map}类型创建一个新的类型描述符。 
	 *  <p>对于转换为键入的地图很有用。 
	 *  <p>例如，可以通过将Map <String，String>转换为使用此方法构建的targetType来转换为Map <Id，EmailAddress>：构造此类TypeDescriptor的方法调用类似于：<pre class ="code"> map（Map.class，TypeDescriptor.valueOf（Id.class），TypeDescriptor.valueOf（EmailAddress.class））; </ pre> 
	 * @param  mapType地图类型，该类型必须实现{@link  Map} 
	 * @param  keyTypeDescriptor该地图键类型的描述符，用于转换地图键
	 * @param  valueTypeDescriptor地图的值类型，用于转换地图值
	 * @return 地图类型描述符
	 */
	public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,
			@Nullable TypeDescriptor valueTypeDescriptor) {

		Assert.notNull(mapType, "Map type must not be null");
		if (!Map.class.isAssignableFrom(mapType)) {
			throw new IllegalArgumentException("Map type must be a [java.util.Map]");
		}
		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);
		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);
		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);
	}

	/**
	 * Create a new type descriptor as an array of the specified type.
	 * <p>For example to create a {@code Map<String,String>[]} use:
	 * <pre class="code">
	 * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));
	 * </pre>
	 * @param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}
	 * @return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}
	 * @since 3.2.1
	 */
	/**
	 * 创建一个新的类型描述符作为指定类型的数组。 
	 *  <p>例如，要创建{@code  Map <String，String> []}，请使用：<pre class ="code"> TypeDescriptor.array（TypeDescriptor.map（Map.class，TypeDescriptor.value（String。 
	 *  class），TypeDescriptor.value（String.class）））; </ pre> 
	 * @param  elementTypeDescriptor或数组元素的{@link  TypeDescriptor}或{@code  null} 
	 * @return 数组{@link  TypeDescriptor}或{@code  null}如果{@code  elementTypeDescriptor}为{@code  null} @3.2.1起
	 */
	@Nullable
	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {
		if (elementTypeDescriptor == null) {
			return null;
		}
		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),
				null, elementTypeDescriptor.getAnnotations());
	}

	/**
	 * Create a type descriptor for a nested type declared within the method parameter.
	 * <p>For example, if the methodParameter is a {@code List<String>} and the
	 * nesting level is 1, the nested type descriptor will be String.class.
	 * <p>If the methodParameter is a {@code List<List<String>>} and the nesting
	 * level is 2, the nested type descriptor will also be a String.class.
	 * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting
	 * level is 1, the nested type descriptor will be String, derived from the map value.
	 * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the
	 * nesting level is 2, the nested type descriptor will be String, derived from the map value.
	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.
	 * For example, if the method parameter is a {@code List<?>}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param methodParameter the method parameter with a nestingLevel of 1
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the method parameter
	 * @return the nested type descriptor at the specified nesting level,
	 * or {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the nesting level of the input
	 * {@link MethodParameter} argument is not 1, or if the types up to the
	 * specified nesting level are not of collection, array, or map types
	 */
	/**
	 * 为在method参数中声明的嵌套类型创建类型描述符。 
	 *  <p>例如，如果methodParameter是{@code  List <String>}，并且嵌套级别是1，则嵌套类型描述符将是String.class。 
	 *  <p>如果methodParameter是{@code  List <List <String >>}，并且嵌套级别是2，则嵌套类型描述符也将是String.class。 
	 *  <p>如果methodParameter是{@code  Map <Integer，String>}并且嵌套级别是1，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果methodParameter是{@code  List <Map <Integer，String >>}，并且嵌套级别是2，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果由于未声明嵌套类型而无法获得嵌套类型，则返回{@code  null}。 
	 * 例如，如果方法参数为{@code  List <？>}，则返回的嵌套类型描述符将为{@code  null}。 
	 *  
	 * @param  methodParameter nestingLevel为1的方法参数
	 * @param  nestingLevel方法参数内的collection / array元素或映射键/值声明的嵌套级别
	 * @return 指定嵌套级别的嵌套类型描述符，或{{@@code> null}，如果无法获取它，则
	 * @throws  IllegalArgumentException如果输入{@link  MethodParameter}参数的嵌套级别不为1，或者指定嵌套级别以下的类型为：不属于集合，数组或地图类型
	 */
	@Nullable
	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {
		if (methodParameter.getNestingLevel() != 1) {
			throw new IllegalArgumentException("MethodParameter nesting level must be 1: " +
					"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal");
		}
		return nested(new TypeDescriptor(methodParameter), nestingLevel);
	}

	/**
	 * Create a type descriptor for a nested type declared within the field.
	 * <p>For example, if the field is a {@code List<String>} and the nesting
	 * level is 1, the nested type descriptor will be {@code String.class}.
	 * <p>If the field is a {@code List<List<String>>} and the nesting level is
	 * 2, the nested type descriptor will also be a {@code String.class}.
	 * <p>If the field is a {@code Map<Integer, String>} and the nesting level
	 * is 1, the nested type descriptor will be String, derived from the map value.
	 * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting
	 * level is 2, the nested type descriptor will be String, derived from the map value.
	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not
	 * declared. For example, if the field is a {@code List<?>}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param field the field
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the field
	 * @return the nested type descriptor at the specified nesting level,
	 * or {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the types up to the specified nesting
	 * level are not of collection, array, or map types
	 */
	/**
	 * 为字段中声明的嵌套类型创建类型描述符。 
	 *  <p>例如，如果该字段为{@code  List <String>}，并且嵌套级别为1，则嵌套类型描述符将为{@code  String.class}。 
	 *  <p>如果该字段是{@code  List <List <String >>}，并且嵌套级别是2，则嵌套类型描述符也将是{@code  String.class}。 
	 *  <p>如果该字段是{@code  Map <Integer，String>}，并且嵌套级别是1，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果该字段是{@code  List <Map <Integer，String >>}，并且嵌套级别是2，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果由于未声明嵌套类型而无法获得嵌套类型，则返回{@code  null}。 
	 * 例如，如果该字段是{@code  List <？>}，则返回的嵌套类型描述符将为{@code  null}。 
	 *  
	 * @param 字段
	 * @param  nestingLevel字段中的集合/数组元素的嵌套级别或映射键/值声明
	 * @return 指定嵌套级别的嵌套类型描述符，或{@code 如果无法获得
	 * @throws  IllegalArgumentException，如果指定嵌套级别以下的类型不是集合，数组或映射类型
	 */
	@Nullable
	public static TypeDescriptor nested(Field field, int nestingLevel) {
		return nested(new TypeDescriptor(field), nestingLevel);
	}

	/**
	 * Create a type descriptor for a nested type declared within the property.
	 * <p>For example, if the property is a {@code List<String>} and the nesting
	 * level is 1, the nested type descriptor will be {@code String.class}.
	 * <p>If the property is a {@code List<List<String>>} and the nesting level
	 * is 2, the nested type descriptor will also be a {@code String.class}.
	 * <p>If the property is a {@code Map<Integer, String>} and the nesting level
	 * is 1, the nested type descriptor will be String, derived from the map value.
	 * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting
	 * level is 2, the nested type descriptor will be String, derived from the map value.
	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not
	 * declared. For example, if the property is a {@code List<?>}, the nested type
	 * descriptor returned will be {@code null}.
	 * @param property the property
	 * @param nestingLevel the nesting level of the collection/array element or
	 * map key/value declaration within the property
	 * @return the nested type descriptor at the specified nesting level, or
	 * {@code null} if it could not be obtained
	 * @throws IllegalArgumentException if the types up to the specified nesting
	 * level are not of collection, array, or map types
	 */
	/**
	 * 为在属性中声明的嵌套类型创建类型描述符。 
	 *  <p>例如，如果属性为{@code  List <String>}，并且嵌套级别为1，则嵌套类型描述符将为{@code  String.class}。 
	 *  <p>如果属性为{@code  List <List <String >>}，并且嵌套级别为2，则嵌套类型描述符也将为{@code  String.class}。 
	 *  <p>如果属性是{@code  Map <Integer，String>}，并且嵌套级别是1，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果属性是{@code  List <Map <Integer，String >>}，并且嵌套级别是2，则嵌套类型描述符将是String，它是从映射值派生的。 
	 *  <p>如果由于未声明嵌套类型而无法获得嵌套类型，则返回{@code  null}。 
	 * 例如，如果属性为{@code  List <？>}，则返回的嵌套类型描述符将为{@code  null}。 
	 *  
	 * @param 属性的属性
	 * @param  nestingLevel在指定嵌套级别的属性
	 * @return 嵌套类型描述符中，集合/数组元素的嵌套级别或映射键/值声明的嵌套级别，或{@code 如果无法获得
	 * @throws  IllegalArgumentException，如果指定嵌套级别以下的类型不是集合，数组或映射类型
	 */
	@Nullable
	public static TypeDescriptor nested(Property property, int nestingLevel) {
		return nested(new TypeDescriptor(property), nestingLevel);
	}

	@Nullable
	private static TypeDescriptor nested(TypeDescriptor typeDescriptor, int nestingLevel) {
		ResolvableType nested = typeDescriptor.resolvableType;
		for (int i = 0; i < nestingLevel; i++) {
			if (Object.class == nested.getType()) {
				// Could be a collection type but we don't know about its element type,
				// so let's just assume there is an element type of type Object...
			}
			else {
				nested = nested.getNested(2);
			}
		}
		if (nested == ResolvableType.NONE) {
			return null;
		}
		return getRelatedIfResolvable(typeDescriptor, nested);
	}

	@Nullable
	private static TypeDescriptor getRelatedIfResolvable(TypeDescriptor source, ResolvableType type) {
		if (type.resolve() == null) {
			return null;
		}
		return new TypeDescriptor(type, null, source.getAnnotations());
	}


	/**
	 * Adapter class for exposing a {@code TypeDescriptor}'s annotations as an
	 * {@link AnnotatedElement}, in particular to {@link AnnotatedElementUtils}.
	 * @see AnnotatedElementUtils#isAnnotated(AnnotatedElement, Class)
	 * @see AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement, Class)
	 */
	/**
	 * 适配器类，用于将{@code  TypeDescriptor}的注释公开为{@link  AnnotatedElement}，尤其是向{@link  AnnotatedElementUtils}公开。 
	 *  
	 * @see  AnnotatedElementUtils＃isAnnotated（AnnotatedElement，类）
	 * @see  AnnotatedElementUtils＃getMergedAnnotation（AnnotatedElement，类）
	 */
	private class AnnotatedElementAdapter implements AnnotatedElement, Serializable {

		@Nullable
		private final Annotation[] annotations;

		public AnnotatedElementAdapter(@Nullable Annotation[] annotations) {
			this.annotations = annotations;
		}

		@Override
		public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
			for (Annotation annotation : getAnnotations()) {
				if (annotation.annotationType() == annotationClass) {
					return true;
				}
			}
			return false;
		}

		@Override
		@Nullable
		@SuppressWarnings("unchecked")
		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
			for (Annotation annotation : getAnnotations()) {
				if (annotation.annotationType() == annotationClass) {
					return (T) annotation;
				}
			}
			return null;
		}

		@Override
		public Annotation[] getAnnotations() {
			return (this.annotations != null ? this.annotations.clone() : EMPTY_ANNOTATION_ARRAY);
		}

		@Override
		public Annotation[] getDeclaredAnnotations() {
			return getAnnotations();
		}

		public boolean isEmpty() {
			return ObjectUtils.isEmpty(this.annotations);
		}

		@Override
		public boolean equals(@Nullable Object other) {
			return (this == other || (other instanceof AnnotatedElementAdapter &&
					Arrays.equals(this.annotations, ((AnnotatedElementAdapter) other).annotations)));
		}

		@Override
		public int hashCode() {
			return Arrays.hashCode(this.annotations);
		}

		@Override
		public String toString() {
			return TypeDescriptor.this.toString();
		}
	}

}
