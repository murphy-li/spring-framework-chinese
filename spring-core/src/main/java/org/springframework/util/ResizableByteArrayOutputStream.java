/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2015的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.util;

import java.io.ByteArrayOutputStream;

/**
 * An extension of {@link java.io.ByteArrayOutputStream} that:
 * <ul>
 * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}
 * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods
 * to get more control over the size of the internal buffer</li>
 * <li>has a higher initial capacity (256) by default</li>
 * </ul>
 *
 * <p>As of 4.2, this class has been superseded by {@link FastByteArrayOutputStream}
 * for Spring's internal use where no assignability to {@link ByteArrayOutputStream}
 * is needed (since {@link FastByteArrayOutputStream} is more efficient with buffer
 * resize management but doesn't extend the standard {@link ByteArrayOutputStream}).
 *
 * @author Brian Clozel
 * @author Juergen Hoeller
 * @since 4.0.3
 * @see #resize
 * @see FastByteArrayOutputStream
 */
/**
 * {@link  java.io.ByteArrayOutputStream}的扩展，它：<ul> <li>具有公共{@link  org.springframework.util.ResizableByteArrayArrayStreamStream＃grow（int）}和{@link  org。 
 *  springframework.util.ResizableByteArrayOutputStream＃resize（int）}方法可更好地控制内部缓冲区的大小</ li> <li>默认情况下具有较高的初始容量（256）</ li> </ ul> <p >从4.2版本开始，该类已由{@link  FastByteArrayOutputStream}取代，供Spring内部使用，无需为{@link  ByteArrayOutputStream}分配权限（因为{@link  FastByteArrayOutputStream}可以更有效地调整缓冲区大小管理，但不扩展标准的{@link  ByteArrayOutputStream}）。 
 *  @author 布赖恩·克洛泽尔​​（Brian Clozel）@author 尤尔根·霍勒（Juergen Hoeller）@自4.0.3起
 * @see  #resize 
 * @see  FastByteArrayOutputStream
 */
public class ResizableByteArrayOutputStream extends ByteArrayOutputStream {

	private static final int DEFAULT_INITIAL_CAPACITY = 256;


	/**
	 * Create a new <code>ResizableByteArrayOutputStream</code>
	 * with the default initial capacity of 256 bytes.
	 */
	/**
	 * 创建一个新的<code> ResizableByteArrayOutputStream </ code>，其默认初始容量为256个字节。 
	 * 
	 */
	public ResizableByteArrayOutputStream() {
		super(DEFAULT_INITIAL_CAPACITY);
	}

	/**
	 * Create a new <code>ResizableByteArrayOutputStream</code>
	 * with the specified initial capacity.
	 * @param initialCapacity the initial buffer size in bytes
	 */
	/**
	 * 使用指定的初始容量创建一个新的<code> ResizableByteArrayOutputStream </ code>。 
	 *  
	 * @param  initialCapacity初始缓冲区大小（以字节为单位）
	 */
	public ResizableByteArrayOutputStream(int initialCapacity) {
		super(initialCapacity);
	}


	/**
	 * Resize the internal buffer size to a specified capacity.
	 * @param targetCapacity the desired size of the buffer
	 * @throws IllegalArgumentException if the given capacity is smaller than
	 * the actual size of the content stored in the buffer already
	 * @see ResizableByteArrayOutputStream#size()
	 */
	/**
	 * 将内部缓冲区的大小调整为指定的容量。 
	 *  
	 * @param  targetCapacity缓冲区的所需大小
	 * @throws  IllegalArgumentException如果给定的容量小于已存储在缓冲区中的内容的实际大小
	 * @see  ResizableByteArrayOutputStream＃size（）
	 */
	public synchronized void resize(int targetCapacity) {
		Assert.isTrue(targetCapacity >= this.count, "New capacity must not be smaller than current size");
		byte[] resizedBuffer = new byte[targetCapacity];
		System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);
		this.buf = resizedBuffer;
	}

	/**
	 * Grow the internal buffer size.
	 * @param additionalCapacity the number of bytes to add to the current buffer size
	 * @see ResizableByteArrayOutputStream#size()
	 */
	/**
	 * 增大内部缓冲区的大小。 
	 *  
	 * @param  AdditionalCapacity要添加到当前缓冲区大小的字节数
	 * @see  ResizableByteArrayOutputStream＃size（）
	 */
	public synchronized void grow(int additionalCapacity) {
		Assert.isTrue(additionalCapacity >= 0, "Additional capacity must be 0 or higher");
		if (this.count + additionalCapacity > this.buf.length) {
			int newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);
			resize(newCapacity);
		}
	}

	/**
	 * Return the current size of this stream's internal buffer.
	 */
	/**
	 * 返回此流的内部缓冲区的当前大小。 
	 * 
	 */
	public synchronized int capacity() {
		return this.buf.length;
	}

}
