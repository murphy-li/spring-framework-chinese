/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.util.unit;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * A data size, such as '12MB'.
 *
 * <p>This class models data size in terms of bytes and is immutable and thread-safe.
 *
 * <p>The terms and units used in this class are based on
 * <a href="https://en.wikipedia.org/wiki/Binary_prefix">binary prefixes</a>
 * indicating multiplication by powers of 2. Consult the following table and
 * the Javadoc for {@link DataUnit} for details.
 *
 * <p>
 * <table border="1">
 * <tr><th>Term</th><th>Data Size</th><th>Size in Bytes</th></tr>
 * <tr><td>byte</td><td>1B</td><td>1</td></tr>
 * <tr><td>kilobyte</td><td>1KB</td><td>1,024</td></tr>
 * <tr><td>megabyte</td><td>1MB</td><td>1,048,576</td></tr>
 * <tr><td>gigabyte</td><td>1GB</td><td>1,073,741,824</td></tr>
 * <tr><td>terabyte</td><td>1TB</td><td>1,099,511,627,776</td></tr>
 * </table>
 *
 * @author Stephane Nicoll
 * @author Sam Brannen
 * @since 5.1
 * @see DataUnit
 */
/**
 * 数据大小，例如"12MB"。 
 *  <p>此类以字节为单位对数据大小进行建模，并且是不可变的并且是线程安全的。 
 *  <p>该类中使用的术语和单位基于<a href="https://en.wikipedia.org/wiki/Binary_prefix">二进制前缀</a>，表示乘以2的幂。 
 * 请咨询以下内容表和{@link  DataUnit}的Javadoc了解详细信息。 
 *  <p> <table border ="1"> <tr> <th> Term </ th> <th>数据大小</ th> <th>大小（以字节为单位）</ th> </ tr> <tr> <td > byte </ td> <td> 1B </ td> <td> 1 </ td> </ tr> <tr> <td>千字节</ td> <td> 1KB </ td> <td> 1,024 < / td> </ tr> <tr> <td>兆字节</ td> <td> 1MB </ td> <td> 1,048,576 </ td> </ tr> <tr> <td>千兆字节</ td> < td> 1GB </ td> <td> 1,073,741,824 </ td> </ tr> <tr> <td> TB </ table> @author  Stephane Nicoll @author  Sam Brannen @从5.1开始
 * @see  DataUnit
 */
public final class DataSize implements Comparable<DataSize> {

	/**
	 * The pattern for parsing.
	 */
	/**
	 * 解析模式。 
	 * 
	 */
	private static final Pattern PATTERN = Pattern.compile("^([+\\-]?\\d+)([a-zA-Z]{0,2})$");

	/**
	 * Bytes per Kilobyte.
	 */
	/**
	 * 每千字节字节。 
	 * 
	 */
	private static final long BYTES_PER_KB = 1024;

	/**
	 * Bytes per Megabyte.
	 */
	/**
	 * 每兆字节字节。 
	 * 
	 */
	private static final long BYTES_PER_MB = BYTES_PER_KB * 1024;

	/**
	 * Bytes per Gigabyte.
	 */
	/**
	 * 每千兆字节字节。 
	 * 
	 */
	private static final long BYTES_PER_GB = BYTES_PER_MB * 1024;

	/**
	 * Bytes per Terabyte.
	 */
	/**
	 * 每太字节字节。 
	 * 
	 */
	private static final long BYTES_PER_TB = BYTES_PER_GB * 1024;


	private final long bytes;


	private DataSize(long bytes) {
		this.bytes = bytes;
	}


	/**
	 * Obtain a {@link DataSize} representing the specified number of bytes.
	 * @param bytes the number of bytes, positive or negative
	 * @return a {@link DataSize}
	 */
	/**
	 * 获取一个{@link  DataSize}，它表示指定的字节数。 
	 *  
	 * @param 个字节字节数，正数或负数
	 * @return  a {@link  DataSize}
	 */
	public static DataSize ofBytes(long bytes) {
		return new DataSize(bytes);
	}

	/**
	 * Obtain a {@link DataSize} representing the specified number of kilobytes.
	 * @param kilobytes the number of kilobytes, positive or negative
	 * @return a {@link DataSize}
	 */
	/**
	 * 获取一个表示指定千字节数的{@link  DataSize}。 
	 *  
	 * @param  KB千字节数，正数或负数
	 * @return  a {@link  DataSize}
	 */
	public static DataSize ofKilobytes(long kilobytes) {
		return new DataSize(Math.multiplyExact(kilobytes, BYTES_PER_KB));
	}

	/**
	 * Obtain a {@link DataSize} representing the specified number of megabytes.
	 * @param megabytes the number of megabytes, positive or negative
	 * @return a {@link DataSize}
	 */
	/**
	 * 获取一个{@link  DataSize}，它表示指定的兆字节数。 
	 *  
	 * @param 兆字节正或负的兆字节数
	 * @return  a {@link  DataSize}
	 */
	public static DataSize ofMegabytes(long megabytes) {
		return new DataSize(Math.multiplyExact(megabytes, BYTES_PER_MB));
	}

	/**
	 * Obtain a {@link DataSize} representing the specified number of gigabytes.
	 * @param gigabytes the number of gigabytes, positive or negative
	 * @return a {@link DataSize}
	 */
	/**
	 * 获取一个{@link  DataSize}，它表示指定的千兆字节数。 
	 *  
	 * @param  gigabytes的数量，正数或负数
	 * @return  a {@link  DataSize}
	 */
	public static DataSize ofGigabytes(long gigabytes) {
		return new DataSize(Math.multiplyExact(gigabytes, BYTES_PER_GB));
	}

	/**
	 * Obtain a {@link DataSize} representing the specified number of terabytes.
	 * @param terabytes the number of terabytes, positive or negative
	 * @return a {@link DataSize}
	 */
	/**
	 * 获取表示指定的TB数量的{@link  DataSize}。 
	 *  
	 * @param 兆字节TB的数量，正数或负数
	 * @return  a {@link  DataSize}
	 */
	public static DataSize ofTerabytes(long terabytes) {
		return new DataSize(Math.multiplyExact(terabytes, BYTES_PER_TB));
	}

	/**
	 * Obtain a {@link DataSize} representing an amount in the specified {@link DataUnit}.
	 * @param amount the amount of the size, measured in terms of the unit,
	 * positive or negative
	 * @return a corresponding {@link DataSize}
	 */
	/**
	 * 获取表示指定的{@link  DataUnit}中的金额的{@link  DataSize}。 
	 *  
	 * @param 金额大小的大小，以单位为正或负
	 * @return 相应的{@link  DataSize}
	 */
	public static DataSize of(long amount, DataUnit unit) {
		Assert.notNull(unit, "Unit must not be null");
		return new DataSize(Math.multiplyExact(amount, unit.size().toBytes()));
	}

	/**
	 * Obtain a {@link DataSize} from a text string such as {@code 12MB} using
	 * {@link DataUnit#BYTES} if no unit is specified.
	 * <p>
	 * Examples:
	 * <pre>
	 * "12KB" -- parses as "12 kilobytes"
	 * "5MB"  -- parses as "5 megabytes"
	 * "20"   -- parses as "20 bytes"
	 * </pre>
	 * @param text the text to parse
	 * @return the parsed {@link DataSize}
	 * @see #parse(CharSequence, DataUnit)
	 */
	/**
	 * 如果未指定单位，请使用{@link  DataUnit＃BYTES}从文本字符串（例如{@code  12MB}）获取{@link  DataSize}。 
	 *  <p>示例：<pre>"12KB"-解析为"12兆字节""5MB"-解析为"5兆字节""20"-解析为"20字节"</ pre> 
	 * @param 文本要解析的文本
	 * @return 已解析的{@link  DataSize} 
	 * @see  #parse（CharSequence，DataUnit）
	 */
	public static DataSize parse(CharSequence text) {
		return parse(text, null);
	}

	/**
	 * Obtain a {@link DataSize} from a text string such as {@code 12MB} using
	 * the specified default {@link DataUnit} if no unit is specified.
	 * <p>
	 * The string starts with a number followed optionally by a unit matching one of the
	 * supported {@linkplain DataUnit suffixes}.
	 * <p>
	 * Examples:
	 * <pre>
	 * "12KB" -- parses as "12 kilobytes"
	 * "5MB"  -- parses as "5 megabytes"
	 * "20"   -- parses as "20 kilobytes" (where the {@code defaultUnit} is {@link DataUnit#KILOBYTES})
	 * </pre>
	 * @param text the text to parse
	 * @return the parsed {@link DataSize}
	 */
	/**
	 * 如果未指定单位，则使用指定的默认{@link  DataUnit}从文本字符串（例如{@code  12MB}）获取{@link  DataSize}。 
	 *  <p>字符串以数字开头，并可选地跟与支持的{@link  plain DataUnit后缀}之一匹配的单元。 
	 *  <p>示例：<pre>"12KB"-解析为"12兆字节""5MB"-解析为"5兆字节""20"-解析为"20 KB"（其中{@code  defaultUnit }是{@link  DataUnit＃KILOBYTES}）</ pre> 
	 * @param 将要解析的文本文本化为
	 * @return 所解析的{@link  DataSize}
	 */
	public static DataSize parse(CharSequence text, @Nullable DataUnit defaultUnit) {
		Assert.notNull(text, "Text must not be null");
		try {
			Matcher matcher = PATTERN.matcher(text);
			Assert.state(matcher.matches(), "Does not match data size pattern");
			DataUnit unit = determineDataUnit(matcher.group(2), defaultUnit);
			long amount = Long.parseLong(matcher.group(1));
			return DataSize.of(amount, unit);
		}
		catch (Exception ex) {
			throw new IllegalArgumentException("'" + text + "' is not a valid data size", ex);
		}
	}

	private static DataUnit determineDataUnit(String suffix, @Nullable DataUnit defaultUnit) {
		DataUnit defaultUnitToUse = (defaultUnit != null ? defaultUnit : DataUnit.BYTES);
		return (StringUtils.hasLength(suffix) ? DataUnit.fromSuffix(suffix) : defaultUnitToUse);
	}

	/**
	 * Checks if this size is negative, excluding zero.
	 * @return true if this size has a size less than zero bytes
	 */
	/**
	 * 检查此大小是否为负数（不包括零）。 
	 *  
	 * @return 如果此大小的大小小于零字节，则为true
	 */
	public boolean isNegative() {
		return this.bytes < 0;
	}

	/**
	 * Return the number of bytes in this instance.
	 * @return the number of bytes
	 */
	/**
	 * 返回此实例中的字节数。 
	 *  
	 * @return 字节数
	 */
	public long toBytes() {
		return this.bytes;
	}

	/**
	 * Return the number of kilobytes in this instance.
	 * @return the number of kilobytes
	 */
	/**
	 * 返回此实例中的千字节数。 
	 *  
	 * @return 千字节数
	 */
	public long toKilobytes() {
		return this.bytes / BYTES_PER_KB;
	}

	/**
	 * Return the number of megabytes in this instance.
	 * @return the number of megabytes
	 */
	/**
	 * 返回此实例中的兆字节数。 
	 *  
	 * @return 兆字节数
	 */
	public long toMegabytes() {
		return this.bytes / BYTES_PER_MB;
	}

	/**
	 * Return the number of gigabytes in this instance.
	 * @return the number of gigabytes
	 */
	/**
	 * 返回此实例中的千兆字节数。 
	 *  
	 * @return 千兆字节数
	 */
	public long toGigabytes() {
		return this.bytes / BYTES_PER_GB;
	}

	/**
	 * Return the number of terabytes in this instance.
	 * @return the number of terabytes
	 */
	/**
	 * 返回此实例中的TB数。 
	 *  
	 * @return 兆字节数
	 */
	public long toTerabytes() {
		return this.bytes / BYTES_PER_TB;
	}

	@Override
	public int compareTo(DataSize other) {
		return Long.compare(this.bytes, other.bytes);
	}

	@Override
	public String toString() {
		return String.format("%dB", this.bytes);
	}


	@Override
	public boolean equals(@Nullable Object other) {
		if (this == other) {
			return true;
		}
		if (other == null || getClass() != other.getClass()) {
			return false;
		}
		DataSize otherSize = (DataSize) other;
		return (this.bytes == otherSize.bytes);
	}

	@Override
	public int hashCode() {
		return Long.hashCode(this.bytes);
	}

}
