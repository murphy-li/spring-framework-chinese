/** Generated by english-annotation-buster, Powered by Google Translate.**/
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.

package org.springframework.asm;

/**
 * The path to a type argument, wildcard bound, array element type, or static inner type within an
 * enclosing type.
 *
 * @author Eric Bruneton
 */
/**
 * 类型参数，通配符绑定，数组元素类型或封闭类型内的静态内部类型的路径。 
 *  @author 埃里克·布鲁内顿
 */
public final class TypePath {

  /** A type path step that steps into the element type of an array type. See {@link #getStep}. */
  /**
   * 类型路径步骤，它逐步进入数组类型的元素类型。 
   * 请参阅{@link  #getStep}。 
   * 
   */
  public static final int ARRAY_ELEMENT = 0;

  /** A type path step that steps into the nested type of a class type. See {@link #getStep}. */
  /**
   * 类型路径步骤，它进入类类型的嵌套类型。 
   * 请参阅{@link  #getStep}。 
   * 
   */
  public static final int INNER_TYPE = 1;

  /** A type path step that steps into the bound of a wildcard type. See {@link #getStep}. */
  /**
   * 进入通配符类型界限的类型路径步骤。 
   * 请参阅{@link  #getStep}。 
   * 
   */
  public static final int WILDCARD_BOUND = 2;

  /** A type path step that steps into a type argument of a generic type. See {@link #getStep}. */
  /**
   * 进入通用类型的类型参数的类型路径步骤。 
   * 请参阅{@link  #getStep}。 
   * 
   */
  public static final int TYPE_ARGUMENT = 3;

  /**
   * The byte array where the 'type_path' structure - as defined in the Java Virtual Machine
   * Specification (JVMS) - corresponding to this TypePath is stored. The first byte of the
   * structure in this array is given by {@link #typePathOffset}.
   *
   * @see <a
   *     href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.2">JVMS
   *     4.7.20.2</a>
   */
  /**
   * 字节数组，用于存储与该TypePath相对应的"type_path"结构（如Java虚拟机规范（JVMS）中所定义）。 
   * 该数组中结构的第一个字节由{@link  #typePathOffset}给出。 
   *  
   * @see  <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.2"> JVMS 4.7.20.2 </a>
   */
  private final byte[] typePathContainer;

  /** The offset of the first byte of the type_path JVMS structure in {@link #typePathContainer}. */
  /**
   * {@link  #typePathContainer}中type_path JVMS结构的第一个字节的偏移量。 
   * 
   */
  private final int typePathOffset;

  /**
   * Constructs a new TypePath.
   *
   * @param typePathContainer a byte array containing a type_path JVMS structure.
   * @param typePathOffset the offset of the first byte of the type_path structure in
   *     typePathContainer.
   */
  /**
   * 构造一个新的TypePath。 
   *  
   * @param  typePathContainer一个包含type_path JVMS结构的字节数组。 
   *  
   * @param  typePathOffset typePathContainer中type_path结构的第一个字节的偏移量。 
   * 
   */
  TypePath(final byte[] typePathContainer, final int typePathOffset) {
    this.typePathContainer = typePathContainer;
    this.typePathOffset = typePathOffset;
  }

  /**
   * Returns the length of this path, i.e. its number of steps.
   *
   * @return the length of this path.
   */
  /**
   * 返回此路径的长度，即其步数。 
   *  
   * @return 此路径的长度。 
   * 
   */
  public int getLength() {
    // path_length is stored in the first byte of a type_path.
    return typePathContainer[typePathOffset];
  }

  /**
   * Returns the value of the given step of this path.
   *
   * @param index an index between 0 and {@link #getLength()}, exclusive.
   * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link
   *     #TYPE_ARGUMENT}.
   */
  /**
   * 返回此路径给定步骤的值。 
   *  
   * @param 索引介于0和{@link  #getLength（）}之间的索引（不包括）。 
   *  
   * @return  {@link  #ARRAY_ELEMENT}，{<@link> #INNER_TYPE}，{<@link> #WILDCARD_BOUND}或{@link  #TYPE_ARGUMENT}之一。 
   * 
   */
  public int getStep(final int index) {
    // Returns the type_path_kind of the path element of the given index.
    return typePathContainer[typePathOffset + 2 * index + 1];
  }

  /**
   * Returns the index of the type argument that the given step is stepping into. This method should
   * only be used for steps whose value is {@link #TYPE_ARGUMENT}.
   *
   * @param index an index between 0 and {@link #getLength()}, exclusive.
   * @return the index of the type argument that the given step is stepping into.
   */
  /**
   * 返回给定步骤正在进入的类型参数的索引。 
   * 此方法仅应用于值为{@link  #TYPE_ARGUMENT}的步骤。 
   *  
   * @param 索引介于0和{@link  #getLength（）}之间的索引（不包括）。 
   *  
   * @return 给定步骤正在进入的类型参数的索引。 
   * 
   */
  public int getStepArgument(final int index) {
    // Returns the type_argument_index of the path element of the given index.
    return typePathContainer[typePathOffset + 2 * index + 2];
  }

  /**
   * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath
   * object.
   *
   * @param typePath a type path in string form, in the format used by {@link #toString()}. May be
   *     {@literal null} or empty.
   * @return the corresponding TypePath object, or {@literal null} if the path is empty.
   */
  /**
   * 将{@link  #toString（）}使用的格式的字符串形式的类型路径转换为TypePath对象。 
   *  
   * @param  typePath字符串形式的类型路径，格式为{@link  #toString（）}。 
   * 可以为{@literal null}或为空。 
   *  
   * @return 相应的TypePath对象，如果路径为空，则为{@literal null}。 
   * 
   */
  public static TypePath fromString(final String typePath) {
    if (typePath == null || typePath.length() == 0) {
      return null;
    }
    int typePathLength = typePath.length();
    ByteVector output = new ByteVector(typePathLength);
    output.putByte(0);
    int typePathIndex = 0;
    while (typePathIndex < typePathLength) {
      char c = typePath.charAt(typePathIndex++);
      if (c == '[') {
        output.put11(ARRAY_ELEMENT, 0);
      } else if (c == '.') {
        output.put11(INNER_TYPE, 0);
      } else if (c == '*') {
        output.put11(WILDCARD_BOUND, 0);
      } else if (c >= '0' && c <= '9') {
        int typeArg = c - '0';
        while (typePathIndex < typePathLength) {
          c = typePath.charAt(typePathIndex++);
          if (c >= '0' && c <= '9') {
            typeArg = typeArg * 10 + c - '0';
          } else if (c == ';') {
            break;
          } else {
            throw new IllegalArgumentException();
          }
        }
        output.put11(TYPE_ARGUMENT, typeArg);
      } else {
        throw new IllegalArgumentException();
      }
    }
    output.data[0] = (byte) (output.length / 2);
    return new TypePath(output.data, 0);
  }

  /**
   * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented
   * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link
   * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by ';'.
   */
  /**
   * 返回此类型路径的字符串表示形式。 
   *  {@link  #ARRAY_ELEMENT}步骤以'['表示，{@link  #INNER_TYPE}步骤以'。 
   * '表示，{@link  #WILDCARD_BOUND}步骤以''和{@link  #TYPE_ARGUMENT }，其类型参数索引以十进制形式后跟";"。 
   * 
   */
  @Override
  public String toString() {
    int length = getLength();
    StringBuilder result = new StringBuilder(length * 2);
    for (int i = 0; i < length; ++i) {
      switch (getStep(i)) {
        case ARRAY_ELEMENT:
          result.append('[');
          break;
        case INNER_TYPE:
          result.append('.');
          break;
        case WILDCARD_BOUND:
          result.append('*');
          break;
        case TYPE_ARGUMENT:
          result.append(getStepArgument(i)).append(';');
          break;
        default:
          throw new AssertionError();
      }
    }
    return result.toString();
  }

  /**
   * Puts the type_path JVMS structure corresponding to the given TypePath into the given
   * ByteVector.
   *
   * @param typePath a TypePath instance, or {@literal null} for empty paths.
   * @param output where the type path must be put.
   */
  /**
   * 将与给定TypePath对应的type_path JVMS结构放入给定ByteVector中。 
   *  
   * @param  typePath一个TypePath实例，或者{@literal null}表示空路径。 
   *  
   * @param 输出必须放置类型路径的位置。 
   * 
   */
  static void put(final TypePath typePath, final ByteVector output) {
    if (typePath == null) {
      output.putByte(0);
    } else {
      int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1;
      output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length);
    }
  }
}
