/** Generated by english-annotation-buster, Powered by Google Translate.**/
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.springframework.asm;

/**
 * A visitor to visit a Java method. The methods of this class must be called in the following
 * order: ( {@code visitParameter} )* [ {@code visitAnnotationDefault} ] ( {@code visitAnnotation} |
 * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} {@code
 * visitTypeAnnotation} | {@code visitAttribute} )* [ {@code visitCode} ( {@code visitFrame} |
 * {@code visit<i>X</i>Insn} | {@code visitLabel} | {@code visitInsnAnnotation} | {@code
 * visitTryCatchBlock} | {@code visitTryCatchAnnotation} | {@code visitLocalVariable} | {@code
 * visitLocalVariableAnnotation} | {@code visitLineNumber} )* {@code visitMaxs} ] {@code visitEnd}.
 * In addition, the {@code visit<i>X</i>Insn} and {@code visitLabel} methods must be called in the
 * sequential order of the bytecode instructions of the visited code, {@code visitInsnAnnotation}
 * must be called <i>after</i> the annotated instruction, {@code visitTryCatchBlock} must be called
 * <i>before</i> the labels passed as arguments have been visited, {@code
 * visitTryCatchBlockAnnotation} must be called <i>after</i> the corresponding try catch block has
 * been visited, and the {@code visitLocalVariable}, {@code visitLocalVariableAnnotation} and {@code
 * visitLineNumber} methods must be called <i>after</i> the labels passed as arguments have been
 * visited.
 *
 * @author Eric Bruneton
 */
/**
 * 访客访问Java方法。 
 * 此类的方法必须按以下顺序调用：（{@code  visitParameter}）[{@code  visitAnnotationDefault}]（{@code  visitAnnotation} | {@code  visitAnnotableParameterCount} | {@code  visitParameterAnnotation} {@code  visitTypeAnnotation} | {@code  visitAttribute}）[{@code  visitCode}（{@code  visitFrame} | {@code  visit <i> X </ i> Insn} | {@code  visitLabel} | {@code  visitInsnAnnotation} | {@code  visitTryCatchBlock} | {@code  visitTryCatchAnnotation} | {@code  visitLocalVariable} | {@code  visitLocalVariableAnnotation} | {@code  visitLineNumber}）{@code  visitMaxs}] {@code  visitEnd}。 
 * 此外，必须按照所访问代码{@code 的字节码指令的顺序来调用{@code  visit <i> X </ i> Insn}和{@code  visitLabel}方法在带注释的指令之后，必须在<i> </ i>之后调用visitInsnAnnotation}，在访问作为参数传递的标签之前，必须在被标记的指令之前，调用{@code  visitTryCatchBlock} {i @@code> visitTryCatchBlockAnnotation }必须在访问了相应的try catch块之后被<i>调用，并且必须调用{@code  visitLocalVariable}，{<@code> visitLocalVariableAnnotation}和{@code  visitLineNumber}方法<i> </ i>之后，已访问作为参数传递的标签。 
 *  @author 埃里克·布鲁内顿
 */
public abstract class MethodVisitor {

  private static final String REQUIRES_ASM5 = "This feature requires ASM5";

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of {@link
   * Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
   */
  /**
   * 此访问者实现的ASM API版本。 
   * 该字段的值必须是{@link  Opcodes＃ASM4}，{<@link> Opcodes＃ASM5}，{<@link> Opcodes＃ASM6}或{@link  Opcodes＃ASM7}之一。 
   * 
   */
  protected final int api;

  /**
   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.
   */
  /**
   * 该访问者必须委派方法调用的方法访问者。 
   * 可能为{@literal null}。 
   * 
   */
  protected MethodVisitor mv;

  /**
   * Constructs a new {@link MethodVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link
   *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
   */
  /**
   * 构造一个新的{@link  MethodVisitor}。 
   *  
   * @param  api此访客实现的ASM API版本。 
   * 必须是{@link  Opcodes＃ASM4}，{<@link> Opcodes＃ASM5}，{<@link> Opcodes＃ASM6}或{@link  Opcodes＃ASM7}之一。 
   * 
   */
  public MethodVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link MethodVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link
   *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
   * @param methodVisitor the method visitor to which this visitor must delegate method calls. May
   *     be null.
   */
  /**
   * 构造一个新的{@link  MethodVisitor}。 
   *  
   * @param  api此访客实现的ASM API版本。 
   * 必须是{@link  Opcodes＃ASM4}，{<@link> Opcodes＃ASM5}，{<@link> Opcodes＃ASM6}或{@link  Opcodes＃ASM7}之一。 
   *  
   * @param  methodVisitor此访问者必须委派该方法调用的方法访问者。 
   * 可能为空。 
   * 
   */
  @SuppressWarnings("deprecation")
  public MethodVisitor(final int api, final MethodVisitor methodVisitor) {
    if (api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM8_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM8_EXPERIMENTAL) {
      Constants.checkAsm8Experimental(this);
    }
    this.api = api;
    this.mv = methodVisitor;
  }

  // -----------------------------------------------------------------------------------------------
  // Parameters, annotations and non standard attributes
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a parameter of this method.
   *
   * @param name parameter name or {@literal null} if none is provided.
   * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}
   *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).
   */
  /**
   * 访问此方法的参数。 
   *  
   * @param 名称参数名称； 
   * 如果未提供，则为{@literal null}。 
   *  
   * @param 访问参数的访问标志，仅允许使用{@code  ACC_FINAL}，{<@code> ACC_SYNTHETIC}或/和{@code  ACC_MANDATED}（请参阅{@link 操作码}）。 
   * 
   */
  public void visitParameter(final String name, final int access) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      mv.visitParameter(name, access);
    }
  }

  /**
   * Visits the default value of this annotation interface method.
   *
   * @return a visitor to the visit the actual default value of this annotation interface method, or
   *     {@literal null} if this visitor is not interested in visiting this default value. The
   *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,
   *     exacly one visit method must be called on this annotation visitor, followed by visitEnd.
   */
  /**
   * 访问此注释接口方法的默认值。 
   *  
   * @return 访问该访问者的访问者，此注释接口方法的实际默认值，或者{@literal null}，如果该访问者对访问此默认值不感兴趣。 
   * 传递给此注释访问者方法的"名称"参数将被忽略。 
   * 此外，必须在此注解访问者上调用一个访问方法，然后是visitEnd。 
   * 
   */
  public AnnotationVisitor visitAnnotationDefault() {
    if (mv != null) {
      return mv.visitAnnotationDefault();
    }
    return null;
  }

  /**
   * Visits an annotation of this method.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 访问此方法的注释。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (mv != null) {
      return mv.visitAnnotation(descriptor, visible);
    }
    return null;
  }

  /**
   * Visits an annotation on a type in the method signature.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link
   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link
   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link
   *     TypeReference#THROWS}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 访问方法签名中类型的注释。 
   *  
   * @param  typeRef对带注释类型的引用。 
   * 此类型引用的类型必须为{@link  TypeReference＃METHOD_TYPE_PARAMETER}，{<@link> TypeReference＃METHOD_TYPE_PARAMETER_BOUND}，{<@link> TypeReference＃METHOD_RETURN}，{<@link> TypeReference＃METHOD_RECEIVER}，{@link  TypeReference＃METHOD_FORMAL_PARAMETER}或{@link  TypeReference＃THROWS}。 
   * 请参阅{@link  TypeReference}。 
   *  
   * @param  typePath注释类型参数，通配符绑定，数组元素类型或'typeRef'中的静态内部类型的路径。 
   * 如果注释整体上针对"typeRef"，则可能为{@literal null}。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits the number of method parameters that can have annotations. By default (i.e. when this
   * method is not called), all the method parameters defined by the method descriptor can have
   * annotations.
   *
   * @param parameterCount the number of method parameters than can have annotations. This number
   *     must be less or equal than the number of parameter types in the method descriptor. It can
   *     be strictly less when a method has synthetic parameters and when these parameters are
   *     ignored when computing parameter indices for the purpose of parameter annotations (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param visible {@literal true} to define the number of method parameters that can have
   *     annotations visible at runtime, {@literal false} to define the number of method parameters
   *     that can have annotations invisible at runtime.
   */
  /**
   * 访问可以带有注释的方法参数的数量。 
   * 默认情况下（即未调用此方法时），方法描述符定义的所有方法参数都可以具有注释。 
   *  
   * @param  parameterCount具有注释的方法参数的数量。 
   * 该数量必须小于或等于方法描述符中参数类型的数量。 
   * 当方法具有合成参数时，以及出于参数注释目的而计算参数索引时，如果忽略这些参数，则严格要少一些（请参见https://docs.oracle.com/javase/specs/jvms/se9/html/jvms -4.html＃jvms-4.7.18）。 
   *  
   * @param 可见{@literal true}定义可以在运行时可见的注释的方法参数的数量，{@literal false}定义可以在运行时不可见的注释的方法参数的数量。 
   * 
   */
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    if (mv != null) {
      mv.visitAnnotableParameterCount(parameterCount, visible);
    }
  }

  /**
   * Visits an annotation of a parameter this method.
   *
   * @param parameter the parameter index. This index must be strictly smaller than the number of
   *     parameters in the method descriptor, and strictly smaller than the parameter count
   *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i
   *     is not required to correspond to the i'th parameter descriptor in the method
   *     descriptor</i>, in particular in case of synthetic parameters (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 使用此方法访问参数的注释。 
   *  
   * @param 参数参数索引。 
   * 该索引必须严格小于方法描述符中的参数数目，并且必须小于{@link  #visitAnnotableParameterCount}中指定的参数计数。 
   * 重要说明：<i>不需要参数索引i对应于方法描述符中的第i个参数描述符</ i>，尤其是在使用合成参数的情况下（请参见https://docs.oracle.com/ javase / specs / jvms / se9 / html / jvms-4.html＃jvms-4.7.18）。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    if (mv != null) {
      return mv.visitParameterAnnotation(parameter, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a non standard attribute of this method.
   *
   * @param attribute an attribute.
   */
  /**
   * 访问此方法的非标准属性。 
   *  
   * @param 属性属性。 
   * 
   */
  public void visitAttribute(final Attribute attribute) {
    if (mv != null) {
      mv.visitAttribute(attribute);
    }
  }

  /** Starts the visit of the method's code, if any (i.e. non abstract method). */
  /**
   * 开始访问该方法的代码（如果有的话）（即非抽象方法）。 
   * 
   */
  public void visitCode() {
    if (mv != null) {
      mv.visitCode();
    }
  }

  /**
   * Visits the current state of the local variables and operand stack elements. This method must(*)
   * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch
   * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an
   * exception handler block. The visited types must describe the values of the local variables and
   * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>
   * <br>
   * (*) this is mandatory only for classes whose version is greater than or equal to {@link
   * Opcodes#V1_6}. <br>
   * <br>
   * The frames of a method must be given either in expanded form, or in compressed form (all frames
   * must use the same format, i.e. you must not mix expanded and compressed frames within a single
   * method):
   *
   * <ul>
   *   <li>In expanded form, all frames must have the F_NEW type.
   *   <li>In compressed form, frames are basically "deltas" from the state of the previous frame:
   *       <ul>
   *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the
   *             previous frame and with the empty stack.
   *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the
   *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and
   *             <code>stack[0]</code> contains value for the type of the stack item).
   *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the
   *             locals in the previous frame, except that additional locals are defined (<code>
   *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values
   *             representing added types).
   *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the
   *             locals in the previous frame, except that the last 1-3 locals are absent and with
   *             the empty stack (<code>numLocal</code> is 1, 2 or 3).
   *         <li>{@link Opcodes#F_FULL} representing complete frame data.
   *       </ul>
   * </ul>
   *
   * <br>
   * In both cases the first frame, corresponding to the method's parameters and access flags, is
   * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same
   * code location (i.e., at least one instruction must be visited between two calls to visitFrame).
   *
   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded
   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link
   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
   * @param numLocal the number of local variables in the visited frame.
   * @param local the local variable types in this frame. This array must not be modified. Primitive
   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or
   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).
   *     Reference types are represented by String objects (representing internal names), and
   *     uninitialized types by Label objects (this label designates the NEW instruction that
   *     created this uninitialized value).
   * @param numStack the number of operand stack elements in the visited frame.
   * @param stack the operand stack types in this frame. This array must not be modified. Its
   *     content has the same format as the "local" array.
   * @throws IllegalStateException if a frame is visited just after another one, without any
   *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it
   *     is silently ignored).
   */
  /**
   * 访问局部变量和操作数堆栈元素的当前状态。 
   * 该方法必须在紧随无条件分支指令（如GOTO或THROW）（是跳转指令的目标）或开始的任何指令<b> i </ b>之前，被<i>调用</ i>。 
   * 异常处理程序块。 
   * 被访问的类型必须在执行前<i> </ b> i </ b>之前描述局部变量和操作数堆栈元素<i>的值。 
   * <br> <br>（）仅对版本大于或等于{@link  Opcodes＃V1_6}的类。 
   *  <br> <br>必须以扩展形式或压缩形式给出方法的框架（所有框架必须使用相同的格式，即，您不得在单个方法中混合使用扩展框架和压缩框架）：<ul> <li>以展开形式，所有框架都必须具有F_NEW类型。 
   *  <li>以压缩形式，帧基本上是前一帧的状态的"增量"：<ul> <li> {<@link> Opcodes＃F_SAME}表示与前一帧具有完全相同的局部语言的帧，并且空堆栈。 
   *  <li> {<@link> Opcodes＃F_SAME1}表示具有与上一帧完全相同的局部性且在堆栈上具有单个值的帧（<code> numStack </ code>为1和<code> stack [0] < / code>包含堆栈项类型的值）。 
   * 表示具有当前局部语言的帧的<li> {<@link>操作码#F_APPEND}与上一帧中的局部语言相同，除了定义了其他局部语言（<code> numLocal </ code>为1、2或3以及<code> local </ code>元素包含代表添加类型的值）。 
   *  <li> {<@link> Opcodes＃F_CHOP}表示具有当前本地语言的帧与上一帧中的本地语言相同，除了不存在最后的1-3个本地语言并且堆栈为空（<code> numLocal </ code>是1、2或3）。 
   *  <li> {<@link>操作码#F_FULL}代表完整的帧数据。 
   *  </ ul> </ ul> <br>在这两种情况下，对应于方法的参数和访问标志的第一帧都是隐式的，不能访问。 
   * 同样，访问相同代码位置的两个或更多帧是非法的（即，必须在两次对visitFrame的调用之间访问至少一条指令）。 
   *  
   * @param 键入此堆栈映射框架的类型。 
   * 对于扩展框架，必须为{@link  Opcodes＃F_NEW}，或者为{@link  Opcodes＃F_FULL}，{@link  Opcodes＃F_APPEND}，{@link  Opcodes＃F_CHOP}，{<@link > Opcodes＃F_SAME}或{@link  Opcodes＃F_APPEND}，{<@link> Opcodes＃F_SAME1}用于压缩帧。 
   *  
   * @param  numLocal访问的帧中局部变量的数量。 
   *  
   * @param 在此框架中本地局部变量类型。 
   * 不得修改此数组。 
   * 基本类型由{@link  Opcodes＃TOP}，{<@link> Opcodes＃INTEGER}，{<@link> Opcodes＃FLOAT}，{<@link> Opcodes＃LONG}，{<@link> Opcodes＃DOUBLE}，{<@link> Opcodes＃NULL}或{@link  Opcodes＃UNINITIALIZED_THIS}（long和double由单个元素表示）。 
   * 引用类型由String对象（表示内部名称）表示，未初始化的类型由Label对象表示（此标签指定创建此未初始化值的NEW指令）。 
   *  
   * @param  numStack访问的帧中操作数堆栈元素的数量。 
   *  
   * @param 在此帧中堆栈操作数堆栈类型。 
   * 不得修改此数组。 
   * 其内容与"本地"数组具有相同的格式。 
   *  
   * @throws  IllegalStateException如果在另一个帧之后紧接着访问了一个帧，而在两个帧之间没有任何指令（除非此帧是Opcodes＃F_SAME帧，在这种情况下，它将被静默忽略）。 
   * 
   */
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (mv != null) {
      mv.visitFrame(type, numLocal, local, numStack, stack);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Normal instructions
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a zero operand instruction.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,
   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,
   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,
   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,
   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,
   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.
   */
  /**
   * 访问零操作数指令。 
   *  
   * @param  opcode要访问的指令的操作码。 
   * 该操作码为NOP，ACONST_NULL，ICONST_M1，ICONST_0，ICONST_1，ICONST_2，ICONST_3，ICONST_4，ICONST_5，LCONST_0，LCONST_1，FCONST_0，FCONST_1，FCONST_2，DCONST_0，DCONST_1，重载，重载，重载，重载，重载加载，IASTORE，LASTORE，FASTORE，DASTORE，AASTORE，BASTORE，CASTORE，SASTORE，POP，POP2，DUP，DUP_X1，DUP_X2，DUP2，DUP2_X1，DUP2_X2，交换，IADD，LADD，FADD，DADD，ISUB，LSUB，LSUB DSUB，IMUL，LMUL，FMUL，DMUL，IDIV，LDIV，FDIV，DDIV，IREM，LREM，FREM，DREM，INEG，LNEG，FNEG，DNEG，ISHL，LSHL，ISHR，LSHR，IUSHR，LUSHR，IAND，土地， IOR，LOR，IXOR，LXOR，I2L，I2F，I2D，L2I，L2F，L2D，F2I，F2L，F2D，D2I，D2L，D2F，I2B，I2C，I2S，LCMP，FCMPL，FCMPG，DCMPL，DCMPG，IRETURN LRETURN，FRETURN，DRETURN，ARETURN，RETURN，ARRAYLENGTH，ATHROW，MONITORENTER或MONITOREXIT。 
   * 
   */
  public void visitInsn(final int opcode) {
    if (mv != null) {
      mv.visitInsn(opcode);
    }
  }

  /**
   * Visits an instruction with a single int operand.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH
   *     or NEWARRAY.
   * @param operand the operand of the instruction to be visited.<br>
   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.
   *     <br>
   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.
   *     <br>
   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link
   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},
   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
   */
  /**
   * 使用单个int操作数访问指令。 
   *  
   * @param  opcode要访问的指令的操作码。 
   * 该操作码是BIPUSH，SIPUSH或NEWARRAY。 
   *  
   * @param 操作数要访问的指令的操作数。 
   * <br>当操作码为BIPUSH时，操作数值应在Byte.MIN_VALUE和Byte.MAX_VALUE之间。 
   *  <br>当操作码为SIPUSH时，操作数值应介于Short.MIN_VALUE和Short.MAX_VALUE之间。 
   *  <br>当操作码为NEWARRAY时，操作数值应为{@link 操作码#T_BOOLEAN}，{<@link>操作码#T_CHAR}，{<@link>操作码#T_FLOAT}，{<@link>操作码之一#T_DOUBLE}，{<@link>操作码#T_BYTE}，{<@link>操作码#T_SHORT}，{<@link>操作码#T_INT}或{@link 操作码#T_LONG}。 
   * 
   */
  public void visitIntInsn(final int opcode, final int operand) {
    if (mv != null) {
      mv.visitIntInsn(opcode, operand);
    }
  }

  /**
   * Visits a local variable instruction. A local variable instruction is an instruction that loads
   * or stores the value of a local variable.
   *
   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either
   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
   * @param var the operand of the instruction to be visited. This operand is the index of a local
   *     variable.
   */
  /**
   * 访问局部变量指令。 
   * 局部变量指令是加载或存储局部变量值的指令。 
   *  
   * @param  opcode要访问的局部变量指令的操作码。 
   * 此操作码可以是ILOAD，LLOAD，FLOAD，DLOAD，ALOAD，ISTORE，LSTORE，FSTORE，DSTORE，ASTORE或RET。 
   *  
   * @param  var要访问的指令的操作数。 
   * 该操作数是局部变量的索引。 
   * 
   */
  public void visitVarInsn(final int opcode, final int var) {
    if (mv != null) {
      mv.visitVarInsn(opcode, var);
    }
  }

  /**
   * Visits a type instruction. A type instruction is an instruction that takes the internal name of
   * a class as parameter.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,
   *     ANEWARRAY, CHECKCAST or INSTANCEOF.
   * @param type the operand of the instruction to be visited. This operand must be the internal
   *     name of an object or array class (see {@link Type#getInternalName()}).
   */
  /**
   * 访问类型指令。 
   * 类型指令是将类的内部名称作为参数的指令。 
   *  
   * @param  opcode要访问的类型指令的操作码。 
   * 该操作码可以是NEW，ANEWARRAY，CHECKCAST或INSTANCEOF。 
   *  
   * @param 键入要访问的指令的操作数。 
   * 此操作数必须是对象或数组类的内部名称（请参见{@link  Type＃getInternalName（）}）。 
   * 
   */
  public void visitTypeInsn(final int opcode, final String type) {
    if (mv != null) {
      mv.visitTypeInsn(opcode, type);
    }
  }

  /**
   * Visits a field instruction. A field instruction is an instruction that loads or stores the
   * value of a field of an object.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   */
  /**
   * 访问现场指导。 
   * 字段指令是加载或存储对象字段值的指令。 
   *  
   * @param  opcode要访问的类型指令的操作码。 
   * 此操作码是GETSTATIC，PUTSTATIC，GETFIELD或PUTFIELD。 
   *  
   * @param  owner字段的所有者类的内部名称（请参见{@link  Type＃getInternalName（）}）。 
   *  
   * @param 命名字段的名称。 
   *  
   * @param 描述符字段的描述符（请参见{@link 类型}）。 
   * 
   */
  public void visitFieldInsn(
      final int opcode, final String owner, final String name, final String descriptor) {
    if (mv != null) {
      mv.visitFieldInsn(opcode, owner, name, descriptor);
    }
  }

  /**
   * Visits a method instruction. A method instruction is an instruction that invokes a method.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
   */
  /**
   * 访问方法指令。 
   * 方法指令是调用方法的指令。 
   *  
   * @param  opcode要访问的类型指令的操作码。 
   * 该操作码可以是INVOKEVIRTUAL，INVOKESPECIAL，INVOKESTATIC或INVOKEINTERFACE。 
   *  
   * @param  owner方法的所有者类的内部名称（请参见{@link  Type＃getInternalName（）}）。 
   *  
   * @param 命名方法的名称。 
   *  
   * @param 描述符方法的描述符（请参见{@link 类型}）。 
   *  @不建议使用{@link  #visitMethodInsn（int，String，String，String，boolean）}代替。 
   * 
   */
  @Deprecated
  public void visitMethodInsn(
      final int opcode, final String owner, final String name, final String descriptor) {
    int opcodeAndSource = opcode | (api < Opcodes.ASM5 ? Opcodes.SOURCE_DEPRECATED : 0);
    visitMethodInsn(opcodeAndSource, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
  }

  /**
   * Visits a method instruction. A method instruction is an instruction that invokes a method.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  /**
   * 访问方法指令。 
   * 方法指令是调用方法的指令。 
   *  
   * @param  opcode要访问的类型指令的操作码。 
   * 该操作码可以是INVOKEVIRTUAL，INVOKESPECIAL，INVOKESTATIC或INVOKEINTERFACE。 
   *  
   * @param  owner方法的所有者类的内部名称（请参见{@link  Type＃getInternalName（）}）。 
   *  
   * @param 命名方法的名称。 
   *  
   * @param 描述符方法的描述符（请参见{@link 类型}）。 
   * 如果方法的所有者类是接口，则
   * @param  isInterface。 
   * 
   */
  public void visitMethodInsn(
      final int opcode,
      final String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcode & Opcodes.SOURCE_DEPRECATED) == 0) {
      if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {
        throw new UnsupportedOperationException("INVOKESPECIAL/STATIC on interfaces requires ASM5");
      }
      visitMethodInsn(opcode, owner, name, descriptor);
      return;
    }
    if (mv != null) {
      mv.visitMethodInsn(opcode & ~Opcodes.SOURCE_MASK, owner, name, descriptor, isInterface);
    }
  }

  /**
   * Visits an invokedynamic instruction.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify
   *     the content of the array so a caller should expect that this array may change.
   */
  /**
   * 访问一个invokedynamic指令。 
   *  
   * @param 命名方法的名称。 
   *  
   * @param 描述符方法的描述符（请参见{@link 类型}）。 
   *  
   * @param  bootstrapMethod处理引导方法。 
   *  
   * @param  bootstrapMethodArguments引导程序方法常量参数。 
   * 每个参数必须是{@link 整数}，{<@link>浮点数}，{<@link>长}，{<@link>双精度}，{<@link>字符串}，{<@link>键入}，{<@link>句柄}或{@link  ConstantDynamic}值。 
   * 允许使用此方法修改数组的内容，因此调用者应期望此数组可能会更改。 
   * 
   */
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    }
  }

  /**
   * Visits a jump instruction. A jump instruction is an instruction that may jump to another
   * instruction.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,
   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
   * @param label the operand of the instruction to be visited. This operand is a label that
   *     designates the instruction to which the jump instruction may jump.
   */
  /**
   * 访问跳转指令。 
   * 跳转指令是可以跳转到另一条指令的指令。 
   *  
   * @param  opcode要访问的类型指令的操作码。 
   * 此操作码为IFEQ，IFNE，IFLT，IFGE，IFGT，IFLE，IF_ICMPEQ，IF_ICMPNE，IF_ICMPLT，IF_ICMPGE，IF_ICMPGT，IF_ICMPLE，IF_ACMPEQ，IF_ACMPNE，GOTO，JSR，IFNULL。 
   *  
   * @param 标记要访问的指令的操作数。 
   * 该操作数是一个标签，用于指定跳转指令可以跳转到的指令。 
   * 
   */
  public void visitJumpInsn(final int opcode, final Label label) {
    if (mv != null) {
      mv.visitJumpInsn(opcode, label);
    }
  }

  /**
   * Visits a label. A label designates the instruction that will be visited just after it.
   *
   * @param label a {@link Label} object.
   */
  /**
   * 访问标签。 
   * 标签指示紧随其后将要访问的指令。 
   *  
   * @param 标记一个{@link  Label}对象。 
   * 
   */
  public void visitLabel(final Label label) {
    if (mv != null) {
      mv.visitLabel(label);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Special instructions
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a LDC instruction. Note that new constant types may be added in future versions of the
   * Java Virtual Machine. To easily detect new constant types, implementations of this method
   * should check for unexpected constant types, like this:
   *
   * <pre>
   * if (cst instanceof Integer) {
   *     // ...
   * } else if (cst instanceof Float) {
   *     // ...
   * } else if (cst instanceof Long) {
   *     // ...
   * } else if (cst instanceof Double) {
   *     // ...
   * } else if (cst instanceof String) {
   *     // ...
   * } else if (cst instanceof Type) {
   *     int sort = ((Type) cst).getSort();
   *     if (sort == Type.OBJECT) {
   *         // ...
   *     } else if (sort == Type.ARRAY) {
   *         // ...
   *     } else if (sort == Type.METHOD) {
   *         // ...
   *     } else {
   *         // throw an exception
   *     }
   * } else if (cst instanceof Handle) {
   *     // ...
   * } else if (cst instanceof ConstantDynamic) {
   *     // ...
   * } else {
   *     // throw an exception
   * }
   * </pre>
   *
   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link
   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link
   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is
   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle
   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant
   *     dynamic for classes whose version is 55.
   */
  /**
   * 访问LDC指令。 
   * 请注意，可以在Java虚拟机的将来版本中添加新的常量类型。 
   * 为了轻松检测新的常量类型，此方法的实现应检查意外的常量类型，如下所示：<pre> if（cst instanceof Integer）{// ...} else if（cst instanceof Float）{// ... } else if（cst instanceof Long）{// ...} else if（cst instanceof Double）{// ...} else if（cst instanceof String）{// ...} else if（cst instanceof Type） {int sort =（（Type）cst）.getSort（）; if（sort == Type.OBJECT）{// ...} else if（sort == Type.ARRAY）{// ...} else if（sort == Type.METHOD）{// ...} else {//引发异常}} else if（cst instanceof句柄）{// ...} else if（cst instanceof常量动态）{// ...} else {//抛出异常} </ pre> 
   * @param 值要在堆栈上加载的常量。 
   * 此参数必须为非空的{@link 整数}，{<@link>浮点数}，{<@link>长}，{<@link>双精度}，{<@link>字符串} ，对于{@code  .class}常量的OBJECT或ARRAY排序的{@link  Type}，对于版本为49的类，对于MethodType的METHOD排序的{@link  Type}，对于MethodType，{<@对于方法版本为51的类，使用MethodHandle常量的link> Handle}； 
   * 对于版本为55的类，为常量动态的{@link  ConstantDynamic}。 
   * 
   */
  public void visitLdcInsn(final Object value) {
    if (api < Opcodes.ASM5
        && (value instanceof Handle
            || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {
      throw new UnsupportedOperationException("This feature requires ASM7");
    }
    if (mv != null) {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Visits an IINC instruction.
   *
   * @param var index of the local variable to be incremented.
   * @param increment amount to increment the local variable by.
   */
  /**
   * 访问IINC指令。 
   *  
   * @param 要增加的局部变量的var索引。 
   *  
   * @param 增量量，用于增加局部变量。 
   * 
   */
  public void visitIincInsn(final int var, final int increment) {
    if (mv != null) {
      mv.visitIincInsn(var, increment);
    }
  }

  /**
   * Visits a TABLESWITCH instruction.
   *
   * @param min the minimum key value.
   * @param max the maximum key value.
   * @param dflt beginning of the default handler block.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code min + i} key.
   */
  /**
   * 访问TABLESWITCH指令。 
   *  
   * @param 最小最小键值。 
   *  
   * @param  max最大密钥值。 
   *  
   * @param  dflt默认处理程序块的开头。 
   *  
   * @param 标记处理程序块的开头。 
   *  {@code 标签[i]}是{@code  min + i}键的处理程序块的开始。 
   * 
   */
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    if (mv != null) {
      mv.visitTableSwitchInsn(min, max, dflt, labels);
    }
  }

  /**
   * Visits a LOOKUPSWITCH instruction.
   *
   * @param dflt beginning of the default handler block.
   * @param keys the values of the keys.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code keys[i]} key.
   */
  /**
   * 访问LOOKUPSWITCH指令。 
   *  
   * @param  dflt默认处理程序块的开头。 
   *  
   * @param 设置键的值。 
   *  
   * @param 标记处理程序块的开头。 
   *  {@code 标签[i]}是{@code  keys [i]}键的处理程序块的开始。 
   * 
   */
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    if (mv != null) {
      mv.visitLookupSwitchInsn(dflt, keys, labels);
    }
  }

  /**
   * Visits a MULTIANEWARRAY instruction.
   *
   * @param descriptor an array type descriptor (see {@link Type}).
   * @param numDimensions the number of dimensions of the array to allocate.
   */
  /**
   * 访问MULTIANEWARRAY指令。 
   *  
   * @param 描述符是数组类型的描述符（请参见{@link  Type}）。 
   *  
   * @param  numDimensions要分配的数组的维数。 
   * 
   */
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    if (mv != null) {
      mv.visitMultiANewArrayInsn(descriptor, numDimensions);
    }
  }

  /**
   * Visits an annotation on an instruction. This method must be called just <i>after</i> the
   * annotated instruction. It can be called several times for the same instruction.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link
   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link
   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 访问指令上的注释。 
   * 必须在带注释的指令之后<i> </ i>调用此方法。 
   * 同一条指令可以多次调用。 
   *  
   * @param  typeRef对带注释类型的引用。 
   * 此类型引用的类型必须为{@link  TypeReference＃INSTANCEOF}，{<@link> TypeReference＃NEW}，{<@link> TypeReference＃CONSTRUCTOR_REFERENCE}，{<@link> TypeReference＃METHOD_REFERENCE}，{@link  TypeReference＃CAST}，{<@link> TypeReference＃CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}，{<@link> TypeReference＃METHOD_INVOCATION_TYPE_ARGUMENT}，{<@link> TypeReference＃CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}或{@link  TypeReference请参阅{@link  TypeReference}。 
   *  
   * @param  typePath注释类型参数，通配符绑定，数组元素类型或'typeRef'中的静态内部类型的路径。 
   * 如果注释整体上针对"typeRef"，则可能为{@literal null}。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  // -----------------------------------------------------------------------------------------------
  // Exceptions table entries, debug information, max stack and max locals
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a try catch block.
   *
   * @param start the beginning of the exception handler's scope (inclusive).
   * @param end the end of the exception handler's scope (exclusive).
   * @param handler the beginning of the exception handler's code.
   * @param type the internal name of the type of exceptions handled by the handler, or {@literal
   *     null} to catch any exceptions (for "finally" blocks).
   * @throws IllegalArgumentException if one of the labels has already been visited by this visitor
   *     (by the {@link #visitLabel} method).
   */
  /**
   * 访问try catch块。 
   *  
   * @param 开始异常处理程序范围的开始（包括）。 
   *  
   * @param 结束异常处理程序作用域的范围（不包括）。 
   *  
   * @param  handler异常处理程序代码的开头。 
   *  
   * @param 键入由处理程序处理的异常类型的内部名称，或键入{@literal null}以捕获任何异常（对于"finally"块）。 
   *  
   * @throws  IllegalArgumentException-如果该访问者已经通过{@link  #visitLabel}方法访问了其中一个标签。 
   * 
   */
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final String type) {
    if (mv != null) {
      mv.visitTryCatchBlock(start, end, handler, type);
    }
  }

  /**
   * Visits an annotation on an exception handler type. This method must be called <i>after</i> the
   * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times
   * for the same exception handler.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 访问有关异常处理程序类型的注释。 
   * 在带注释的异常处理程序的{@link  #visitTryCatchBlock}之后，必须在<i>之后</ i>调用此方法。 
   * 对于同一个异常处理程序，可以多次调用它。 
   *  
   * @param  typeRef对带注释类型的引用。 
   * 此类型引用的类型必须为{@link  TypeReference＃EXCEPTION_PARAMETER}。 
   * 请参阅{@link  TypeReference}。 
   *  
   * @param  typePath注释类型参数，通配符绑定，数组元素类型或'typeRef'中的静态内部类型的路径。 
   * 如果注释整体上针对"typeRef"，则可能为{@literal null}。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a local variable declaration.
   *
   * @param name the name of a local variable.
   * @param descriptor the type descriptor of this local variable.
   * @param signature the type signature of this local variable. May be {@literal null} if the local
   *     variable type does not use generic types.
   * @param start the first instruction corresponding to the scope of this local variable
   *     (inclusive).
   * @param end the last instruction corresponding to the scope of this local variable (exclusive).
   * @param index the local variable's index.
   * @throws IllegalArgumentException if one of the labels has not already been visited by this
   *     visitor (by the {@link #visitLabel} method).
   */
  /**
   * 访问局部变量声明。 
   *  
   * @param 名称局部变量的名称。 
   *  
   * @param 描述符此局部变量的类型描述符。 
   *  
   * @param 签名此局部变量的类型签名。 
   * 如果局部变量类型不使用泛型类型，则可以为{@literal null}。 
   *  
   * @param 开始与该局部变量的范围（含）相对应的第一条指令。 
   *  
   * @param 结束与该局部变量的范围相对应的最后一条指令（不包括）。 
   *  
   * @param 索引局部变量的索引。 
   *  
   * @throws  IllegalArgumentException如果此访问者尚未访问标签之一（通过{@link  #visitLabel}方法）。 
   * 
   */
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    if (mv != null) {
      mv.visitLocalVariable(name, descriptor, signature, start, end, index);
    }
  }

  /**
   * Visits an annotation on a local variable type.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link
   *     TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param start the fist instructions corresponding to the continuous ranges that make the scope
   *     of this local variable (inclusive).
   * @param end the last instructions corresponding to the continuous ranges that make the scope of
   *     this local variable (exclusive). This array must have the same size as the 'start' array.
   * @param index the local variable's index in each range. This array must have the same size as
   *     the 'start' array.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  /**
   * 访问有关局部变量类型的注释。 
   *  
   * @param  typeRef对带注释类型的引用。 
   * 此类型引用的类型必须为{@link  TypeReference＃LOCAL_VARIABLE}或{@link  TypeReference＃RESOURCE_VARIABLE}。 
   * 请参阅{@link  TypeReference}。 
   *  
   * @param  typePath注释类型参数，通配符绑定，数组元素类型或'typeRef'中的静态内部类型的路径。 
   * 如果注释整体上针对"typeRef"，则可能为{@literal null}。 
   *  
   * @param 开始与构成该局部变量（包括）的范围的连续范围相对应的第一条指令。 
   *  
   * @param 结束与构成该局部变量范围的连续范围相对应的最后一条指令（不包括）。 
   * 该数组的大小必须与"开始"数组的大小相同。 
   *  
   * @param 索引每个范围中局部变量的索引。 
   * 该数组的大小必须与"开始"数组的大小相同。 
   *  
   * @param 描述符注释类的类描述符。 
   *  
   * @param 可见{@literal true}（如果注释在运行时可见）。 
   *  
   * @return 访问者以访问注释值，如果访问者对访问此注释不感兴趣，则返回{@literal null}。 
   * 
   */
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitLocalVariableAnnotation(
          typeRef, typePath, start, end, index, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a line number declaration.
   *
   * @param line a line number. This number refers to the source file from which the class was
   *     compiled.
   * @param start the first instruction corresponding to this line number.
   * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor
   *     (by the {@link #visitLabel} method).
   */
  /**
   * 访问行号声明。 
   *  
   * @param 行的行号。 
   * 此数字是指从中编译类的源文件。 
   *  
   * @param 启动与此行号相对应的第一条指令。 
   *  
   * @throws  IllegalArgumentException如果此访问者尚未访问{@code  start}（通过{@link  #visitLabel}方法）。 
   * 
   */
  public void visitLineNumber(final int line, final Label start) {
    if (mv != null) {
      mv.visitLineNumber(line, start);
    }
  }

  /**
   * Visits the maximum stack size and the maximum number of local variables of the method.
   *
   * @param maxStack maximum stack size of the method.
   * @param maxLocals maximum number of local variables for the method.
   */
  /**
   * 访问方法的最大堆栈大小和局部变量的最大数量。 
   *  
   * @param  maxStack方法的最大堆栈大小。 
   *  
   * @param  maxLocals方法的最大局部变量数。 
   * 
   */
  public void visitMaxs(final int maxStack, final int maxLocals) {
    if (mv != null) {
      mv.visitMaxs(maxStack, maxLocals);
    }
  }

  /**
   * Visits the end of the method. This method, which is the last one to be called, is used to
   * inform the visitor that all the annotations and attributes of the method have been visited.
   */
  /**
   * 访问方法的结尾。 
   * 此方法是最后一个要调用的方法，用于通知访问者该方法的所有注释和属性都已被访问。 
   * 
   */
  public void visitEnd() {
    if (mv != null) {
      mv.visitEnd();
    }
  }
}
