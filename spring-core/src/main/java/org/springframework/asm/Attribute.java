/** Generated by english-annotation-buster, Powered by Google Translate.**/
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.
package org.springframework.asm;

/**
 * A non standard class, field, method or Code attribute, as defined in the Java Virtual Machine
 * Specification (JVMS).
 *
 * @see <a href= "https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7">JVMS
 *     4.7</a>
 * @see <a href= "https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3">JVMS
 *     4.7.3</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
/**
 * 非标准类，字段，方法或代码属性，如Java虚拟机规范（JVMS）中所定义。 
 *  
 * @see  <a href= "https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7"> JVMS 4.7 </a> 
 * @see  <a href=""https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3"> JVMS 4.7.3 </a> @author 埃里克·布鲁内顿（Eric Bruneton）@author 尤金·库列肖夫（Eugene Kuleshov）
 */
public class Attribute {

  /** The type of this attribute, also called its name in the JVMS. */
  /**
   * 此属性的类型，在JVMS中也称为其名称。 
   * 
   */
  public final String type;

  /**
   * The raw content of this attribute, only used for unknown attributes (see {@link #isUnknown()}).
   * The 6 header bytes of the attribute (attribute_name_index and attribute_length) are <i>not</i>
   * included.
   */
  /**
   * 此属性的原始内容，仅用于未知属性（请参见{@link  #isUnknown（）}）。 
   *  <i>不</ i>不包含属性的6个标头字节（attribute_name_index和attribute_length）。 
   * 
   */
  private byte[] content;

  /**
   * The next attribute in this attribute list (Attribute instances can be linked via this field to
   * store a list of class, field, method or Code attributes). May be {@literal null}.
   */
  /**
   * 此属性列表中的下一个属性（可以通过此字段链接属性实例，以存储类，字段，方法或Code属性的列表）。 
   * 可能为{@literal null}。 
   * 
   */
  Attribute nextAttribute;

  /**
   * Constructs a new empty attribute.
   *
   * @param type the type of the attribute.
   */
  /**
   * 构造一个新的空属性。 
   *  
   * @param 键入属性的类型。 
   * 
   */
  protected Attribute(final String type) {
    this.type = type;
  }

  /**
   * Returns {@literal true} if this type of attribute is unknown. This means that the attribute
   * content can't be parsed to extract constant pool references, labels, etc. Instead, the
   * attribute content is read as an opaque byte array, and written back as is. This can lead to
   * invalid attributes, if the content actually contains constant pool references, labels, or other
   * symbolic references that need to be updated when there are changes to the constant pool, the
   * method bytecode, etc. The default implementation of this method always returns {@literal true}.
   *
   * @return {@literal true} if this type of attribute is unknown.
   */
  /**
   * 如果此类属性未知，则返回{@literal true}。 
   * 这意味着无法解析属性内容以提取常量池引用，标签等。 
   * 相反，属性内容被读取为不透明字节数组，并照原样写回。 
   * 如果内容实际上包含常量池引用，标签或其他符号引用，而这些常量引用在常量池，方法字节码等发生更改时需要更新，则可能导致无效的属性。 
   * 此方法的默认实现始终返回{@literal true}。 
   *  
   * @return  {@literal true}（如果此类属性未知）。 
   * 
   */
  public boolean isUnknown() {
    return true;
  }

  /**
   * Returns {@literal true} if this type of attribute is a Code attribute.
   *
   * @return {@literal true} if this type of attribute is a Code attribute.
   */
  /**
   * 如果此类型的属性是Code属性，则返回{@literal true}。 
   *  
   * @return  {@literal true}（如果此类型的属性是Code属性）。 
   * 
   */
  public boolean isCodeAttribute() {
    return false;
  }

  /**
   * Returns the labels corresponding to this attribute.
   *
   * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not
   *     a Code attribute that contains labels.
   */
  /**
   * 返回与此属性对应的标签。 
   *  
   * @return 与此属性对应的标签，如果此属性不是包含标签的Code属性，则为{@literal null}。 
   * 
   */
  protected Label[] getLabels() {
    return new Label[0];
  }

  /**
   * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,
   * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given
   * ClassReader.
   *
   * @param classReader the class that contains the attribute to be read.
   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a
   *     'charBuffer' parameter.
   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute
   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
   *     is not a Code attribute.
   * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.
   */
  /**
   * 读取{@link  #type}属性。 
   * 此方法必须返回给定ClassReader中类型为<< @link> #type}的<i> new </ i> {@link  #type}对象，该对象对应于从"偏移"开始的"长度"字节。 
   *  。 
   *  
   * @param  classReader包含要读取的属性的类。 
   *  {@@link> ClassReader}中属性内容的第一个字节的
   * @param 偏移量索引。 
   * 此处不考虑6个属性标头字节（attribute_name_index和attribute_length）。 
   *  
   * @param  length属性内容的长度（不包括6个属性头字节）。 
   *  
   * @param  charBuffer用于调用需要'charBuffer'参数的ClassReader方法的缓冲区。 
   *  {@@link> ClassReader}中封闭的Code属性内容的第一字节的
   * @param  codeAttributeOffset索引； 
   * 如果要读取的属性不是Code属性，则为-1。 
   * 此处不考虑6个属性标头字节（attribute_name_index和attribute_length）。 
   *  
   * @param 标记方法代码的标签，如果要读取的属性不是Code属性，则为{@literal null}。 
   *  
   * @return 对应于指定字节的<i> new </ i> {@link 属性}对象。 
   * 
   */
  protected Attribute read(
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
    Attribute attribute = new Attribute(type);
    attribute.content = new byte[length];
    System.arraycopy(classReader.classFileBuffer, offset, attribute.content, 0, length);
    return attribute;
  }

  /**
   * Returns the byte array form of the content of this attribute. The 6 header bytes
   * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned
   * ByteVector.
   *
   * @param classWriter the class to which this attribute must be added. This parameter can be used
   *     to add the items that corresponds to this attribute to the constant pool of this class.
   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}
   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to this code
   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'
   *     field of the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or
   *     -1 if this attribute is not a Code attribute.
   * @param maxLocals the maximum number of local variables of the method corresponding to this code
   *     attribute, or -1 if this attribute is not a Code attribute.
   * @return the byte array form of this attribute.
   */
  /**
   * 返回此属性内容的字节数组形式。 
   * 必须<i>不</ i>将6个标头字节（attribute_name_index和attribute_length）添加到返回的ByteVector中。 
   *  
   * @param  classWriter必须将此属性添加到的类。 
   * 此参数可用于将与此属性对应的项目添加到此类的常量池中。 
   *  
   * @param 编码与此Code属性对应的方法的字节码，如果此属性不是Code属性，则为{@literal null}。 
   * 对应于"代码"属性的"代码"字段。 
   *  
   * @param  codeLength与此代码属性对应的方法的字节码的长度，如果此属性不是Code属性，则为0。 
   * 对应于Code属性的'code_length'字段。 
   *  
   * @param  maxStack与此Code属性对应的方法的最大堆栈大小； 
   * 如果此属性不是Code属性，则为-1。 
   *  
   * @param  maxLocals与此代码属性对应的方法的最大局部变量数； 
   * 如果此属性不是Code属性，则为-1。 
   *  
   * @return 此属性的字节数组形式。 
   * 
   */
  protected ByteVector write(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    return new ByteVector(content);
  }

  /**
   * Returns the number of attributes of the attribute list that begins with this attribute.
   *
   * @return the number of attributes of the attribute list that begins with this attribute.
   */
  /**
   * 返回以该属性开头的属性列表的属性数量。 
   *  
   * @return 以该属性开头的属性列表的属性数。 
   * 
   */
  final int getAttributeCount() {
    int count = 0;
    Attribute attribute = this;
    while (attribute != null) {
      count += 1;
      attribute = attribute.nextAttribute;
    }
    return count;
  }

  /**
   * Returns the total size in bytes of all the attributes in the attribute list that begins with
   * this attribute. This size includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @return the size of all the attributes in this attribute list. This size includes the size of
   *     the attribute headers.
   */
  /**
   * 返回以该属性开头的属性列表中所有属性的总大小（以字节为单位）。 
   * 此大小包括每个属性的6个标头字节（attribute_name_index和attribute_length）。 
   * 还将属性类型名称添加到常量池中。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @return 此属性列表中所有属性的大小。 
   * 该大小包括属性标题的大小。 
   * 
   */
  final int computeAttributesSize(final SymbolTable symbolTable) {
    final byte[] code = null;
    final int codeLength = 0;
    final int maxStack = -1;
    final int maxLocals = -1;
    return computeAttributesSize(symbolTable, code, codeLength, maxStack, maxLocals);
  }

  /**
   * Returns the total size in bytes of all the attributes in the attribute list that begins with
   * this attribute. This size includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal
   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to these code
   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of
   *     the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or
   *     -1 if they are not Code attributes.
   * @param maxLocals the maximum number of local variables of the method corresponding to these
   *     Code attributes, or -1 if they are not Code attribute.
   * @return the size of all the attributes in this attribute list. This size includes the size of
   *     the attribute headers.
   */
  /**
   * 返回以该属性开头的属性列表中所有属性的总大小（以字节为单位）。 
   * 此大小包括每个属性的6个标头字节（attribute_name_index和attribute_length）。 
   * 还将属性类型名称添加到常量池中。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @param 编码与这些Code属性相对应的方法的字节码，如果不是Code属性，则为{@literal null}。 
   * 对应于"代码"属性的"代码"字段。 
   *  
   * @param  codeLength对应于这些代码属性的方法的字节码的长度； 
   * 如果不是Code属性，则为0。 
   * 对应于Code属性的'code_length'字段。 
   *  
   * @param  maxStack与这些Code属性对应的方法的最大堆栈大小； 
   * 如果不是Code属性，则为-1。 
   *  
   * @param  maxLocals对应于这些Code属性的方法的最大局部变量数； 
   * 如果不是Code属性，则为-1。 
   *  
   * @return 此属性列表中所有属性的大小。 
   * 该大小包括属性标题的大小。 
   * 
   */
  final int computeAttributesSize(
      final SymbolTable symbolTable,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    final ClassWriter classWriter = symbolTable.classWriter;
    int size = 0;
    Attribute attribute = this;
    while (attribute != null) {
      symbolTable.addConstantUtf8(attribute.type);
      size += 6 + attribute.write(classWriter, code, codeLength, maxStack, maxLocals).length;
      attribute = attribute.nextAttribute;
    }
    return size;
  }

  /**
   * Returns the total size in bytes of all the attributes that correspond to the given field,
   * method or class access flags and signature. This size includes the 6 header bytes
   * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names
   * to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param accessFlags some field, method or class access flags.
   * @param signatureIndex the constant pool index of a field, method of class signature.
   * @return the size of all the attributes in bytes. This size includes the size of the attribute
   *     headers.
   */
  /**
   * 返回与给定字段，方法或类访问标志和签名相对应的所有属性的总大小（以字节为单位）。 
   * 此大小包括每个属性的6个标头字节（attribute_name_index和attribute_length）。 
   * 还将属性类型名称添加到常量池中。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @param  accessFlags一些字段，方法或类访问标志。 
   *  
   * @param  signatureIndex字段的常量池索引，类签名的方法。 
   *  
   * @return 所有属性的大小（以字节为单位）。 
   * 该大小包括属性标题的大小。 
   * 
   */
  static int computeAttributesSize(
      final SymbolTable symbolTable, final int accessFlags, final int signatureIndex) {
    int size = 0;
    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0
        && symbolTable.getMajorVersion() < Opcodes.V1_5) {
      // Synthetic attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.SYNTHETIC);
      size += 6;
    }
    if (signatureIndex != 0) {
      // Signature attributes always use 8 bytes.
      symbolTable.addConstantUtf8(Constants.SIGNATURE);
      size += 8;
    }
    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      // Deprecated attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.DEPRECATED);
      size += 6;
    }
    return size;
  }

  /**
   * Puts all the attributes of the attribute list that begins with this attribute, in the given
   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per
   * attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param output where the attributes must be written.
   */
  /**
   * 将以该属性开头的属性列表的所有属性放入给定的字节向量中。 
   * 每个属性包括6个标头字节（attribute_name_index和attribute_length）。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @param 输出必须在其中写入属性的位置。 
   * 
   */
  final void putAttributes(final SymbolTable symbolTable, final ByteVector output) {
    final byte[] code = null;
    final int codeLength = 0;
    final int maxStack = -1;
    final int maxLocals = -1;
    putAttributes(symbolTable, code, codeLength, maxStack, maxLocals, output);
  }

  /**
   * Puts all the attributes of the attribute list that begins with this attribute, in the given
   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per
   * attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal
   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to these code
   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of
   *     the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or
   *     -1 if they are not Code attributes.
   * @param maxLocals the maximum number of local variables of the method corresponding to these
   *     Code attributes, or -1 if they are not Code attribute.
   * @param output where the attributes must be written.
   */
  /**
   * 将以该属性开头的属性列表的所有属性放入给定的字节向量中。 
   * 每个属性包括6个标头字节（attribute_name_index和attribute_length）。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @param 编码与这些Code属性相对应的方法的字节码，如果不是Code属性，则为{@literal null}。 
   * 对应于"代码"属性的"代码"字段。 
   *  
   * @param  codeLength对应于这些代码属性的方法的字节码的长度； 
   * 如果不是Code属性，则为0。 
   * 对应于Code属性的'code_length'字段。 
   *  
   * @param  maxStack与这些Code属性对应的方法的最大堆栈大小； 
   * 如果不是Code属性，则为-1。 
   *  
   * @param  maxLocals对应于这些Code属性的方法的最大局部变量数； 
   * 如果不是Code属性，则为-1。 
   *  
   * @param 输出必须在其中写入属性的位置。 
   * 
   */
  final void putAttributes(
      final SymbolTable symbolTable,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals,
      final ByteVector output) {
    final ClassWriter classWriter = symbolTable.classWriter;
    Attribute attribute = this;
    while (attribute != null) {
      ByteVector attributeContent =
          attribute.write(classWriter, code, codeLength, maxStack, maxLocals);
      // Put attribute_name_index and attribute_length.
      output.putShort(symbolTable.addConstantUtf8(attribute.type)).putInt(attributeContent.length);
      output.putByteArray(attributeContent.data, 0, attributeContent.length);
      attribute = attribute.nextAttribute;
    }
  }

  /**
   * Puts all the attributes that correspond to the given field, method or class access flags and
   * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param accessFlags some field, method or class access flags.
   * @param signatureIndex the constant pool index of a field, method of class signature.
   * @param output where the attributes must be written.
   */
  /**
   * 将与给定字段，方法或类访问标志和签名对应的所有属性放在给定的字节向量中。 
   * 每个属性包括6个标头字节（attribute_name_index和attribute_length）。 
   *  
   * @param  symbolTable必须存储属性中使用的常量的位置。 
   *  
   * @param  accessFlags一些字段，方法或类访问标志。 
   *  
   * @param  signatureIndex字段的常量池索引，类签名的方法。 
   *  
   * @param 输出必须在其中写入属性的位置。 
   * 
   */
  static void putAttributes(
      final SymbolTable symbolTable,
      final int accessFlags,
      final int signatureIndex,
      final ByteVector output) {
    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0
        && symbolTable.getMajorVersion() < Opcodes.V1_5) {
      output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);
    }
    if (signatureIndex != 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))
          .putInt(2)
          .putShort(signatureIndex);
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);
    }
  }

  /** A set of attribute prototypes (attributes with the same type are considered equal). */
  /**
   * 一组属性原型（具有相同类型的属性被视为相等）。 
   * 
   */
  static final class Set {

    private static final int SIZE_INCREMENT = 6;

    private int size;
    private Attribute[] data = new Attribute[SIZE_INCREMENT];

    void addAttributes(final Attribute attributeList) {
      Attribute attribute = attributeList;
      while (attribute != null) {
        if (!contains(attribute)) {
          add(attribute);
        }
        attribute = attribute.nextAttribute;
      }
    }

    Attribute[] toArray() {
      Attribute[] result = new Attribute[size];
      System.arraycopy(data, 0, result, 0, size);
      return result;
    }

    private boolean contains(final Attribute attribute) {
      for (int i = 0; i < size; ++i) {
        if (data[i].type.equals(attribute.type)) {
          return true;
        }
      }
      return false;
    }

    private void add(final Attribute attribute) {
      if (size >= data.length) {
        Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];
        System.arraycopy(data, 0, newData, 0, size);
        data = newData;
      }
      data[size++] = attribute;
    }
  }
}
