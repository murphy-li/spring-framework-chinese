/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.core.testfixture.codec;

import java.util.Map;
import java.util.function.Consumer;

import org.junit.jupiter.api.Test;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.test.StepVerifier;

import org.springframework.core.ResolvableType;
import org.springframework.core.codec.Encoder;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.MimeType;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.core.io.buffer.DataBufferUtils.release;

/**
 * Abstract base class for {@link Encoder} unit tests. Subclasses need to implement
 * {@link #canEncode()} and {@link #encode()}, possibly using the wide
 *  * variety of helper methods like {@link #testEncodeAll}.
 *
 * @author Arjen Poutsma
 * @since 5.1.3
 */
/**
 * {@link  Encoder}单元测试的抽象基类。 
 * 子类需要实现{@link  #canEncode（）}和{@link  #encode（）}，可能使用各种辅助方法，例如{@link  #testEncodeAll}。 
 *  @author  Arjen Poutsma @自5.1.3起
 */
public abstract class AbstractEncoderTests<E extends Encoder<?>> extends AbstractLeakCheckingTests {

	/**
	 * The encoder to test.
	 */
	/**
	 * 编码器进行测试。 
	 * 
	 */
	protected final E encoder;


	/**
	 * Construct a new {@code AbstractEncoderTestCase} for the given parameters.
	 * @param encoder the encoder
	 */
	/**
	 * 为给定参数构造一个新的{@code  AbstractEncoderTestCase}。 
	 *  
	 * @param 编码器编码器
	 */
	protected AbstractEncoderTests(E encoder) {

		Assert.notNull(encoder, "Encoder must not be null");

		this.encoder = encoder;
	}


	/**
	 * Subclasses should implement this method to test {@link Encoder#canEncode}.
	 */
	/**
	 * 子类应实现此方法以测试{@link  Encoder＃canEncode}。 
	 * 
	 */
	@Test
	public abstract void canEncode() throws Exception;

	/**
	 * Subclasses should implement this method to test {@link Encoder#encode}, possibly using
	 * {@link #testEncodeAll} or other helper methods.
	 */
	/**
	 * 子类应实现此方法以测试{@link  Encoder＃encode}，可能使用{@link  #testEncodeAll}或其他辅助方法。 
	 * 
	 */
	@Test
	public abstract void encode() throws Exception;


	/**
	 * Helper methods that tests for a variety of encoding scenarios. This methods
	 * invokes:
	 * <ul>
	 *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>
	 * </ul>
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputClass the input class
	 * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output
	 * @param <T> the output type
	 */
	/**
	 * 测试各种编码方案的辅助方法。 
	 * 此方法调用：<ul> <li> {<@link> #testEncode（Publisher，ResolvableType，Consumer，MimeType，Map）} </ li> <li> {<@link> #testEncodeError（Publisher，ResolvableType，MimeType，地图）} </ li> <li> {<@link> #testEncodeCancel（发布者，ResolvableType，MimeType，地图）} </ li> <li> {<@link> #testEncodeEmpty（ResolvableType，MimeType，地图）} < / li> </ ul> 
	 * @param 输入要提供给编码器的输入
	 * @param  inputClass输入类
	 * @param  step消费者使用{{@link> plain StepVerifier verify}输出<
	 * @param > <T>输出类型
	 */
	protected <T> void testEncodeAll(Publisher<? extends T> input, Class<? extends T> inputClass,
			Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {
		testEncodeAll(input, ResolvableType.forClass(inputClass), stepConsumer, null, null);
	}

	/**
	 * Helper methods that tests for a variety of decoding scenarios. This methods
	 * invokes:
	 * <ul>
	 *     <li>{@link #testEncode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>
	 *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>
	 * </ul>
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputType the input type
	 * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output
	 * @param mimeType the mime type to use for decoding. May be {@code null}.
	 * @param hints the hints used for decoding. May be {@code null}.
	 * @param <T> the output type
	 */
	/**
	 * 测试各种解码方案的辅助方法。 
	 * 此方法调用：<ul> <li> {<@link> #testEncode（Publisher，ResolvableType，Consumer，MimeType，Map）} </ li> <li> {<@link> #testEncodeError（Publisher，ResolvableType，MimeType，地图）} </ li> <li> {<@link> #testEncodeCancel（发布商，ResolvableType，MimeType，地图）} </ li> <li> {<@link> #testEncodeEmpty（ResolvableType，MimeType，地图）} < / li> </ ul> 
	 * @param 输入要提供给编码器的输入
	 * @param  inputType输入类型
	 * @param  step消费者使用{{@link> plain StepVerifier verify}输出<
	 * @param > mime键入用于解码的mime类型。 
	 * 可能为{@code  null}。 
	 *  
	 * @param 提示用于解码的提示。 
	 * 可能为{@code  null}。 
	 *  
	 * @param  <T>输出类型
	 */
	protected <T> void testEncodeAll(Publisher<? extends T> input, ResolvableType inputType,
			Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {
		testEncode(input, inputType, stepConsumer, mimeType, hints);
		testEncodeError(input, inputType, mimeType, hints);
		testEncodeCancel(input, inputType, mimeType, hints);
		testEncodeEmpty(inputType, mimeType, hints);
	}

	/**
	 * Test a standard {@link Encoder#encode encode} scenario.
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputClass the input class
	 * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output
	 * @param <T> the output type
	 */
	/**
	 * 测试标准的{@link  Encoder＃encode编码}方案。 
	 *  
	 * @param 输入要提供给编码器的输入
	 * @param  inputClass输入类
	 * @param  step消费者使用{{@link> plain StepVerifier verify}输出
	 * @param  <T>输出类型
	 */
	protected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass,
			Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {
		testEncode(input, ResolvableType.forClass(inputClass), stepConsumer, null, null);
	}

	/**
	 * Test a standard {@link Encoder#encode encode} scenario.
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputType the input type
	 * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output
	 * @param mimeType the mime type to use for decoding. May be {@code null}.
	 * @param hints the hints used for decoding. May be {@code null}.
	 * @param <T> the output type
	 */
	/**
	 * 测试标准的{@link  Encoder＃encode编码}方案。 
	 *  
	 * @param 输入要提供给编码器的输入
	 * @param  inputType输入类型
	 * @param  step消费者使用{{@link> plain StepVerifier verify}输出
	 * @param  mimeType要使用的mime类型用于解码。 
	 * 可能为{@code  null}。 
	 *  
	 * @param 提示用于解码的提示。 
	 * 可能为{@code  null}。 
	 *  
	 * @param  <T>输出类型
	 */
	protected <T> void testEncode(Publisher<? extends T> input, ResolvableType inputType,
			Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {

		Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType,
				mimeType, hints);
		StepVerifier.FirstStep<DataBuffer> step = StepVerifier.create(result);
		stepConsumer.accept(step);
	}

	/**
	 * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.
	 * This test method will feed the first element of the {@code input} stream to the encoder,
	 * followed by an {@link InputException}.
	 * The result is expected to contain one "normal" element, followed by the error.
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputType the input type
	 * @param mimeType the mime type to use for decoding. May be {@code null}.
	 * @param hints the hints used for decoding. May be {@code null}.
	 * @see InputException
	 */
	/**
	 * 测试一个{@link  Encoder＃encode encode}方案，其中输入流包含一个错误。 
	 * 此测试方法会将{@code  input}流的第一个元素馈送到编码器，然后是{@link  InputException}。 
	 * 结果应包含一个"正常"元素，后跟错误。 
	 *  
	 * @param 输入要提供给编码器的输入
	 * @param  inputType输入类型
	 * @param  mimeType用于解码的mime类型。 
	 * 可能为{@code  null}。 
	 *  
	 * @param 提示用于解码的提示。 
	 * 可能为{@code  null}。 
	 *  
	 * @see  InputException
	 */
	protected void testEncodeError(Publisher<?> input, ResolvableType inputType,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {

		input = Flux.concat(
				Flux.from(input).take(1),
				Flux.error(new InputException()));

		Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType,
				mimeType, hints);

		StepVerifier.create(result)
				.consumeNextWith(DataBufferUtils::release)
				.expectError(InputException.class)
				.verify();
	}

	/**
	 * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.
	 * This test method will feed the first element of the {@code input} stream to the decoder,
	 * followed by a cancel signal.
	 * The result is expected to contain one "normal" element.
	 *
	 * @param input the input to be provided to the encoder
	 * @param inputType the input type
	 * @param mimeType the mime type to use for decoding. May be {@code null}.
	 * @param hints the hints used for decoding. May be {@code null}.
	 */
	/**
	 * 测试一个{@link  Encoder＃encode编码}方案，其中输入流被取消。 
	 * 此测试方法会将{@code  input}流的第一个元素馈送到解码器，然后是取消信号。 
	 * 预期结果将包含一个"正常"元素。 
	 *  
	 * @param 输入要提供给编码器的输入
	 * @param  inputType输入类型
	 * @param  mimeType用于解码的mime类型。 
	 * 可能为{@code  null}。 
	 *  
	 * @param 提示用于解码的提示。 
	 * 可能为{@code  null}。 
	 * 
	 */
	protected void testEncodeCancel(Publisher<?> input, ResolvableType inputType,
			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {

		Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType,
				hints);

		StepVerifier.create(result)
				.consumeNextWith(DataBufferUtils::release)
				.thenCancel()
				.verify();
	}

	/**
	 * Test a {@link Encoder#encode encode} scenario where the input stream is empty.
	 * The output is expected to be empty as well.
	 *
	 * @param inputType the input type
	 * @param mimeType the mime type to use for decoding. May be {@code null}.
	 * @param hints the hints used for decoding. May be {@code null}.
	 */
	/**
	 * 测试一个{@link  Encoder＃encode编码}方案，其中输入流为空。 
	 * 预计输出也将为空。 
	 *  
	 * @param  inputType输入类型
	 * @param  mimeType用于解码的mime类型。 
	 * 可能为{@code  null}。 
	 *  
	 * @param 提示用于解码的提示。 
	 * 可能为{@code  null}。 
	 * 
	 */
	protected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType,
			@Nullable Map<String, Object> hints) {

		Flux<?> input = Flux.empty();
		Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType,
				mimeType, hints);

		StepVerifier.create(result)
				.verifyComplete();
	}

	/**
	 * Create a result consumer that expects the given bytes.
	 * @param expected the expected bytes
	 * @return a consumer that expects the given data buffer to be equal to {@code expected}
	 */
	/**
	 * 创建一个期望给定字节的结果使用者。 
	 *  
	 * @param 预期的预期字节
	 * @return 消费者，预期给定的数据缓冲区等于{@code 预期的}
	 */
	protected final Consumer<DataBuffer> expectBytes(byte[] expected) {
		return dataBuffer -> {
			byte[] resultBytes = new byte[dataBuffer.readableByteCount()];
			dataBuffer.read(resultBytes);
			release(dataBuffer);
			assertThat(resultBytes).isEqualTo(expected);
		};
	}

	/**
	 * Create a result consumer that expects the given string, using the UTF-8 encoding.
	 * @param expected the expected string
	 * @return a consumer that expects the given data buffer to be equal to {@code expected}
	 */
	/**
	 * 使用UTF-8编码创建期望给定字符串的结果使用者。 
	 *  
	 * @param 预期的预期字符串
	 * @return 消费者，预期给定的数据缓冲区等于{@code 预期的}
	 */
	protected Consumer<DataBuffer> expectString(String expected) {
		return dataBuffer -> {
			byte[] resultBytes = new byte[dataBuffer.readableByteCount()];
			dataBuffer.read(resultBytes);
			release(dataBuffer);
			String actual = new String(resultBytes, UTF_8);
			assertThat(actual).isEqualTo(expected);
		};

	}

	@SuppressWarnings("unchecked")
	private <T> Encoder<T> encoder() {
		return (Encoder<T>) this.encoder;

	}

	/**
	 * Exception used in {@link #testEncodeError}.
	 */
	/**
	 * {@link  #testEncodeError}中使用的异常。 
	 * 
	 */
	@SuppressWarnings("serial")
	public static class InputException extends RuntimeException {

	}

}
