/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.concurrent;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.support.DelegatingErrorHandlingRunnable;
import org.springframework.scheduling.support.TaskUtils;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;

/**
 * {@link org.springframework.beans.factory.FactoryBean} that sets up
 * a {@link java.util.concurrent.ScheduledExecutorService}
 * (by default: a {@link java.util.concurrent.ScheduledThreadPoolExecutor})
 * and exposes it for bean references.
 *
 * <p>Allows for registration of {@link ScheduledExecutorTask ScheduledExecutorTasks},
 * automatically starting the {@link ScheduledExecutorService} on initialization and
 * cancelling it on destruction of the context. In scenarios that only require static
 * registration of tasks at startup, there is no need to access the
 * {@link ScheduledExecutorService} instance itself in application code at all;
 * {@code ScheduledExecutorFactoryBean} is then just being used for lifecycle integration.
 *
 * <p>For an alternative, you may set up a {@link ScheduledThreadPoolExecutor} instance
 * directly using constructor injection, or use a factory method definition that points
 * to the {@link java.util.concurrent.Executors} class.
 * <b>This is strongly recommended in particular for common {@code @Bean} methods in
 * configuration classes, where this {@code FactoryBean} variant would force you to
 * return the {@code FactoryBean} type instead of {@code ScheduledExecutorService}.</b>
 *
 * <p>Note that {@link java.util.concurrent.ScheduledExecutorService}
 * uses a {@link Runnable} instance that is shared between repeated executions,
 * in contrast to Quartz which instantiates a new Job for each execution.
 *
 * <p><b>WARNING:</b> {@link Runnable Runnables} submitted via a native
 * {@link java.util.concurrent.ScheduledExecutorService} are removed from
 * the execution schedule once they throw an exception. If you would prefer
 * to continue execution after such an exception, switch this FactoryBean's
 * {@link #setContinueScheduledExecutionAfterException "continueScheduledExecutionAfterException"}
 * property to "true".
 *
 * @author Juergen Hoeller
 * @since 2.0
 * @see #setPoolSize
 * @see #setRemoveOnCancelPolicy
 * @see #setThreadFactory
 * @see ScheduledExecutorTask
 * @see java.util.concurrent.ScheduledExecutorService
 * @see java.util.concurrent.ScheduledThreadPoolExecutor
 */
/**
 * {@link  org.springframework.beans.factory.FactoryBean}设置了一个{@link  java.util.concurrent.ScheduledExecutorService}（默认情况下：一个{@link  java.util.concurrent.ScheduledThreadPoolExecutor} ）并将其公开以供bean参考。 
 *  <p>允许注册{@link  ScheduledExecutorTask ScheduledExecutorTasks}，并在初始化时自动启动{@link  ScheduledExecutorService}，并在破坏上下文时将其取消。 
 * 在只需要在启动时静态注册任务的情况下，根本不需要在应用程序代码中访问{@link  ScheduledExecutorService}实例本身。 
 * 然后，将{@code  ScheduledExecutorFactoryBean}用于生命周期集成。 
 *  <p>作为替代方案，您可以直接使用构造函数注入来设置{@link  ScheduledThreadPoolExecutor}实例，或使用指向{@link  java.util.concurrent.Executors}类的工厂方法定义。 
 *  <b>强烈建议这样做，尤其是对于配置类中的常见{@code  @Bean}方法而言，这种{@code  FactoryBean}变体将迫使您返回{@code  FactoryBean}类型而不是{@code  ScheduledExecutorService}。 
 * </ b> <p>请注意，与重复执行相比，{<@link> java.util.concurrent.ScheduledExecutorService}使用在重复执行之间共享的{@link  Runnable}实例。 
 *  Quartz会为每个执行实例化一个新的Job。 
 *  <p> <b>警告：</ b>一旦发生异常，通过本地{@link  java.util.concurrent.ScheduledExecutorService}提交的{@link  Runnable Runnables}将从执行计划中删除。 
 * 如果您希望在此类异常后继续执行，请将此FactoryBean的{@link  #setContinueScheduledExecutionAfterException"continueScheduledExecutionAfterException"}属性切换为"true"。 
 *  @author  Juergen Hoeller @since 2.0起
 * @see  #setPoolSize 
 * @see  #setRemoveOnCancelPolicy 
 * @see  #setThreadFactory 
 * @see  ScheduledExecutorTask 
 * @see  java.util.concurrent.ScheduledExecutorService 
 * @see  java.util .concurrent.ScheduledThreadPoolExecutor
 */
@SuppressWarnings("serial")
public class ScheduledExecutorFactoryBean extends ExecutorConfigurationSupport
		implements FactoryBean<ScheduledExecutorService> {

	private int poolSize = 1;

	@Nullable
	private ScheduledExecutorTask[] scheduledExecutorTasks;

	private boolean removeOnCancelPolicy = false;

	private boolean continueScheduledExecutionAfterException = false;

	private boolean exposeUnconfigurableExecutor = false;

	@Nullable
	private ScheduledExecutorService exposedExecutor;


	/**
	 * Set the ScheduledExecutorService's pool size.
	 * Default is 1.
	 */
	/**
	 * 设置ScheduledExecutorService的池大小。 
	 * 默认值为1。 
	 * 
	 */
	public void setPoolSize(int poolSize) {
		Assert.isTrue(poolSize > 0, "'poolSize' must be 1 or higher");
		this.poolSize = poolSize;
	}

	/**
	 * Register a list of ScheduledExecutorTask objects with the ScheduledExecutorService
	 * that this FactoryBean creates. Depending on each ScheduledExecutorTask's settings,
	 * it will be registered via one of ScheduledExecutorService's schedule methods.
	 * @see java.util.concurrent.ScheduledExecutorService#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)
	 * @see java.util.concurrent.ScheduledExecutorService#scheduleWithFixedDelay(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)
	 * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate(java.lang.Runnable, long, long, java.util.concurrent.TimeUnit)
	 */
	/**
	 * 使用此FactoryBean创建的ScheduledExecutorService注册ScheduledExecutorTask对象的列表。 
	 * 根据每个ScheduledExecutorTask的设置，将通过ScheduledExecutorService的计划方法之一进行注册。 
	 *  
	 * @see  java.util.concurrent.ScheduledExecutorService＃schedule（java.lang.Runnable，long，java.util.concurrent.TimeUnit）
	 * @see  java.util.concurrent.ScheduledExecutorService＃scheduleWithFixedDelay（java.lang.Runnable， long，long，java.util.concurrent.TimeUnit）
	 * @see  java.util.concurrent.ScheduledExecutorService＃scheduleAtFixedRate（java.lang.Runnable，long，long，java.util.concurrent.TimeUnit）
	 */
	public void setScheduledExecutorTasks(ScheduledExecutorTask... scheduledExecutorTasks) {
		this.scheduledExecutorTasks = scheduledExecutorTasks;
	}

	/**
	 * Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}.
	 * <p>Default is {@code false}. If set to {@code true}, the target executor will be
	 * switched into remove-on-cancel mode (if possible, with a soft fallback otherwise).
	 */
	/**
	 * 在{@link  ScheduledThreadPoolExecutor}上设置取消删除模式。 
	 *  <p>默认值为{@code  false}。 
	 * 如果设置为{@code  true}，则目标执行程序将切换到取消删除模式（如果可能，否则进行软备用）。 
	 * 
	 */
	public void setRemoveOnCancelPolicy(boolean removeOnCancelPolicy) {
		this.removeOnCancelPolicy = removeOnCancelPolicy;
	}

	/**
	 * Specify whether to continue the execution of a scheduled task
	 * after it threw an exception.
	 * <p>Default is "false", matching the native behavior of a
	 * {@link java.util.concurrent.ScheduledExecutorService}.
	 * Switch this flag to "true" for exception-proof execution of each task,
	 * continuing scheduled execution as in the case of successful execution.
	 * @see java.util.concurrent.ScheduledExecutorService#scheduleAtFixedRate
	 */
	/**
	 * 指定引发异常后是否继续执行计划任务。 
	 *  <p>默认值为"false"，与{@link  java.util.concurrent.ScheduledExecutorService}的本机行为匹配。 
	 * 将此标志切换为"true"以执行每个任务的防异常处理，并像成功执行一样继续计划的执行。 
	 *  
	 * @see  java.util.concurrent.ScheduledExecutorService＃scheduleAtFixedRate
	 */
	public void setContinueScheduledExecutionAfterException(boolean continueScheduledExecutionAfterException) {
		this.continueScheduledExecutionAfterException = continueScheduledExecutionAfterException;
	}

	/**
	 * Specify whether this FactoryBean should expose an unconfigurable
	 * decorator for the created executor.
	 * <p>Default is "false", exposing the raw executor as bean reference.
	 * Switch this flag to "true" to strictly prevent clients from
	 * modifying the executor's configuration.
	 * @see java.util.concurrent.Executors#unconfigurableScheduledExecutorService
	 */
	/**
	 * 指定此FactoryBean是否应为创建的执行程序公开不可配置的装饰器。 
	 *  <p>默认为"false"，将原始执行程序公开为bean引用。 
	 * 将此标志切换为"true"以严格防止客户端修改执行程序的配置。 
	 *  
	 * @see  java.util.concurrent.Executors＃unconfigurableScheduledExecutorService
	 */
	public void setExposeUnconfigurableExecutor(boolean exposeUnconfigurableExecutor) {
		this.exposeUnconfigurableExecutor = exposeUnconfigurableExecutor;
	}


	@Override
	protected ExecutorService initializeExecutor(
			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {

		ScheduledExecutorService executor =
				createExecutor(this.poolSize, threadFactory, rejectedExecutionHandler);

		if (this.removeOnCancelPolicy) {
			if (executor instanceof ScheduledThreadPoolExecutor) {
				((ScheduledThreadPoolExecutor) executor).setRemoveOnCancelPolicy(true);
			}
			else {
				logger.debug("Could not apply remove-on-cancel policy - not a ScheduledThreadPoolExecutor");
			}
		}

		// Register specified ScheduledExecutorTasks, if necessary.
		if (!ObjectUtils.isEmpty(this.scheduledExecutorTasks)) {
			registerTasks(this.scheduledExecutorTasks, executor);
		}

		// Wrap executor with an unconfigurable decorator.
		this.exposedExecutor = (this.exposeUnconfigurableExecutor ?
				Executors.unconfigurableScheduledExecutorService(executor) : executor);

		return executor;
	}

	/**
	 * Create a new {@link ScheduledExecutorService} instance.
	 * <p>The default implementation creates a {@link ScheduledThreadPoolExecutor}.
	 * Can be overridden in subclasses to provide custom {@link ScheduledExecutorService} instances.
	 * @param poolSize the specified pool size
	 * @param threadFactory the ThreadFactory to use
	 * @param rejectedExecutionHandler the RejectedExecutionHandler to use
	 * @return a new ScheduledExecutorService instance
	 * @see #afterPropertiesSet()
	 * @see java.util.concurrent.ScheduledThreadPoolExecutor
	 */
	/**
	 * 创建一个新的{@link  ScheduledExecutorService}实例。 
	 *  <p>默认实现创建一个{@link  ScheduledThreadPoolExecutor}。 
	 * 可以在子类中重写以提供自定义{@link  ScheduledExecutorService}实例。 
	 *  
	 * @param  poolSize指定的池大小
	 * @param  threadFactory使用的ThreadFactory 
	 * @param  rejectedExecutionHandler RejectedExecutionHandler使用
	 * @return 一个新的ScheduledExecutorService实例
	 * @see  #afterPropertiesSet（）
	 * @see  java.util .concurrent.ScheduledThreadPoolExecutor
	 */
	protected ScheduledExecutorService createExecutor(
			int poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {

		return new ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler);
	}

	/**
	 * Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks}
	 * on the given {@link ScheduledExecutorService}.
	 * @param tasks the specified ScheduledExecutorTasks (never empty)
	 * @param executor the ScheduledExecutorService to register the tasks on.
	 */
	/**
	 * 在给定的{@link  ScheduledExecutorService}上注册指定的{@link  ScheduledExecutorTask ScheduledExecutorTasks}。 
	 *  
	 * @param 任务指定的ScheduledExecutorTasks（从不为空）
	 * @param 执行者ScheduledExecutorService在其上注册任务。 
	 * 
	 */
	protected void registerTasks(ScheduledExecutorTask[] tasks, ScheduledExecutorService executor) {
		for (ScheduledExecutorTask task : tasks) {
			Runnable runnable = getRunnableToSchedule(task);
			if (task.isOneTimeTask()) {
				executor.schedule(runnable, task.getDelay(), task.getTimeUnit());
			}
			else {
				if (task.isFixedRate()) {
					executor.scheduleAtFixedRate(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());
				}
				else {
					executor.scheduleWithFixedDelay(runnable, task.getDelay(), task.getPeriod(), task.getTimeUnit());
				}
			}
		}
	}

	/**
	 * Determine the actual Runnable to schedule for the given task.
	 * <p>Wraps the task's Runnable in a
	 * {@link org.springframework.scheduling.support.DelegatingErrorHandlingRunnable}
	 * that will catch and log the Exception. If necessary, it will suppress the
	 * Exception according to the
	 * {@link #setContinueScheduledExecutionAfterException "continueScheduledExecutionAfterException"}
	 * flag.
	 * @param task the ScheduledExecutorTask to schedule
	 * @return the actual Runnable to schedule (may be a decorator)
	 */
	/**
	 * 确定为给定任务安排的实际Runnable。 
	 *  <p>将任务的Runnable包装在{@link  org.springframework.scheduling.support.DelegatingErrorHandlingRunnable}中，该异常将捕获并记录异常。 
	 * 如有必要，它将根据{@link  #setContinueScheduledExecutionAfterException"continueScheduledExecutionAfterException"}标志来抑制该异常。 
	 *  
	 * @param 任务，安排ScheduledExecutorTask计划
	 * @return 实际运行的Runnable计划（可能是装饰器）
	 */
	protected Runnable getRunnableToSchedule(ScheduledExecutorTask task) {
		return (this.continueScheduledExecutionAfterException ?
				new DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER) :
				new DelegatingErrorHandlingRunnable(task.getRunnable(), TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER));
	}


	@Override
	@Nullable
	public ScheduledExecutorService getObject() {
		return this.exposedExecutor;
	}

	@Override
	public Class<? extends ScheduledExecutorService> getObjectType() {
		return (this.exposedExecutor != null ? this.exposedExecutor.getClass() : ScheduledExecutorService.class);
	}

	@Override
	public boolean isSingleton() {
		return true;
	}

}
