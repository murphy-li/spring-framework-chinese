/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.concurrent;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;

/**
 * Base class for setting up a {@link java.util.concurrent.ExecutorService}
 * (typically a {@link java.util.concurrent.ThreadPoolExecutor} or
 * {@link java.util.concurrent.ScheduledThreadPoolExecutor}).
 * Defines common configuration settings and common lifecycle handling.
 *
 * @author Juergen Hoeller
 * @since 3.0
 * @see java.util.concurrent.ExecutorService
 * @see java.util.concurrent.Executors
 * @see java.util.concurrent.ThreadPoolExecutor
 * @see java.util.concurrent.ScheduledThreadPoolExecutor
 */
/**
 * 设置{@link  java.util.concurrent.ExecutorService}的基类（通常是{@link  java.util.concurrent.ThreadPoolExecutor}或{@link  java.util.concurrent.ScheduledThreadPoolExecutor}） 。 
 * 定义通用配置设置和通用生命周期处理。 
 *  @author  Juergen Hoeller @since 3.0起
 * @see  java.util.concurrent.ExecutorService 
 * @see  java.util.concurrent.Executors 
 * @see  java.util.concurrent.ThreadPoolExecutor 
 * @see  java.util。 
 *  parallel.ScheduledThreadPoolExecutor
 */
@SuppressWarnings("serial")
public abstract class ExecutorConfigurationSupport extends CustomizableThreadFactory
		implements BeanNameAware, InitializingBean, DisposableBean {

	protected final Log logger = LogFactory.getLog(getClass());

	private ThreadFactory threadFactory = this;

	private boolean threadNamePrefixSet = false;

	private RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.AbortPolicy();

	private boolean waitForTasksToCompleteOnShutdown = false;

	private long awaitTerminationMillis = 0;

	@Nullable
	private String beanName;

	@Nullable
	private ExecutorService executor;


	/**
	 * Set the ThreadFactory to use for the ExecutorService's thread pool.
	 * Default is the underlying ExecutorService's default thread factory.
	 * <p>In a Java EE 7 or other managed environment with JSR-236 support,
	 * consider specifying a JNDI-located ManagedThreadFactory: by default,
	 * to be found at "java:comp/DefaultManagedThreadFactory".
	 * Use the "jee:jndi-lookup" namespace element in XML or the programmatic
	 * {@link org.springframework.jndi.JndiLocatorDelegate} for convenient lookup.
	 * Alternatively, consider using Spring's {@link DefaultManagedAwareThreadFactory}
	 * with its fallback to local threads in case of no managed thread factory found.
	 * @see java.util.concurrent.Executors#defaultThreadFactory()
	 * @see javax.enterprise.concurrent.ManagedThreadFactory
	 * @see DefaultManagedAwareThreadFactory
	 */
	/**
	 * 设置ThreadFactory以用于ExecutorService的线程池。 
	 * 默认是基础ExecutorService的默认线程工厂。 
	 *  <p>在具有JSR-236支持的Java EE 7或其他托管环境中，请考虑指定位于JNDI的ManagedThreadFactory：默认情况下位于"java：comp / DefaultManagedThreadFactory"中。 
	 * 使用XML中的"jee：jndi-lookup"命名空间元素或程序化的{@link  org.springframework.jndi.JndiLocatorDelegate}可以方便地进行查找。 
	 * 或者，考虑在未找到托管线程工厂的情况下，使用Spring的{@link  DefaultManagedAwareThreadFactory}及其后援到本地线程。 
	 *  
	 * @see  java.util.concurrent.Executors＃defaultThreadFactory（）
	 * @see  javax.enterprise.concurrent.ManagedThreadFactory 
	 * @see  DefaultManagedAwareThreadFactory
	 */
	public void setThreadFactory(@Nullable ThreadFactory threadFactory) {
		this.threadFactory = (threadFactory != null ? threadFactory : this);
	}

	@Override
	public void setThreadNamePrefix(@Nullable String threadNamePrefix) {
		super.setThreadNamePrefix(threadNamePrefix);
		this.threadNamePrefixSet = true;
	}

	/**
	 * Set the RejectedExecutionHandler to use for the ExecutorService.
	 * Default is the ExecutorService's default abort policy.
	 * @see java.util.concurrent.ThreadPoolExecutor.AbortPolicy
	 */
	/**
	 * 设置RejectedExecutionHandler以用于ExecutorService。 
	 * 默认是ExecutorService的默认中止策略。 
	 *  
	 * @see  java.util.concurrent.ThreadPoolExecutor.AbortPolicy
	 */
	public void setRejectedExecutionHandler(@Nullable RejectedExecutionHandler rejectedExecutionHandler) {
		this.rejectedExecutionHandler =
				(rejectedExecutionHandler != null ? rejectedExecutionHandler : new ThreadPoolExecutor.AbortPolicy());
	}

	/**
	 * Set whether to wait for scheduled tasks to complete on shutdown,
	 * not interrupting running tasks and executing all tasks in the queue.
	 * <p>Default is "false", shutting down immediately through interrupting
	 * ongoing tasks and clearing the queue. Switch this flag to "true" if you
	 * prefer fully completed tasks at the expense of a longer shutdown phase.
	 * <p>Note that Spring's container shutdown continues while ongoing tasks
	 * are being completed. If you want this executor to block and wait for the
	 * termination of tasks before the rest of the container continues to shut
	 * down - e.g. in order to keep up other resources that your tasks may need -,
	 * set the {@link #setAwaitTerminationSeconds "awaitTerminationSeconds"}
	 * property instead of or in addition to this property.
	 * @see java.util.concurrent.ExecutorService#shutdown()
	 * @see java.util.concurrent.ExecutorService#shutdownNow()
	 */
	/**
	 * 设置是否等待计划的任务在关闭时完成，而不中断正在运行的任务并执行队列中的所有任务。 
	 *  <p>默认值为"false"，通过中断正在进行的任务并清除队列立即关闭。 
	 * 如果您希望完全完成的任务而又花费较长的关闭阶段，则将此标志切换为"true"。 
	 *  <p>请注意，在完成正在进行的任务时，Spring的容器将继续关闭。 
	 * 如果您希望该执行程序阻塞并等待任务终止，然后容器的其余部分继续关闭-例如为了保持您的任务可能需要的其他资源-，请设置{@link  #setAwaitTerminationSeconds"awaitTerminationSeconds"}属性，以代替或附加此属性。 
	 *  
	 * @see  java.util.concurrent.ExecutorService＃shutdown（）
	 * @see  java.util.concurrent.ExecutorService＃shutdownNow（）
	 */
	public void setWaitForTasksToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown) {
		this.waitForTasksToCompleteOnShutdown = waitForJobsToCompleteOnShutdown;
	}

	/**
	 * Set the maximum number of seconds that this executor is supposed to block
	 * on shutdown in order to wait for remaining tasks to complete their execution
	 * before the rest of the container continues to shut down. This is particularly
	 * useful if your remaining tasks are likely to need access to other resources
	 * that are also managed by the container.
	 * <p>By default, this executor won't wait for the termination of tasks at all.
	 * It will either shut down immediately, interrupting ongoing tasks and clearing
	 * the remaining task queue - or, if the
	 * {@link #setWaitForTasksToCompleteOnShutdown "waitForTasksToCompleteOnShutdown"}
	 * flag has been set to {@code true}, it will continue to fully execute all
	 * ongoing tasks as well as all remaining tasks in the queue, in parallel to
	 * the rest of the container shutting down.
	 * <p>In either case, if you specify an await-termination period using this property,
	 * this executor will wait for the given time (max) for the termination of tasks.
	 * As a rule of thumb, specify a significantly higher timeout here if you set
	 * "waitForTasksToCompleteOnShutdown" to {@code true} at the same time,
	 * since all remaining tasks in the queue will still get executed - in contrast
	 * to the default shutdown behavior where it's just about waiting for currently
	 * executing tasks that aren't reacting to thread interruption.
	 * @see #setAwaitTerminationMillis
	 * @see java.util.concurrent.ExecutorService#shutdown()
	 * @see java.util.concurrent.ExecutorService#awaitTermination
	 */
	/**
	 * 设置执行程序在关闭时应阻塞的最大秒数，以等待其余任务完成其执行，然后容器的其余部分继续关闭。 
	 * 如果您剩余的任务可能需要访问也由容器管理的其他资源，则此功能特别有用。 
	 *  <p>默认情况下，该执行程序根本不会等待任务终止。 
	 * 它将立即关闭，中断正在进行的任务并清除剩余的任务队列-或，如果{@link  #setWaitForTasksToCompleteOnShutdown"waitForTasksToCompleteOnShutdown"}标志设置为{@code  true}，它将继续完全运行执行所有正在进行的任务以及队列中所有剩余的任务，同时关闭其余的容器。 
	 *  <p>在任何一种情况下，如果您使用此属性指定一个等待终止时间，则该执行程序将等待给定时间（最长）以终止任务。 
	 * 根据经验，如果同时将"waitForTasksToCompleteOnShutdown"设置为{@code  true}，请在此处指定更高的超时时间，因为队列中的所有其余任务仍将被执行-与默认的关闭行为相反它只是在等待当前对线程中断没有反应的正在执行的任务。 
	 *  
	 * @see  #setAwaitTerminationMillis 
	 * @see  java.util.concurrent.ExecutorService＃shutdown（）
	 * @see  java.util.concurrent.ExecutorService＃awaitTermination
	 */
	public void setAwaitTerminationSeconds(int awaitTerminationSeconds) {
		this.awaitTerminationMillis = awaitTerminationSeconds * 1000;
	}

	/**
	 * Variant of {@link #setAwaitTerminationSeconds} with millisecond precision.
	 * @since 5.2.4
	 * @see #setAwaitTerminationSeconds
	 */
	/**
	 * {@link  #setAwaitTerminationSeconds}的变体，以毫秒为单位。 
	 *  @since 5.2.4 
	 * @see  #setAwaitTerminationSeconds
	 */
	public void setAwaitTerminationMillis(long awaitTerminationMillis) {
		this.awaitTerminationMillis = awaitTerminationMillis;
	}

	@Override
	public void setBeanName(String name) {
		this.beanName = name;
	}


	/**
	 * Calls {@code initialize()} after the container applied all property values.
	 * @see #initialize()
	 */
	/**
	 * 容器应用所有属性值后，调用{@code  initialize（）}。 
	 *  
	 * @see  #initialize（）
	 */
	@Override
	public void afterPropertiesSet() {
		initialize();
	}

	/**
	 * Set up the ExecutorService.
	 */
	/**
	 * 设置ExecutorService。 
	 * 
	 */
	public void initialize() {
		if (logger.isInfoEnabled()) {
			logger.info("Initializing ExecutorService" + (this.beanName != null ? " '" + this.beanName + "'" : ""));
		}
		if (!this.threadNamePrefixSet && this.beanName != null) {
			setThreadNamePrefix(this.beanName + "-");
		}
		this.executor = initializeExecutor(this.threadFactory, this.rejectedExecutionHandler);
	}

	/**
	 * Create the target {@link java.util.concurrent.ExecutorService} instance.
	 * Called by {@code afterPropertiesSet}.
	 * @param threadFactory the ThreadFactory to use
	 * @param rejectedExecutionHandler the RejectedExecutionHandler to use
	 * @return a new ExecutorService instance
	 * @see #afterPropertiesSet()
	 */
	/**
	 * 创建目标{@link  java.util.concurrent.ExecutorService}实例。 
	 * 由{@code  afterPropertiesSet}调用。 
	 *  
	 * @param  threadFactory ThreadFactory使用
	 * @param  rejectedExecutionHandler RejectedExecutionHandler使用
	 * @return 一个新的ExecutorService实例
	 * @see  #afterPropertiesSet（）
	 */
	protected abstract ExecutorService initializeExecutor(
			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler);


	/**
	 * Calls {@code shutdown} when the BeanFactory destroys
	 * the task executor instance.
	 * @see #shutdown()
	 */
	/**
	 * BeanFactory销毁任务执行程序实例时，调用{@code  shutdown}。 
	 *  
	 * @see  #shutdown（）
	 */
	@Override
	public void destroy() {
		shutdown();
	}

	/**
	 * Perform a shutdown on the underlying ExecutorService.
	 * @see java.util.concurrent.ExecutorService#shutdown()
	 * @see java.util.concurrent.ExecutorService#shutdownNow()
	 */
	/**
	 * 对基础ExecutorService执行关闭。 
	 *  
	 * @see  java.util.concurrent.ExecutorService＃shutdown（）
	 * @see  java.util.concurrent.ExecutorService＃shutdownNow（）
	 */
	public void shutdown() {
		if (logger.isInfoEnabled()) {
			logger.info("Shutting down ExecutorService" + (this.beanName != null ? " '" + this.beanName + "'" : ""));
		}
		if (this.executor != null) {
			if (this.waitForTasksToCompleteOnShutdown) {
				this.executor.shutdown();
			}
			else {
				for (Runnable remainingTask : this.executor.shutdownNow()) {
					cancelRemainingTask(remainingTask);
				}
			}
			awaitTerminationIfNecessary(this.executor);
		}
	}

	/**
	 * Cancel the given remaining task which never commended execution,
	 * as returned from {@link ExecutorService#shutdownNow()}.
	 * @param task the task to cancel (typically a {@link RunnableFuture})
	 * @since 5.0.5
	 * @see #shutdown()
	 * @see RunnableFuture#cancel(boolean)
	 */
	/**
	 * 从{@link  ExecutorService＃shutdownNow（）}返回的结果中，取消从未执行的给定剩余任务。 
	 *  
	 * @param 任务取消任务的任务（通常为{@link  RunnableFuture}）@5.0.5起
	 * @see  #shutdown（）
	 * @see  RunnableFuture＃cancel（boolean）
	 */
	protected void cancelRemainingTask(Runnable task) {
		if (task instanceof Future) {
			((Future<?>) task).cancel(true);
		}
	}

	/**
	 * Wait for the executor to terminate, according to the value of the
	 * {@link #setAwaitTerminationSeconds "awaitTerminationSeconds"} property.
	 */
	/**
	 * 根据{@link  #setAwaitTerminationSeconds"awaitTerminationSeconds"}属性的值，等待执行程序终止。 
	 * 
	 */
	private void awaitTerminationIfNecessary(ExecutorService executor) {
		if (this.awaitTerminationMillis > 0) {
			try {
				if (!executor.awaitTermination(this.awaitTerminationMillis, TimeUnit.MILLISECONDS)) {
					if (logger.isWarnEnabled()) {
						logger.warn("Timed out while waiting for executor" +
								(this.beanName != null ? " '" + this.beanName + "'" : "") + " to terminate");
					}
				}
			}
			catch (InterruptedException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Interrupted while waiting for executor" +
							(this.beanName != null ? " '" + this.beanName + "'" : "") + " to terminate");
				}
				Thread.currentThread().interrupt();
			}
		}
	}

}
