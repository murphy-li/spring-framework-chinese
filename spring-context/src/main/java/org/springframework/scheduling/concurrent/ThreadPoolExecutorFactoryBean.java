/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.concurrent;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;

/**
 * JavaBean that allows for configuring a {@link java.util.concurrent.ThreadPoolExecutor}
 * in bean style (through its "corePoolSize", "maxPoolSize", "keepAliveSeconds",
 * "queueCapacity" properties) and exposing it as a bean reference of its native
 * {@link java.util.concurrent.ExecutorService} type.
 *
 * <p>The default configuration is a core pool size of 1, with unlimited max pool size
 * and unlimited queue capacity. This is roughly equivalent to
 * {@link java.util.concurrent.Executors#newSingleThreadExecutor()}, sharing a single
 * thread for all tasks. Setting {@link #setQueueCapacity "queueCapacity"} to 0 mimics
 * {@link java.util.concurrent.Executors#newCachedThreadPool()}, with immediate scaling
 * of threads in the pool to a potentially very high number. Consider also setting a
 * {@link #setMaxPoolSize "maxPoolSize"} at that point, as well as possibly a higher
 * {@link #setCorePoolSize "corePoolSize"} (see also the
 * {@link #setAllowCoreThreadTimeOut "allowCoreThreadTimeOut"} mode of scaling).
 *
 * <p>For an alternative, you may set up a {@link ThreadPoolExecutor} instance directly
 * using constructor injection, or use a factory method definition that points to the
 * {@link java.util.concurrent.Executors} class.
 * <b>This is strongly recommended in particular for common {@code @Bean} methods in
 * configuration classes, where this {@code FactoryBean} variant would force you to
 * return the {@code FactoryBean} type instead of the actual {@code Executor} type.</b>
 *
 * <p>If you need a timing-based {@link java.util.concurrent.ScheduledExecutorService}
 * instead, consider {@link ScheduledExecutorFactoryBean}.

 * @author Juergen Hoeller
 * @since 3.0
 * @see java.util.concurrent.ExecutorService
 * @see java.util.concurrent.Executors
 * @see java.util.concurrent.ThreadPoolExecutor
 */
/**
 * 允许以bean样式配置{@link  java.util.concurrent.ThreadPoolExecutor}的JavaBean（通过其"corePoolSize"，"maxPoolSize"，"keepAliveSeconds"，"queueCapacity"属性），并将其作为Bean引用公开其本机{@link  java.util.concurrent.ExecutorService}类型。 
 *  <p>默认配置是核心池大小为1，最大池大小不受限制，队列容量不受限制。 
 * 这大致相当于{@link  java.util.concurrent.Executors＃newSingleThreadExecutor（）}，为所有任务共享一个线程。 
 * 将{@link  #setQueueCapacity"queueCapacity"}设置为0可以模拟{@link  java.util.concurrent.Executors＃newCachedThreadPool（）}，并立即将池中的线程扩展到可能非常高的数量。 
 * 考虑在此同时设置一个{@link  #setMaxPoolSize"maxPoolSize"}，以及更高的{@link  #setCorePoolSize"corePoolSize"}（另请参见{@link  #setAllowCoreThreadTimeOut"allowCoreThreadTimeOut"}缩放模式）。 
 *  <p>作为替代方案，您可以直接使用构造函数注入来设置{@link  ThreadPoolExecutor}实例，或者使用指向{@link  java.util.concurrent.Executors}类的工厂方法定义。 
 *  <b>强烈建议这样做，尤其是对于配置类中的常见{@code  @Bean}方法而言，这种{@code  FactoryBean}变体将迫使您返回{@code  FactoryBean}类型而不是实际的{@code  Executor}类型。 
 * </ b> <p>如果您需要基于时间的{@link  java.util.concurrent.ScheduledExecutorService}，请考虑使用{@link  ScheduledExecutorFactoryBean}。 
 *  @author  Juergen Hoeller @since 3.0 
 * @see  java.util.concurrent.ExecutorService 
 * @see  java.util.concurrent.Executors 
 * @see  java.util.concurrent.ThreadPoolExecutor
 */
@SuppressWarnings("serial")
public class ThreadPoolExecutorFactoryBean extends ExecutorConfigurationSupport
		implements FactoryBean<ExecutorService>, InitializingBean, DisposableBean {

	private int corePoolSize = 1;

	private int maxPoolSize = Integer.MAX_VALUE;

	private int keepAliveSeconds = 60;

	private boolean allowCoreThreadTimeOut = false;

	private int queueCapacity = Integer.MAX_VALUE;

	private boolean exposeUnconfigurableExecutor = false;

	@Nullable
	private ExecutorService exposedExecutor;


	/**
	 * Set the ThreadPoolExecutor's core pool size.
	 * Default is 1.
	 */
	/**
	 * 设置ThreadPoolExecutor的核心池大小。 
	 * 默认值为1。 
	 * 
	 */
	public void setCorePoolSize(int corePoolSize) {
		this.corePoolSize = corePoolSize;
	}

	/**
	 * Set the ThreadPoolExecutor's maximum pool size.
	 * Default is {@code Integer.MAX_VALUE}.
	 */
	/**
	 * 设置ThreadPoolExecutor的最大池大小。 
	 * 默认值为{@code  Integer.MAX_VALUE}。 
	 * 
	 */
	public void setMaxPoolSize(int maxPoolSize) {
		this.maxPoolSize = maxPoolSize;
	}

	/**
	 * Set the ThreadPoolExecutor's keep-alive seconds.
	 * Default is 60.
	 */
	/**
	 * 设置ThreadPoolExecutor的keep-alive秒。 
	 * 默认值为60。 
	 * 
	 */
	public void setKeepAliveSeconds(int keepAliveSeconds) {
		this.keepAliveSeconds = keepAliveSeconds;
	}

	/**
	 * Specify whether to allow core threads to time out. This enables dynamic
	 * growing and shrinking even in combination with a non-zero queue (since
	 * the max pool size will only grow once the queue is full).
	 * <p>Default is "false".
	 * @see java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)
	 */
	/**
	 * 指定是否允许核心线程超时。 
	 * 即使与非零队列结合使用，这也可以实现动态增长和收缩（因为最大池大小仅在队列已满时才会增长）。 
	 *  <p>默认为"false"。 
	 *  
	 * @see  java.util.concurrent.ThreadPoolExecutor＃allowCoreThreadTimeOut（boolean）
	 */
	public void setAllowCoreThreadTimeOut(boolean allowCoreThreadTimeOut) {
		this.allowCoreThreadTimeOut = allowCoreThreadTimeOut;
	}

	/**
	 * Set the capacity for the ThreadPoolExecutor's BlockingQueue.
	 * Default is {@code Integer.MAX_VALUE}.
	 * <p>Any positive value will lead to a LinkedBlockingQueue instance;
	 * any other value will lead to a SynchronousQueue instance.
	 * @see java.util.concurrent.LinkedBlockingQueue
	 * @see java.util.concurrent.SynchronousQueue
	 */
	/**
	 * 设置ThreadPoolExecutor的BlockingQueue的容量。 
	 * 默认值为{@code  Integer.MAX_VALUE}。 
	 *  <p>任何正值将导致LinkedBlockingQueue实例； 
	 * 其他任何值都将导致SynchronousQueue实例。 
	 *  
	 * @see  java.util.concurrent.LinkedBlockingQueue 
	 * @see  java.util.concurrent.SynchronousQueue
	 */
	public void setQueueCapacity(int queueCapacity) {
		this.queueCapacity = queueCapacity;
	}

	/**
	 * Specify whether this FactoryBean should expose an unconfigurable
	 * decorator for the created executor.
	 * <p>Default is "false", exposing the raw executor as bean reference.
	 * Switch this flag to "true" to strictly prevent clients from
	 * modifying the executor's configuration.
	 * @see java.util.concurrent.Executors#unconfigurableExecutorService
	 */
	/**
	 * 指定此FactoryBean是否应为创建的执行程序公开不可配置的装饰器。 
	 *  <p>默认为"false"，将原始执行程序公开为bean引用。 
	 * 将此标志切换为"true"以严格防止客户端修改执行程序的配置。 
	 *  
	 * @see  java.util.concurrent.Executors＃unconfigurableExecutorService
	 */
	public void setExposeUnconfigurableExecutor(boolean exposeUnconfigurableExecutor) {
		this.exposeUnconfigurableExecutor = exposeUnconfigurableExecutor;
	}


	@Override
	protected ExecutorService initializeExecutor(
			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {

		BlockingQueue<Runnable> queue = createQueue(this.queueCapacity);
		ThreadPoolExecutor executor  = createExecutor(this.corePoolSize, this.maxPoolSize,
				this.keepAliveSeconds, queue, threadFactory, rejectedExecutionHandler);
		if (this.allowCoreThreadTimeOut) {
			executor.allowCoreThreadTimeOut(true);
		}

		// Wrap executor with an unconfigurable decorator.
		this.exposedExecutor = (this.exposeUnconfigurableExecutor ?
				Executors.unconfigurableExecutorService(executor) : executor);

		return executor;
	}

	/**
	 * Create a new instance of {@link ThreadPoolExecutor} or a subclass thereof.
	 * <p>The default implementation creates a standard {@link ThreadPoolExecutor}.
	 * Can be overridden to provide custom {@link ThreadPoolExecutor} subclasses.
	 * @param corePoolSize the specified core pool size
	 * @param maxPoolSize the specified maximum pool size
	 * @param keepAliveSeconds the specified keep-alive time in seconds
	 * @param queue the BlockingQueue to use
	 * @param threadFactory the ThreadFactory to use
	 * @param rejectedExecutionHandler the RejectedExecutionHandler to use
	 * @return a new ThreadPoolExecutor instance
	 * @see #afterPropertiesSet()
	 */
	/**
	 * 创建{@link  ThreadPoolExecutor}或其子类的新实例。 
	 *  <p>默认实现创建一个标准的{@link  ThreadPoolExecutor}。 
	 * 可以重写以提供自定义的{@link  ThreadPoolExecutor}子类。 
	 *  
	 * @param  corePoolSize指定的核心池大小
	 * @param  maxPoolSize指定的最大池大小
	 * @param  keepAlive将指定的保持活动时间以秒为单位
	 * @param 将BlockingQueue排队使用
	 * @param  threadFactory使用
	 * @param  rejectedExecutionHandler和RejectedExecutionHandler来使用
	 * @return 一个新的ThreadPoolExecutor实例
	 * @see  #afterPropertiesSet（）
	 */
	protected ThreadPoolExecutor createExecutor(
			int corePoolSize, int maxPoolSize, int keepAliveSeconds, BlockingQueue<Runnable> queue,
			ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {

		return new ThreadPoolExecutor(corePoolSize, maxPoolSize,
				keepAliveSeconds, TimeUnit.SECONDS, queue, threadFactory, rejectedExecutionHandler);
	}

	/**
	 * Create the BlockingQueue to use for the ThreadPoolExecutor.
	 * <p>A LinkedBlockingQueue instance will be created for a positive
	 * capacity value; a SynchronousQueue else.
	 * @param queueCapacity the specified queue capacity
	 * @return the BlockingQueue instance
	 * @see java.util.concurrent.LinkedBlockingQueue
	 * @see java.util.concurrent.SynchronousQueue
	 */
	/**
	 * 创建用于ThreadPoolExecutor的BlockingQueue。 
	 *  <p>将为一个正的容量值创建一个LinkedBlockingQueue实例； 
	 * 一个SynchronousQueue。 
	 *  
	 * @param  queueCapacity指定的队列容量
	 * @return  BlockingQueue实例
	 * @see  java.util.concurrent.LinkedBlockingQueue 
	 * @see  java.util.concurrent.SynchronousQueue
	 */
	protected BlockingQueue<Runnable> createQueue(int queueCapacity) {
		if (queueCapacity > 0) {
			return new LinkedBlockingQueue<>(queueCapacity);
		}
		else {
			return new SynchronousQueue<>();
		}
	}


	@Override
	@Nullable
	public ExecutorService getObject() {
		return this.exposedExecutor;
	}

	@Override
	public Class<? extends ExecutorService> getObjectType() {
		return (this.exposedExecutor != null ? this.exposedExecutor.getClass() : ExecutorService.class);
	}

	@Override
	public boolean isSingleton() {
		return true;
	}

}
