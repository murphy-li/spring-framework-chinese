/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.scheduling.annotation;

import java.lang.annotation.Annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.annotation.AdviceMode;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.Ordered;

/**
 * Enables Spring's asynchronous method execution capability, similar to functionality
 * found in Spring's {@code <task:*>} XML namespace.
 *
 * <p>To be used together with @{@link Configuration Configuration} classes as follows,
 * enabling annotation-driven async processing for an entire Spring application context:
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;EnableAsync
 * public class AppConfig {
 *
 * }</pre>
 *
 * {@code MyAsyncBean} is a user-defined type with one or more methods annotated with
 * either Spring's {@code @Async} annotation, the EJB 3.1 {@code @javax.ejb.Asynchronous}
 * annotation, or any custom annotation specified via the {@link #annotation} attribute.
 * The aspect is added transparently for any registered bean, for instance via this
 * configuration:
 *
 * <pre class="code">
 * &#064;Configuration
 * public class AnotherAppConfig {
 *
 *     &#064;Bean
 *     public MyAsyncBean asyncBean() {
 *         return new MyAsyncBean();
 *     }
 * }</pre>
 *
 * <p>By default, Spring will be searching for an associated thread pool definition:
 * either a unique {@link org.springframework.core.task.TaskExecutor} bean in the context,
 * or an {@link java.util.concurrent.Executor} bean named "taskExecutor" otherwise. If
 * neither of the two is resolvable, a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}
 * will be used to process async method invocations. Besides, annotated methods having a
 * {@code void} return type cannot transmit any exception back to the caller. By default,
 * such uncaught exceptions are only logged.
 *
 * <p>To customize all this, implement {@link AsyncConfigurer} and provide:
 * <ul>
 * <li>your own {@link java.util.concurrent.Executor Executor} through the
 * {@link AsyncConfigurer#getAsyncExecutor getAsyncExecutor()} method, and</li>
 * <li>your own {@link org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler
 * AsyncUncaughtExceptionHandler} through the {@link AsyncConfigurer#getAsyncUncaughtExceptionHandler
 * getAsyncUncaughtExceptionHandler()}
 * method.</li>
 * </ul>
 *
 * <p><b>NOTE: {@link AsyncConfigurer} configuration classes get initialized early
 * in the application context bootstrap. If you need any dependencies on other beans
 * there, make sure to declare them 'lazy' as far as possible in order to let them
 * go through other post-processors as well.</b>
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;EnableAsync
 * public class AppConfig implements AsyncConfigurer {
 *
 *     &#064;Override
 *     public Executor getAsyncExecutor() {
 *         ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
 *         executor.setCorePoolSize(7);
 *         executor.setMaxPoolSize(42);
 *         executor.setQueueCapacity(11);
 *         executor.setThreadNamePrefix("MyExecutor-");
 *         executor.initialize();
 *         return executor;
 *     }
 *
 *     &#064;Override
 *     public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
 *         return new MyAsyncUncaughtExceptionHandler();
 *     }
 * }</pre>
 *
 * <p>If only one item needs to be customized, {@code null} can be returned to
 * keep the default settings. Consider also extending from {@link AsyncConfigurerSupport}
 * when possible.
 *
 * <p>Note: In the above example the {@code ThreadPoolTaskExecutor} is not a fully managed
 * Spring bean. Add the {@code @Bean} annotation to the {@code getAsyncExecutor()} method
 * if you want a fully managed bean. In such circumstances it is no longer necessary to
 * manually call the {@code executor.initialize()} method as this will be invoked
 * automatically when the bean is initialized.
 *
 * <p>For reference, the example above can be compared to the following Spring XML
 * configuration:
 *
 * <pre class="code">
 * &lt;beans&gt;
 *
 *     &lt;task:annotation-driven executor="myExecutor" exception-handler="exceptionHandler"/&gt;
 *
 *     &lt;task:executor id="myExecutor" pool-size="7-42" queue-capacity="11"/&gt;
 *
 *     &lt;bean id="asyncBean" class="com.foo.MyAsyncBean"/&gt;
 *
 *     &lt;bean id="exceptionHandler" class="com.foo.MyAsyncUncaughtExceptionHandler"/&gt;
 *
 * &lt;/beans&gt;
 * </pre>
 *
 * The above XML-based and JavaConfig-based examples are equivalent except for the
 * setting of the <em>thread name prefix</em> of the {@code Executor}; this is because
 * the {@code <task:executor>} element does not expose such an attribute. This
 * demonstrates how the JavaConfig-based approach allows for maximum configurability
 * through direct access to actual componentry.
 *
 * <p>The {@link #mode} attribute controls how advice is applied: If the mode is
 * {@link AdviceMode#PROXY} (the default), then the other attributes control the behavior
 * of the proxying. Please note that proxy mode allows for interception of calls through
 * the proxy only; local calls within the same class cannot get intercepted that way.
 *
 * <p>Note that if the {@linkplain #mode} is set to {@link AdviceMode#ASPECTJ}, then the
 * value of the {@link #proxyTargetClass} attribute will be ignored. Note also that in
 * this case the {@code spring-aspects} module JAR must be present on the classpath, with
 * compile-time weaving or load-time weaving applying the aspect to the affected classes.
 * There is no proxy involved in such a scenario; local calls will be intercepted as well.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @author Sam Brannen
 * @since 3.1
 * @see Async
 * @see AsyncConfigurer
 * @see AsyncConfigurationSelector
 */
/**
 * 启用S​​pring的异步方法执行功能，类似于Spring的{<< @code >> <task：>} XML名称空间中的功能。 
 *  <p>如下所述与@{<< @link >> Configuration Configuration}类一起使用，从而为整个Spring应用程序上下文启用注释驱动的异步处理：<pre class ="code"> @Configuration @EnableAsync公共类AppConfig {} </ pre> {<< @code >> MyAsyncBean}是一种用户定义的类型，具有一个或多个方法，这些方法使用Spring的{<< @code >> @Async}注解EJB 3.1 {<< @code >> @javax.ejb.Asynchronous}注释，或通过{<< @link >> #annotation}属性指定的任何自定义注释。 
 * 例如，通过以下配置，可以为任何注册的bean透明地添加该方面：<pre class ="code"> @Configuration公共类AnotherAppConfig {@Bean public MyAsyncBean asyncBean（）{return new MyAsyncBean（）; }} </ pre> <p>默认情况下，Spring将搜索关联的线程池定义：在上下文中是唯一的{<< @link >> org.springframework.core.task.TaskExecutor} bean，或者是否则，将{<< @link >> java.util.concurrent.Executor} bean命名为"taskExecutor"。 
 * 如果这两个都不可解析，则将使用{<< @link >> org.springframework.core.task.SimpleAsyncTaskExecutor}处理异步方法调用。 
 * 此外，具有{<< @code >> void}返回类型的带注释的方法无法将任何异常发送回调用方。 
 * 默认情况下，仅记录此类未捕获的异常。 
 *  <p>要自定义所有这些，请实现{<< @link >> AsyncConfigurer}并通过{<<提供您自己的{<< @link >> java.util.concurrent.Executor Executor}。 
 *  @link >> AsyncConfigurer＃getAsyncExecutor getAsyncExecutor（）}方法和</ li> <li>您自己的{<< @link >> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler AsyncUncaughtExceptionHandler}通过{<< @link >> AsyncConfigurer＃getAsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler（）}方法。 
 * </ li> </ ul> <p> <b>注意：{<< @link >> AsyncConfigurer}配置类在应用程序上下文引导程序的早期初始化。 
 * 如果您需要在那里依赖于其他bean，请确保尽可能将它们声明为"惰性"，以使它们也可以通过其他后处理器。 
 * </ b> <pre class ="code"> @Configuration @EnableAsync公共类AppConfig实现AsyncConfigurer {@Override public Executor getAsyncExecutor（）{ThreadPoolTask​​Executor executor = new ThreadPoolTask​​Executor（）; executor.setCorePoolSize（7）; executor.setMaxPoolSize（42）; executor.setQueueCapacity（11）; executor.setThreadNamePrefix（"MyExecutor-"）; executor.initialize（）;返回执行人； 
 *  } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler（）{返回新的MyAsyncUncaughtExceptionHandler（）; }} </ pre> <p>如果仅需要自定义一项，则可以返回{<< @code >> null}以保留默认设置。 
 * 考虑尽可能从{<< @link >> AsyncConfigurerSupport}扩展。 
 *  <p>注意：在上面的示例中，{<< @code >> ThreadPoolTask​​Executor}不是完全托管的Spring bean。 
 * 如果要使用完全托管的bean，请将{<< @code >> @Bean}注解添加到{<< @code >> getAsyncExecutor（）}方法中。 
 * 在这种情况下，不再需要手动调用{<< @code >> executor.initialize（）}方法，因为在初始化bean时将自动调用该方法。 
 *  <p>作为参考，可以将上面的示例与以下Spring XML配置进行比较：<pre class ="code"> <beans> <task：annotation驱动的executor ="myExecutor"exception-handler ="exceptionHandler"/> <task：executor id ="myExecutor"pool-size ="7-42"queue-capacity ="11"/> <bean id ="asyncBean"class ="com.foo.MyAsyncBean"/> <bean id ="exceptionHandler"class ="com.foo.MyAsyncUncaughtExceptionHandler"/> </ beans> </ pre>上述基于XML和基于JavaConfig的示例是等效的，只是设置了<em> thread name prefix </ em> {<< @code >>执行器}； 
 * 这是因为{<< @code >> <task：executor>}元素没有公开这样的属性。 
 * 这说明了基于JavaConfig的方法如何通过直接访问实际组件来实现最大的可配置性。 
 *  <p> {<< @link >> #mode}属性控制如何应用建议：如果模式为{<< @link >> AdviceMode＃PROXY}（默认设置），则其他属性控制建议的行为。 
 * 代理。 
 * 请注意，代理模式仅允许通过代理拦截呼叫； 
 * 同一类中的本地调用无法以这种方式被拦截。 
 *  <p>请注意，如果将{<< @link >> plain #mode}设置为{<< @link >> AdviceMode＃ASPECTJ}，则{<< @link >> #proxyTargetClass}属性的值将被忽略。 
 * 还要注意，在这种情况下，{<< @code >> spring-aspects}模块JAR必须存在于类路径中，并通过编译时编织或加载时编织将方面应用于受影响的类。 
 * 在这种情况下不涉及任何代理； 
 * 本地电话也会被拦截
 */
/**
 * << @author >>克里斯·比姆斯（Chris Beams）<< @author >> Juergen Hoeller << @author >>斯蒂芬·尼科尔（Stephane Nicoll）<< @author >> Sam Brannen @since 3.1起// 
 * @see >> Async << 
 * @see >> AsyncConfigurer < <
 * @see >> AsyncConfigurationSelector
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AsyncConfigurationSelector.class)
public @interface EnableAsync {

	/**
	 * Indicate the 'async' annotation type to be detected at either class
	 * or method level.
	 * <p>By default, both Spring's @{@link Async} annotation and the EJB 3.1
	 * {@code @javax.ejb.Asynchronous} annotation will be detected.
	 * <p>This attribute exists so that developers can provide their own
	 * custom annotation type to indicate that a method (or all methods of
	 * a given class) should be invoked asynchronously.
	 */
	/**
	 * 指示要在类或方法级别检测到的"异步"注释类型。 
	 *  <p>默认情况下，将同时检测Spring的@{<@link> Async}注释和EJB 3.1 {@code  @javax.ejb.Asynchronous}注释。 
	 *  <p>此属性存在，以便开发人员可以提供自己的自定义注释类型，以指示应异步调用一个方法（或给定类的所有方法）。 
	 * 
	 */
	Class<? extends Annotation> annotation() default Annotation.class;

	/**
	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
	 * to standard Java interface-based proxies.
	 * <p><strong>Applicable only if the {@link #mode} is set to {@link AdviceMode#PROXY}</strong>.
	 * <p>The default is {@code false}.
	 * <p>Note that setting this attribute to {@code true} will affect <em>all</em>
	 * Spring-managed beans requiring proxying, not just those marked with {@code @Async}.
	 * For example, other beans marked with Spring's {@code @Transactional} annotation
	 * will be upgraded to subclass proxying at the same time. This approach has no
	 * negative impact in practice unless one is explicitly expecting one type of proxy
	 * vs. another &mdash; for example, in tests.
	 */
	/**
	 * 指示与基于标准Java接口的代理相反，是否要创建基于子类（CGLIB）的代理。 
	 *  <p> <strong>仅在{@link  #mode}设置为{@link  AdviceMode＃PROXY} </ strong>时适用。 
	 *  <p>默认值为{@code  false}。 
	 *  <p>请注意，将此属性设置为{@code  true}将影响<em>所有</ em>需要代理的Spring管理的bean，而不仅仅是标记为{@code  @Async}的bean。 
	 * 例如，其他标有Spring的{@code  @Transactional}注释的bean将同时升级为子类代理。 
	 * 这种方法在实践中不会产生负面影响，除非有人明确期望一种类型的代理与另一种类型的代理（例如在测试中）。 
	 * 
	 */
	boolean proxyTargetClass() default false;

	/**
	 * Indicate how async advice should be applied.
	 * <p><b>The default is {@link AdviceMode#PROXY}.</b>
	 * Please note that proxy mode allows for interception of calls through the proxy
	 * only. Local calls within the same class cannot get intercepted that way; an
	 * {@link Async} annotation on such a method within a local call will be ignored
	 * since Spring's interceptor does not even kick in for such a runtime scenario.
	 * For a more advanced mode of interception, consider switching this to
	 * {@link AdviceMode#ASPECTJ}.
	 */
	/**
	 * 指示应如何应用异步建议。 
	 *  <p> <b>默认值为{@link  AdviceMode＃PROXY}。 
	 * </ b>请注意，代理模式仅允许通过代理拦截呼叫。 
	 * 同一类中的本地调用不能以这种方式被拦截； 
	 * 在本地调用中，此类方法上的{@link  Async}注释将被忽略，因为对于这种运行时场景，Spring的拦截器甚至不会启动。 
	 * 有关更高级的拦截模式，请考虑将其切换为{@link  AdviceMode＃ASPECTJ}。 
	 * 
	 */
	AdviceMode mode() default AdviceMode.PROXY;

	/**
	 * Indicate the order in which the {@link AsyncAnnotationBeanPostProcessor}
	 * should be applied.
	 * <p>The default is {@link Ordered#LOWEST_PRECEDENCE} in order to run
	 * after all other post-processors, so that it can add an advisor to
	 * existing proxies rather than double-proxy.
	 */
	/**
	 * 指示应应用{@link  AsyncAnnotationBeanPostProcessor}的顺序。 
	 *  <p>默认为{@link  Ordered＃LOWEST_PRECEDENCE}，以便在所有其他后处理器之后运行，以便它可以为现有代理添加顾问程序，而不是双代理。 
	 * 
	 */
	int order() default Ordered.LOWEST_PRECEDENCE;

}
