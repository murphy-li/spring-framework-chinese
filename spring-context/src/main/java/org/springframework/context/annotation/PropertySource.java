/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.core.io.support.PropertySourceFactory;

/**
 * Annotation providing a convenient and declarative mechanism for adding a
 * {@link org.springframework.core.env.PropertySource PropertySource} to Spring's
 * {@link org.springframework.core.env.Environment Environment}. To be used in
 * conjunction with @{@link Configuration} classes.
 *
 * <h3>Example usage</h3>
 *
 * <p>Given a file {@code app.properties} containing the key/value pair
 * {@code testbean.name=myTestBean}, the following {@code @Configuration} class
 * uses {@code @PropertySource} to contribute {@code app.properties} to the
 * {@code Environment}'s set of {@code PropertySources}.
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;PropertySource("classpath:/com/myco/app.properties")
 * public class AppConfig {
 *
 *     &#064;Autowired
 *     Environment env;
 *
 *     &#064;Bean
 *     public TestBean testBean() {
 *         TestBean testBean = new TestBean();
 *         testBean.setName(env.getProperty("testbean.name"));
 *         return testBean;
 *     }
 * }</pre>
 *
 * <p>Notice that the {@code Environment} object is
 * {@link org.springframework.beans.factory.annotation.Autowired @Autowired} into the
 * configuration class and then used when populating the {@code TestBean} object. Given
 * the configuration above, a call to {@code testBean.getName()} will return "myTestBean".
 *
 * <h3>Resolving <code>${...}</code> placeholders in {@code <bean>} and {@code @Value} annotations</h3>
 *
 * <p>In order to resolve ${...} placeholders in {@code <bean>} definitions or {@code @Value}
 * annotations using properties from a {@code PropertySource}, you must ensure that an
 * appropriate <em>embedded value resolver</em> is registered in the {@code BeanFactory}
 * used by the {@code ApplicationContext}. This happens automatically when using
 * {@code <context:property-placeholder>} in XML. When using {@code @Configuration} classes
 * this can be achieved by explicitly registering a {@code PropertySourcesPlaceholderConfigurer}
 * via a {@code static} {@code @Bean} method. Note, however, that explicit registration
 * of a {@code PropertySourcesPlaceholderConfigurer} via a {@code static} {@code @Bean}
 * method is typically only required if you need to customize configuration such as the
 * placeholder syntax, etc. See the "Working with externalized values" section of
 * {@link Configuration @Configuration}'s javadocs and "a note on
 * BeanFactoryPostProcessor-returning {@code @Bean} methods" of {@link Bean @Bean}'s
 * javadocs for details and examples.
 *
 * <h3>Resolving ${...} placeholders within {@code @PropertySource} resource locations</h3>
 *
 * <p>Any ${...} placeholders present in a {@code @PropertySource} {@linkplain #value()
 * resource location} will be resolved against the set of property sources already
 * registered against the environment. For example:
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
 * public class AppConfig {
 *
 *     &#064;Autowired
 *     Environment env;
 *
 *     &#064;Bean
 *     public TestBean testBean() {
 *         TestBean testBean = new TestBean();
 *         testBean.setName(env.getProperty("testbean.name"));
 *         return testBean;
 *     }
 * }</pre>
 *
 * <p>Assuming that "my.placeholder" is present in one of the property sources already
 * registered, e.g. system properties or environment variables, the placeholder will
 * be resolved to the corresponding value. If not, then "default/path" will be used as a
 * default. Expressing a default value (delimited by colon ":") is optional.  If no
 * default is specified and a property cannot be resolved, an {@code
 * IllegalArgumentException} will be thrown.
 *
 * <h3>A note on property overriding with @PropertySource</h3>
 *
 * <p>In cases where a given property key exists in more than one {@code .properties}
 * file, the last {@code @PropertySource} annotation processed will 'win' and override.
 *
 * <p>For example, given two properties files {@code a.properties} and
 * {@code b.properties}, consider the following two configuration classes
 * that reference them with {@code @PropertySource} annotations:
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;PropertySource("classpath:/com/myco/a.properties")
 * public class ConfigA { }
 *
 * &#064;Configuration
 * &#064;PropertySource("classpath:/com/myco/b.properties")
 * public class ConfigB { }
 * </pre>
 *
 * <p>The override ordering depends on the order in which these classes are registered
 * with the application context.
 *
 * <pre class="code">
 * AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
 * ctx.register(ConfigA.class);
 * ctx.register(ConfigB.class);
 * ctx.refresh();
 * </pre>
 *
 * <p>In the scenario above, the properties in {@code b.properties} will override any
 * duplicates that exist in {@code a.properties}, because {@code ConfigB} was registered
 * last.
 *
 * <p>In certain situations, it may not be possible or practical to tightly control
 * property source ordering when using {@code @PropertySource} annotations. For example,
 * if the {@code @Configuration} classes above were registered via component-scanning,
 * the ordering is difficult to predict. In such cases - and if overriding is important -
 * it is recommended that the user fall back to using the programmatic PropertySource API.
 * See {@link org.springframework.core.env.ConfigurableEnvironment ConfigurableEnvironment}
 * and {@link org.springframework.core.env.MutablePropertySources MutablePropertySources}
 * javadocs for details.
 *
 * <p><b>NOTE: This annotation is repeatable according to Java 8 conventions.</b>
 * However, all such {@code @PropertySource} annotations need to be declared at the same
 * level: either directly on the configuration class or as meta-annotations within the
 * same custom annotation. Mixing of direct annotations and meta-annotations is not
 * recommended since direct annotations will effectively override meta-annotations.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @author Sam Brannen
 * @since 3.1
 * @see PropertySources
 * @see Configuration
 * @see org.springframework.core.env.PropertySource
 * @see org.springframework.core.env.ConfigurableEnvironment#getPropertySources()
 * @see org.springframework.core.env.MutablePropertySources
 */
/**
 * 注释提供了一种方便且声明性的机制，用于将{<< @link >> org.springframework.core.env.PropertySource PropertySource}添加到Spring的{<< @link >> org.springframework.core.env.Environment Environment}中。 
 * 与@{<< @link >> Configuration}类结合使用。 
 *  <h3>用法示例</ h3> <p>给出一个包含键/值对{<< @code >> testbean.name = myTestBean}的文件{<< @code >> app.properties}，下面的{< <@code >> @Configuration}类使用{<< @code >> @PropertySource}将{<< @code >> app.properties}贡献到{<< @code >> Environment}的{< <@code >> PropertySources}。 
 *  <pre class ="code"> @Configuration @PropertySource（"classpath：/com/myco/app.properties"）公共类AppConfig {@Autowired Environment env; @Bean public TestBean testBean（）{TestBean testBean = new TestBean（）; testBean.setName（env.getProperty（"testbean.name"））;返回testBean; }} </ pre> <p>注意，{<< @code >> Environment}对象是{<< @link >> org.springframework.beans.factory.annotation.Autowired @Autowired}进入配置类，然后在填充{<< @code >> TestBean}对象时使用。 
 * 根据上述配置，对{<< @code >> testBean.getName（）}的调用将返回"myTestBean"。 
 *  <h3>在{<< @code >> <bean>}和{<< @code >> @Value}注解中解析<code> $ {...} </ code>占位符</ h3> <p>在要使用{<< @code >> PropertySource}中的属性解析{<< @code >> <bean>}定义或{<< @code >> @Value}注解中的$ {...}占位符，您必须确保在{<< @code >> ApplicationContext}使用的{<< @code >> BeanFactory}中注册了适当的<em>嵌入式值解析器</ em>。 
 * 在XML中使用{<< @code >> <context：property-placeholder>}时，会自动发生这种情况。 
 * 使用{<< @code >> @Configuration}类时，可以通过通过{<< @code >>静态} {<< @code >> @@Bean显式注册{<< @code >> PropertySourcesPlaceholderConfigurer}来实现。 
 *  } 方法。 
 * 但是请注意，通常仅在您需要自定义配置时才需要通过{<< @code >>静态} {<< @code >> @Bean}方法来显式注册{<< @code >> PropertySourcesPlaceholderConfigurer}。 
 * 例如占位符语法等。 
 * 请参见{<< @link >> Configuration @Configuration}的javadocs的"使用外部化的值"一节和"关于BeanFactoryPostProcessor返回{<< @code >> @Bean}的注释"{<< @link >> Bean @Bean}的javadocs的"方法"以获取详细信息和示例。 
 *  <h3>在{<< @code >> @PropertySource}资源位置中解析$ {...}占位符</ h3> <p>在{<< @code >> >>中存在的任何$ {...}占位符PropertySource} {<< @link >> plain #value（）资源位置}将针对已经针对该环境注册的一组属性源进行解析。 
 * 例如：<pre class ="code"> @Configuration @PropertySource（"classpath：/ com / $ {my.placeholder：default / path} /app.properties"）公共类AppConfig {@Autowired Environment env; @Bean public TestBean testBean（）{TestBean testBean = new TestBean（）; testBean.setName（env.getProperty（"testbean.name"））;返回testBean; }} </ pre> <p>假定"my.placeholder"存在于已注册的属性源之一中，例如系统属性或环境变量，则占位符将解析为相应的值。 
 * 如果不是，那么将使用"默认值/路径"作为默认值。 
 * 表示默认值（用冒号"："分隔）是可选的。 
 * 如果未指定默认值且无法解析属性，则将引发{<< @code >> IllegalArgumentException}。 
 *  <h3>有关使用@PropertySource覆盖属性的说明</ h3> <p>如果给定的属性密钥存在于多个{<< @code >> .properties}文件中，则最后一个{<< @code> > @PropertySource}注解将"获胜"并覆盖。 
 *  <p>例如，给定两个属性文件{<< @code >> a.properties}和{<< @code >> b.properties}，请考虑以下两个用{<< @code>引用它们的配置类> @PropertySource}注释：<pre class ="code"> @Configuration @PropertySource（"classpath：/com/myco/a.properties"）公共类ConfigA {} @Configuration @PropertySource（"classpath：/ com / myco / b.properties"）公共类ConfigB {} </ pre> <p>覆盖顺序取决于这些类在应用程序上下文中注册的顺序。 
 *  <pre class ="code"> AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext（）; ctx.register（ConfigA.class）; ctx.register（ConfigB.class）; ctx.refresh（）; </ pre> <p>在上述情况下，{<< @code >> b.properties}中的属性将覆盖{<< @code >> a.properties}中存在的所有重复项，因为{<< @代码>> ConfigB}被最后注册。 
 *  <p>在某些情况下，使用{<< @@code >> @PropertySource}注解来严格控制属性源的顺序可能是不可行的。 
 * 例如，如果上面的{<< @code >> @Configuration}类是通过组件扫描注册的，则顺序很难预测
 */
/**
 * 在这种情况下（如果覆盖很重要），建议用户退回到使用编程式PropertySource API。 
 * 有关详细信息，请参见{<< @link >> org.springframework.core.env.ConfigurableEnvironment}和{<< @link >> org.springframework.core.env.MutablePropertySources MutablePropertySources} javadocs。 
 *  <p> <b>注意：根据Java 8约定，该注解是可重复的。 
 * </ b>但是，所有此类{<< @code >> @PropertySource}注解都必须在同一级别上声明：可以直接在配置类或作为同一自定义注解中的元注解。 
 * 不建议将直接注释和元注释混合使用，因为直接注释将有效地覆盖元注释。 
 *  << @author >> Chris Beams << @author >> Juergen Hoeller << @author >> Phillip Webb << @author >> Sam Brannen @源自3.1 << 
 * @see >> PropertySources << 
 * @see >>配置< <
 * @see >> org.springframework.core.env.PropertySource << 
 * @see >> org.springframework.core.env.ConfigurableEnvironment＃getPropertySources（）<< 
 * @see >> org.springframework.core.env.MutablePropertySources
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {

	/**
	 * Indicate the name of this property source. If omitted, a name will
	 * be generated based on the description of the underlying resource.
	 * @see org.springframework.core.env.PropertySource#getName()
	 * @see org.springframework.core.io.Resource#getDescription()
	 */
	/**
	 * 指示此属性源的名称。 
	 * 如果省略，将根据基础资源的描述生成名称。 
	 *  
	 * @see  org.springframework.core.env.PropertySource＃getName（）
	 * @see  org.springframework.core.io.Resource＃getDescription（）
	 */
	String name() default "";

	/**
	 * Indicate the resource location(s) of the properties file to be loaded.
	 * <p>Both traditional and XML-based properties file formats are supported
	 * &mdash; for example, {@code "classpath:/com/myco/app.properties"}
	 * or {@code "file:/path/to/file.xml"}.
	 * <p>Resource location wildcards (e.g. *&#42;/*.properties) are not permitted;
	 * each location must evaluate to exactly one {@code .properties} resource.
	 * <p>${...} placeholders will be resolved against any/all property sources already
	 * registered with the {@code Environment}. See {@linkplain PropertySource above}
	 * for examples.
	 * <p>Each location will be added to the enclosing {@code Environment} as its own
	 * property source, and in the order declared.
	 */
	/**
	 * 指示要加载的属性文件的资源位置。 
	 *  <p>同时支持传统的和基于XML的属性文件格式，例如{@code "classpath：/com/myco/app.properties"}或{@code "file：/ path / to / file.xml"}。 
	 *  <p>不允许使用资源位置通配符（例如* .properties）； 
	 * 每个位置都必须精确评估为一个{@code  .properties}资源。 
	 *  <p> $ {...}占位符将针对已经在{@code  Environment}中注册的任何/所有属性源进行解析。 
	 * 有关示例，请参见{@link  plain PropertySource}。 
	 *  <p>每个位置都将按照声明的顺序添加到封闭的{@code  Environment}中作为其自己的属性源。 
	 * 
	 */
	String[] value();

	/**
	 * Indicate if failure to find the a {@link #value() property resource} should be
	 * ignored.
	 * <p>{@code true} is appropriate if the properties file is completely optional.
	 * Default is {@code false}.
	 * @since 4.0
	 */
	/**
	 * 指示是否找不到{@link  #value（）属性资源}失败。 
	 * 如果属性文件是完全可选的，则<p> {<@code> true}是合适的。 
	 * 默认值为{@code  false}。 
	 *  @始于4.0
	 */
	boolean ignoreResourceNotFound() default false;

	/**
	 * A specific character encoding for the given resources, e.g. "UTF-8".
	 * @since 4.3
	 */
	/**
	 * 给定资源的特定字符编码，例如"UTF-8"。 
	 *  @4.3起
	 */
	String encoding() default "";

	/**
	 * Specify a custom {@link PropertySourceFactory}, if any.
	 * <p>By default, a default factory for standard resource files will be used.
	 * @since 4.3
	 * @see org.springframework.core.io.support.DefaultPropertySourceFactory
	 * @see org.springframework.core.io.support.ResourcePropertySource
	 */
	/**
	 * 指定自定义{@link  PropertySourceFactory}（如果有）。 
	 *  <p>默认情况下，将使用标准资源文件的默认工厂。 
	 *  @since 4.3 
	 * @see  org.springframework.core.io.support.DefaultPropertySourceFactory 
	 * @see  org.springframework.core.io.support.ResourcePropertySource
	 */
	Class<? extends PropertySourceFactory> factory() default PropertySourceFactory.class;

}
