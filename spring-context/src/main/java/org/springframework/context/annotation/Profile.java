/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.core.env.AbstractEnvironment;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.Profiles;

/**
 * Indicates that a component is eligible for registration when one or more
 * {@linkplain #value specified profiles} are active.
 *
 * <p>A <em>profile</em> is a named logical grouping that may be activated
 * programmatically via {@link ConfigurableEnvironment#setActiveProfiles} or declaratively
 * by setting the {@link AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME
 * spring.profiles.active} property as a JVM system property, as an
 * environment variable, or as a Servlet context parameter in {@code web.xml}
 * for web applications. Profiles may also be activated declaratively in
 * integration tests via the {@code @ActiveProfiles} annotation.
 *
 * <p>The {@code @Profile} annotation may be used in any of the following ways:
 * <ul>
 * <li>as a type-level annotation on any class directly or indirectly annotated with
 * {@code @Component}, including {@link Configuration @Configuration} classes</li>
 * <li>as a meta-annotation, for the purpose of composing custom stereotype annotations</li>
 * <li>as a method-level annotation on any {@link Bean @Bean} method</li>
 * </ul>
 *
 * <p>If a {@code @Configuration} class is marked with {@code @Profile}, all of the
 * {@code @Bean} methods and {@link Import @Import} annotations associated with that class
 * will be bypassed unless one or more of the specified profiles are active. A profile
 * string may contain a simple profile name (for example {@code "p1"}) or a profile
 * expression. A profile expression allows for more complicated profile logic to be
 * expressed, for example {@code "p1 & p2"}. See {@link Profiles#of(String...)} for more
 * details about supported formats.
 *
 * <p>This is analogous to the behavior in Spring XML: if the {@code profile} attribute of
 * the {@code beans} element is supplied e.g., {@code <beans profile="p1,p2">}, the
 * {@code beans} element will not be parsed unless at least profile 'p1' or 'p2' has been
 * activated. Likewise, if a {@code @Component} or {@code @Configuration} class is marked
 * with {@code @Profile({"p1", "p2"})}, that class will not be registered or processed unless
 * at least profile 'p1' or 'p2' has been activated.
 *
 * <p>If a given profile is prefixed with the NOT operator ({@code !}), the annotated
 * component will be registered if the profile is <em>not</em> active &mdash; for example,
 * given {@code @Profile({"p1", "!p2"})}, registration will occur if profile 'p1' is active
 * or if profile 'p2' is <em>not</em> active.
 *
 * <p>If the {@code @Profile} annotation is omitted, registration will occur regardless
 * of which (if any) profiles are active.
 *
 * <p><b>NOTE:</b> With {@code @Profile} on {@code @Bean} methods, a special scenario may
 * apply: In the case of overloaded {@code @Bean} methods of the same Java method name
 * (analogous to constructor overloading), an {@code @Profile} condition needs to be
 * consistently declared on all overloaded methods. If the conditions are inconsistent,
 * only the condition on the first declaration among the overloaded methods will matter.
 * {@code @Profile} can therefore not be used to select an overloaded method with a
 * particular argument signature over another; resolution between all factory methods
 * for the same bean follows Spring's constructor resolution algorithm at creation time.
 * <b>Use distinct Java method names pointing to the same {@link Bean#name bean name}
 * if you'd like to define alternative beans with different profile conditions</b>;
 * see {@code ProfileDatabaseConfig} in {@link Configuration @Configuration}'s javadoc.
 *
 * <p>When defining Spring beans via XML, the {@code "profile"} attribute of the
 * {@code <beans>} element may be used. See the documentation in the
 * {@code spring-beans} XSD (version 3.1 or greater) for details.
 *
 * @author Chris Beams
 * @author Phillip Webb
 * @author Sam Brannen
 * @since 3.1
 * @see ConfigurableEnvironment#setActiveProfiles
 * @see ConfigurableEnvironment#setDefaultProfiles
 * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME
 * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME
 * @see Conditional
 * @see org.springframework.test.context.ActiveProfiles
 */
/**
 * 指示当一个或多个{@link  plain #value指定的配置文件}有效时，组件可以进行注册。 
 *  <p> <em>配置文件</ em>是一个命名的逻辑组，可以通过{@link  ConfigurableEnvironment＃setActiveProfiles}以编程方式激活，也可以通过设置{@link  AbstractEnvironment＃ACTIVE_PROFILES_PROPERTY_NAME spring.profiles.active }属性作为JVM系统属性，环境变量或Web应用程序的{@code  web.xml}中的Servlet上下文参数。 
 * 还可以通过{@code  @ActiveProfiles}注释在集成测试中以声明方式激活配置文件。 
 *  <p> {<@code> @Profile}注解可以通过以下任何一种方式使用：<ul> <li>作为直接或间接由{@code  @Component注解的任何类的类型级别的注解}，其中包括{@link  Configuration @Configuration}类</ li> <li>作为元注释，目的是在任何{上将自定义构造型注释添加为</ li> <li>作为方法级注释@link  Bean @Bean}方法</ li> </ ul> <p>如果{{@code> @Configuration}类标记为{@code  @Profile}，则所有{<@code除非一个或多个指定的配置文件处于活动状态，否则将跳过与该类关联的> @Bean}方法和{@link  Import @Import}注解。 
 * 配置文件字符串可以包含简单的配置文件名称（例如{@code "p1"}）或配置文件表达式。 
 * 配置文件表达式允许表达更复杂的配置文件逻辑，例如{@code "p1＆p2"}。 
 * 有关受支持的格式的更多详细信息，请参见{@link  Profiles＃of（String ...）}。 
 *  <p>这与Spring XML中的行为类似：如果提供了{@code  beans}元素的{@code  profile}属性，例如，{@code  <beans profile ="p1，p2 ">}，将不会解析{@code  beans}元素，除非至少已激活概要文件"p1"或"p2"。 
 * 同样，如果将{@code  @Component}或{@code  @Configuration}类标记为{@code  @Profile（{"p1"，"p2"}）}}，则该类将不会已注册或处理过，除非至少已激活配置文件"p1"或"p2"。 
 *  <p>如果给定的配置文件以NOT运算符（{@code ！ 
 * }）为前缀，则如果配置文件为<em> not </ em>处于活动状态，则注解的组件将被注册-例如，给定的{<@code> @Profile（{"p1"，"！ 
 * p2"}）}}，如果配置文件'p1'是活动的，或者如果配置文件'p2'是<em> </ em>不是活动的，则会进行注册。 
 *  <p>如果省略{@code  @Profile}注解，则无论哪个（如果有）配置文件处于活动状态，都会进行注册。 
 *  <p> <b>注意：</ b>在{@code  @Bean}方法上使用{@code  @Profile}时，可能会出现特殊情况：在重载{@code  @Bean的情况下}具有相同Java方法名称的方法（类似于构造函数重载），需要在所有重载方法上一致声明一个{@code  @Profile}条件。 
 * 如果条件不一致，则只有重载方法中第一个声明的条件才重要。 
 * 因此，{<@code> @Profile}不能用于选择具有特定参数签名的重载方法； 
 * 同一bean的所有工厂方法之间的解析在创建时遵循Spring的构造函数解析算法。 
 *  <b>如果您要定义具有不同概要文件条件的替代bean，请使用指向相同的{@link  Bean＃name bean name}的不同Java方法名称</ b>； 
 * 请参见{@link 配置@Configuration}的javadoc中的{@code  ProfileDatabaseConfig}。 
 *  <p>通过XML定义Spring bean时，可以使用{@code  <beans>}元素的{@code "profile"}属性。 
 * 有关详细信息，请参见{@code  spring-beans} XSD（版本3.1或更高版本）中的文档。 
 *  @author  Chris Beams @author  Phillip Webb @author  Sam Brannen @since 3.1 
 * @see  ConfigurableEnvironment＃setActiveProfiles 
 * @see  ConfigurableEnvironment＃setDefaultProfiles 
 * @see  AbstractEnvironment＃ACTIVE_PROFILES_PROPERTY_NAME 
 * @see  AbstractEnvironment＃DEFA 
 * @see>条件
 * @see  org.springframework.test.context.ActiveProfiles
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(ProfileCondition.class)
public @interface Profile {

	/**
	 * The set of profiles for which the annotated component should be registered.
	 */
	/**
	 * 注释组件应为其注册的配置文件集。 
	 * 
	 */
	String[] value();

}
