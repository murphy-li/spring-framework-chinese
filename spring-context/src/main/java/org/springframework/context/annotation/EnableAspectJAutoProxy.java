/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Enables support for handling components marked with AspectJ's {@code @Aspect} annotation,
 * similar to functionality found in Spring's {@code <aop:aspectj-autoproxy>} XML element.
 * To be used on @{@link Configuration} classes as follows:
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;EnableAspectJAutoProxy
 * public class AppConfig {
 *
 *     &#064;Bean
 *     public FooService fooService() {
 *         return new FooService();
 *     }
 *
 *     &#064;Bean
 *     public MyAspect myAspect() {
 *         return new MyAspect();
 *     }
 * }</pre>
 *
 * Where {@code FooService} is a typical POJO component and {@code MyAspect} is an
 * {@code @Aspect}-style aspect:
 *
 * <pre class="code">
 * public class FooService {
 *
 *     // various methods
 * }</pre>
 *
 * <pre class="code">
 * &#064;Aspect
 * public class MyAspect {
 *
 *     &#064;Before("execution(* FooService+.*(..))")
 *     public void advice() {
 *         // advise FooService methods as appropriate
 *     }
 * }</pre>
 *
 * In the scenario above, {@code @EnableAspectJAutoProxy} ensures that {@code MyAspect}
 * will be properly processed and that {@code FooService} will be proxied mixing in the
 * advice that it contributes.
 *
 * <p>Users can control the type of proxy that gets created for {@code FooService} using
 * the {@link #proxyTargetClass()} attribute. The following enables CGLIB-style 'subclass'
 * proxies as opposed to the default interface-based JDK proxy approach.
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;EnableAspectJAutoProxy(proxyTargetClass=true)
 * public class AppConfig {
 *     // ...
 * }</pre>
 *
 * <p>Note that {@code @Aspect} beans may be component-scanned like any other.
 * Simply mark the aspect with both {@code @Aspect} and {@code @Component}:
 *
 * <pre class="code">
 * package com.foo;
 *
 * &#064;Component
 * public class FooService { ... }
 *
 * &#064;Aspect
 * &#064;Component
 * public class MyAspect { ... }</pre>
 *
 * Then use the @{@link ComponentScan} annotation to pick both up:
 *
 * <pre class="code">
 * &#064;Configuration
 * &#064;ComponentScan("com.foo")
 * &#064;EnableAspectJAutoProxy
 * public class AppConfig {
 *
 *     // no explicit &#064Bean definitions required
 * }</pre>
 *
 * <b>Note: {@code @EnableAspectJAutoProxy} applies to its local application context only,
 * allowing for selective proxying of beans at different levels.</b> Please redeclare
 * {@code @EnableAspectJAutoProxy} in each individual context, e.g. the common root web
 * application context and any separate {@code DispatcherServlet} application contexts,
 * if you need to apply its behavior at multiple levels.
 *
 * <p>This feature requires the presence of {@code aspectjweaver} on the classpath.
 * While that dependency is optional for {@code spring-aop} in general, it is required
 * for {@code @EnableAspectJAutoProxy} and its underlying facilities.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see org.aspectj.lang.annotation.Aspect
 */
/**
 * 启用对标记有AspectJ的{@code  @Aspect}标注的组件的支持，类似于Spring的{@code  <aop：aspectj-autoproxy>} XML元素中的功能。 
 * 要在@{<< link> Configuration}类上使用，如下所示：<pre class ="code"> @Configuration @EnableAspectJAutoProxy公共类AppConfig {@Bean public FooService fooService（）{return new FooService（）; } @Bean public MyAspect myAspect（）{返回新的MyAspect（）; }} </ pre>其中{@code  FooService}是典型的POJO组件，而{@code  MyAspect}是{@code  @Aspect}样式的方面：<pre class ="code"> public class FooService {//各种方法} </ pre> <pre class ="code"> @Aspect公共类MyAspect {@Before（"execution（FooService +。 
 * （..））"）public void advisor（）{//咨询在上述情况下，{@code  @EnableAspectJAutoProxy}确保{@code  MyAspect}将得到正确处理，并且{{@@code> FooService}将被混合使用它提供的建议。 
 *  <p>用户可以使用{@link  #proxyTargetClass（）}属性来控制为{@code  FooService}创建的代理类型。 
 * 与默认的基于接口的JDK代理方法相反，以下启用了CGLIB风格的"子类"代理。 
 *  <pre class ="code"> @Configuration @EnableAspectJAutoProxy（proxyTargetClass = true）公共类AppConfig {// ...} </ pre> <p>请注意，{<@code> @Aspect} bean可以进行组件扫描像其他任何人一样只需使用{@code  @Aspect}和{@code  @Component}标记该方面：<pre class ="code"> package com.foo; @Component公共类FooService {...} @Aspect @Component公共类MyAspect {...} </ pre>然后使用@{<@link> ComponentScan}注解进行选择：<pre class ="code"> @Configuration @ComponentScan（"com.foo"）@EnableAspectJAutoProxy公共类AppConfig {//不需要明确的@Bean定义} </ pre> <b>注意：{@code  @EnableAspectJAutoProxy}适用于其本地应用程序上下文</ b>请在每个单独的上下文中重新声明{@code  @EnableAspectJAutoProxy}，例如，公共根Web应用程序上下文以及任何单独的{@code  DispatcherServlet}应用程序上下文（如果需要在多个级别上应用其行为）。 
 *  <p>此功能要求在类路径上存在{@code  Aspectjweaver}。 
 * 尽管通常对于{@code  spring-aop}来说，该依赖性是可选的，但对于{@code  @EnableAspectJAutoProxy}及其基础设施来说，则是必需的。 
 *  @author 克里斯·比姆斯（Chris Beams）@author 于尔根·霍勒（Juergen Hoeller）@从3.1起
 * @see  org.aspectj.lang.annotation.Aspect
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {

	/**
	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
	 * to standard Java interface-based proxies. The default is {@code false}.
	 */
	/**
	 * 指示与基于标准Java接口的代理相反，是否要创建基于子类（CGLIB）的代理。 
	 * 默认值为{@code  false}。 
	 * 
	 */
	boolean proxyTargetClass() default false;

	/**
	 * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal}
	 * for retrieval via the {@link org.springframework.aop.framework.AopContext} class.
	 * Off by default, i.e. no guarantees that {@code AopContext} access will work.
	 * @since 4.3.1
	 */
	/**
	 * 指示代理应由AOP框架公开为{@code  ThreadLocal}，以便通过{@link  org.springframework.aop.framework.AopContext}类进行检索。 
	 * 默认情况下为关闭，即不保证{@code  AopContext}访问将起作用。 
	 *  @4.3.1起
	 */
	boolean exposeProxy() default false;

}
