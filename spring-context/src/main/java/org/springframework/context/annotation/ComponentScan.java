/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.beans.factory.support.BeanNameGenerator;
import org.springframework.core.annotation.AliasFor;
import org.springframework.core.type.filter.TypeFilter;

/**
 * Configures component scanning directives for use with @{@link Configuration} classes.
 * Provides support parallel with Spring XML's {@code <context:component-scan>} element.
 *
 * <p>Either {@link #basePackageClasses} or {@link #basePackages} (or its alias
 * {@link #value}) may be specified to define specific packages to scan. If specific
 * packages are not defined, scanning will occur from the package of the
 * class that declares this annotation.
 *
 * <p>Note that the {@code <context:component-scan>} element has an
 * {@code annotation-config} attribute; however, this annotation does not. This is because
 * in almost all cases when using {@code @ComponentScan}, default annotation config
 * processing (e.g. processing {@code @Autowired} and friends) is assumed. Furthermore,
 * when using {@link AnnotationConfigApplicationContext}, annotation config processors are
 * always registered, meaning that any attempt to disable them at the
 * {@code @ComponentScan} level would be ignored.
 *
 * <p>See {@link Configuration @Configuration}'s Javadoc for usage examples.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 3.1
 * @see Configuration
 */
/**
 * 配置组件扫描指令，以与@{<@link> Configuration}类一起使用。 
 * 提供与Spring XML的{@code  <context：component-scan>}元素并行的支持。 
 *  <p>可以指定{@link  #basePackageClasses}或{@link  #basePackages}（或其别名{@link  #value}）来定义要扫描的特定程序包。 
 * 如果未定义特定的程序包，则将从声明此注解的类的程序包中进行扫描。 
 *  <p>请注意，{@code  <context：component-scan>}元素具有{@code 注解配置}属性； 
 * 但是，此注释没有。 
 * 这是因为在几乎所有情况下，使用{@code  @ComponentScan}时，都假定使用默认注释配置处理（例如，处理{@code  @Autowired}和朋友）。 
 * 此外，在使用{@link  AnnotationConfigApplicationContext}时，注释配置处理器始终会被注册，这意味着在{@code  @ComponentScan}级别禁用它们的任何尝试都将被忽略。 
 *  <p>有关使用示例，请参见{@link 配置@配置}的Javadoc。 
 *  @author  Chris Beams @author  Juergen Hoeller @author  Sam Brannen @since 3.1 
 * @see 配置
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	/**
	 * Alias for {@link #basePackages}.
	 * <p>Allows for more concise annotation declarations if no other attributes
	 * are needed &mdash; for example, {@code @ComponentScan("org.my.pkg")}
	 * instead of {@code @ComponentScan(basePackages = "org.my.pkg")}.
	 */
	/**
	 * {@link  #basePackages}的别名。 
	 *  <p>如果不需要其他属性，则允许使用更简洁的注释声明-例如，{@code  @ComponentScan（"org.my.pkg"）}而不是{@code  @ComponentScan（basePackages ="org .my.pkg"）}。 
	 * 
	 */
	@AliasFor("basePackages")
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components.
	 * <p>{@link #value} is an alias for (and mutually exclusive with) this
	 * attribute.
	 * <p>Use {@link #basePackageClasses} for a type-safe alternative to
	 * String-based package names.
	 */
	/**
	 * 基本软件包以扫描带注释的组件。 
	 *  <p> {<@link> #value}是此属性的别名（并与之互斥）。 
	 *  <p>使用{@link  #basePackageClasses}作为基于字符串的程序包名称的类型安全替代。 
	 * 
	 */
	@AliasFor("value")
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages} for specifying the packages
	 * to scan for annotated components. The package of each class specified will be scanned.
	 * <p>Consider creating a special no-op marker class or interface in each package
	 * that serves no purpose other than being referenced by this attribute.
	 */
	/**
	 * {@link  #basePackages}的类型安全替代品，用于指定要扫描以查找带注释的组件的软件包。 
	 * 指定类别的包装将被扫描。 
	 *  <p>请考虑在每个程序包中创建一个特殊的无操作标记类或接口，该类或接口除了被该属性引用外没有其他用途。 
	 * 
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * The {@link BeanNameGenerator} class to be used for naming detected components
	 * within the Spring container.
	 * <p>The default value of the {@link BeanNameGenerator} interface itself indicates
	 * that the scanner used to process this {@code @ComponentScan} annotation should
	 * use its inherited bean name generator, e.g. the default
	 * {@link AnnotationBeanNameGenerator} or any custom instance supplied to the
	 * application context at bootstrap time.
	 * @see AnnotationConfigApplicationContext#setBeanNameGenerator(BeanNameGenerator)
	 * @see AnnotationBeanNameGenerator
	 * @see FullyQualifiedAnnotationBeanNameGenerator
	 */
	/**
	 * {@link  BeanNameGenerator}类用于在Spring容器中命名检测到的组件。 
	 *  <p> {<@link> BeanNameGenerator}接口本身的默认值指示用于处理此{@code  @ComponentScan}注解的扫描程序应使用其继承的Bean名称生成器，例如默认{@link  AnnotationBeanNameGenerator}或在引导时提供给应用程序上下文的任何自定义实例。 
	 *  
	 * @see  AnnotationConfigApplicationContext＃setBeanNameGenerator（BeanNameGenerator）
	 * @see  AnnotationBeanNameGenerator 
	 * @see  FullyQualifiedAnnotationBeanNameGenerator
	 */
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

	/**
	 * The {@link ScopeMetadataResolver} to be used for resolving the scope of detected components.
	 */
	/**
	 * {@link  ScopeMetadataResolver}用于解决检测到的组件的范围。 
	 * 
	 */
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	/**
	 * Indicates whether proxies should be generated for detected components, which may be
	 * necessary when using scopes in a proxy-style fashion.
	 * <p>The default is defer to the default behavior of the component scanner used to
	 * execute the actual scan.
	 * <p>Note that setting this attribute overrides any value set for {@link #scopeResolver}.
	 * @see ClassPathBeanDefinitionScanner#setScopedProxyMode(ScopedProxyMode)
	 */
	/**
	 * 指示是否应为检测到的组件生成代理，当以代理样式的方式使用合并范围时，可能有必要。 
	 *  <p>默认值遵循用于执行实际扫描的组件扫描程序的默认行为。 
	 *  <p>请注意，设置此属性将覆盖为{@link  #scopeResolver}设置的任何值。 
	 *  
	 * @see  ClassPathBeanDefinitionScanner＃setScopedProxyMode（ScopedProxyMode）
	 */
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	/**
	 * Controls the class files eligible for component detection.
	 * <p>Consider use of {@link #includeFilters} and {@link #excludeFilters}
	 * for a more flexible approach.
	 */
	/**
	 * 控制有资格进行组件检测的类文件。 
	 *  <p>请考虑使用{@link  #includeFilters}和{@link  #excludeFilters}以获得更灵活的方法。 
	 * 
	 */
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	/**
	 * Indicates whether automatic detection of classes annotated with {@code @Component}
	 * {@code @Repository}, {@code @Service}, or {@code @Controller} should be enabled.
	 */
	/**
	 * 指示是否应启用对带有{@code  @Component} {@code  @Repository}，{<@code> @Service}或{@code  @Controller}注释的类的自动检测。 
	 * 
	 */
	boolean useDefaultFilters() default true;

	/**
	 * Specifies which types are eligible for component scanning.
	 * <p>Further narrows the set of candidate components from everything in {@link #basePackages}
	 * to everything in the base packages that matches the given filter or filters.
	 * <p>Note that these filters will be applied in addition to the default filters, if specified.
	 * Any type under the specified base packages which matches a given filter will be included,
	 * even if it does not match the default filters (i.e. is not annotated with {@code @Component}).
	 * @see #resourcePattern()
	 * @see #useDefaultFilters()
	 */
	/**
	 * 指定哪些类型适合进行组件扫描。 
	 *  <p>进一步将候选组件集从{@link  #basePackages}中的所有内容缩小到与给定过滤器匹配的基本程序包中的所有内容。 
	 *  <p>请注意，如果指定了默认过滤器，还将应用这些过滤器。 
	 * 即使与默认过滤器不匹配（即未使用{@code  @Component}注释），也将包括与指定过滤器匹配的指定基本软件包下的任何类型。 
	 *  
	 * @see  #resourcePattern（）
	 * @see  #useDefaultFilters（）
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 * @see #resourcePattern
	 */
	/**
	 * 指定哪些类型不适合组件扫描。 
	 *  
	 * @see  #resourcePattern
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Specify whether scanned beans should be registered for lazy initialization.
	 * <p>Default is {@code false}; switch this to {@code true} when desired.
	 * @since 4.1
	 */
	/**
	 * 指定是否应为延迟初始化注册扫描的Bean。 
	 *  <p>默认为{@code  false};根据需要将其切换为{@code  true}。 
	 *  @始于4.1
	 */
	boolean lazyInit() default false;


	/**
	 * Declares the type filter to be used as an {@linkplain ComponentScan#includeFilters
	 * include filter} or {@linkplain ComponentScan#excludeFilters exclude filter}.
	 */
	/**
	 * 声明要用作{@link 普通ComponentScan＃includeFilters包含过滤器}或{@link 普通ComponentScan＃excludeFilters排除过滤器}的类型过滤器。 
	 * 
	 */
	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		/**
		 * The type of filter to use.
		 * <p>Default is {@link FilterType#ANNOTATION}.
		 * @see #classes
		 * @see #pattern
		 */
		/**
		 * 要使用的过滤器类型。 
		 *  <p>默认值为{@link  FilterType＃ANNOTATION}。 
		 *  
		 * @see  #classes 
		 * @see  #pattern
		 */
		FilterType type() default FilterType.ANNOTATION;

		/**
		 * Alias for {@link #classes}.
		 * @see #classes
		 */
		/**
		 * {@link  #classes}的别名。 
		 *  
		 * @see  #classes
		 */
		@AliasFor("classes")
		Class<?>[] value() default {};

		/**
		 * The class or classes to use as the filter.
		 * <p>The following table explains how the classes will be interpreted
		 * based on the configured value of the {@link #type} attribute.
		 * <table border="1">
		 * <tr><th>{@code FilterType}</th><th>Class Interpreted As</th></tr>
		 * <tr><td>{@link FilterType#ANNOTATION ANNOTATION}</td>
		 * <td>the annotation itself</td></tr>
		 * <tr><td>{@link FilterType#ASSIGNABLE_TYPE ASSIGNABLE_TYPE}</td>
		 * <td>the type that detected components should be assignable to</td></tr>
		 * <tr><td>{@link FilterType#CUSTOM CUSTOM}</td>
		 * <td>an implementation of {@link TypeFilter}</td></tr>
		 * </table>
		 * <p>When multiple classes are specified, <em>OR</em> logic is applied
		 * &mdash; for example, "include types annotated with {@code @Foo} OR {@code @Bar}".
		 * <p>Custom {@link TypeFilter TypeFilters} may optionally implement any of the
		 * following {@link org.springframework.beans.factory.Aware Aware} interfaces, and
		 * their respective methods will be called prior to {@link TypeFilter#match match}:
		 * <ul>
		 * <li>{@link org.springframework.context.EnvironmentAware EnvironmentAware}</li>
		 * <li>{@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware}
		 * <li>{@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware}
		 * <li>{@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware}
		 * </ul>
		 * <p>Specifying zero classes is permitted but will have no effect on component
		 * scanning.
		 * @since 4.2
		 * @see #value
		 * @see #type
		 */
		/**
		 * 用作过滤器的一个或多个类。 
		 *  <p>下表解释了如何基于{@link  #type}属性的配置值解释类。 
		 *  <table border ="1"> <tr> <th> {<@code> FilterType} </ th> <th>类解释为</ th> </ tr> <tr> <td> {<@link> FilterType＃ANNOTATION ANNOTATION} </ td> <td>注释本身</ td> </ tr> <tr> <td> {<@link> FilterType＃ASSIGNABLE_TYPE ASSIGNABLE_TYPE} </ td> <td>检测到的类型组件应可分配给</ td> </ tr> <tr> <td> {<@link> FilterType＃CUSTOM CUSTOM} </ td> <td> {@link  TypeFilter} </ td>的实现</ tr> </ table> <p>当指定了多个类时，将应用<em> OR </ em>逻辑-例如，"包含用{@code  @Foo}或{<@code > @Bar}"。 
		 *  <p>自定义{@link  TypeFilter TypeFilters}可以选择实现以下任何{@link  org.springframework.beans.factory.Aware Aware}接口，它们各自的方法将在{<@link > TypeFilter＃match match}：<ul> <li> {<@link> org.springframework.context.EnvironmentAware EnvironmentAware} </ li> <li> {<@link> org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware} <li> {<@link> org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware} <li> {<@link> org.springframework.context.ResourceLoaderAware ResourceLoaderAware} </ ul> <p>允许指定零类对组件扫描没有影响。 
		 *  @since 4.2 
		 * @see  #value 
		 * @see  #type
		 */
		@AliasFor("value")
		Class<?>[] classes() default {};

		/**
		 * The pattern (or patterns) to use for the filter, as an alternative
		 * to specifying a Class {@link #value}.
		 * <p>If {@link #type} is set to {@link FilterType#ASPECTJ ASPECTJ},
		 * this is an AspectJ type pattern expression. If {@link #type} is
		 * set to {@link FilterType#REGEX REGEX}, this is a regex pattern
		 * for the fully-qualified class names to match.
		 * @see #type
		 * @see #classes
		 */
		/**
		 * 用于过滤器的一种或多种模式，作为指定Class {@link  #value}的替代方法。 
		 *  <p>如果{@link  #type}设置为{@link  FilterType＃ASPECTJ ASPECTJ}，则这是AspectJ类型模式表达式。 
		 * 如果{@link  #type}设置为{@link  FilterType＃REGEX REGEX}，则这是用于完全匹配的类名的正则表达式模式。 
		 *  
		 * @see  #type 
		 * @see  #classes
		 */
		String[] pattern() default {};

	}

}
