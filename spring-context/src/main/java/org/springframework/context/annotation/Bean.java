/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.beans.factory.annotation.Autowire;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.core.annotation.AliasFor;

/**
 * Indicates that a method produces a bean to be managed by the Spring container.
 *
 * <h3>Overview</h3>
 *
 * <p>The names and semantics of the attributes to this annotation are intentionally
 * similar to those of the {@code <bean/>} element in the Spring XML schema. For
 * example:
 *
 * <pre class="code">
 *     &#064;Bean
 *     public MyBean myBean() {
 *         // instantiate and configure MyBean obj
 *         return obj;
 *     }
 * </pre>
 *
 * <h3>Bean Names</h3>
 *
 * <p>While a {@link #name} attribute is available, the default strategy for
 * determining the name of a bean is to use the name of the {@code @Bean} method.
 * This is convenient and intuitive, but if explicit naming is desired, the
 * {@code name} attribute (or its alias {@code value}) may be used. Also note
 * that {@code name} accepts an array of Strings, allowing for multiple names
 * (i.e. a primary bean name plus one or more aliases) for a single bean.
 *
 * <pre class="code">
 *     &#064;Bean({"b1", "b2"}) // bean available as 'b1' and 'b2', but not 'myBean'
 *     public MyBean myBean() {
 *         // instantiate and configure MyBean obj
 *         return obj;
 *     }
 * </pre>
 *
 * <h3>Profile, Scope, Lazy, DependsOn, Primary, Order</h3>
 *
 * <p>Note that the {@code @Bean} annotation does not provide attributes for profile,
 * scope, lazy, depends-on or primary. Rather, it should be used in conjunction with
 * {@link Scope @Scope}, {@link Lazy @Lazy}, {@link DependsOn @DependsOn} and
 * {@link Primary @Primary} annotations to declare those semantics. For example:
 *
 * <pre class="code">
 *     &#064;Bean
 *     &#064;Profile("production")
 *     &#064;Scope("prototype")
 *     public MyBean myBean() {
 *         // instantiate and configure MyBean obj
 *         return obj;
 *     }
 * </pre>
 *
 * The semantics of the above-mentioned annotations match their use at the component
 * class level: {@code @Profile} allows for selective inclusion of certain beans.
 * {@code @Scope} changes the bean's scope from singleton to the specified scope.
 * {@code @Lazy} only has an actual effect in case of the default singleton scope.
 * {@code @DependsOn} enforces the creation of specific other beans before this
 * bean will be created, in addition to any dependencies that the bean expressed
 * through direct references, which is typically helpful for singleton startup.
 * {@code @Primary} is a mechanism to resolve ambiguity at the injection point level
 * if a single target component needs to be injected but several beans match by type.
 *
 * <p>Additionally, {@code @Bean} methods may also declare qualifier annotations
 * and {@link org.springframework.core.annotation.Order @Order} values, to be
 * taken into account during injection point resolution just like corresponding
 * annotations on the corresponding component classes but potentially being very
 * individual per bean definition (in case of multiple definitions with the same
 * bean class). Qualifiers narrow the set of candidates after the initial type match;
 * order values determine the order of resolved elements in case of collection
 * injection points (with several target beans matching by type and qualifier).
 *
 * <p><b>NOTE:</b> {@code @Order} values may influence priorities at injection points,
 * but please be aware that they do not influence singleton startup order which is an
 * orthogonal concern determined by dependency relationships and {@code @DependsOn}
 * declarations as mentioned above. Also, {@link javax.annotation.Priority} is not
 * available at this level since it cannot be declared on methods; its semantics can
 * be modeled through {@code @Order} values in combination with {@code @Primary} on
 * a single bean per type.
 *
 * <h3>{@code @Bean} Methods in {@code @Configuration} Classes</h3>
 *
 * <p>Typically, {@code @Bean} methods are declared within {@code @Configuration}
 * classes. In this case, bean methods may reference other {@code @Bean} methods in the
 * same class by calling them <i>directly</i>. This ensures that references between beans
 * are strongly typed and navigable. Such so-called <em>'inter-bean references'</em> are
 * guaranteed to respect scoping and AOP semantics, just like {@code getBean()} lookups
 * would. These are the semantics known from the original 'Spring JavaConfig' project
 * which require CGLIB subclassing of each such configuration class at runtime. As a
 * consequence, {@code @Configuration} classes and their factory methods must not be
 * marked as final or private in this mode. For example:
 *
 * <pre class="code">
 * &#064;Configuration
 * public class AppConfig {
 *
 *     &#064;Bean
 *     public FooService fooService() {
 *         return new FooService(fooRepository());
 *     }
 *
 *     &#064;Bean
 *     public FooRepository fooRepository() {
 *         return new JdbcFooRepository(dataSource());
 *     }
 *
 *     // ...
 * }</pre>
 *
 * <h3>{@code @Bean} <em>Lite</em> Mode</h3>
 *
 * <p>{@code @Bean} methods may also be declared within classes that are <em>not</em>
 * annotated with {@code @Configuration}. For example, bean methods may be declared
 * in a {@code @Component} class or even in a <em>plain old class</em>. In such cases,
 * a {@code @Bean} method will get processed in a so-called <em>'lite'</em> mode.
 *
 * <p>Bean methods in <em>lite</em> mode will be treated as plain <em>factory
 * methods</em> by the container (similar to {@code factory-method} declarations
 * in XML), with scoping and lifecycle callbacks properly applied. The containing
 * class remains unmodified in this case, and there are no unusual constraints for
 * the containing class or the factory methods.
 *
 * <p>In contrast to the semantics for bean methods in {@code @Configuration} classes,
 * <em>'inter-bean references'</em> are not supported in <em>lite</em> mode. Instead,
 * when one {@code @Bean}-method invokes another {@code @Bean}-method in <em>lite</em>
 * mode, the invocation is a standard Java method invocation; Spring does not intercept
 * the invocation via a CGLIB proxy. This is analogous to inter-{@code @Transactional}
 * method calls where in proxy mode, Spring does not intercept the invocation &mdash;
 * Spring does so only in AspectJ mode.
 *
 * <p>For example:
 *
 * <pre class="code">
 * &#064;Component
 * public class Calculator {
 *     public int sum(int a, int b) {
 *         return a+b;
 *     }
 *
 *     &#064;Bean
 *     public MyBean myBean() {
 *         return new MyBean();
 *     }
 * }</pre>
 *
 * <h3>Bootstrapping</h3>
 *
 * <p>See the @{@link Configuration} javadoc for further details including how to bootstrap
 * the container using {@link AnnotationConfigApplicationContext} and friends.
 *
 * <h3>{@code BeanFactoryPostProcessor}-returning {@code @Bean} methods</h3>
 *
 * <p>Special consideration must be taken for {@code @Bean} methods that return Spring
 * {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}
 * ({@code BFPP}) types. Because {@code BFPP} objects must be instantiated very early in the
 * container lifecycle, they can interfere with processing of annotations such as {@code @Autowired},
 * {@code @Value}, and {@code @PostConstruct} within {@code @Configuration} classes. To avoid these
 * lifecycle issues, mark {@code BFPP}-returning {@code @Bean} methods as {@code static}. For example:
 *
 * <pre class="code">
 *     &#064;Bean
 *     public static PropertySourcesPlaceholderConfigurer pspc() {
 *         // instantiate, configure and return pspc ...
 *     }
 * </pre>
 *
 * By marking this method as {@code static}, it can be invoked without causing instantiation of its
 * declaring {@code @Configuration} class, thus avoiding the above-mentioned lifecycle conflicts.
 * Note however that {@code static} {@code @Bean} methods will not be enhanced for scoping and AOP
 * semantics as mentioned above. This works out in {@code BFPP} cases, as they are not typically
 * referenced by other {@code @Bean} methods. As a reminder, a WARN-level log message will be
 * issued for any non-static {@code @Bean} methods having a return type assignable to
 * {@code BeanFactoryPostProcessor}.
 *
 * @author Rod Johnson
 * @author Costin Leau
 * @author Chris Beams
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 3.0
 * @see Configuration
 * @see Scope
 * @see DependsOn
 * @see Lazy
 * @see Primary
 * @see org.springframework.stereotype.Component
 * @see org.springframework.beans.factory.annotation.Autowired
 * @see org.springframework.beans.factory.annotation.Value
 */
/**
 * 表示方法产生一个由Spring容器管理的bean。 
 *  <h3>概述</ h3> <p>此注释的属性的名称和语义有意类似于Spring XML模式中的{<< @code >> <bean />}元素的名称和语义。 
 * 例如：<pre class ="code"> @Bean public MyBean myBean（）{//实例化并配置MyBean obj return obj; } </ pre> <h3> Bean名称</ h3> <p>虽然有{<< @link >> #name}属性，但是确定Bean名称的默认策略是使用Bean名称。 
 *  {<< @code >> @Bean}方法。 
 * 这既方便又直观，但是如果需要显式命名，则可以使用{<< @code >> name}属性（或其别名{<< @code >> value}）。 
 * 还要注意，{<< @code >> name}接受一个字符串数组，允许单个bean有多个名称（即主bean名称加上一个或多个别名）。 
 *  <pre class ="code"> @Bean（{"b1"，"b2"}）//可以作为'b1'和'b2'的bean，但不能作为'myBean'public MyBean myBean（）{//实例化并配置MyBean obj返回obj; } </ pre> <h3>配置文件，范围，延迟，DependsOn，主要，顺序</ h3> <p>请注意，{<< @code >> @Bean}注释不提供配置文件，范围，延迟的属性，取决于或主要。 
 * 相反，它应与{<< @link >> Scope @Scope}，{<< @link >> Lazy @Lazy}，{<< @link >> DependsOn @DependsOn}和{<< @link >> Primary @Primary}注解来声明这些语义。 
 * 例如：<pre class ="code"> @Bean @Profile（"production"）@Scope（"prototype"）public MyBean myBean（）{//实例化并配置MyBean obj return obj; } </ pre>上述注释的语义与它们在组件类级别的用法相匹配：{<< @code >> @Profile}允许选择性地包含某些bean。 
 *  {<< @code >> @Scope}将bean的范围从单例更改为指定的范围。 
 *  {<< @code >> @Lazy}仅在默认单例作用域的情况下才具有实际效果。 
 *  {<< @code >> @DependsOn}会在创建该bean之前强制创建其他特定的bean，除了该bean通过直接引用表示的任何依赖关系之外，这通常对于单例启动很有帮助。 
 *  {<<< @code >> @Primary}是一种在注入点级别解决歧义的机制，如果需要注入单个目标组件，但多个bean按类型匹配。 
 *  <p>此外，{<< @code >> @Bean}方法还可以声明限定符注解和{<< @link >> org.springframework.core.annotation.Order @Order}值，以便在注入期间予以考虑点分辨率与相应组件类上的相应注解一样，但每个bean定义可能非常个别（在具有相同bean类的多个定义的情况下）。 
 * 在初始类型匹配之后，限定词会缩小候选集的范围； 
 *  order值确定在集合注入点的情况下解析元素的顺序（几个目标bean通过类型和限定符进行匹配）。 
 *  <p> <b>注意：</ b> {<< @code >> @Order}值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系决定的正交关注点关系和{<< @code >> @DependsOn}声明，如上所述。 
 * 另外，{<< @link >> javax.annotation.Priority}在此级别不可用，因为无法在方法上声明它； 
 * 可以通过每种类型的单个bean上的{<< @code >> @Order}值与{<< @code >> @Primary}的组合来建模其语义。 
 *  <h3> {<< @@code >> @Bean}类在{<< @code >> @Configuration}类中</ h3> <p>通常，{<< @code >> @Bean}方法在{ << @code >> @Configuration}类。 
 * 在这种情况下，bean方法可以通过直接<i> </ i>调用同一类中的其他{<< @code >> @Bean}方法。 
 * 这确保了bean之间的引用是强类型的且可导航的。 
 * 这样的<em>'bean间引用'</ em>可以保证遵循作用域和AOP语义，就像{<< @code >> getBean（）}查找一样。 
 * 这些是原始"Spring JavaConfig"项目中已知的语义，这些语义要求在运行时将每个此类配置类的CGLIB子类化。 
 * 因此，在此模式下，不得将{<< @code >> @Configuration}类及其工厂方法标记为final或private。 
 * 例如：<pre class ="code"> @Configuration公共类AppConfig {@Bean public FooService fooService（）{return new FooService（fooRepository（））; } @Bean public FooRepository fooRepository（）{返回新的JdbcFooRepository（dataSource（））; } // ...} </ pre> <h3> {<< @code >> @Bean} <em>精简</ em>模式</ h3> <p> {<< @code >> @Bean}方法也可以在用<<< @code >> @Configuration}注释的<em> not </ em>类中声明。 
 * 例如，可以在{<< @code >> @Component}类中甚至在<em>纯旧类</ em>中声明bean方法。 
 * 在这种情况下，将以所谓的<em>'lite'</ em>模式处理{<< @code >> @Bean}方法
 */
/**
 * 容器将<em> lite </ em>模式下的<p> Bean方法视为普通的<em>工厂方法</ em>（类似于XML中的{<< @code >> factory-method}声明） ，并正确应用范围和生命周期回调。 
 * 在这种情况下，包含类保持不变，并且对于包含类或工厂方法没有异常约束。 
 *  <p>与{<< @code >> @Configuration}类中bean方法的语义相反，在<em> lite </ em>模式下不支持<em>'bean间引用'</ em> 。 
 * 相反，当一个{<< @code >> @Bean}方法以<em> lite </ em>模式调用另一个{<< @code >> @Bean}方法时，该调用是标准的Java方法调用。 
 *  Spring不会通过CGLIB代理拦截调用。 
 * 这类似于{{<< @code >> @@Transactional}之间的方法调用，在代理模式下，Spring不会拦截调用-Spring仅在AspectJ模式下会拦截调用。 
 *  <p>例如：<pre class ="code"> @Component公共类计算器{public int sum（int a，int b）{return a + b; } @Bean public MyBean myBean（）{return new MyBean（）; }} </ pre> <h3> Bootstrapping </ h3> <p>有关更多详细信息，包括如何使用{<< @link >> AnnotationConfigApplicationContext}引导容器，请参见@{<< @link >>配置} javadoc。 
 * 朋友们。 
 *  <h3> {<<< @code >> BeanFactoryPostProcessor}-返回{<< @code >> @Bean}方法</ h3> <p>对于{<< @code >> @Bean}方法必须特别注意返回Spring {<< @link >> org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}（{<< @code >> BFPP}）类型。 
 * 由于{<< @code >> BFPP}对象必须在容器生命周期的早期进行实例化，因此它们会干扰对诸如{<< @code >> @Autowired}，{<< @code >> >> @Value之类的注释的处理。 
 *  }和{<< @code >> @Configuration}类中的{<< @code >> @PostConstruct}。 
 * 为避免这些生命周期问题，请将{<< @code >> BFPP}标记为返回的{<< @code >> @Bean}方法为{<< @code >> static}。 
 * 例如：<pre class ="code"> @Bean public static PropertySourcesPlaceholderConfigurer pspc（）{//实例化，配置并返回pspc ...} </ pre>通过将此方法标记为{<< @code >> static} ，可以在不引起其声明{<< @code >> @Configuration}类实例化的情况下调用它，从而避免了上述生命周期冲突。 
 * 但是请注意，如上所述，对于作用域和AOP语义，{<< @code >>静态} {<< @code >> @Bean}方法不会得到增强。 
 * 这在{<< @code >> BFPP}情况下可行，因为其他{{<< @code >> @@Bean}方法通常不引用它们。 
 * 提醒一下，将为具有返回类型可分配给{<< @code >> BeanFactoryPostProcessor}的任何非静态{<< @code >> @Bean}方法发出WARN级别的日志消息。 
 *  << @author >> Rod Johnson << @author >> Costin Leau << @author >> Chris Beams << @author >> Juergen Hoeller << @author >> Sam Brannen @始于3.0 << 
 * @see >>配置<< 
 * @see >>范围<< 
 * @see >>取决于<< 
 * @see >> Lazy << 
 * @see >>主要<< 
 * @see >> org.springframework.stereotype.Component << 
 * @see >> org.springframework .beans.factory.annotation.Autowired << 
 * @see >> org.springframework.beans.factory.annotation.Value
 */
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {

	/**
	 * Alias for {@link #name}.
	 * <p>Intended to be used when no other attributes are needed, for example:
	 * {@code @Bean("customBeanName")}.
	 * @since 4.3.3
	 * @see #name
	 */
	/**
	 * {@link  #name}的别名。 
	 *  <p>打算在不需要其他属性时使用，例如：{@code  @Bean（"customBeanName"）}。 
	 *  @since 4.3.3 
	 * @see  #name
	 */
	@AliasFor("name")
	String[] value() default {};

	/**
	 * The name of this bean, or if several names, a primary bean name plus aliases.
	 * <p>If left unspecified, the name of the bean is the name of the annotated method.
	 * If specified, the method name is ignored.
	 * <p>The bean name and aliases may also be configured via the {@link #value}
	 * attribute if no other attributes are declared.
	 * @see #value
	 */
	/**
	 * 此Bean的名称，或者，如果有多个名称，则为主Bean名称加别名。 
	 *  <p>如果未指定，则Bean的名称为带注释的方法的名称。 
	 * 如果指定，方法名称将被忽略。 
	 *  <p>如果未声明其他属性，也可以通过{@link  #value}属性来配置bean名称和别名。 
	 *  
	 * @see ＃值
	 */
	@AliasFor("value")
	String[] name() default {};

	/**
	 * Are dependencies to be injected via convention-based autowiring by name or type?
	 * <p>Note that this autowire mode is just about externally driven autowiring based
	 * on bean property setter methods by convention, analogous to XML bean definitions.
	 * <p>The default mode does allow for annotation-driven autowiring. "no" refers to
	 * externally driven autowiring only, not affecting any autowiring demands that the
	 * bean class itself expresses through annotations.
	 * @see Autowire#BY_NAME
	 * @see Autowire#BY_TYPE
	 * @deprecated as of 5.1, since {@code @Bean} factory method argument resolution and
	 * {@code @Autowired} processing supersede name/type-based bean property injection
	 */
	/**
	 * 是否通过名称或类型通过基于约定的自动装配来注入依赖项？ <p>请注意，此自动装配模式只是基于约定的基于bean属性设置器方法的外部驱动自动装配，类似于XML bean定义。 
	 *  <p>默认模式确实允许注释驱动的自动装配。 
	 *  "no"仅指外部驱动的自动装配，不影响bean类本身通过注释表示的任何自动装配要求。 
	 *  
	 * @see  Autowire＃BY_NAME 
	 * @see  Autowire＃BY_TYPE @自5.1开始弃用，因为{@code  @Bean}工厂方法参数解析和{@code  @Autowired}处理取代了基于名称/类型的bean财产注入
	 */
	@Deprecated
	Autowire autowire() default Autowire.NO;

	/**
	 * Is this bean a candidate for getting autowired into some other bean?
	 * <p>Default is {@code true}; set this to {@code false} for internal delegates
	 * that are not meant to get in the way of beans of the same type in other places.
	 * @since 5.1
	 */
	/**
	 * 该bean是否适合自动连接到其他bean？ <p>默认值为{@code  true}； 
	 * 对于内部委托，请将其设置为{@code  false}，这些委托并不打算在其他地方妨碍相同类型的Bean。 
	 *  @5.1起
	 */
	boolean autowireCandidate() default true;

	/**
	 * The optional name of a method to call on the bean instance during initialization.
	 * Not commonly used, given that the method may be called programmatically directly
	 * within the body of a Bean-annotated method.
	 * <p>The default value is {@code ""}, indicating no init method to be called.
	 * @see org.springframework.beans.factory.InitializingBean
	 * @see org.springframework.context.ConfigurableApplicationContext#refresh()
	 */
	/**
	 * 初始化期间在Bean实例上调用的方法的可选名称。 
	 * 鉴于可以直接在Bean注释方法的主体内以编程方式调用该方法，因此不常用。 
	 *  <p>默认值为{@code ""}，表示没有要调用的初始化方法。 
	 *  
	 * @see  org.springframework.beans.factory.InitializingBean 
	 * @see  org.springframework.context.ConfigurableApplicationContext＃refresh（）
	 */
	String initMethod() default "";

	/**
	 * The optional name of a method to call on the bean instance upon closing the
	 * application context, for example a {@code close()} method on a JDBC
	 * {@code DataSource} implementation, or a Hibernate {@code SessionFactory} object.
	 * The method must have no arguments but may throw any exception.
	 * <p>As a convenience to the user, the container will attempt to infer a destroy
	 * method against an object returned from the {@code @Bean} method. For example, given
	 * an {@code @Bean} method returning an Apache Commons DBCP {@code BasicDataSource},
	 * the container will notice the {@code close()} method available on that object and
	 * automatically register it as the {@code destroyMethod}. This 'destroy method
	 * inference' is currently limited to detecting only public, no-arg methods named
	 * 'close' or 'shutdown'. The method may be declared at any level of the inheritance
	 * hierarchy and will be detected regardless of the return type of the {@code @Bean}
	 * method (i.e., detection occurs reflectively against the bean instance itself at
	 * creation time).
	 * <p>To disable destroy method inference for a particular {@code @Bean}, specify an
	 * empty string as the value, e.g. {@code @Bean(destroyMethod="")}. Note that the
	 * {@link org.springframework.beans.factory.DisposableBean} callback interface will
	 * nevertheless get detected and the corresponding destroy method invoked: In other
	 * words, {@code destroyMethod=""} only affects custom close/shutdown methods and
	 * {@link java.io.Closeable}/{@link java.lang.AutoCloseable} declared close methods.
	 * <p>Note: Only invoked on beans whose lifecycle is under the full control of the
	 * factory, which is always the case for singletons but not guaranteed for any
	 * other scope.
	 * @see org.springframework.beans.factory.DisposableBean
	 * @see org.springframework.context.ConfigurableApplicationContext#close()
	 */
	/**
	 * 关闭应用程序上下文时要在Bean实例上调用的方法的可选名称，例如JDBC {@code  DataSource}实现上的{@code  close（）}方法或Hibernate {<@code > SessionFactory}对象。 
	 * 该方法必须没有参数，但可以引发任何异常。 
	 *  <p>为方便用户，容器将尝试针对从{@code  @Bean}方法返回的对象推断一个destroy方法。 
	 * 例如，给定一个{@code  @Bean}方法返回一个Apache Commons DBCP {@code  BasicDataSource}，该容器将注意到该对象上可用的{@code  close（）}方法并自动注册它作为{@code  destroyMethod}。 
	 * 目前，这种"销毁方法推断"仅限于检测名为"close"或"shutdown"的公共无参数方法。 
	 * 可以在继承层次结构的任何级别上声明该方法，并且无论{@code  @Bean}方法的返回类型如何，都将检测该方法（即，检测在创建时针对bean实例本身进行了反射）。 
	 *  <p>要为特定的{@code  @Bean}禁用destroy方法推断，请指定一个空字符串作为值，例如{@code  @Bean（destroyMethod =""）}。 
	 * 请注意，{{@link> org.springframework.beans.factory.DisposableBean}回调接口仍将被检测到，并调用相应的destroy方法：换句话说，{<@code> destroyMethod =""}仅影响自定义close /关闭方法和{@link  java.io.Closeable} / {<@link> java.lang.AutoCloseable}声明为关闭方法。 
	 *  <p>注意：仅在其生命周期在工厂的完全控制下的bean上调用，对于单例来说总是这样，但对于任何其他范围都不能保证。 
	 *  
	 * @see  org.springframework.beans.factory.DisposableBean 
	 * @see  org.springframework.context.ConfigurableApplicationContext＃close（）
	 */
	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;

}
