/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.support;

import groovy.lang.GroovyObject;
import groovy.lang.GroovySystem;
import groovy.lang.MetaClass;

import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.lang.Nullable;

/**
 * An {@link org.springframework.context.ApplicationContext} implementation that extends
 * {@link GenericApplicationContext} and implements {@link GroovyObject} such that beans
 * can be retrieved with the dot de-reference syntax instead of using {@link #getBean}.
 *
 * <p>Consider this as the equivalent of {@link GenericXmlApplicationContext} for
 * Groovy bean definitions, or even an upgrade thereof since it seamlessly understands
 * XML bean definition files as well. The main difference is that, within a Groovy
 * script, the context can be used with an inline bean definition closure as follows:
 *
 * <pre class="code">
 * import org.hibernate.SessionFactory
 * import org.apache.commons.dbcp.BasicDataSource
 *
 * def context = new GenericGroovyApplicationContext()
 * context.reader.beans {
 *     dataSource(BasicDataSource) {                  // <--- invokeMethod
 *         driverClassName = "org.hsqldb.jdbcDriver"
 *         url = "jdbc:hsqldb:mem:grailsDB"
 *         username = "sa"                            // <-- setProperty
 *         password = ""
 *         settings = [mynew:"setting"]
 *     }
 *     sessionFactory(SessionFactory) {
 *         dataSource = dataSource                    // <-- getProperty for retrieving references
 *     }
 *     myService(MyService) {
 *         nestedBean = { AnotherBean bean ->         // <-- setProperty with closure for nested bean
 *             dataSource = dataSource
 *         }
 *     }
 * }
 * context.refresh()
 * </pre>
 *
 * <p>Alternatively, load a Groovy bean definition script like the following
 * from an external resource (e.g. an "applicationContext.groovy" file):
 *
 * <pre class="code">
 * import org.hibernate.SessionFactory
 * import org.apache.commons.dbcp.BasicDataSource
 *
 * beans {
 *     dataSource(BasicDataSource) {
 *         driverClassName = "org.hsqldb.jdbcDriver"
 *         url = "jdbc:hsqldb:mem:grailsDB"
 *         username = "sa"
 *         password = ""
 *         settings = [mynew:"setting"]
 *     }
 *     sessionFactory(SessionFactory) {
 *         dataSource = dataSource
 *     }
 *     myService(MyService) {
 *         nestedBean = { AnotherBean bean ->
 *             dataSource = dataSource
 *         }
 *     }
 * }
 * </pre>
 *
 * <p>With the following Java code creating the {@code GenericGroovyApplicationContext}
 * (potentially using Ant-style '*'/'**' location patterns):
 *
 * <pre class="code">
 * GenericGroovyApplicationContext context = new GenericGroovyApplicationContext();
 * context.load("org/myapp/applicationContext.groovy");
 * context.refresh();
 * </pre>
 *
 * <p>Or even more concise, provided that no extra configuration is needed:
 *
 * <pre class="code">
 * ApplicationContext context = new GenericGroovyApplicationContext("org/myapp/applicationContext.groovy");
 * </pre>
 *
 * <p><b>This application context also understands XML bean definition files,
 * allowing for seamless mixing and matching with Groovy bean definition files.</b>
 * ".xml" files will be parsed as XML content; all other kinds of resources will
 * be parsed as Groovy scripts.
 *
 * @author Juergen Hoeller
 * @author Jeff Brown
 * @since 4.0
 * @see org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader
 */
/**
 * 一个{@link  org.springframework.context.ApplicationContext}实现，它扩展了{@link  GenericApplicationContext}并实现了{@link  GroovyObject}，以便可以使用点取消引用语法而不是使用{ @link  #getBean}。 
 *  <p>将其视为与Groovy bean定义的{@link  GenericXmlApplicationContext}等效，甚至对其进行升级，因为它也无缝地理解XML bean定义文件。 
 * 主要区别在于，在Groovy脚本中，上下文可以与内联bean定义闭包一起使用，如下所示：<pre class ="code"> import org.hibernate.SessionFactory import org.apache.commons.dbcp.BasicDataSource def context = new GenericGroovyApplicationContext（）context.reader.beans {dataSource（BasicDataSource）{// <--- invokeMethod driverClassName ="org.hsqldb.jdbcDriver"url ="jdbc：hsqldb：mem：grailsDB"用户名="sa"/ / <-setProperty密码=""设置= [mynew："设置"]} sessionFactory（SessionFactory）{dataSource = dataSource // // <用于获取引用的getProperty} myService（MyService）{nestedBean = {AnotherBean bean-> / / <-setProperty，闭包嵌套的bean dataSource = dataSource}}} context.refresh（）</ pre> <p>或者，从外部资源（例如"applicationContext.groovy"）中加载如下所示的Groovy bean定义脚本。 
 *  "文件）：<pre class ="code"> import org.hibernate.SessionFactory impo rt org.apache.commons.dbcp.BasicDataSource bean {dataSource（BasicDataSource）{driverClassName ="org.hsqldb.jdbcDriver"url ="jdbc：hsqldb：mem：grailsDB"用户名="sa"密码=""设置= [mynew ：："设置"]} sessionFactory（SessionFactory）{dataSource = dataSource} myService（MyService）{nestedBean = {AnotherBean bean-> dataSource = dataSource}}} </ pre> <p>使用以下Java代码创建{<@代码> GenericGroovyApplicationContext}（可能使用Ant样式的"/"位置模式）：<pre class ="code"> GenericGroovyApplicationContext context = new GenericGroovyApplicationContext（）; context.load（"org / myapp / applicationContext.groovy"）; context.refresh（）; </ pre> <p>或更简洁，只要不需要额外的配置即可：<pre class ="code"> ApplicationContext context = new GenericGroovyApplicationContext（"org / myapp / applicationContext.groovy"）; </ pre> <p> <b>此应用程序上下文还可以理解XML bean定义文件，从而可以与Groovy bean定义文件进行无缝混合和匹配。 
 * </ b>"。 
 * xml"文件将被解析为XML内容； 
 * 所有其他类型的资源都将被解析为Groovy脚本。 
 *  @author  Juergen Hoeller @author 杰夫·布朗@since 4.0 
 * @see  org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader
 */
public class GenericGroovyApplicationContext extends GenericApplicationContext implements GroovyObject {

	private final GroovyBeanDefinitionReader reader = new GroovyBeanDefinitionReader(this);

	private final BeanWrapper contextWrapper = new BeanWrapperImpl(this);

	private MetaClass metaClass = GroovySystem.getMetaClassRegistry().getMetaClass(getClass());


	/**
	 * Create a new GenericGroovyApplicationContext that needs to be
	 * {@link #load loaded} and then manually {@link #refresh refreshed}.
	 */
	/**
	 * 创建一个新的GenericGroovyApplicationContext，它需要{@link  #load加载}，然后手动{@link  #refresh refreshed}。 
	 * 
	 */
	public GenericGroovyApplicationContext() {
	}

	/**
	 * Create a new GenericGroovyApplicationContext, loading bean definitions
	 * from the given resources and automatically refreshing the context.
	 * @param resources the resources to load from
	 */
	/**
	 * 创建一个新的GenericGroovyApplicationContext，从给定资源加载bean定义并自动刷新上下文。 
	 *  
	 * @param 资源从中加载资源
	 */
	public GenericGroovyApplicationContext(Resource... resources) {
		load(resources);
		refresh();
	}

	/**
	 * Create a new GenericGroovyApplicationContext, loading bean definitions
	 * from the given resource locations and automatically refreshing the context.
	 * @param resourceLocations the resources to load from
	 */
	/**
	 * 创建一个新的GenericGroovyApplicationContext，从给定的资源位置加载bean定义并自动刷新上下文。 
	 *  
	 * @param  resourceLocations从中加载资源
	 */
	public GenericGroovyApplicationContext(String... resourceLocations) {
		load(resourceLocations);
		refresh();
	}

	/**
	 * Create a new GenericGroovyApplicationContext, loading bean definitions
	 * from the given resource locations and automatically refreshing the context.
	 * @param relativeClass class whose package will be used as a prefix when
	 * loading each specified resource name
	 * @param resourceNames relatively-qualified names of resources to load
	 */
	/**
	 * 创建一个新的GenericGroovyApplicationContext，从给定的资源位置加载bean定义并自动刷新上下文。 
	 *  
	 * @param  relativeClass类，在加载每个指定的资源名称时其包将用作前缀
	 * @param  resourceNames要加载的相对合格的资源名称
	 */
	public GenericGroovyApplicationContext(Class<?> relativeClass, String... resourceNames) {
		load(relativeClass, resourceNames);
		refresh();
	}


	/**
	 * Exposes the underlying {@link GroovyBeanDefinitionReader} for convenient access
	 * to the {@code loadBeanDefinition} methods on it as well as the ability
	 * to specify an inline Groovy bean definition closure.
	 * @see GroovyBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)
	 * @see GroovyBeanDefinitionReader#loadBeanDefinitions(String...)
	 */
	/**
	 * 公开基础的{@link  GroovyBeanDefinitionReader}，以方便地访问其上的{@code  loadBeanDefinition}方法，以及指定内联Groovy bean定义闭包的能力。 
	 *  
	 * @see  GroovyBeanDefinitionReader＃loadBeanDefinitions（org.springframework.core.io.Resource ...）
	 * @see  GroovyBeanDefinitionReader＃loadBeanDefinitions（String ...）
	 */
	public final GroovyBeanDefinitionReader getReader() {
		return this.reader;
	}

	/**
	 * Delegates the given environment to underlying {@link GroovyBeanDefinitionReader}.
	 * Should be called before any call to {@code #load}.
	 */
	/**
	 * 将给定环境委托给基础{@link  GroovyBeanDefinitionReader}。 
	 * 应该在调用{@code  #load}之前调用。 
	 * 
	 */
	@Override
	public void setEnvironment(ConfigurableEnvironment environment) {
		super.setEnvironment(environment);
		this.reader.setEnvironment(getEnvironment());
	}

	/**
	 * Load bean definitions from the given Groovy scripts or XML files.
	 * <p>Note that ".xml" files will be parsed as XML content; all other kinds
	 * of resources will be parsed as Groovy scripts.
	 * @param resources one or more resources to load from
	 */
	/**
	 * 从给定的Groovy脚本或XML文件加载bean定义。 
	 *  <p>请注意，"。 
	 * xml"文件将被解析为XML内容； 
	 * 所有其他类型的资源都将被解析为Groovy脚本。 
	 *  
	 * @param 资源一个或多个要加载的资源
	 */
	public void load(Resource... resources) {
		this.reader.loadBeanDefinitions(resources);
	}

	/**
	 * Load bean definitions from the given Groovy scripts or XML files.
	 * <p>Note that ".xml" files will be parsed as XML content; all other kinds
	 * of resources will be parsed as Groovy scripts.
	 * @param resourceLocations one or more resource locations to load from
	 */
	/**
	 * 从给定的Groovy脚本或XML文件加载bean定义。 
	 *  <p>请注意，"。 
	 * xml"文件将被解析为XML内容； 
	 * 所有其他类型的资源都将被解析为Groovy脚本。 
	 *  
	 * @param  resourceLocations一个或多个要从中加载的资源位置
	 */
	public void load(String... resourceLocations) {
		this.reader.loadBeanDefinitions(resourceLocations);
	}

	/**
	 * Load bean definitions from the given Groovy scripts or XML files.
	 * <p>Note that ".xml" files will be parsed as XML content; all other kinds
	 * of resources will be parsed as Groovy scripts.
	 * @param relativeClass class whose package will be used as a prefix when
	 * loading each specified resource name
	 * @param resourceNames relatively-qualified names of resources to load
	 */
	/**
	 * 从给定的Groovy脚本或XML文件加载bean定义。 
	 *  <p>请注意，"。 
	 * xml"文件将被解析为XML内容； 
	 * 所有其他类型的资源都将被解析为Groovy脚本。 
	 *  
	 * @param  relativeClass类，在加载每个指定的资源名称时其包将用作前缀
	 * @param  resourceNames要加载的相对合格的资源名称
	 */
	public void load(Class<?> relativeClass, String... resourceNames) {
		Resource[] resources = new Resource[resourceNames.length];
		for (int i = 0; i < resourceNames.length; i++) {
			resources[i] = new ClassPathResource(resourceNames[i], relativeClass);
		}
		load(resources);
	}


	// Implementation of the GroovyObject interface

	@Override
	public void setMetaClass(MetaClass metaClass) {
		this.metaClass = metaClass;
	}

	@Override
	public MetaClass getMetaClass() {
		return this.metaClass;
	}

	@Override
	public Object invokeMethod(String name, Object args) {
		return this.metaClass.invokeMethod(this, name, args);
	}

	@Override
	public void setProperty(String property, Object newValue) {
		if (newValue instanceof BeanDefinition) {
			registerBeanDefinition(property, (BeanDefinition) newValue);
		}
		else {
			this.metaClass.setProperty(this, property, newValue);
		}
	}

	@Override
	@Nullable
	public Object getProperty(String property) {
		if (containsBean(property)) {
			return getBean(property);
		}
		else if (this.contextWrapper.isReadableProperty(property)) {
			return this.contextWrapper.getPropertyValue(property);
		}
		throw new NoSuchBeanDefinitionException(property);
	}

}
