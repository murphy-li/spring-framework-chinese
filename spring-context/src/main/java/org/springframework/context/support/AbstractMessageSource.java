/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.support;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;

import org.springframework.context.HierarchicalMessageSource;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceResolvable;
import org.springframework.context.NoSuchMessageException;
import org.springframework.lang.Nullable;
import org.springframework.util.ObjectUtils;

/**
 * Abstract implementation of the {@link HierarchicalMessageSource} interface,
 * implementing common handling of message variants, making it easy
 * to implement a specific strategy for a concrete MessageSource.
 *
 * <p>Subclasses must implement the abstract {@link #resolveCode}
 * method. For efficient resolution of messages without arguments, the
 * {@link #resolveCodeWithoutArguments} method should be overridden
 * as well, resolving messages without a MessageFormat being involved.
 *
 * <p><b>Note:</b> By default, message texts are only parsed through
 * MessageFormat if arguments have been passed in for the message. In case
 * of no arguments, message texts will be returned as-is. As a consequence,
 * you should only use MessageFormat escaping for messages with actual
 * arguments, and keep all other messages unescaped. If you prefer to
 * escape all messages, set the "alwaysUseMessageFormat" flag to "true".
 *
 * <p>Supports not only MessageSourceResolvables as primary messages
 * but also resolution of message arguments that are in turn
 * MessageSourceResolvables themselves.
 *
 * <p>This class does not implement caching of messages per code, thus
 * subclasses can dynamically change messages over time. Subclasses are
 * encouraged to cache their messages in a modification-aware fashion,
 * allowing for hot deployment of updated messages.
 *
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @see #resolveCode(String, java.util.Locale)
 * @see #resolveCodeWithoutArguments(String, java.util.Locale)
 * @see #setAlwaysUseMessageFormat
 * @see java.text.MessageFormat
 */
/**
 * {@link  HierarchicalMessageSource}接口的抽象实现，实现了对消息变体的通用处理，从而可以轻松地为具体的MessageSource实施特定策略。 
 *  <p>子类必须实现抽象的{@link  #resolveCode}方法。 
 * 为了有效地解析不带参数的消息，还应该重写{@link  #resolveCodeWithoutArguments}方法，以在不涉及MessageFormat的情况下解析消息。 
 *  <p> <b>注意：</ b>默认情况下，仅当已为消息传递参数时，才通过MessageFormat解析消息文本。 
 * 如果没有参数，则将按原样返回消息文本。 
 * 因此，您只应对带有实际参数的消息使用MessageFormat转义，并保留所有其他消息不转义。 
 * 如果您希望转义所有消息，请将"alwaysUseMessageFormat"标志设置为"true"。 
 *  <p>不仅支持将MessageSourceResolvables作为主要消息，而且还支持消息参数的解析，而这些参数又是MessageSourceResolvables本身。 
 *  <p>该类未实现每个代码的消息缓存，因此子类可以随着时间动态更改消息。 
 * 鼓励子类以感知修改的方式缓存其消息，以允许热部署更新的消息。 
 *  @author  Juergen Hoeller @author 罗德·约翰逊
 * @see  #resolveCode（String，java.util.Locale）
 * @see  #resolveCodeWithoutArguments（String，java.util.Locale）
 * @see  #setAlwaysUseMessageFormat <@查看> java.text.MessageFormat
 */
public abstract class AbstractMessageSource extends MessageSourceSupport implements HierarchicalMessageSource {

	@Nullable
	private MessageSource parentMessageSource;

	@Nullable
	private Properties commonMessages;

	private boolean useCodeAsDefaultMessage = false;


	@Override
	public void setParentMessageSource(@Nullable MessageSource parent) {
		this.parentMessageSource = parent;
	}

	@Override
	@Nullable
	public MessageSource getParentMessageSource() {
		return this.parentMessageSource;
	}

	/**
	 * Specify locale-independent common messages, with the message code as key
	 * and the full message String (may contain argument placeholders) as value.
	 * <p>May also link to an externally defined Properties object, e.g. defined
	 * through a {@link org.springframework.beans.factory.config.PropertiesFactoryBean}.
	 */
	/**
	 * 指定与语言环境无关的通用消息，并将消息代码作为键，并将完整消息String（可能包含参数占位符）作为值。 
	 *  <p>也可以链接到外部定义的Properties对象，例如通过{@link  org.springframework.beans.factory.config.PropertiesFactoryBean}定义。 
	 * 
	 */
	public void setCommonMessages(@Nullable Properties commonMessages) {
		this.commonMessages = commonMessages;
	}

	/**
	 * Return a Properties object defining locale-independent common messages, if any.
	 */
	/**
	 * 返回一个Properties对象，该对象定义与区域设置无关的通用消息（如果有）。 
	 * 
	 */
	@Nullable
	protected Properties getCommonMessages() {
		return this.commonMessages;
	}

	/**
	 * Set whether to use the message code as default message instead of
	 * throwing a NoSuchMessageException. Useful for development and debugging.
	 * Default is "false".
	 * <p>Note: In case of a MessageSourceResolvable with multiple codes
	 * (like a FieldError) and a MessageSource that has a parent MessageSource,
	 * do <i>not</i> activate "useCodeAsDefaultMessage" in the <i>parent</i>:
	 * Else, you'll get the first code returned as message by the parent,
	 * without attempts to check further codes.
	 * <p>To be able to work with "useCodeAsDefaultMessage" turned on in the parent,
	 * AbstractMessageSource and AbstractApplicationContext contain special checks
	 * to delegate to the internal {@link #getMessageInternal} method if available.
	 * In general, it is recommended to just use "useCodeAsDefaultMessage" during
	 * development and not rely on it in production in the first place, though.
	 * @see #getMessage(String, Object[], Locale)
	 * @see org.springframework.validation.FieldError
	 */
	/**
	 * 设置是否将消息代码用作默认消息，而不是引发NoSuchMessageException。 
	 * 对于开发和调试很有用。 
	 * 默认值为"false"。 
	 *  <p>注意：如果MessageSourceResolvable具有多个代码（例如FieldError）且MessageSource具有父MessageSource，则不要<i>不</ i>在<i>父级</ i>中激活"useCodeAsDefaultMessage"：否则，您将获得父级作为消息返回的第一个代码，而无需尝试检查其他代码。 
	 *  <p>为了能够与在父级中打开的"useCodeAsDefaultMessage"一起使用，AbstractMessageSource和AbstractApplicationContext包含特殊检查，以委托给内部{@link  #getMessageInternal}方法（如果可用）。 
	 * 通常，建议在开发过程中仅使用"useCodeAsDefaultMessage"，而不要首先在生产中使用它。 
	 *  
	 * @see  #getMessage（String，Object []，Locale）
	 * @see  org.springframework.validation.FieldError
	 */
	public void setUseCodeAsDefaultMessage(boolean useCodeAsDefaultMessage) {
		this.useCodeAsDefaultMessage = useCodeAsDefaultMessage;
	}

	/**
	 * Return whether to use the message code as default message instead of
	 * throwing a NoSuchMessageException. Useful for development and debugging.
	 * Default is "false".
	 * <p>Alternatively, consider overriding the {@link #getDefaultMessage}
	 * method to return a custom fallback message for an unresolvable code.
	 * @see #getDefaultMessage(String)
	 */
	/**
	 * 返回是否将消息代码用作默认消息，而不是引发NoSuchMessageException。 
	 * 对于开发和调试很有用。 
	 * 默认值为"false"。 
	 *  <p>或者，考虑覆盖{@link  #getDefaultMessage}方法，以为无法解析的代码返回自定义后备消息。 
	 *  
	 * @see  #getDefaultMessage（String）
	 */
	protected boolean isUseCodeAsDefaultMessage() {
		return this.useCodeAsDefaultMessage;
	}


	@Override
	public final String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale) {
		String msg = getMessageInternal(code, args, locale);
		if (msg != null) {
			return msg;
		}
		if (defaultMessage == null) {
			return getDefaultMessage(code);
		}
		return renderDefaultMessage(defaultMessage, args, locale);
	}

	@Override
	public final String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException {
		String msg = getMessageInternal(code, args, locale);
		if (msg != null) {
			return msg;
		}
		String fallback = getDefaultMessage(code);
		if (fallback != null) {
			return fallback;
		}
		throw new NoSuchMessageException(code, locale);
	}

	@Override
	public final String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException {
		String[] codes = resolvable.getCodes();
		if (codes != null) {
			for (String code : codes) {
				String message = getMessageInternal(code, resolvable.getArguments(), locale);
				if (message != null) {
					return message;
				}
			}
		}
		String defaultMessage = getDefaultMessage(resolvable, locale);
		if (defaultMessage != null) {
			return defaultMessage;
		}
		throw new NoSuchMessageException(!ObjectUtils.isEmpty(codes) ? codes[codes.length - 1] : "", locale);
	}


	/**
	 * Resolve the given code and arguments as message in the given Locale,
	 * returning {@code null} if not found. Does <i>not</i> fall back to
	 * the code as default message. Invoked by {@code getMessage} methods.
	 * @param code the code to lookup up, such as 'calculator.noRateSet'
	 * @param args array of arguments that will be filled in for params
	 * within the message
	 * @param locale the locale in which to do the lookup
	 * @return the resolved message, or {@code null} if not found
	 * @see #getMessage(String, Object[], String, Locale)
	 * @see #getMessage(String, Object[], Locale)
	 * @see #getMessage(MessageSourceResolvable, Locale)
	 * @see #setUseCodeAsDefaultMessage
	 */
	/**
	 * 在给定的语言环境中将给定的代码和参数解析为消息，如果找不到，则返回{@code  null}。 
	 *  <i>不是</ i>会作为默认消息退回到该代码。 
	 * 由{@code  getMessage}方法调用。 
	 *  
	 * @param 对要查找的代码进行编码，例如'calculator.noRateSet'
	 * @param  args参数数组，将为消息中的params填充参数
	 * @param  locale进行查找的语言环境
	 * @return 已解析的消息，如果找不到，则返回{@code  null} 
	 * @see  #getMessage（String，Object []，String，Locale）
	 * @see  #getMessage（String，Object []，Locale） 
	 * @see  #getMessage（MessageSourceResolvable，Locale）
	 * @see  #setUseCodeAsDefaultMessage
	 */
	@Nullable
	protected String getMessageInternal(@Nullable String code, @Nullable Object[] args, @Nullable Locale locale) {
		if (code == null) {
			return null;
		}
		if (locale == null) {
			locale = Locale.getDefault();
		}
		Object[] argsToUse = args;

		if (!isAlwaysUseMessageFormat() && ObjectUtils.isEmpty(args)) {
			// Optimized resolution: no arguments to apply,
			// therefore no MessageFormat needs to be involved.
			// Note that the default implementation still uses MessageFormat;
			// this can be overridden in specific subclasses.
			String message = resolveCodeWithoutArguments(code, locale);
			if (message != null) {
				return message;
			}
		}

		else {
			// Resolve arguments eagerly, for the case where the message
			// is defined in a parent MessageSource but resolvable arguments
			// are defined in the child MessageSource.
			argsToUse = resolveArguments(args, locale);

			MessageFormat messageFormat = resolveCode(code, locale);
			if (messageFormat != null) {
				synchronized (messageFormat) {
					return messageFormat.format(argsToUse);
				}
			}
		}

		// Check locale-independent common messages for the given message code.
		Properties commonMessages = getCommonMessages();
		if (commonMessages != null) {
			String commonMessage = commonMessages.getProperty(code);
			if (commonMessage != null) {
				return formatMessage(commonMessage, args, locale);
			}
		}

		// Not found -> check parent, if any.
		return getMessageFromParent(code, argsToUse, locale);
	}

	/**
	 * Try to retrieve the given message from the parent {@code MessageSource}, if any.
	 * @param code the code to lookup up, such as 'calculator.noRateSet'
	 * @param args array of arguments that will be filled in for params
	 * within the message
	 * @param locale the locale in which to do the lookup
	 * @return the resolved message, or {@code null} if not found
	 * @see #getParentMessageSource()
	 */
	/**
	 * 尝试从父{@code  MessageSource}中检索给定的消息（如果有）。 
	 *  
	 * @param 对要查找的代码进行编码，例如'calculator.noRateSet'
	 * @param  args参数数组，将为消息中的params填充参数
	 * @param  locale进行查找的语言环境
	 * @return 已解析的消息，如果找不到，则返回{@code  null} 
	 * @see  #getParentMessageSource（）
	 */
	@Nullable
	protected String getMessageFromParent(String code, @Nullable Object[] args, Locale locale) {
		MessageSource parent = getParentMessageSource();
		if (parent != null) {
			if (parent instanceof AbstractMessageSource) {
				// Call internal method to avoid getting the default code back
				// in case of "useCodeAsDefaultMessage" being activated.
				return ((AbstractMessageSource) parent).getMessageInternal(code, args, locale);
			}
			else {
				// Check parent MessageSource, returning null if not found there.
				// Covers custom MessageSource impls and DelegatingMessageSource.
				return parent.getMessage(code, args, null, locale);
			}
		}
		// Not found in parent either.
		return null;
	}

	/**
	 * Get a default message for the given {@code MessageSourceResolvable}.
	 * <p>This implementation fully renders the default message if available,
	 * or just returns the plain default message {@code String} if the primary
	 * message code is being used as a default message.
	 * @param resolvable the value object to resolve a default message for
	 * @param locale the current locale
	 * @return the default message, or {@code null} if none
	 * @since 4.3.6
	 * @see #renderDefaultMessage(String, Object[], Locale)
	 * @see #getDefaultMessage(String)
	 */
	/**
	 * 为给定的{@code  MessageSourceResolvable}获取默认消息。 
	 *  <p>此实现将完全呈现默认消息（如果可用），或者如果将主要消息代码用作默认消息，则仅返回纯默认消息{@code  String}。 
	 *  
	 * @param 可解析值对象，以为
	 * @param 语言环境解析默认消息，作为当前语言环境
	 * @return 默认消息，如果没有，则为{@code  null} @4.3.6起
	 * @see  renderDefaultMessage（String，Object []，Locale）
	 * @see  #getDefaultMessage（String）
	 */
	@Nullable
	protected String getDefaultMessage(MessageSourceResolvable resolvable, Locale locale) {
		String defaultMessage = resolvable.getDefaultMessage();
		String[] codes = resolvable.getCodes();
		if (defaultMessage != null) {
			if (resolvable instanceof DefaultMessageSourceResolvable &&
					!((DefaultMessageSourceResolvable) resolvable).shouldRenderDefaultMessage()) {
				// Given default message does not contain any argument placeholders
				// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.
				return defaultMessage;
			}
			if (!ObjectUtils.isEmpty(codes) && defaultMessage.equals(codes[0])) {
				// Never format a code-as-default-message, even with alwaysUseMessageFormat=true
				return defaultMessage;
			}
			return renderDefaultMessage(defaultMessage, resolvable.getArguments(), locale);
		}
		return (!ObjectUtils.isEmpty(codes) ? getDefaultMessage(codes[0]) : null);
	}

	/**
	 * Return a fallback default message for the given code, if any.
	 * <p>Default is to return the code itself if "useCodeAsDefaultMessage" is activated,
	 * or return no fallback else. In case of no fallback, the caller will usually
	 * receive a {@code NoSuchMessageException} from {@code getMessage}.
	 * @param code the message code that we couldn't resolve
	 * and that we didn't receive an explicit default message for
	 * @return the default message to use, or {@code null} if none
	 * @see #setUseCodeAsDefaultMessage
	 */
	/**
	 * 返回给定代码的后备默认消息（如果有）。 
	 *  <p>如果激活"useCodeAsDefaultMessage"，则默认为返回代码本身，否则不返回任何回退。 
	 * 在没有回退的情况下，调用者通常会从{@code  getMessage}收到{@code  NoSuchMessageException}。 
	 *  
	 * @param 编码我们无法解析的消息代码，并且我们没有收到明确的默认消息以供
	 * @return 使用的默认消息； 
	 * 如果没有，则为{@code  null}（
	 * @see ） #setUseCodeAsDefaultMessage
	 */
	@Nullable
	protected String getDefaultMessage(String code) {
		if (isUseCodeAsDefaultMessage()) {
			return code;
		}
		return null;
	}


	/**
	 * Searches through the given array of objects, finds any MessageSourceResolvable
	 * objects and resolves them.
	 * <p>Allows for messages to have MessageSourceResolvables as arguments.
	 * @param args array of arguments for a message
	 * @param locale the locale to resolve through
	 * @return an array of arguments with any MessageSourceResolvables resolved
	 */
	/**
	 * 搜索给定的对象数组，找到任何MessageSourceResolvable对象并解析它们。 
	 *  <p>允许消息具有MessageSourceResolvables作为参数。 
	 *  
	 * @param 消息的参数args数组
	 * @param 语言环境通过
	 * @return 解析的参数数组，其中解析了任何MessageSourceResolvables
	 */
	@Override
	protected Object[] resolveArguments(@Nullable Object[] args, Locale locale) {
		if (ObjectUtils.isEmpty(args)) {
			return super.resolveArguments(args, locale);
		}
		List<Object> resolvedArgs = new ArrayList<>(args.length);
		for (Object arg : args) {
			if (arg instanceof MessageSourceResolvable) {
				resolvedArgs.add(getMessage((MessageSourceResolvable) arg, locale));
			}
			else {
				resolvedArgs.add(arg);
			}
		}
		return resolvedArgs.toArray();
	}

	/**
	 * Subclasses can override this method to resolve a message without arguments
	 * in an optimized fashion, i.e. to resolve without involving a MessageFormat.
	 * <p>The default implementation <i>does</i> use MessageFormat, through
	 * delegating to the {@link #resolveCode} method. Subclasses are encouraged
	 * to replace this with optimized resolution.
	 * <p>Unfortunately, {@code java.text.MessageFormat} is not implemented
	 * in an efficient fashion. In particular, it does not detect that a message
	 * pattern doesn't contain argument placeholders in the first place. Therefore,
	 * it is advisable to circumvent MessageFormat for messages without arguments.
	 * @param code the code of the message to resolve
	 * @param locale the locale to resolve the code for
	 * (subclasses are encouraged to support internationalization)
	 * @return the message String, or {@code null} if not found
	 * @see #resolveCode
	 * @see java.text.MessageFormat
	 */
	/**
	 * 子类可以重写此方法以优化的方式解析不带参数的消息，即不涉及MessageFormat即可解析。 
	 *  <p>默认实现<i>确实</ i>通过委派给{@link  #resolveCode}方法来使用MessageFormat。 
	 * 鼓励子类将其替换为优化的分辨率。 
	 *  <p>不幸的是，{<@code> java.text.MessageFormat}并不是以有效的方式实现的。 
	 * 特别是，它不会检测到消息模式首先不包含参数占位符。 
	 * 因此，对于没有参数的消息，建议绕过MessageFormat。 
	 *  
	 * @param 编码要解析的消息的代码
	 * @param  locale要解析其代码的语言环境（鼓励子类支持国际化）
	 * @return 消息String，如果不是，则为{@code  null}找到
	 * @see  #resolveCode 
	 * @see  java.text.MessageFormat
	 */
	@Nullable
	protected String resolveCodeWithoutArguments(String code, Locale locale) {
		MessageFormat messageFormat = resolveCode(code, locale);
		if (messageFormat != null) {
			synchronized (messageFormat) {
				return messageFormat.format(new Object[0]);
			}
		}
		return null;
	}

	/**
	 * Subclasses must implement this method to resolve a message.
	 * <p>Returns a MessageFormat instance rather than a message String,
	 * to allow for appropriate caching of MessageFormats in subclasses.
	 * <p><b>Subclasses are encouraged to provide optimized resolution
	 * for messages without arguments, not involving MessageFormat.</b>
	 * See the {@link #resolveCodeWithoutArguments} javadoc for details.
	 * @param code the code of the message to resolve
	 * @param locale the locale to resolve the code for
	 * (subclasses are encouraged to support internationalization)
	 * @return the MessageFormat for the message, or {@code null} if not found
	 * @see #resolveCodeWithoutArguments(String, java.util.Locale)
	 */
	/**
	 * 子类必须实现此方法才能解析消息。 
	 *  <p>返回MessageFormat实例而不是消息String，以允许在子类中适当地缓存MessageFormat。 
	 * 鼓励<p> <b>子类为没有参数的消息提供优化的解析，不涉及MessageFormat。 
	 * </ b>有关详细信息，请参见{@link  #resolveCodeWithoutArguments} javadoc。 
	 *  
	 * @param 编码要解析的消息的代码
	 * @param 区域设置解析其代码的区域设置（鼓励子类支持国际化）
	 * @return 消息的MessageFormat，或者{@code  null}如果未找到
	 * @see  #resolveCodeWithoutArguments（String，java.util.Locale）
	 */
	@Nullable
	protected abstract MessageFormat resolveCode(String code, Locale locale);

}
