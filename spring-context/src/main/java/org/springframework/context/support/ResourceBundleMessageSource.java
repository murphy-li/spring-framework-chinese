/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.support;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;

/**
 * {@link org.springframework.context.MessageSource} implementation that
 * accesses resource bundles using specified basenames. This class relies
 * on the underlying JDK's {@link java.util.ResourceBundle} implementation,
 * in combination with the JDK's standard message parsing provided by
 * {@link java.text.MessageFormat}.
 *
 * <p>This MessageSource caches both the accessed ResourceBundle instances and
 * the generated MessageFormats for each message. It also implements rendering of
 * no-arg messages without MessageFormat, as supported by the AbstractMessageSource
 * base class. The caching provided by this MessageSource is significantly faster
 * than the built-in caching of the {@code java.util.ResourceBundle} class.
 *
 * <p>The basenames follow {@link java.util.ResourceBundle} conventions: essentially,
 * a fully-qualified classpath location. If it doesn't contain a package qualifier
 * (such as {@code org.mypackage}), it will be resolved from the classpath root.
 * Note that the JDK's standard ResourceBundle treats dots as package separators:
 * This means that "test.theme" is effectively equivalent to "test/theme".
 *
 * <p>On the classpath, bundle resources will be read with the locally configured
 * {@link #setDefaultEncoding encoding}: by default, ISO-8859-1; consider switching
 * this to UTF-8, or to {@code null} for the platform default encoding. On the JDK 9+
 * module path where locally provided {@code ResourceBundle.Control} handles are not
 * supported, this MessageSource always falls back to {@link ResourceBundle#getBundle}
 * retrieval with the platform default encoding: UTF-8 with a ISO-8859-1 fallback on
 * JDK 9+ (configurable through the "java.util.PropertyResourceBundle.encoding" system
 * property). Note that {@link #loadBundle(Reader)}/{@link #loadBundle(InputStream)}
 * won't be called in this case either, effectively ignoring overrides in subclasses.
 * Consider implementing a JDK 9 {@code java.util.spi.ResourceBundleProvider} instead.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see #setBasenames
 * @see ReloadableResourceBundleMessageSource
 * @see java.util.ResourceBundle
 * @see java.text.MessageFormat
 */
/**
 * {@link  org.springframework.context.MessageSource}实现，使用指定的基本名称访问资源包。 
 * 此类依赖于基础JDK的{@link  java.util.ResourceBundle}实现，以及{{@@link> java.text.MessageFormat}提供的JDK标准消息解析。 
 *  <p>此MessageSource缓存访问的ResourceBundle实例和为每个消息生成的MessageFormats。 
 * 如AbstractMessageSource基类所支持，它还实现了不带MessageFormat的无参数消息的呈现。 
 * 此MessageSource提供的缓存比{@code  java.util.ResourceBundle}类的内置缓存要快得多。 
 *  <p>基本名称遵循{@link  java.util.ResourceBundle}约定：本质上是完全合格的类路径位置。 
 * 如果它不包含包限定符（例如{@code  org.mypackage}），它将从类路径根目录解析。 
 * 请注意，JDK的标准ResourceBundle将点视为包分隔符：这意味着"test.theme"实际上等效于"test / theme"。 
 *  <p>在类路径上，将使用本地配置的{@link  #setDefaultEncoding encoding}读取捆绑包资源：默认情况下为ISO-8859-1； 
 * 考虑将其切换为UTF-8，或将其转换为{@code  null}以获取平台默认编码。 
 * 在不支持本地提供的{@code  ResourceBundle.Control}句柄的JDK 9+模块路径上，此MessageSource始终退回到{@link  ResourceBundle＃getBundle}检索，其平台默认编码为：UTF-8，带有JDK 9+上的ISO-8859-1后备（可通过"java.util.PropertyResourceBundle.encoding"系统属性进行配置）。 
 * 请注意，在这种情况下，也不会调用{@link  #loadBundle（Reader）} / {<@link> #loadBundle（InputStream）}，实际上会忽略子类中的替代。 
 * 考虑改用JDK 9 {@code  java.util.spi.ResourceBundleProvider}。 
 *  @author 罗德·约翰逊@author 于尔根·霍勒尔
 * @see  #setBasenames 
 * @see  ReloadableResourceBundleMessageSource 
 * @see  java.util.ResourceBundle 
 * @see  java.text.MessageFormat
 */
public class ResourceBundleMessageSource extends AbstractResourceBasedMessageSource implements BeanClassLoaderAware {

	@Nullable
	private ClassLoader bundleClassLoader;

	@Nullable
	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();

	/**
	 * Cache to hold loaded ResourceBundles.
	 * This Map is keyed with the bundle basename, which holds a Map that is
	 * keyed with the Locale and in turn holds the ResourceBundle instances.
	 * This allows for very efficient hash lookups, significantly faster
	 * than the ResourceBundle class's own cache.
	 */
	/**
	 * 缓存以保存加载的ResourceBundle。 
	 * 该Map用bundle basename进行绑定，bundle basename包含一个Map，该Map用Locale进行键入，并依次保存ResourceBundle实例。 
	 * 这允许非常有效的哈希查找，比ResourceBundle类自己的缓存快得多。 
	 * 
	 */
	private final Map<String, Map<Locale, ResourceBundle>> cachedResourceBundles =
			new ConcurrentHashMap<>();

	/**
	 * Cache to hold already generated MessageFormats.
	 * This Map is keyed with the ResourceBundle, which holds a Map that is
	 * keyed with the message code, which in turn holds a Map that is keyed
	 * with the Locale and holds the MessageFormat values. This allows for
	 * very efficient hash lookups without concatenated keys.
	 * @see #getMessageFormat
	 */
	/**
	 * 缓存以保存已生成的MessageFormats。 
	 * 该Map用ResourceBundle进行键控，该ResourceBundle保存一个用消息代码键控的Map，而该消息代码又保存一个用Locale键控的Map并保存MessageFormat值。 
	 * 这允许非常高效的哈希查找，而无需连接键。 
	 *  
	 * @see  #getMessageFormat
	 */
	private final Map<ResourceBundle, Map<String, Map<Locale, MessageFormat>>> cachedBundleMessageFormats =
			new ConcurrentHashMap<>();

	@Nullable
	private volatile MessageSourceControl control = new MessageSourceControl();


	public ResourceBundleMessageSource() {
		setDefaultEncoding("ISO-8859-1");
	}


	/**
	 * Set the ClassLoader to load resource bundles with.
	 * <p>Default is the containing BeanFactory's
	 * {@link org.springframework.beans.factory.BeanClassLoaderAware bean ClassLoader},
	 * or the default ClassLoader determined by
	 * {@link org.springframework.util.ClassUtils#getDefaultClassLoader()}
	 * if not running within a BeanFactory.
	 */
	/**
	 * 设置ClassLoader以加载资源束。 
	 *  <p>默认值为包含BeanFactory的{@link  org.springframework.beans.factory.BeanClassLoaderAware bean ClassLoader}，或者由{@link  org.springframework.util.ClassUtils＃getDefaultClassLoader（）}确定的默认ClassLoader。 
	 * 不在BeanFactory中运行。 
	 * 
	 */
	public void setBundleClassLoader(ClassLoader classLoader) {
		this.bundleClassLoader = classLoader;
	}

	/**
	 * Return the ClassLoader to load resource bundles with.
	 * <p>Default is the containing BeanFactory's bean ClassLoader.
	 * @see #setBundleClassLoader
	 */
	/**
	 * 返回ClassLoader以加载资源束。 
	 *  <p>默认为包含BeanFactory的Bean ClassLoader。 
	 *  
	 * @see  #setBundleClassLoader
	 */
	@Nullable
	protected ClassLoader getBundleClassLoader() {
		return (this.bundleClassLoader != null ? this.bundleClassLoader : this.beanClassLoader);
	}

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}


	/**
	 * Resolves the given message code as key in the registered resource bundles,
	 * returning the value found in the bundle as-is (without MessageFormat parsing).
	 */
	/**
	 * 将给定的消息代码解析为已注册资源束中的键，按原样返回在束中找到的值（不进行MessageFormat解析）。 
	 * 
	 */
	@Override
	protected String resolveCodeWithoutArguments(String code, Locale locale) {
		Set<String> basenames = getBasenameSet();
		for (String basename : basenames) {
			ResourceBundle bundle = getResourceBundle(basename, locale);
			if (bundle != null) {
				String result = getStringOrNull(bundle, code);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}

	/**
	 * Resolves the given message code as key in the registered resource bundles,
	 * using a cached MessageFormat instance per message code.
	 */
	/**
	 * 使用每个消息代码的缓存MessageFormat实例，将给定的消息代码解析为已注册资源包中的键。 
	 * 
	 */
	@Override
	@Nullable
	protected MessageFormat resolveCode(String code, Locale locale) {
		Set<String> basenames = getBasenameSet();
		for (String basename : basenames) {
			ResourceBundle bundle = getResourceBundle(basename, locale);
			if (bundle != null) {
				MessageFormat messageFormat = getMessageFormat(bundle, code, locale);
				if (messageFormat != null) {
					return messageFormat;
				}
			}
		}
		return null;
	}


	/**
	 * Return a ResourceBundle for the given basename and code,
	 * fetching already generated MessageFormats from the cache.
	 * @param basename the basename of the ResourceBundle
	 * @param locale the Locale to find the ResourceBundle for
	 * @return the resulting ResourceBundle, or {@code null} if none
	 * found for the given basename and Locale
	 */
	/**
	 * 返回给定基本名称和代码的ResourceBundle，从缓存中获取已生成的MessageFormat。 
	 *  
	 * @param  basename ResourceBundle的基础名称
	 * @param 语言环境，以找到<< return>结果ResourceBundle的ResourceBundle的语言环境，如果找不到给定的基础名称和语言环境，则为{@code  null}
	 */
	@Nullable
	protected ResourceBundle getResourceBundle(String basename, Locale locale) {
		if (getCacheMillis() >= 0) {
			// Fresh ResourceBundle.getBundle call in order to let ResourceBundle
			// do its native caching, at the expense of more extensive lookup steps.
			return doGetBundle(basename, locale);
		}
		else {
			// Cache forever: prefer locale cache over repeated getBundle calls.
			Map<Locale, ResourceBundle> localeMap = this.cachedResourceBundles.get(basename);
			if (localeMap != null) {
				ResourceBundle bundle = localeMap.get(locale);
				if (bundle != null) {
					return bundle;
				}
			}
			try {
				ResourceBundle bundle = doGetBundle(basename, locale);
				if (localeMap == null) {
					localeMap = new ConcurrentHashMap<>();
					Map<Locale, ResourceBundle> existing = this.cachedResourceBundles.putIfAbsent(basename, localeMap);
					if (existing != null) {
						localeMap = existing;
					}
				}
				localeMap.put(locale, bundle);
				return bundle;
			}
			catch (MissingResourceException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("ResourceBundle [" + basename + "] not found for MessageSource: " + ex.getMessage());
				}
				// Assume bundle not found
				// -> do NOT throw the exception to allow for checking parent message source.
				return null;
			}
		}
	}

	/**
	 * Obtain the resource bundle for the given basename and Locale.
	 * @param basename the basename to look for
	 * @param locale the Locale to look for
	 * @return the corresponding ResourceBundle
	 * @throws MissingResourceException if no matching bundle could be found
	 * @see java.util.ResourceBundle#getBundle(String, Locale, ClassLoader)
	 * @see #getBundleClassLoader()
	 */
	/**
	 * 获取给定的基本名称和语言环境的资源包。 
	 *  
	 * @param  basename查找
	 * @param 语言环境的基本名称如果未找到匹配的包，则查找对应的ResourceBundle 
	 * @throws  MissingResourceException的语言环境
	 * @see  java.util.ResourceBundle＃getBundle （字符串，语言环境，ClassLoader）
	 * @see  #getBundleClassLoader（）
	 */
	protected ResourceBundle doGetBundle(String basename, Locale locale) throws MissingResourceException {
		ClassLoader classLoader = getBundleClassLoader();
		Assert.state(classLoader != null, "No bundle ClassLoader set");

		MessageSourceControl control = this.control;
		if (control != null) {
			try {
				return ResourceBundle.getBundle(basename, locale, classLoader, control);
			}
			catch (UnsupportedOperationException ex) {
				// Probably in a Jigsaw environment on JDK 9+
				this.control = null;
				String encoding = getDefaultEncoding();
				if (encoding != null && logger.isInfoEnabled()) {
					logger.info("ResourceBundleMessageSource is configured to read resources with encoding '" +
							encoding + "' but ResourceBundle.Control not supported in current system environment: " +
							ex.getMessage() + " - falling back to plain ResourceBundle.getBundle retrieval with the " +
							"platform default encoding. Consider setting the 'defaultEncoding' property to 'null' " +
							"for participating in the platform default and therefore avoiding this log message.");
				}
			}
		}

		// Fallback: plain getBundle lookup without Control handle
		return ResourceBundle.getBundle(basename, locale, classLoader);
	}

	/**
	 * Load a property-based resource bundle from the given reader.
	 * <p>This will be called in case of a {@link #setDefaultEncoding "defaultEncoding"},
	 * including {@link ResourceBundleMessageSource}'s default ISO-8859-1 encoding.
	 * Note that this method can only be called with a {@code ResourceBundle.Control}:
	 * When running on the JDK 9+ module path where such control handles are not
	 * supported, any overrides in custom subclasses will effectively get ignored.
	 * <p>The default implementation returns a {@link PropertyResourceBundle}.
	 * @param reader the reader for the target resource
	 * @return the fully loaded bundle
	 * @throws IOException in case of I/O failure
	 * @since 4.2
	 * @see #loadBundle(InputStream)
	 * @see PropertyResourceBundle#PropertyResourceBundle(Reader)
	 */
	/**
	 * 从给定的读取器加载基于属性的资源束。 
	 *  <p>如果使用{@link  #setDefaultEncoding"defaultEncoding"}，包括{@link  ResourceBundleMessageSource}的默认ISO-8859-1编码，将调用此方法。 
	 * 请注意，只能使用{@code  ResourceBundle.Control}调用此方法：在不支持此类控件句柄的JDK 9+模块路径上运行时，自定义子类中的任何覆盖都将有效地被忽略。 
	 *  <p>默认实现返回一个{@link  PropertyResourceBundle}。 
	 *  
	 * @param 读取器目标资源的读取器
	 * @return 完全加载的捆绑软件
	 * @throws  IO发生I / O失败时IOException @自4.2起
	 * @see  #loadBundle（InputStream）
	 * @see  （读者）
	 */
	protected ResourceBundle loadBundle(Reader reader) throws IOException {
		return new PropertyResourceBundle(reader);
	}

	/**
	 * Load a property-based resource bundle from the given input stream,
	 * picking up the default properties encoding on JDK 9+.
	 * <p>This will only be called with {@link #setDefaultEncoding "defaultEncoding"}
	 * set to {@code null}, explicitly enforcing the platform default encoding
	 * (which is UTF-8 with a ISO-8859-1 fallback on JDK 9+ but configurable
	 * through the "java.util.PropertyResourceBundle.encoding" system property).
	 * Note that this method can only be called with a {@code ResourceBundle.Control}:
	 * When running on the JDK 9+ module path where such control handles are not
	 * supported, any overrides in custom subclasses will effectively get ignored.
	 * <p>The default implementation returns a {@link PropertyResourceBundle}.
	 * @param inputStream the input stream for the target resource
	 * @return the fully loaded bundle
	 * @throws IOException in case of I/O failure
	 * @since 5.1
	 * @see #loadBundle(Reader)
	 * @see PropertyResourceBundle#PropertyResourceBundle(InputStream)
	 */
	/**
	 * 从给定的输入流中加载基于属性的资源包，并选择JDK 9+上的默认属性编码。 
	 *  <p>仅在将{@link  #setDefaultEncoding"defaultEncoding"}设置为{@code  null}的情况下调用此方法，显式强制执行平台默认编码（采用ISO-8859-1后备格式的UTF-8在JDK 9+上，但可以通过"java.util.PropertyResourceBundle.encoding"系统属性进行配置）。 
	 * 请注意，只能使用{@code  ResourceBundle.Control}调用此方法：在不支持此类控件句柄的JDK 9+模块路径上运行时，自定义子类中的任何覆盖都将有效地被忽略。 
	 *  <p>默认实现返回一个{@link  PropertyResourceBundle}。 
	 *  
	 * @param  inputStream目标资源的输入流
	 * @return 完全加载的包
	 * @throws  IOException（在I / O失败的情况下）IOException @始于5​​.1 
	 * @see  #loadBundle（Reader）
	 * @see  PropertyResourceBundle＃ PropertyResourceBundle（InputStream）
	 */
	protected ResourceBundle loadBundle(InputStream inputStream) throws IOException {
		return new PropertyResourceBundle(inputStream);
	}

	/**
	 * Return a MessageFormat for the given bundle and code,
	 * fetching already generated MessageFormats from the cache.
	 * @param bundle the ResourceBundle to work on
	 * @param code the message code to retrieve
	 * @param locale the Locale to use to build the MessageFormat
	 * @return the resulting MessageFormat, or {@code null} if no message
	 * defined for the given code
	 * @throws MissingResourceException if thrown by the ResourceBundle
	 */
	/**
	 * 返回给定包和代码的MessageFormat，从缓存中获取已生成的MessageFormat。 
	 *  
	 * @param 捆绑ResourceBundle以便在
	 * @param 代码上工作消息代码以检索
	 * @param 语言环境，用于构建MessageFormat的语言环境
	 * @return 生成的MessageFormat，或者{@code  null}如果由ResourceBundle抛出，则没有为给定代码
	 * @throws  MissingResourceException定义任何消息
	 */
	@Nullable
	protected MessageFormat getMessageFormat(ResourceBundle bundle, String code, Locale locale)
			throws MissingResourceException {

		Map<String, Map<Locale, MessageFormat>> codeMap = this.cachedBundleMessageFormats.get(bundle);
		Map<Locale, MessageFormat> localeMap = null;
		if (codeMap != null) {
			localeMap = codeMap.get(code);
			if (localeMap != null) {
				MessageFormat result = localeMap.get(locale);
				if (result != null) {
					return result;
				}
			}
		}

		String msg = getStringOrNull(bundle, code);
		if (msg != null) {
			if (codeMap == null) {
				codeMap = new ConcurrentHashMap<>();
				Map<String, Map<Locale, MessageFormat>> existing =
						this.cachedBundleMessageFormats.putIfAbsent(bundle, codeMap);
				if (existing != null) {
					codeMap = existing;
				}
			}
			if (localeMap == null) {
				localeMap = new ConcurrentHashMap<>();
				Map<Locale, MessageFormat> existing = codeMap.putIfAbsent(code, localeMap);
				if (existing != null) {
					localeMap = existing;
				}
			}
			MessageFormat result = createMessageFormat(msg, locale);
			localeMap.put(locale, result);
			return result;
		}

		return null;
	}

	/**
	 * Efficiently retrieve the String value for the specified key,
	 * or return {@code null} if not found.
	 * <p>As of 4.2, the default implementation checks {@code containsKey}
	 * before it attempts to call {@code getString} (which would require
	 * catching {@code MissingResourceException} for key not found).
	 * <p>Can be overridden in subclasses.
	 * @param bundle the ResourceBundle to perform the lookup in
	 * @param key the key to look up
	 * @return the associated value, or {@code null} if none
	 * @since 4.2
	 * @see ResourceBundle#getString(String)
	 * @see ResourceBundle#containsKey(String)
	 */
	/**
	 * 有效地检索指定键的String值，如果找不到，则返回{@code  null}。 
	 *  <p>从4.2版本开始，默认实现在尝试调用{@code  getString}之前会检查{@code  containsKey}（这将需要捕获{@code  MissingResourceException}来查找未找到的密钥）。 
	 *  <p>可以在子类中覆盖。 
	 *  
	 * @param 捆绑ResourceBundle以在
	 * @param 键中执行查找，以查找
	 * @return 相关值的键，如果没有，则为{@code  null} @4.2起，@
	 * @see> ResourceBundle＃getString （字符串）
	 * @see  ResourceBundle＃containsKey（字符串）
	 */
	@Nullable
	protected String getStringOrNull(ResourceBundle bundle, String key) {
		if (bundle.containsKey(key)) {
			try {
				return bundle.getString(key);
			}
			catch (MissingResourceException ex) {
				// Assume key not found for some other reason
				// -> do NOT throw the exception to allow for checking parent message source.
			}
		}
		return null;
	}

	/**
	 * Show the configuration of this MessageSource.
	 */
	/**
	 * 显示此MessageSource的配置。 
	 * 
	 */
	@Override
	public String toString() {
		return getClass().getName() + ": basenames=" + getBasenameSet();
	}


	/**
	 * Custom implementation of {@code ResourceBundle.Control}, adding support
	 * for custom file encodings, deactivating the fallback to the system locale
	 * and activating ResourceBundle's native cache, if desired.
	 */
	/**
	 * {@code  ResourceBundle.Control}的自定义实现，添加了对自定义文件编码的支持，取消了对系统区域设置的回退，并根据需要激活了ResourceBundle的本机缓存。 
	 * 
	 */
	private class MessageSourceControl extends ResourceBundle.Control {

		@Override
		@Nullable
		public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload)
				throws IllegalAccessException, InstantiationException, IOException {

			// Special handling of default encoding
			if (format.equals("java.properties")) {
				String bundleName = toBundleName(baseName, locale);
				final String resourceName = toResourceName(bundleName, "properties");
				final ClassLoader classLoader = loader;
				final boolean reloadFlag = reload;
				InputStream inputStream;
				try {
					inputStream = AccessController.doPrivileged((PrivilegedExceptionAction<InputStream>) () -> {
						InputStream is = null;
						if (reloadFlag) {
							URL url = classLoader.getResource(resourceName);
							if (url != null) {
								URLConnection connection = url.openConnection();
								if (connection != null) {
									connection.setUseCaches(false);
									is = connection.getInputStream();
								}
							}
						}
						else {
							is = classLoader.getResourceAsStream(resourceName);
						}
						return is;
					});
				}
				catch (PrivilegedActionException ex) {
					throw (IOException) ex.getException();
				}
				if (inputStream != null) {
					String encoding = getDefaultEncoding();
					if (encoding != null) {
						try (InputStreamReader bundleReader = new InputStreamReader(inputStream, encoding)) {
							return loadBundle(bundleReader);
						}
					}
					else {
						try (InputStream bundleStream = inputStream) {
							return loadBundle(bundleStream);
						}
					}
				}
				else {
					return null;
				}
			}
			else {
				// Delegate handling of "java.class" format to standard Control
				return super.newBundle(baseName, locale, format, loader, reload);
			}
		}

		@Override
		@Nullable
		public Locale getFallbackLocale(String baseName, Locale locale) {
			Locale defaultLocale = getDefaultLocale();
			return (defaultLocale != null && !defaultLocale.equals(locale) ? defaultLocale : null);
		}

		@Override
		public long getTimeToLive(String baseName, Locale locale) {
			long cacheMillis = getCacheMillis();
			return (cacheMillis >= 0 ? cacheMillis : super.getTimeToLive(baseName, locale));
		}

		@Override
		public boolean needsReload(
				String baseName, Locale locale, String format, ClassLoader loader, ResourceBundle bundle, long loadTime) {

			if (super.needsReload(baseName, locale, format, loader, bundle, loadTime)) {
				cachedBundleMessageFormats.remove(bundle);
				return true;
			}
			else {
				return false;
			}
		}
	}

}
