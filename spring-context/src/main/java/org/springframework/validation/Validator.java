/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.validation;

/**
 * A validator for application-specific objects.
 *
 * <p>This interface is totally divorced from any infrastructure
 * or context; that is to say it is not coupled to validating
 * only objects in the web tier, the data-access tier, or the
 * whatever-tier. As such it is amenable to being used in any layer
 * of an application, and supports the encapsulation of validation
 * logic as a first-class citizen in its own right.
 *
 * <p>Find below a simple but complete {@code Validator}
 * implementation, which validates that the various {@link String}
 * properties of a {@code UserLogin} instance are not empty
 * (that is they are not {@code null} and do not consist
 * wholly of whitespace), and that any password that is present is
 * at least {@code 'MINIMUM_PASSWORD_LENGTH'} characters in length.
 *
 * <pre class="code"> public class UserLoginValidator implements Validator {
 *
 *    private static final int MINIMUM_PASSWORD_LENGTH = 6;
 *
 *    public boolean supports(Class clazz) {
 *       return UserLogin.class.isAssignableFrom(clazz);
 *    }
 *
 *    public void validate(Object target, Errors errors) {
 *       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "userName", "field.required");
 *       ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "field.required");
 *       UserLogin login = (UserLogin) target;
 *       if (login.getPassword() != null
 *             && login.getPassword().trim().length() < MINIMUM_PASSWORD_LENGTH) {
 *          errors.rejectValue("password", "field.min.length",
 *                new Object[]{Integer.valueOf(MINIMUM_PASSWORD_LENGTH)},
 *                "The password must be at least [" + MINIMUM_PASSWORD_LENGTH + "] characters in length.");
 *       }
 *    }
 * }</pre>
 *
 * <p>See also the Spring reference manual for a fuller discussion of
 * the {@code Validator} interface and its role in an enterprise
 * application.
 *
 * @author Rod Johnson
 * @see SmartValidator
 * @see Errors
 * @see ValidationUtils
 */
/**
 * 用于特定于应用程序的对象的验证器。 
 *  <p>此接口完全脱离了任何基础架构或上下文； 
 * 也就是说，它不与仅验证Web层，数据访问层或任何层中的对象耦合。 
 * 因此，它可以在应用程序的任何层中使用，并支持将验证逻辑本身封装为一等公民。 
 *  <p>在下面找到一个简单但完整的{@code  Validator}实现，该实现可验证{@code  UserLogin}实例的各种{@link  String}属性不是空的（即它们不是{@code  null}并且不完全由空格组成），并且所存在的任何密码的长度至少为{@code 'MINIMUM_PASSWORD_LENGTH'}个字符。 
 *  <pre class ="code">公共类UserLoginValidator实现了Validator {private static final int MINIMUM_PASSWORD_LENGTH = 6; public boolean support（Class clazz）{返回UserLogin.class.isAssignableFrom（clazz）; } public void validate（对象目标，错误错误）{ValidationUtils.rejectIfEmptyOrWhitespace（errors，"userName"，"field.required"）; ValidationUtils.rejectIfEmptyOrWhitespace（errors，"password"，"field.required"）; UserLogin登录=（UserLogin）目标; if（login.getPassword（）！ 
 * = null && login.getPassword（）。 
 * trim（）。 
 * length（）<MINIMUM_PASSWORD_LENGTH）{errors.rejectValue（"password"，"field.min.length"，new Object [] {Integer .valueOf（MINIMUM_PASSWORD_LENGTH）}，"密码的长度必须至少为["+ MINIMUM_PASSWORD_LENGTH +"]个字符。 
 * "）; }}} </ pre> <p>另请参见Spring参考手册，以更全面地讨论{@code  Validator}接口及其在企业应用程序中的作用。 
 *  @author  Rod Johnson 
 * @see  SmartValidator 
 * @see 错误
 * @see  ValidationUtils
 */
public interface Validator {

	/**
	 * Can this {@link Validator} {@link #validate(Object, Errors) validate}
	 * instances of the supplied {@code clazz}?
	 * <p>This method is <i>typically</i> implemented like so:
	 * <pre class="code">return Foo.class.isAssignableFrom(clazz);</pre>
	 * (Where {@code Foo} is the class (or superclass) of the actual
	 * object instance that is to be {@link #validate(Object, Errors) validated}.)
	 * @param clazz the {@link Class} that this {@link Validator} is
	 * being asked if it can {@link #validate(Object, Errors) validate}
	 * @return {@code true} if this {@link Validator} can indeed
	 * {@link #validate(Object, Errors) validate} instances of the
	 * supplied {@code clazz}
	 */
	/**
	 * 此{@link 验证程序} {@link  #validate（Object，Errors）验证}提供的{@code  clazz}的实例可以吗？ <p>此方法通常<i> </ i>的实现方式如下：<pre class ="code">返回Foo.class.isAssignableFrom（clazz）; </ pre>（其中{<@@code> Foo}是{{@link> #validate（Object，Errors）validated}的实际对象实例的类（或超类）。 
	 * ）
	 * @param 对此{<@link询问>验证程序}是否可以{@link  #validate（Object，Errors validate）} 
	 * @return  {@code  true}，如果此{@link 验证程序}确实可以{@link 提供的{@code  clazz}的#validate（Object，Errors）validate}实例
	 */
	boolean supports(Class<?> clazz);

	/**
	 * Validate the supplied {@code target} object, which must be
	 * of a {@link Class} for which the {@link #supports(Class)} method
	 * typically has (or would) return {@code true}.
	 * <p>The supplied {@link Errors errors} instance can be used to report
	 * any resulting validation errors.
	 * @param target the object that is to be validated
	 * @param errors contextual state about the validation process
	 * @see ValidationUtils
	 */
	/**
	 * 验证提供的{@code 目标}对象，该对象必须是{@link  #supports（Class）}方法通常具有（或会）返回{<@code > true}。 
	 *  <p>提供的{@link 错误错误}实例可用于报告所有由此产生的验证错误。 
	 *  
	 * @param 定位要验证的对象
	 * @param 有关验证过程的上下文状态错误
	 * @see  ValidationUtils
	 */
	void validate(Object target, Errors errors);

}
