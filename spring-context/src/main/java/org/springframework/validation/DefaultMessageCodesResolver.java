/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.validation;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.StringJoiner;

import org.springframework.lang.Nullable;
import org.springframework.util.StringUtils;

/**
 * Default implementation of the {@link MessageCodesResolver} interface.
 *
 * <p>Will create two message codes for an object error, in the following order (when
 * using the {@link Format#PREFIX_ERROR_CODE prefixed}
 * {@link #setMessageCodeFormatter(MessageCodeFormatter) formatter}):
 * <ul>
 * <li>1.: code + "." + object name
 * <li>2.: code
 * </ul>
 *
 * <p>Will create four message codes for a field specification, in the following order:
 * <ul>
 * <li>1.: code + "." + object name + "." + field
 * <li>2.: code + "." + field
 * <li>3.: code + "." + field type
 * <li>4.: code
 * </ul>
 *
 * <p>For example, in case of code "typeMismatch", object name "user", field "age":
 * <ul>
 * <li>1. try "typeMismatch.user.age"
 * <li>2. try "typeMismatch.age"
 * <li>3. try "typeMismatch.int"
 * <li>4. try "typeMismatch"
 * </ul>
 *
 * <p>This resolution algorithm thus can be leveraged for example to show
 * specific messages for binding errors like "required" and "typeMismatch":
 * <ul>
 * <li>at the object + field level ("age" field, but only on "user");
 * <li>at the field level (all "age" fields, no matter which object name);
 * <li>or at the general level (all fields, on any object).
 * </ul>
 *
 * <p>In case of array, {@link List} or {@link java.util.Map} properties,
 * both codes for specific elements and for the whole collection are
 * generated. Assuming a field "name" of an array "groups" in object "user":
 * <ul>
 * <li>1. try "typeMismatch.user.groups[0].name"
 * <li>2. try "typeMismatch.user.groups.name"
 * <li>3. try "typeMismatch.groups[0].name"
 * <li>4. try "typeMismatch.groups.name"
 * <li>5. try "typeMismatch.name"
 * <li>6. try "typeMismatch.java.lang.String"
 * <li>7. try "typeMismatch"
 * </ul>
 *
 * <p>By default the {@code errorCode}s will be placed at the beginning of constructed
 * message strings. The {@link #setMessageCodeFormatter(MessageCodeFormatter)
 * messageCodeFormatter} property can be used to specify an alternative concatenation
 * {@link MessageCodeFormatter format}.
 *
 * <p>In order to group all codes into a specific category within your resource bundles,
 * e.g. "validation.typeMismatch.name" instead of the default "typeMismatch.name",
 * consider specifying a {@link #setPrefix prefix} to be applied.
 *
 * @author Juergen Hoeller
 * @author Phillip Webb
 * @author Chris Beams
 * @since 1.0.1
 */
/**
 * {@link  MessageCodesResolver}接口的默认实现。 
 *  <p>将按照以下顺序为对象错误创建两个消息代码（使用{@link  Format＃PREFIX_ERROR_CODE前缀} {@link  #setMessageCodeFormatter（MessageCodeFormatter）formatter}时）：<ul> <li > 1 .：代码+"。 
 * "+对象名称<li> 2 .:代码</ ul> <p>将为字段说明创建四个消息代码，顺序如下：<ul> <li> 1 .: code +"。 
 * "+对象名称+"。 
 * "+栏位<li> 2 .：代码+"。 
 * "+栏位<li> 3 .：代码+"。 
 * "+字段类型<li> 4 .：代码</ ul> <p>例如，对于代码"typeMismatch"，对象名称为"user"，字段"age"：<ul> <li> 1。 
 * 尝试"typeMismatch.user.age"<li> 2。 
 * 尝试"typeMismatch.age"<li> 3。 
 * 尝试"typeMismatch.int"<li> 4。 
 * 尝试使用"typeMismatch"</ ul> <p>例如，可以利用此解析算法来显示特定的消息，以了解诸如"required"和"typeMismatch"的绑定错误：<ul> <li>在对象+字段级别（"年龄"字段，但仅针对"用户"）； 
 *  <li>在字段级别（所有"年龄"字段，无论使用哪个对象名称）； 
 *  <li>或在常规级别（所有字段，在任何对象上）。 
 *  </ ul> <p>如果是数组，{<@link>列表}或{@link  java.util.Map}属性，则将生成特定元素和整个集合的代码。 
 * 假设对象"用户"中数组"组"的字段"名称"为：<ul> <li> 1。 
 * 尝试"typeMismatch.user.groups [0] .name"<li> 2。 
 * 尝试"typeMismatch.user.groups.name"<li> 3。 
 * 尝试"typeMismatch.groups [0] .name"<li> 4。 
 * 尝试"typeMismatch.groups.name"<li> 5。 
 * 尝试"typeMismatch.name"<li> 6。 
 * 尝试"typeMismatch.java.lang.String"<li> 7。 
 * 尝试"typeMismatch"</ ul> <p>默认情况下，{@code  errorCode} s将放置在构造的消息字符串的开头。 
 *  {@link  #setMessageCodeFormatter（MessageCodeFormatter）messageCodeFormatter}属性可用于指定备用串联{@link  MessageCodeFormatter format}。 
 *  <p>为了将所有代码分组到资源束中的特定类别，例如考虑使用"validation.typeMismatch.name"而不是默认的"typeMismatch.name"，指定要应用的{@link  #setPrefix前缀}。 
 *  @author  Juergen Hoeller @author  Phillip Webb @author 克里斯·比姆斯（Chris Beams）1.0.1起
 */
@SuppressWarnings("serial")
public class DefaultMessageCodesResolver implements MessageCodesResolver, Serializable {

	/**
	 * The separator that this implementation uses when resolving message codes.
	 */
	/**
	 * 此实现在解析消息代码时使用的分隔符。 
	 * 
	 */
	public static final String CODE_SEPARATOR = ".";

	private static final MessageCodeFormatter DEFAULT_FORMATTER = Format.PREFIX_ERROR_CODE;


	private String prefix = "";

	private MessageCodeFormatter formatter = DEFAULT_FORMATTER;


	/**
	 * Specify a prefix to be applied to any code built by this resolver.
	 * <p>Default is none. Specify, for example, "validation." to get
	 * error codes like "validation.typeMismatch.name".
	 */
	/**
	 * 指定要应用于此解析器构建的任何代码的前缀。 
	 *  <p>默认为无。 
	 * 指定例如"验证"。 
	 * 获取错误代码，例如"validation.typeMismatch.name"。 
	 * 
	 */
	public void setPrefix(@Nullable String prefix) {
		this.prefix = (prefix != null ? prefix : "");
	}

	/**
	 * Return the prefix to be applied to any code built by this resolver.
	 * <p>Returns an empty String in case of no prefix.
	 */
	/**
	 * 返回要应用于此解析器构建的任何代码的前缀。 
	 *  <p>在没有前缀的情况下返回一个空字符串。 
	 * 
	 */
	protected String getPrefix() {
		return this.prefix;
	}

	/**
	 * Specify the format for message codes built by this resolver.
	 * <p>The default is {@link Format#PREFIX_ERROR_CODE}.
	 * @since 3.2
	 * @see Format
	 */
	/**
	 * 指定此解析器生成的消息代码的格式。 
	 *  <p>默认值为{@link  Format＃PREFIX_ERROR_CODE}。 
	 *  @since 3.2 
	 * @see 格式
	 */
	public void setMessageCodeFormatter(@Nullable MessageCodeFormatter formatter) {
		this.formatter = (formatter != null ? formatter : DEFAULT_FORMATTER);
	}


	@Override
	public String[] resolveMessageCodes(String errorCode, String objectName) {
		return resolveMessageCodes(errorCode, objectName, "", null);
	}

	/**
	 * Build the code list for the given code and field: an
	 * object/field-specific code, a field-specific code, a plain error code.
	 * <p>Arrays, Lists and Maps are resolved both for specific elements and
	 * the whole collection.
	 * <p>See the {@link DefaultMessageCodesResolver class level javadoc} for
	 * details on the generated codes.
	 * @return the list of codes
	 */
	/**
	 * 为给定的代码和字段构建代码列表：对象/字段特定的代码，字段特定的代码，纯错误代码。 
	 *  <p>数组，列表和映射都针对特定元素和整个集合进行解析。 
	 *  <p>有关生成的代码的详细信息，请参见{@link  DefaultMessageCodesResolver类级别javadoc}。 
	 *  
	 * @return 代码列表
	 */
	@Override
	public String[] resolveMessageCodes(String errorCode, String objectName, String field, @Nullable Class<?> fieldType) {
		Set<String> codeList = new LinkedHashSet<>();
		List<String> fieldList = new ArrayList<>();
		buildFieldList(field, fieldList);
		addCodes(codeList, errorCode, objectName, fieldList);
		int dotIndex = field.lastIndexOf('.');
		if (dotIndex != -1) {
			buildFieldList(field.substring(dotIndex + 1), fieldList);
		}
		addCodes(codeList, errorCode, null, fieldList);
		if (fieldType != null) {
			addCode(codeList, errorCode, null, fieldType.getName());
		}
		addCode(codeList, errorCode, null, null);
		return StringUtils.toStringArray(codeList);
	}

	private void addCodes(Collection<String> codeList, String errorCode, @Nullable String objectName, Iterable<String> fields) {
		for (String field : fields) {
			addCode(codeList, errorCode, objectName, field);
		}
	}

	private void addCode(Collection<String> codeList, String errorCode, @Nullable String objectName, @Nullable String field) {
		codeList.add(postProcessMessageCode(this.formatter.format(errorCode, objectName, field)));
	}

	/**
	 * Add both keyed and non-keyed entries for the supplied {@code field}
	 * to the supplied field list.
	 */
	/**
	 * 将提供的{@code 字段}的键输入和非键输入都添加到提供的字段列表中。 
	 * 
	 */
	protected void buildFieldList(String field, List<String> fieldList) {
		fieldList.add(field);
		String plainField = field;
		int keyIndex = plainField.lastIndexOf('[');
		while (keyIndex != -1) {
			int endKeyIndex = plainField.indexOf(']', keyIndex);
			if (endKeyIndex != -1) {
				plainField = plainField.substring(0, keyIndex) + plainField.substring(endKeyIndex + 1);
				fieldList.add(plainField);
				keyIndex = plainField.lastIndexOf('[');
			}
			else {
				keyIndex = -1;
			}
		}
	}

	/**
	 * Post-process the given message code, built by this resolver.
	 * <p>The default implementation applies the specified prefix, if any.
	 * @param code the message code as built by this resolver
	 * @return the final message code to be returned
	 * @see #setPrefix
	 */
	/**
	 * 对由此解析器构建的给定消息代码进行后处理。 
	 *  <p>默认实现使用指定的前缀（如果有）。 
	 *  
	 * @param 编码此解析器构建的消息代码
	 * @return 要返回的最终消息代码
	 * @see  #setPrefix
	 */
	protected String postProcessMessageCode(String code) {
		return getPrefix() + code;
	}


	/**
	 * Common message code formats.
	 * @see MessageCodeFormatter
	 * @see DefaultMessageCodesResolver#setMessageCodeFormatter(MessageCodeFormatter)
	 */
	/**
	 * 通用消息代码格式。 
	 *  
	 * @see  MessageCodeFormatter 
	 * @see  DefaultMessageCodesResolver＃setMessageCodeFormatter（MessageCodeFormatter）
	 */
	public enum Format implements MessageCodeFormatter {

		/**
		 * Prefix the error code at the beginning of the generated message code. e.g.:
		 * {@code errorCode + "." + object name + "." + field}
		 */
		/**
		 * 将错误代码前缀在生成的消息代码的开头。 
		 * 例如：{<@@code> errorCode +"。 
		 *  +对象名称+"。 
		 * "+栏位}
		 */
		PREFIX_ERROR_CODE {
			@Override
			public String format(String errorCode, @Nullable String objectName, @Nullable String field) {
				return toDelimitedString(errorCode, objectName, field);
			}
		},

		/**
		 * Postfix the error code at the end of the generated message code. e.g.:
		 * {@code object name + "." + field + "." + errorCode}
		 */
		/**
		 * 将错误代码后缀到生成的消息代码的末尾。 
		 * 例如：{@code 对象名称+"。 
		 *  +栏位+"。 
		 * "+ errorCode}
		 */
		POSTFIX_ERROR_CODE {
			@Override
			public String format(String errorCode, @Nullable String objectName, @Nullable String field) {
				return toDelimitedString(objectName, field, errorCode);
			}
		};

		/**
		 * Concatenate the given elements, delimiting each with
		 * {@link DefaultMessageCodesResolver#CODE_SEPARATOR}, skipping zero-length or
		 * null elements altogether.
		 */
		/**
		 * 连接给定元素，用{@link  DefaultMessageCodesResolver＃CODE_SEPARATOR}分隔每个元素，完全跳过零长度或空元素。 
		 * 
		 */
		public static String toDelimitedString(String... elements) {
			StringJoiner rtn = new StringJoiner(CODE_SEPARATOR);
			for (String element : elements) {
				if (StringUtils.hasLength(element)) {
					rtn.add(element);
				}
			}
			return rtn.toString();
		}
	}

}
