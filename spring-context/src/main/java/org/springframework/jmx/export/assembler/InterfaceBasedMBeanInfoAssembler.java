/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2020的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jmx.export.assembler;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * Subclass of {@code AbstractReflectiveMBeanInfoAssembler} that allows for
 * the management interface of a bean to be defined using arbitrary interfaces.
 * Any methods or properties that are defined in those interfaces are exposed
 * as MBean operations and attributes.
 *
 * <p>By default, this class votes on the inclusion of each operation or attribute
 * based on the interfaces implemented by the bean class. However, you can supply an
 * array of interfaces via the {@code managedInterfaces} property that will be
 * used instead. If you have multiple beans and you wish each bean to use a different
 * set of interfaces, then you can map bean keys (that is the name used to pass the
 * bean to the {@code MBeanExporter}) to a list of interface names using the
 * {@code interfaceMappings} property.
 *
 * <p>If you specify values for both {@code interfaceMappings} and
 * {@code managedInterfaces}, Spring will attempt to find interfaces in the
 * mappings first. If no interfaces for the bean are found, it will use the
 * interfaces defined by {@code managedInterfaces}.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @since 1.2
 * @see #setManagedInterfaces
 * @see #setInterfaceMappings
 * @see MethodNameBasedMBeanInfoAssembler
 * @see SimpleReflectiveMBeanInfoAssembler
 * @see org.springframework.jmx.export.MBeanExporter
 */
/**
 * {@code  AbstractReflectiveMBeanInfoAssembler}的子类，允许使用任意接口定义bean的管理接口。 
 * 这些接口中定义的任何方法或属性都作为MBean操作和属性公开。 
 *  <p>默认情况下，此类基于Bean类实现的接口对每个操作或属性的包含进行投票。 
 * 但是，您可以通过将使用的{@code  managedInterfaces}属性提供一系列接口。 
 * 如果您有多个bean，并且希望每个bean使用一组不同的接口，则可以将bean键（即用于将bean传递到{@code  MBeanExporter}的名称）映射到接口名称列表使用{@code  interfaceMappings}属性。 
 *  <p>如果您同时为{@code  interfaceMappings}和{@code  managedInterfaces}指定值，Spring将尝试首先在映射中查找接口。 
 * 如果找不到该bean的接口，它将使用{@code  managedInterfaces}定义的接口。 
 *  @author 罗布·哈罗普（Rob Harrop）@author 于尔根·霍勒（Juergen Hoeller）@自1.2起
 */
public class InterfaceBasedMBeanInfoAssembler extends AbstractConfigurableMBeanInfoAssembler
		implements BeanClassLoaderAware, InitializingBean {

	@Nullable
	private Class<?>[] managedInterfaces;

	/** Mappings of bean keys to an array of classes. */
	/**
	 * bean键到类数组的映射。 
	 * 
	 */
	@Nullable
	private Properties interfaceMappings;

	@Nullable
	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();

	/** Mappings of bean keys to an array of classes. */
	/**
	 * bean键到类数组的映射。 
	 * 
	 */
	@Nullable
	private Map<String, Class<?>[]> resolvedInterfaceMappings;


	/**
	 * Set the array of interfaces to use for creating the management info.
	 * These interfaces will be used for a bean if no entry corresponding to
	 * that bean is found in the {@code interfaceMappings} property.
	 * @param managedInterfaces an array of classes indicating the interfaces to use.
	 * Each entry <strong>MUST</strong> be an interface.
	 * @see #setInterfaceMappings
	 */
	/**
	 * 设置用于创建管理信息的接口阵列。 
	 * 如果在{@code  interfaceMappings}属性中找不到与该bean对应的条目，则这些接口将用于bean。 
	 *  
	 * @param  managedInterfaces表示要使用的接口的类的数组。 
	 * 每个条目<strong>必须</ strong>都是一个界面。 
	 *  
	 * @see  #setInterfaceMappings
	 */
	public void setManagedInterfaces(@Nullable Class<?>... managedInterfaces) {
		if (managedInterfaces != null) {
			for (Class<?> ifc : managedInterfaces) {
				if (!ifc.isInterface()) {
					throw new IllegalArgumentException(
							"Management interface [" + ifc.getName() + "] is not an interface");
				}
			}
		}
		this.managedInterfaces = managedInterfaces;
	}

	/**
	 * Set the mappings of bean keys to a comma-separated list of interface names.
	 * <p>The property key should match the bean key and the property value should match
	 * the list of interface names. When searching for interfaces for a bean, Spring
	 * will check these mappings first.
	 * @param mappings the mappings of bean keys to interface names
	 */
	/**
	 * 将bean键的映射设置为接口名称的逗号分隔列表。 
	 *  <p>属性键应与bean键匹配，属性值应与接口名称列表匹配。 
	 * 在搜索bean的接口时，Spring将首先检查这些映射。 
	 *  
	 * @param 将Bean键的映射映射到接口名称
	 */
	public void setInterfaceMappings(@Nullable Properties mappings) {
		this.interfaceMappings = mappings;
	}

	@Override
	public void setBeanClassLoader(@Nullable ClassLoader beanClassLoader) {
		this.beanClassLoader = beanClassLoader;
	}


	@Override
	public void afterPropertiesSet() {
		if (this.interfaceMappings != null) {
			this.resolvedInterfaceMappings = resolveInterfaceMappings(this.interfaceMappings);
		}
	}

	/**
	 * Resolve the given interface mappings, turning class names into Class objects.
	 * @param mappings the specified interface mappings
	 * @return the resolved interface mappings (with Class objects as values)
	 */
	/**
	 * 解析给定的接口映射，将类名称转换为Class对象。 
	 *  
	 * @param 映射指定的接口映射
	 * @return 解析的接口映射（以Class对象为值）
	 */
	private Map<String, Class<?>[]> resolveInterfaceMappings(Properties mappings) {
		Map<String, Class<?>[]> resolvedMappings = new HashMap<>(mappings.size());
		for (Enumeration<?> en = mappings.propertyNames(); en.hasMoreElements();) {
			String beanKey = (String) en.nextElement();
			String[] classNames = StringUtils.commaDelimitedListToStringArray(mappings.getProperty(beanKey));
			Class<?>[] classes = resolveClassNames(classNames, beanKey);
			resolvedMappings.put(beanKey, classes);
		}
		return resolvedMappings;
	}

	/**
	 * Resolve the given class names into Class objects.
	 * @param classNames the class names to resolve
	 * @param beanKey the bean key that the class names are associated with
	 * @return the resolved Class
	 */
	/**
	 * 将给定的类名称解析为Class对象。 
	 *  
	 * @param  classNames为要解析的类名
	 * @param  beanKey与该类名关联的bean键与
	 * @return 所解析的Class
	 */
	private Class<?>[] resolveClassNames(String[] classNames, String beanKey) {
		Class<?>[] classes = new Class<?>[classNames.length];
		for (int x = 0; x < classes.length; x++) {
			Class<?> cls = ClassUtils.resolveClassName(classNames[x].trim(), this.beanClassLoader);
			if (!cls.isInterface()) {
				throw new IllegalArgumentException(
						"Class [" + classNames[x] + "] mapped to bean key [" + beanKey + "] is no interface");
			}
			classes[x] = cls;
		}
		return classes;
	}


	/**
	 * Check to see if the {@code Method} is declared in
	 * one of the configured interfaces and that it is public.
	 * @param method the accessor {@code Method}.
	 * @param beanKey the key associated with the MBean in the
	 * {@code beans} {@code Map}.
	 * @return {@code true} if the {@code Method} is declared in one of the
	 * configured interfaces, otherwise {@code false}.
	 */
	/**
	 * 检查{@code 方法}是否在已配置的接口之一中声明并且是公共的。 
	 *  
	 * @param 方法访问者{@code 方法}。 
	 *  
	 * @param  beanKey与{@code  bean} {@code  Map}中与MBean关联的密钥。 
	 *  
	 * @return  {@code  true}，如果在已配置的接口之一中声明了{@code 方法}，否则为{@code  false}。 
	 * 
	 */
	@Override
	protected boolean includeReadAttribute(Method method, String beanKey) {
		return isPublicInInterface(method, beanKey);
	}

	/**
	 * Check to see if the {@code Method} is declared in
	 * one of the configured interfaces and that it is public.
	 * @param method the mutator {@code Method}.
	 * @param beanKey the key associated with the MBean in the
	 * {@code beans} {@code Map}.
	 * @return {@code true} if the {@code Method} is declared in one of the
	 * configured interfaces, otherwise {@code false}.
	 */
	/**
	 * 检查{@code 方法}是否在已配置的接口之一中声明并且是公共的。 
	 *  
	 * @param 方法，更改器{<@@code>方法}。 
	 *  
	 * @param  beanKey与{@code  bean} {@code  Map}中与MBean关联的密钥。 
	 *  
	 * @return  {@code  true}，如果在已配置的接口之一中声明了{@code 方法}，否则为{@code  false}。 
	 * 
	 */
	@Override
	protected boolean includeWriteAttribute(Method method, String beanKey) {
		return isPublicInInterface(method, beanKey);
	}

	/**
	 * Check to see if the {@code Method} is declared in
	 * one of the configured interfaces and that it is public.
	 * @param method the operation {@code Method}.
	 * @param beanKey the key associated with the MBean in the
	 * {@code beans} {@code Map}.
	 * @return {@code true} if the {@code Method} is declared in one of the
	 * configured interfaces, otherwise {@code false}.
	 */
	/**
	 * 检查{@code 方法}是否在已配置的接口之一中声明并且是公共的。 
	 *  
	 * @param 方法的操作{@code 方法}。 
	 *  
	 * @param  beanKey与{@code  bean} {@code  Map}中与MBean关联的密钥。 
	 *  
	 * @return  {@code  true}，如果在已配置的接口之一中声明了{@code 方法}，否则为{@code  false}。 
	 * 
	 */
	@Override
	protected boolean includeOperation(Method method, String beanKey) {
		return isPublicInInterface(method, beanKey);
	}

	/**
	 * Check to see if the {@code Method} is both public and declared in
	 * one of the configured interfaces.
	 * @param method the {@code Method} to check.
	 * @param beanKey the key associated with the MBean in the beans map
	 * @return {@code true} if the {@code Method} is declared in one of the
	 * configured interfaces and is public, otherwise {@code false}.
	 */
	/**
	 * 检查{@code 方法}是否既是公共的又在已配置的接口之一中声明。 
	 *  
	 * @param 方法{{@@code>方法}进行检查。 
	 *  
	 * @param  beanKey如果在已配置的接口之一中声明了{@code 方法}并且是公共的，则与bean映射中的MBean关联的键
	 * @return  {@code  true}，否则为{@code  false}。 
	 * 
	 */
	private boolean isPublicInInterface(Method method, String beanKey) {
		return Modifier.isPublic(method.getModifiers()) && isDeclaredInInterface(method, beanKey);
	}

	/**
	 * Checks to see if the given method is declared in a managed
	 * interface for the given bean.
	 */
	/**
	 * 检查是否在给定bean的托管接口中声明了给定方法。 
	 * 
	 */
	private boolean isDeclaredInInterface(Method method, String beanKey) {
		Class<?>[] ifaces = null;

		if (this.resolvedInterfaceMappings != null) {
			ifaces = this.resolvedInterfaceMappings.get(beanKey);
		}

		if (ifaces == null) {
			ifaces = this.managedInterfaces;
			if (ifaces == null) {
				ifaces = ClassUtils.getAllInterfacesForClass(method.getDeclaringClass());
			}
		}

		for (Class<?> ifc : ifaces) {
			for (Method ifcMethod : ifc.getMethods()) {
				if (ifcMethod.getName().equals(method.getName()) &&
						ifcMethod.getParameterCount() == method.getParameterCount() &&
						Arrays.equals(ifcMethod.getParameterTypes(), method.getParameterTypes())) {
					return true;
				}
			}
		}

		return false;
	}

}
