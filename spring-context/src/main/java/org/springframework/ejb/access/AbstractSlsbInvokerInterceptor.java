/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.ejb.access;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import javax.naming.Context;
import javax.naming.NamingException;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

import org.springframework.jndi.JndiObjectLocator;
import org.springframework.lang.Nullable;

/**
 * Base class for AOP interceptors invoking local or remote Stateless Session Beans.
 * Designed for EJB 2.x, but works for EJB 3 Session Beans as well.
 *
 * <p>Such an interceptor must be the last interceptor in the advice chain.
 * In this case, there is no direct target object: The call is handled in a
 * special way, getting executed on an EJB instance retrieved via an EJB home.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 */
/**
 * 调用本地或远程无状态会话Bean的AOP拦截器的基类。 
 * 专为EJB 2.x设计，但也适用于EJB 3会话Bean。 
 *  <p>此类拦截器必须是通知链中的最后一个拦截器。 
 * 在这种情况下，没有直接的目标对象：调用以特殊方式处理，在通过EJB主页检索的EJB实例上执行。 
 *  @author 罗德·约翰逊@author  Juergen Hoeller
 */
public abstract class AbstractSlsbInvokerInterceptor extends JndiObjectLocator
		implements MethodInterceptor {

	private boolean lookupHomeOnStartup = true;

	private boolean cacheHome = true;

	private boolean exposeAccessContext = false;

	/**
	 * The EJB's home object, potentially cached.
	 * The type must be Object as it could be either EJBHome or EJBLocalHome.
	 */
	/**
	 * EJB的home对象，可能已缓存。 
	 * 该类型必须是Object，因为它可以是EJBHome或EJBLocalHome。 
	 * 
	 */
	@Nullable
	private Object cachedHome;

	/**
	 * The no-arg create() method required on EJB homes, potentially cached.
	 */
	/**
	 * EJB宿主上需要的no-arg create（）方法（可能已缓存）。 
	 * 
	 */
	@Nullable
	private Method createMethod;

	private final Object homeMonitor = new Object();


	/**
	 * Set whether to look up the EJB home object on startup.
	 * Default is "true".
	 * <p>Can be turned off to allow for late start of the EJB server.
	 * In this case, the EJB home object will be fetched on first access.
	 * @see #setCacheHome
	 */
	/**
	 * 设置是否在启动时查找EJB home对象。 
	 * 默认值为"true"。 
	 *  <p>可以关闭以允许EJB服务器延迟启动。 
	 * 在这种情况下，将在首次访问时获取EJB home对象。 
	 *  
	 * @see  #setCacheHome
	 */
	public void setLookupHomeOnStartup(boolean lookupHomeOnStartup) {
		this.lookupHomeOnStartup = lookupHomeOnStartup;
	}

	/**
	 * Set whether to cache the EJB home object once it has been located.
	 * Default is "true".
	 * <p>Can be turned off to allow for hot restart of the EJB server.
	 * In this case, the EJB home object will be fetched for each invocation.
	 * @see #setLookupHomeOnStartup
	 */
	/**
	 * 设置一旦定位后是否缓存EJB home对象。 
	 * 默认值为"true"。 
	 *  <p>可以关闭以允许EJB服务器热重启。 
	 * 在这种情况下，将为每次调用获取EJB home对象。 
	 *  
	 * @see  #setLookupHomeOnStartup
	 */
	public void setCacheHome(boolean cacheHome) {
		this.cacheHome = cacheHome;
	}

	/**
	 * Set whether to expose the JNDI environment context for all access to the target
	 * EJB, i.e. for all method invocations on the exposed object reference.
	 * <p>Default is "false", i.e. to only expose the JNDI context for object lookup.
	 * Switch this flag to "true" in order to expose the JNDI environment (including
	 * the authorization context) for each EJB invocation, as needed by WebLogic
	 * for EJBs with authorization requirements.
	 */
	/**
	 * 设置是否为所有对目标EJB的访问（即对公开对象引用上的所有方法调用）公开JNDI环境上下文。 
	 *  <p>默认为"false"，即仅公开JNDI上下文进行对象查找。 
	 * 将此标志切换为"true"，以便根据WebLogic对于具有授权要求的EJB的需要，为每个EJB调用公开JNDI环境（包括授权上下文）。 
	 * 
	 */
	public void setExposeAccessContext(boolean exposeAccessContext) {
		this.exposeAccessContext = exposeAccessContext;
	}


	/**
	 * Fetches EJB home on startup, if necessary.
	 * @see #setLookupHomeOnStartup
	 * @see #refreshHome
	 */
	/**
	 * 如有必要，在启动时获取EJB主页。 
	 *  
	 * @see  #setLookupHomeOnStartup 
	 * @see  #refreshHome
	 */
	@Override
	public void afterPropertiesSet() throws NamingException {
		super.afterPropertiesSet();
		if (this.lookupHomeOnStartup) {
			// look up EJB home and create method
			refreshHome();
		}
	}

	/**
	 * Refresh the cached home object, if applicable.
	 * Also caches the create method on the home object.
	 * @throws NamingException if thrown by the JNDI lookup
	 * @see #lookup
	 * @see #getCreateMethod
	 */
	/**
	 * 刷新缓存的主对象（如果适用）。 
	 * 还可以在本地对象上缓存create方法。 
	 *  
	 * @throws  NamingException（如果由JNDI查找抛出）
	 * @see  #lookup 
	 * @see  #getCreateMethod
	 */
	protected void refreshHome() throws NamingException {
		synchronized (this.homeMonitor) {
			Object home = lookup();
			if (this.cacheHome) {
				this.cachedHome = home;
				this.createMethod = getCreateMethod(home);
			}
		}
	}

	/**
	 * Determine the create method of the given EJB home object.
	 * @param home the EJB home object
	 * @return the create method
	 * @throws EjbAccessException if the method couldn't be retrieved
	 */
	/**
	 * 确定给定EJB主对象的创建方法。 
	 *  
	 * @param 将EJB原始对象
	 * @return 放置到创建方法
	 * @throws  EjbAccessException中，如果无法检索到该方法
	 */
	@Nullable
	protected Method getCreateMethod(Object home) throws EjbAccessException {
		try {
			// Cache the EJB create() method that must be declared on the home interface.
			return home.getClass().getMethod("create");
		}
		catch (NoSuchMethodException ex) {
			throw new EjbAccessException("EJB home [" + home + "] has no no-arg create() method");
		}
	}

	/**
	 * Return the EJB home object to use. Called for each invocation.
	 * <p>Default implementation returns the home created on initialization,
	 * if any; else, it invokes lookup to get a new proxy for each invocation.
	 * <p>Can be overridden in subclasses, for example to cache a home object
	 * for a given amount of time before recreating it, or to test the home
	 * object whether it is still alive.
	 * @return the EJB home object to use for an invocation
	 * @throws NamingException if proxy creation failed
	 * @see #lookup
	 * @see #getCreateMethod
	 */
	/**
	 * 返回要使用的EJB home对象。 
	 * 要求每次调用。 
	 *  <p>默认实现返回初始化时创建的起始位置（如果有）； 
	 * 否则，它将为每个调用调用查找以获取新的代理。 
	 *  <p>可以在子类中重写，例如在重新创建它之前将其归类给定时间缓存，或者测试该归类对象是否仍然存在。 
	 *  
	 * @return 用于调用的EJB主对象
	 * @throws 如果代理创建失败，则命名错误
	 * @see  #lookup 
	 * @see  #getCreateMethod
	 */
	protected Object getHome() throws NamingException {
		if (!this.cacheHome || (this.lookupHomeOnStartup && !isHomeRefreshable())) {
			return (this.cachedHome != null ? this.cachedHome : lookup());
		}
		else {
			synchronized (this.homeMonitor) {
				if (this.cachedHome == null) {
					this.cachedHome = lookup();
					this.createMethod = getCreateMethod(this.cachedHome);
				}
				return this.cachedHome;
			}
		}
	}

	/**
	 * Return whether the cached EJB home object is potentially
	 * subject to on-demand refreshing. Default is "false".
	 */
	/**
	 * 返回高速缓存的EJB Home对象是否可能需要按需刷新。 
	 * 默认值为"false"。 
	 * 
	 */
	protected boolean isHomeRefreshable() {
		return false;
	}


	/**
	 * Prepares the thread context if necessary, and delegates to
	 * {@link #invokeInContext}.
	 */
	/**
	 * 如有必要，准备线程上下文，并将其委托给{@link  #invokeInContext}。 
	 * 
	 */
	@Override
	@Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {
		Context ctx = (this.exposeAccessContext ? getJndiTemplate().getContext() : null);
		try {
			return invokeInContext(invocation);
		}
		finally {
			getJndiTemplate().releaseContext(ctx);
		}
	}

	/**
	 * Perform the given invocation on the current EJB home,
	 * within the thread context being prepared accordingly.
	 * Template method to be implemented by subclasses.
	 * @param invocation the AOP method invocation
	 * @return the invocation result, if any
	 * @throws Throwable in case of invocation failure
	 */
	/**
	 * 在相应准备的线程上下文中，在当前EJB主目录上执行给定的调用。 
	 * 子类要实现的模板方法。 
	 *  
	 * @param 调用AOP方法调用
	 * @return 调用结果（如果有）
	 * @throws 调用失败时可抛出
	 */
	@Nullable
	protected abstract Object invokeInContext(MethodInvocation invocation) throws Throwable;


	/**
	 * Invokes the {@code create()} method on the cached EJB home object.
	 * @return a new EJBObject or EJBLocalObject
	 * @throws NamingException if thrown by JNDI
	 * @throws InvocationTargetException if thrown by the create method
	 */
	/**
	 * 在缓存的EJB Home对象上调用{@code  create（）}方法。 
	 *  
	 * @return 一个新的EJBObject或EJBLocalObject 
	 * @throws 如果被JNDI抛出，则为NamingException 
	 * @throws 如果被create方法抛出，则为InvocationTargetException
	 */
	protected Object create() throws NamingException, InvocationTargetException {
		try {
			Object home = getHome();
			Method createMethodToUse = this.createMethod;
			if (createMethodToUse == null) {
				createMethodToUse = getCreateMethod(home);
			}
			if (createMethodToUse == null) {
				return home;
			}
			// Invoke create() method on EJB home object.
			return createMethodToUse.invoke(home, (Object[]) null);
		}
		catch (IllegalAccessException ex) {
			throw new EjbAccessException("Could not access EJB home create() method", ex);
		}
	}

}
