/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.remoting.rmi;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.Properties;

import javax.naming.NamingException;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.jndi.JndiTemplate;
import org.springframework.lang.Nullable;
import org.springframework.util.ReflectionUtils;

/**
 * Service exporter which binds RMI services to JNDI.
 * Typically used for RMI-IIOP (CORBA).
 *
 * <p>Exports services via the {@link javax.rmi.PortableRemoteObject} class.
 * You need to run "rmic" with the "-iiop" option to generate corresponding
 * stubs and skeletons for each exported service.
 *
 * <p>Also supports exposing any non-RMI service via RMI invokers, to be accessed
 * via {@link JndiRmiClientInterceptor} / {@link JndiRmiProxyFactoryBean}'s
 * automatic detection of such invokers.
 *
 * <p>With an RMI invoker, RMI communication works on the {@link RmiInvocationHandler}
 * level, needing only one stub for any service. Service interfaces do not have to
 * extend {@code java.rmi.Remote} or throw {@code java.rmi.RemoteException}
 * on all methods, but in and out parameters have to be serializable.
 *
 * <p>The JNDI environment can be specified as "jndiEnvironment" bean property,
 * or be configured in a {@code jndi.properties} file or as system properties.
 * For example:
 *
 * <pre class="code">&lt;property name="jndiEnvironment"&gt;
 * 	 &lt;props>
 *		 &lt;prop key="java.naming.factory.initial"&gt;com.sun.jndi.cosnaming.CNCtxFactory&lt;/prop&gt;
 *		 &lt;prop key="java.naming.provider.url"&gt;iiop://localhost:1050&lt;/prop&gt;
 *	 &lt;/props&gt;
 * &lt;/property&gt;</pre>
 *
 * @author Juergen Hoeller
 * @since 1.1
 * @see #setService
 * @see #setJndiTemplate
 * @see #setJndiEnvironment
 * @see #setJndiName
 * @see JndiRmiClientInterceptor
 * @see JndiRmiProxyFactoryBean
 * @see javax.rmi.PortableRemoteObject#exportObject
 */
/**
 * 将RMI服务绑定到JNDI的服务导出器。 
 * 通常用于RMI-IIOP（CORBA）。 
 *  <p>通过{@link  javax.rmi.PortableRemoteObject}类导出服务。 
 * 您需要使用"-iiop"选项运行"rmic"，以为每个导出的服务生成相应的存根和框架。 
 *  <p>还支持通过RMI调用程序公开任何非RMI服务，可以通过{@link  JndiRmiClientInterceptor} / {@link  JndiRmiProxyFactoryBean}自动检测此类调用程序进行访问。 
 *  <p>使用RMI调用程序，RMI通信可在{@link  RmiInvocationHandler}级别上进行，任何服务仅需要一个存根。 
 * 服务接口不必在所有方法上都扩展{@code  java.rmi.Remote}或抛出{@code  java.rmi.RemoteException}，但是输入和输出参数必须可序列化。 
 *  <p> JNDI环境可以指定为"jndiEnvironment"bean属性，也可以在{@code  jndi.properties}文件中进行配置，也可以配置为系统属性。 
 * 例如：<pre class ="code"> <property name ="jndiEnvironment"> <props> <prop key ="java.naming.factory.initial"> com.sun.jndi.cosnaming.CNCtxFactory </ prop> < prop key ="java.naming.provider.url"> iiop：// localhost：1050 </ prop> </ props> </ property> </ pre> @author  Juergen Hoeller @since 1.1 
 * @see ＃ setService 
 * @see  #setJndiTemplate 
 * @see  #setJndiEnvironment 
 * @see  #setJndiName 
 * @see  JndiRmiClientInterceptor 
 * @see  JndiRmiProxyFactoryBean 
 * @see  javax.rmi.PortableRemoteObject＃exportObject
 */
public class JndiRmiServiceExporter extends RmiBasedExporter implements InitializingBean, DisposableBean {

	@Nullable
	private static Method exportObject;

	@Nullable
	private static Method unexportObject;

	static {
		try {
			Class<?> portableRemoteObject =
					JndiRmiServiceExporter.class.getClassLoader().loadClass("javax.rmi.PortableRemoteObject");
			exportObject = portableRemoteObject.getMethod("exportObject", Remote.class);
			unexportObject = portableRemoteObject.getMethod("unexportObject", Remote.class);
		}
		catch (Throwable ex) {
			// java.corba module not available on JDK 9+
			exportObject = null;
			unexportObject = null;
		}
	}


	private JndiTemplate jndiTemplate = new JndiTemplate();

	private String jndiName;

	private Remote exportedObject;


	/**
	 * Set the JNDI template to use for JNDI lookups.
	 * You can also specify JNDI environment settings via "jndiEnvironment".
	 * @see #setJndiEnvironment
	 */
	/**
	 * 设置JNDI模板以用于JNDI查找。 
	 * 您也可以通过"jndiEnvironment"指定JNDI环境设置。 
	 *  
	 * @see  #setJndiEnvironment
	 */
	public void setJndiTemplate(JndiTemplate jndiTemplate) {
		this.jndiTemplate = (jndiTemplate != null ? jndiTemplate : new JndiTemplate());
	}

	/**
	 * Set the JNDI environment to use for JNDI lookups.
	 * Creates a JndiTemplate with the given environment settings.
	 * @see #setJndiTemplate
	 */
	/**
	 * 设置JNDI环境以用于JNDI查找。 
	 * 使用给定的环境设置创建一个JndiTemplate。 
	 *  
	 * @see  #setJndiTemplate
	 */
	public void setJndiEnvironment(Properties jndiEnvironment) {
		this.jndiTemplate = new JndiTemplate(jndiEnvironment);
	}

	/**
	 * Set the JNDI name of the exported RMI service.
	 */
	/**
	 * 设置导出的RMI服务的JNDI名称。 
	 * 
	 */
	public void setJndiName(String jndiName) {
		this.jndiName = jndiName;
	}


	@Override
	public void afterPropertiesSet() throws NamingException, RemoteException {
		prepare();
	}

	/**
	 * Initialize this service exporter, binding the specified service to JNDI.
	 * @throws NamingException if service binding failed
	 * @throws RemoteException if service export failed
	 */
	/**
	 * 初始化此服务导出器，将指定的服务绑定到JNDI。 
	 * 如果服务绑定失败，则
	 * @throws  NamingException如果服务导出失败，则
	 * @throws  RemoteException
	 */
	public void prepare() throws NamingException, RemoteException {
		if (this.jndiName == null) {
			throw new IllegalArgumentException("Property 'jndiName' is required");
		}

		// Initialize and cache exported object.
		this.exportedObject = getObjectToExport();
		invokePortableRemoteObject(exportObject);

		rebind();
	}

	/**
	 * Rebind the specified service to JNDI, for recovering in case
	 * of the target registry having been restarted.
	 * @throws NamingException if service binding failed
	 */
	/**
	 * 将指定服务重新绑定到JNDI，以便在目标注册表重新启动后进行恢复。 
	 *  
	 * @throws  NamingException如果服务绑定失败
	 */
	public void rebind() throws NamingException {
		if (logger.isDebugEnabled()) {
			logger.debug("Binding RMI service to JNDI location [" + this.jndiName + "]");
		}
		this.jndiTemplate.rebind(this.jndiName, this.exportedObject);
	}

	/**
	 * Unbind the RMI service from JNDI on bean factory shutdown.
	 */
	/**
	 * 在bean工厂关闭时，从JNDI取消绑定RMI服务。 
	 * 
	 */
	@Override
	public void destroy() throws NamingException, RemoteException {
		if (logger.isDebugEnabled()) {
			logger.debug("Unbinding RMI service from JNDI location [" + this.jndiName + "]");
		}
		this.jndiTemplate.unbind(this.jndiName);
		invokePortableRemoteObject(unexportObject);
	}


	private void invokePortableRemoteObject(@Nullable Method method) throws RemoteException {
		if (method != null) {
			try {
				method.invoke(null, this.exportedObject);
			}
			catch (InvocationTargetException ex) {
				Throwable targetEx = ex.getTargetException();
				if (targetEx instanceof RemoteException) {
					throw (RemoteException) targetEx;
				}
				ReflectionUtils.rethrowRuntimeException(targetEx);
			}
			catch (Throwable ex) {
				throw new IllegalStateException("PortableRemoteObject invocation failed", ex);
			}
		}
	}

}
