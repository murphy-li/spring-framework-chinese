/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.remoting.rmi;

import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.UnicastRemoteObject;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.lang.Nullable;

/**
 * {@link FactoryBean} that locates a {@link java.rmi.registry.Registry} and
 * exposes it for bean references. Can also create a local RMI registry
 * on the fly if none exists already.
 *
 * <p>Can be used to set up and pass around the actual Registry object to
 * applications objects that need to work with RMI. One example for such an
 * object that needs to work with RMI is Spring's {@link RmiServiceExporter},
 * which either works with a passed-in Registry reference or falls back to
 * the registry as specified by its local properties and defaults.
 *
 * <p>Also useful to enforce creation of a local RMI registry at a given port,
 * for example for a JMX connector. If used in conjunction with
 * {@link org.springframework.jmx.support.ConnectorServerFactoryBean},
 * it is recommended to mark the connector definition (ConnectorServerFactoryBean)
 * as "depends-on" the registry definition (RmiRegistryFactoryBean),
 * to guarantee starting up the registry first.
 *
 * <p>Note: The implementation of this class mirrors the corresponding logic
 * in {@link RmiServiceExporter}, and also offers the same customization hooks.
 * RmiServiceExporter implements its own registry lookup as a convenience:
 * It is very common to simply rely on the registry defaults.
 *
 * @author Juergen Hoeller
 * @since 1.2.3
 * @see RmiServiceExporter#setRegistry
 * @see org.springframework.jmx.support.ConnectorServerFactoryBean
 * @see java.rmi.registry.Registry
 * @see java.rmi.registry.LocateRegistry
 */
/**
 * {@link  FactoryBean}查找{@link  java.rmi.registry.Registry}并将其公开以供bean参考。 
 * 如果还不存在，还可以即时创建本地RMI注册表。 
 *  <p>可用于设置实际的Registry对象并将其传递给需要使用RMI的应用程序对象。 
 *  Spring的{@link  RmiServiceExporter}就是这样一个需要与RMI一起使用的对象的示例，它可以与传入的注册表参考一起使用，也可以根据其本地属性和默认值退回到注册表。 
 *  <p>对于在给定端口（例如JMX连接器）上强制创建本地RMI注册表也很有用。 
 * 如果与{@link  org.springframework.jmx.support.ConnectorServerFactoryBean}结合使用，建议将连接器定义（ConnectorServerFactoryBean）标记为"依赖于"注册表定义（RmiRegistryFactoryBean），以确保启动该定义。 
 * 首先注册。 
 *  <p>注意：此类的实现反映了{@link  RmiServiceExporter}中的相应逻辑，并且还提供了相同的自定义挂钩。 
 * 为了方便起见，RmiServiceExporter实现了自己的注册表查找：仅依靠注册表默认值是非常普遍的。 
 *  @author  Juergen Hoeller @1.2.3起
 * @see  RmiServiceExporter＃setRegistry 
 * @see  org.springframework.jmx.support.ConnectorServerFactoryBean 
 * @see  java.rmi.registry.Registry 
 * @see  java.rmi。 
 *  Registry.LocateRegistry
 */
public class RmiRegistryFactoryBean implements FactoryBean<Registry>, InitializingBean, DisposableBean {

	protected final Log logger = LogFactory.getLog(getClass());

	private String host;

	private int port = Registry.REGISTRY_PORT;

	private RMIClientSocketFactory clientSocketFactory;

	private RMIServerSocketFactory serverSocketFactory;

	private Registry registry;

	private boolean alwaysCreate = false;

	private boolean created = false;


	/**
	 * Set the host of the registry for the exported RMI service,
	 * i.e. {@code rmi://HOST:port/name}
	 * <p>Default is localhost.
	 */
	/**
	 * 设置导出RMI服务的注册表主机，即{@code  rmi：// HOST：port / name} <p>默认为localhost。 
	 * 
	 */
	public void setHost(String host) {
		this.host = host;
	}

	/**
	 * Return the host of the registry for the exported RMI service.
	 */
	/**
	 * 返回导出的RMI服务的注册表主机。 
	 * 
	 */
	public String getHost() {
		return this.host;
	}

	/**
	 * Set the port of the registry for the exported RMI service,
	 * i.e. {@code rmi://host:PORT/name}
	 * <p>Default is {@code Registry.REGISTRY_PORT} (1099).
	 */
	/**
	 * 为导出的RMI服务设置注册表的端口，即{@code  rmi：// host：PORT / name} <p>默认值为{@code  Registry.REGISTRY_PORT}（1099）。 
	 * 
	 */
	public void setPort(int port) {
		this.port = port;
	}

	/**
	 * Return the port of the registry for the exported RMI service.
	 */
	/**
	 * 返回导出的RMI服务的注册表端口。 
	 * 
	 */
	public int getPort() {
		return this.port;
	}

	/**
	 * Set a custom RMI client socket factory to use for the RMI registry.
	 * <p>If the given object also implements {@code java.rmi.server.RMIServerSocketFactory},
	 * it will automatically be registered as server socket factory too.
	 * @see #setServerSocketFactory
	 * @see java.rmi.server.RMIClientSocketFactory
	 * @see java.rmi.server.RMIServerSocketFactory
	 * @see java.rmi.registry.LocateRegistry#getRegistry(String, int, java.rmi.server.RMIClientSocketFactory)
	 */
	/**
	 * 设置一个自定义RMI客户端套接字工厂以用于RMI注册表。 
	 *  <p>如果给定对象还实现了{@code  java.rmi.server.RMIServerSocketFactory}，则该对象也将自动注册为服务器套接字工厂。 
	 *  
	 * @see  #setServerSocketFactory 
	 * @see  java.rmi.server.RMIClientSocketFactory 
	 * @see  java.rmi.server.RMIServerSocketFactory 
	 * @see  java.rmi.registry.LocateRegistry＃getRegistry（String，int，java.rmi。 
	 *  server.RMIClientSocketFactory）
	 */
	public void setClientSocketFactory(RMIClientSocketFactory clientSocketFactory) {
		this.clientSocketFactory = clientSocketFactory;
	}

	/**
	 * Set a custom RMI server socket factory to use for the RMI registry.
	 * <p>Only needs to be specified when the client socket factory does not
	 * implement {@code java.rmi.server.RMIServerSocketFactory} already.
	 * @see #setClientSocketFactory
	 * @see java.rmi.server.RMIClientSocketFactory
	 * @see java.rmi.server.RMIServerSocketFactory
	 * @see java.rmi.registry.LocateRegistry#createRegistry(int, RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
	 */
	/**
	 * 设置一个自定义RMI服务器套接字工厂以用于RMI注册表。 
	 *  <p>仅当客户端套接字工厂尚未实现{@code  java.rmi.server.RMIServerSocketFactory}时才需要指定。 
	 *  
	 * @see  #setClientSocketFactory 
	 * @see  java.rmi.server.RMIClientSocketFactory 
	 * @see  java.rmi.server.RMIServerSocketFactory 
	 * @see  java.rmi.registry.LocateRegistry＃createRegistry（int，RMIClientSocketFactory，java.rmi。 
	 *  server.RMIServerSocketFactory）
	 */
	public void setServerSocketFactory(RMIServerSocketFactory serverSocketFactory) {
		this.serverSocketFactory = serverSocketFactory;
	}

	/**
	 * Set whether to always create the registry in-process,
	 * not attempting to locate an existing registry at the specified port.
	 * <p>Default is "false". Switch this flag to "true" in order to avoid
	 * the overhead of locating an existing registry when you always
	 * intend to create a new registry in any case.
	 */
	/**
	 * 设置是否始终在进程中创建注册表，而不尝试在指定端口上查找现有注册表。 
	 *  <p>默认为"false"。 
	 * 为了避免在任何情况下始终打算创建新注册表时查找现有注册表的开销，请将此标志切换为"true"。 
	 * 
	 */
	public void setAlwaysCreate(boolean alwaysCreate) {
		this.alwaysCreate = alwaysCreate;
	}


	@Override
	public void afterPropertiesSet() throws Exception {
		// Check socket factories for registry.
		if (this.clientSocketFactory instanceof RMIServerSocketFactory) {
			this.serverSocketFactory = (RMIServerSocketFactory) this.clientSocketFactory;
		}
		if ((this.clientSocketFactory != null && this.serverSocketFactory == null) ||
				(this.clientSocketFactory == null && this.serverSocketFactory != null)) {
			throw new IllegalArgumentException(
					"Both RMIClientSocketFactory and RMIServerSocketFactory or none required");
		}

		// Fetch RMI registry to expose.
		this.registry = getRegistry(this.host, this.port, this.clientSocketFactory, this.serverSocketFactory);
	}


	/**
	 * Locate or create the RMI registry.
	 * @param registryHost the registry host to use (if this is specified,
	 * no implicit creation of a RMI registry will happen)
	 * @param registryPort the registry port to use
	 * @param clientSocketFactory the RMI client socket factory for the registry (if any)
	 * @param serverSocketFactory the RMI server socket factory for the registry (if any)
	 * @return the RMI registry
	 * @throws java.rmi.RemoteException if the registry couldn't be located or created
	 */
	/**
	 * 找到或创建RMI注册表。 
	 *  
	 * @param  RegistryHost要使用的注册表主机（如果已指定，则不会隐式创建RMI注册表）。 
	 * 
	 * @param  RegistryPort注册表端口以使用
	 * @param  clientSocketFactory注册表的RMI客户端套接字工厂（ 
	 * @param  serverSocketFactory注册表的RMI服务器套接字工厂（如果有）
	 * @return  RMI注册表
	 * @throws  java.rmi.RemoteException（如果找不到或创建注册表）
	 */
	protected Registry getRegistry(String registryHost, int registryPort,
			@Nullable RMIClientSocketFactory clientSocketFactory, @Nullable RMIServerSocketFactory serverSocketFactory)
			throws RemoteException {

		if (registryHost != null) {
			// Host explicitly specified: only lookup possible.
			if (logger.isDebugEnabled()) {
				logger.debug("Looking for RMI registry at port '" + registryPort + "' of host [" + registryHost + "]");
			}
			Registry reg = LocateRegistry.getRegistry(registryHost, registryPort, clientSocketFactory);
			testRegistry(reg);
			return reg;
		}

		else {
			return getRegistry(registryPort, clientSocketFactory, serverSocketFactory);
		}
	}

	/**
	 * Locate or create the RMI registry.
	 * @param registryPort the registry port to use
	 * @param clientSocketFactory the RMI client socket factory for the registry (if any)
	 * @param serverSocketFactory the RMI server socket factory for the registry (if any)
	 * @return the RMI registry
	 * @throws RemoteException if the registry couldn't be located or created
	 */
	/**
	 * 找到或创建RMI注册表。 
	 *  
	 * @param  RegistryPort注册表端口，以使用
	 * @param  clientSocketFactory RMI客户端套接字工厂用于注册表（如果有的话）
	 * @param  serverSocketFactory RMI服务器套接字工厂用于注册表（如果有的话）
	 * @return  RMI注册表
	 * @throws  RemoteException，如果找不到或创建注册表
	 */
	protected Registry getRegistry(int registryPort,
			@Nullable RMIClientSocketFactory clientSocketFactory, @Nullable RMIServerSocketFactory serverSocketFactory)
			throws RemoteException {

		if (clientSocketFactory != null) {
			if (this.alwaysCreate) {
				logger.debug("Creating new RMI registry");
				this.created = true;
				return LocateRegistry.createRegistry(registryPort, clientSocketFactory, serverSocketFactory);
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Looking for RMI registry at port '" + registryPort + "', using custom socket factory");
			}
			synchronized (LocateRegistry.class) {
				try {
					// Retrieve existing registry.
					Registry reg = LocateRegistry.getRegistry(null, registryPort, clientSocketFactory);
					testRegistry(reg);
					return reg;
				}
				catch (RemoteException ex) {
					logger.trace("RMI registry access threw exception", ex);
					logger.debug("Could not detect RMI registry - creating new one");
					// Assume no registry found -> create new one.
					this.created = true;
					return LocateRegistry.createRegistry(registryPort, clientSocketFactory, serverSocketFactory);
				}
			}
		}

		else {
			return getRegistry(registryPort);
		}
	}

	/**
	 * Locate or create the RMI registry.
	 * @param registryPort the registry port to use
	 * @return the RMI registry
	 * @throws RemoteException if the registry couldn't be located or created
	 */
	/**
	 * 找到或创建RMI注册表。 
	 *  
	 * @param  RegistryPort注册表端口以使用
	 * @return  RMI注册表
	 * @throws  RemoteException（如果找不到或创建注册表）
	 */
	protected Registry getRegistry(int registryPort) throws RemoteException {
		if (this.alwaysCreate) {
			logger.debug("Creating new RMI registry");
			this.created = true;
			return LocateRegistry.createRegistry(registryPort);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Looking for RMI registry at port '" + registryPort + "'");
		}
		synchronized (LocateRegistry.class) {
			try {
				// Retrieve existing registry.
				Registry reg = LocateRegistry.getRegistry(registryPort);
				testRegistry(reg);
				return reg;
			}
			catch (RemoteException ex) {
				logger.trace("RMI registry access threw exception", ex);
				logger.debug("Could not detect RMI registry - creating new one");
				// Assume no registry found -> create new one.
				this.created = true;
				return LocateRegistry.createRegistry(registryPort);
			}
		}
	}

	/**
	 * Test the given RMI registry, calling some operation on it to
	 * check whether it is still active.
	 * <p>Default implementation calls {@code Registry.list()}.
	 * @param registry the RMI registry to test
	 * @throws RemoteException if thrown by registry methods
	 * @see java.rmi.registry.Registry#list()
	 */
	/**
	 * 测试给定的RMI注册表，在其上调用一些操作以检查其是否仍处于活动状态。 
	 *  <p>默认实现调用{@code  Registry.list（）}。 
	 *  
	 * @param 注册表RMI注册表以测试
	 * @throws  RemoteException（如果由注册表方法抛出）
	 * @see  java.rmi.registry.Registry＃list（）
	 */
	protected void testRegistry(Registry registry) throws RemoteException {
		registry.list();
	}


	@Override
	public Registry getObject() throws Exception {
		return this.registry;
	}

	@Override
	public Class<? extends Registry> getObjectType() {
		return (this.registry != null ? this.registry.getClass() : Registry.class);
	}

	@Override
	public boolean isSingleton() {
		return true;
	}


	/**
	 * Unexport the RMI registry on bean factory shutdown,
	 * provided that this bean actually created a registry.
	 */
	/**
	 * 在bean工厂关闭时取消导出RMI注册表，前提是该bean实际上创建了一个注册表。 
	 * 
	 */
	@Override
	public void destroy() throws RemoteException {
		if (this.created) {
			logger.debug("Unexporting RMI registry");
			UnicastRemoteObject.unexportObject(this.registry, true);
		}
	}

}
