/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.remoting.support;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

import org.aopalliance.intercept.MethodInvocation;

import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;

/**
 * Encapsulates a remote invocation, providing core method invocation properties
 * in a serializable fashion. Used for RMI and HTTP-based serialization invokers.
 *
 * <p>This is an SPI class, typically not used directly by applications.
 * Can be subclassed for additional invocation parameters.
 *
 * <p>Both {@link RemoteInvocation} and {@link RemoteInvocationResult} are designed
 * for use with standard Java serialization as well as JavaBean-style serialization.
 *
 * @author Juergen Hoeller
 * @since 25.02.2004
 * @see RemoteInvocationResult
 * @see RemoteInvocationFactory
 * @see RemoteInvocationExecutor
 * @see org.springframework.remoting.rmi.RmiProxyFactoryBean
 * @see org.springframework.remoting.rmi.RmiServiceExporter
 * @see org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean
 * @see org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter
 */
/**
 * 封装远程调用，以可序列化的方式提供核心方法调用属性。 
 * 用于RMI和基于HTTP的序列化调用程序。 
 *  <p>这是SPI类，通常不被应用程序直接使用。 
 * 可以子类化以获取其他调用参数。 
 *  <p> {@link  RemoteInvocation}和{@link  RemoteInvocationResult}都设计用于标准Java序列化以及JavaBean样式的序列化。 
 *  @author  Juergen Hoeller @2004年2月25日起
 * @see  RemoteInvocationResult 
 * @see  RemoteInvocationFactory 
 * @see  RemoteInvocationExecutor 
 * @see  org.springframework.remoting.rmi.RmiProxyFactoryBean 
 * @see  org.springframework.remoting.rmi .RmiServiceExporter 
 * @see  org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean 
 * @see  org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter
 */
public class RemoteInvocation implements Serializable {

	/** use serialVersionUID from Spring 1.1 for interoperability. */
	/**
	 * 使用Spring 1.1中的serialVersionUID来实现互操作性。 
	 * 
	 */
	private static final long serialVersionUID = 6876024250231820554L;


	private String methodName;

	private Class<?>[] parameterTypes;

	private Object[] arguments;

	private Map<String, Serializable> attributes;


	/**
	 * Create a new RemoteInvocation for the given AOP method invocation.
	 * @param methodInvocation the AOP invocation to convert
	 */
	/**
	 * 为给定的AOP方法调用创建一个新的RemoteInvocation。 
	 *  
	 * @param  methodInvocation AOP调用进行转换
	 */
	public RemoteInvocation(MethodInvocation methodInvocation) {
		this.methodName = methodInvocation.getMethod().getName();
		this.parameterTypes = methodInvocation.getMethod().getParameterTypes();
		this.arguments = methodInvocation.getArguments();
	}

	/**
	 * Create a new RemoteInvocation for the given parameters.
	 * @param methodName the name of the method to invoke
	 * @param parameterTypes the parameter types of the method
	 * @param arguments the arguments for the invocation
	 */
	/**
	 * 为给定的参数创建一个新的RemoteInvocation。 
	 *  
	 * @param  methodName调用方法的名称
	 * @param  parameterTypes方法的参数类型
	 * @param  arguments调用的参数
	 */
	public RemoteInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
		this.methodName = methodName;
		this.parameterTypes = parameterTypes;
		this.arguments = arguments;
	}

	/**
	 * Create a new RemoteInvocation for JavaBean-style deserialization
	 * (e.g. with Jackson).
	 */
	/**
	 * 为JavaBean样式的反序列化创建新的RemoteInvocation（例如，与Jackson一起使用）。 
	 * 
	 */
	public RemoteInvocation() {
	}


	/**
	 * Set the name of the target method.
	 * <p>This setter is intended for JavaBean-style deserialization.
	 */
	/**
	 * 设置目标方法的名称。 
	 *  <p>此设置程序用于JavaBean风格的反序列化。 
	 * 
	 */
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}

	/**
	 * Return the name of the target method.
	 */
	/**
	 * 返回目标方法的名称。 
	 * 
	 */
	public String getMethodName() {
		return this.methodName;
	}

	/**
	 * Set the parameter types of the target method.
	 * <p>This setter is intended for JavaBean-style deserialization.
	 */
	/**
	 * 设置目标方法的参数类型。 
	 *  <p>此设置程序用于JavaBean风格的反序列化。 
	 * 
	 */
	public void setParameterTypes(Class<?>[] parameterTypes) {
		this.parameterTypes = parameterTypes;
	}

	/**
	 * Return the parameter types of the target method.
	 */
	/**
	 * 返回目标方法的参数类型。 
	 * 
	 */
	public Class<?>[] getParameterTypes() {
		return this.parameterTypes;
	}

	/**
	 * Set the arguments for the target method call.
	 * <p>This setter is intended for JavaBean-style deserialization.
	 */
	/**
	 * 设置目标方法调用的参数。 
	 *  <p>此设置程序用于JavaBean风格的反序列化。 
	 * 
	 */
	public void setArguments(Object[] arguments) {
		this.arguments = arguments;
	}

	/**
	 * Return the arguments for the target method call.
	 */
	/**
	 * 返回目标方法调用的参数。 
	 * 
	 */
	public Object[] getArguments() {
		return this.arguments;
	}


	/**
	 * Add an additional invocation attribute. Useful to add additional
	 * invocation context without having to subclass RemoteInvocation.
	 * <p>Attribute keys have to be unique, and no overriding of existing
	 * attributes is allowed.
	 * <p>The implementation avoids to unnecessarily create the attributes
	 * Map, to minimize serialization size.
	 * @param key the attribute key
	 * @param value the attribute value
	 * @throws IllegalStateException if the key is already bound
	 */
	/**
	 * 添加一个附加的调用属性。 
	 * 无需添加RemoteInvocation即可添加其他调用上下文很有用。 
	 *  <p>属性键必须唯一，并且不允许覆盖现有属性。 
	 *  <p>该实现避免不必要地创建属性Map，以最小化序列化大小。 
	 *  
	 * @param 键属性键
	 * @param 值属性值
	 * @throws  IllegalStateException如果键已绑定
	 */
	public void addAttribute(String key, Serializable value) throws IllegalStateException {
		if (this.attributes == null) {
			this.attributes = new HashMap<>();
		}
		if (this.attributes.containsKey(key)) {
			throw new IllegalStateException("There is already an attribute with key '" + key + "' bound");
		}
		this.attributes.put(key, value);
	}

	/**
	 * Retrieve the attribute for the given key, if any.
	 * <p>The implementation avoids to unnecessarily create the attributes
	 * Map, to minimize serialization size.
	 * @param key the attribute key
	 * @return the attribute value, or {@code null} if not defined
	 */
	/**
	 * 检索给定键的属性（如果有）。 
	 *  <p>该实现避免不必要地创建属性Map，以最小化序列化大小。 
	 *  
	 * @param 键属性键
	 * @return 属性值，如果未定义，则为{@code  null}
	 */
	@Nullable
	public Serializable getAttribute(String key) {
		if (this.attributes == null) {
			return null;
		}
		return this.attributes.get(key);
	}

	/**
	 * Set the attributes Map. Only here for special purposes:
	 * Preferably, use {@link #addAttribute} and {@link #getAttribute}.
	 * @param attributes the attributes Map
	 * @see #addAttribute
	 * @see #getAttribute
	 */
	/**
	 * 设置属性Map。 
	 * 仅在此处出于特殊目的：最好使用{@link  #addAttribute}和{@link  #getAttribute}。 
	 *  
	 * @param 为属性Map分配属性
	 * @see  #addAttribute 
	 * @see  #getAttribute
	 */
	public void setAttributes(@Nullable Map<String, Serializable> attributes) {
		this.attributes = attributes;
	}

	/**
	 * Return the attributes Map. Mainly here for debugging purposes:
	 * Preferably, use {@link #addAttribute} and {@link #getAttribute}.
	 * @return the attributes Map, or {@code null} if none created
	 * @see #addAttribute
	 * @see #getAttribute
	 */
	/**
	 * 返回属性Map。 
	 * 主要是出于调试目的：最好使用{@link  #addAttribute}和{@link  #getAttribute}。 
	 *  
	 * @return 属性Map，如果未创建，则为{<@@code> null} 
	 * @see  #addAttribute 
	 * @see  #getAttribute
	 */
	@Nullable
	public Map<String, Serializable> getAttributes() {
		return this.attributes;
	}


	/**
	 * Perform this invocation on the given target object.
	 * Typically called when a RemoteInvocation is received on the server.
	 * @param targetObject the target object to apply the invocation to
	 * @return the invocation result
	 * @throws NoSuchMethodException if the method name could not be resolved
	 * @throws IllegalAccessException if the method could not be accessed
	 * @throws InvocationTargetException if the method invocation resulted in an exception
	 * @see java.lang.reflect.Method#invoke
	 */
	/**
	 * 对给定的目标对象执行此调用。 
	 * 通常在服务器上收到RemoteInvocation时调用。 
	 *  
	 * @param  targetObject将调用应用于
	 * @return 调用结果的目标对象
	 * @throws  NoSuchMethodException如果无法解析方法名称
	 * @throws  IllegalAccessException如果无法访问该方法
	 * @throws  InvocationTargetException如果方法调用导致异常
	 * @see  java.lang.reflect.Method＃invoke
	 */
	public Object invoke(Object targetObject)
			throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {

		Method method = targetObject.getClass().getMethod(this.methodName, this.parameterTypes);
		return method.invoke(targetObject, this.arguments);
	}


	@Override
	public String toString() {
		return "RemoteInvocation: method name '" + this.methodName + "'; parameter types " +
				ClassUtils.classNamesToString(this.parameterTypes);
	}

}
