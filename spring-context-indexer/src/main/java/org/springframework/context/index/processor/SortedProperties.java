/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.context.index.processor;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;

/**
 * Specialization of {@link Properties} that sorts properties alphanumerically
 * based on their keys.
 *
 * <p>This can be useful when storing the {@link Properties} instance in a
 * properties file, since it allows such files to be generated in a repeatable
 * manner with consistent ordering of properties.
 *
 * <p>Comments in generated properties files can also be optionally omitted.
 *
 * @author Sam Brannen
 * @since 5.2
 * @see java.util.Properties
 */
/**
 * {@link  Properties}的专业化，可以根据属性键对属性进行字母数字排序。 
 *  <p>当将{@link  Properties}实例存储在属性文件中时，这很有用，因为它允许以一致的属性顺序以可重复的方式生成此类文件。 
 *  <p>生成的属性文件中的注释也可以选择省略。 
 *  @author  Sam Brannen @从5.2起
 * @see  java.util.Properties
 */
@SuppressWarnings("serial")
class SortedProperties extends Properties {

	static final String EOL = System.lineSeparator();

	private static final Comparator<Object> keyComparator = Comparator.comparing(String::valueOf);

	private static final Comparator<Entry<Object, Object>> entryComparator = Entry.comparingByKey(keyComparator);


	private final boolean omitComments;


	/**
	 * Construct a new {@code SortedProperties} instance that honors the supplied
	 * {@code omitComments} flag.
	 * @param omitComments {@code true} if comments should be omitted when
	 * storing properties in a file
	 */
	/**
	 * 构造一个新的{@code  SortedProperties}实例，以兑现提供的{@code  omitComments}标志。 
	 *  
	 * @param  omitComments {@code  true}如果在文件中存储属性时应省略注释
	 */
	SortedProperties(boolean omitComments) {
		this.omitComments = omitComments;
	}

	/**
	 * Construct a new {@code SortedProperties} instance with properties populated
	 * from the supplied {@link Properties} object and honoring the supplied
	 * {@code omitComments} flag.
	 * <p>Default properties from the supplied {@code Properties} object will
	 * not be copied.
	 * @param properties the {@code Properties} object from which to copy the
	 * initial properties
	 * @param omitComments {@code true} if comments should be omitted when
	 * storing properties in a file
	 */
	/**
	 * 使用从提供的{@link  Properties}对象填充的属性并遵循提供的{@code  omitComments}标志构造一个新的{@code  SortedProperties}实例。 
	 *  <p>提供的{@code  Properties}对象中的默认属性将不会被复制。 
	 *  
	 * @param 属性{{@@code> Properties}对象，从中复制初始属性。 
	 * 
	 * @param  omitComments {<@@code> true}，如果在文件中存储属性时应省略注释
	 */
	SortedProperties(Properties properties, boolean omitComments) {
		this(omitComments);
		putAll(properties);
	}


	@Override
	public void store(OutputStream out, String comments) throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		super.store(baos, (this.omitComments ? null : comments));
		String contents = new String(baos.toByteArray(), StandardCharsets.ISO_8859_1);
		for (String line : contents.split(EOL)) {
			if (!(this.omitComments && line.startsWith("#"))) {
				out.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));
			}
		}
	}

	@Override
	public void store(Writer writer, String comments) throws IOException {
		StringWriter stringWriter = new StringWriter();
		super.store(stringWriter, (this.omitComments ? null : comments));
		String contents = stringWriter.toString();
		for (String line : contents.split(EOL)) {
			if (!(this.omitComments && line.startsWith("#"))) {
				writer.write(line + EOL);
			}
		}
	}

	@Override
	public void storeToXML(OutputStream out, String comments) throws IOException {
		super.storeToXML(out, (this.omitComments ? null : comments));
	}

	@Override
	public void storeToXML(OutputStream out, String comments, String encoding) throws IOException {
		super.storeToXML(out, (this.omitComments ? null : comments), encoding);
	}

	/**
	 * Return a sorted enumeration of the keys in this {@link Properties} object.
	 * @see #keySet()
	 */
	/**
	 * 返回此{@link  Properties}对象中的键的排序枚举。 
	 *  
	 * @see  #keySet（）
	 */
	@Override
	public synchronized Enumeration<Object> keys() {
		return Collections.enumeration(keySet());
	}

	/**
	 * Return a sorted set of the keys in this {@link Properties} object.
	 * <p>The keys will be converted to strings if necessary using
	 * {@link String#valueOf(Object)} and sorted alphanumerically according to
	 * the natural order of strings.
	 */
	/**
	 * 返回此{@link  Properties}对象中的一组排序键。 
	 *  <p>如有必要，将使用{@link  String＃valueOf（Object）}将键转换为字符串，并根据字符串的自然顺序按字母数字顺序进行排序。 
	 * 
	 */
	@Override
	public Set<Object> keySet() {
		Set<Object> sortedKeys = new TreeSet<>(keyComparator);
		sortedKeys.addAll(super.keySet());
		return Collections.synchronizedSet(sortedKeys);
	}

	/**
	 * Return a sorted set of the entries in this {@link Properties} object.
	 * <p>The entries will be sorted based on their keys, and the keys will be
	 * converted to strings if necessary using {@link String#valueOf(Object)}
	 * and compared alphanumerically according to the natural order of strings.
	 */
	/**
	 * 返回此{@link  Properties}对象中的一组排序的条目。 
	 *  <p>将根据条目的键对条目进行排序，并在必要时使用{@link  String＃valueOf（Object）}将键转换为字符串，并根据字符串的自然顺序对其进行字母数字比较。 
	 * 
	 */
	@Override
	public Set<Entry<Object, Object>> entrySet() {
		Set<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);
		sortedEntries.addAll(super.entrySet());
		return Collections.synchronizedSet(sortedEntries);
	}

}
