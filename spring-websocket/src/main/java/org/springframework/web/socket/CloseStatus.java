/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.socket;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;

/**
 * Represents a WebSocket close status code and reason. Status codes in the 1xxx range are
 * pre-defined by the protocol. Optionally, a status code may be sent with a reason.
 *
 * <p>See <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455, Section 7.4.1
 * "Defined Status Codes"</a>.
 *
 * @author Rossen Stoyanchev
 * @since 4.0
 */
/**
 * 表示WebSocket关闭状态代码和原因。 
 * 协议预定义了1xxx范围内的状态码。 
 * 可选地，可以发送带有原因的状态码。 
 *  <p>请参见<a href="https://tools.ietf.org/html/rfc6455#section-7.4.1"> RFC 6455，第7.4.1节"定义的状态代码"</a>。 
 *  @author  Rossen Stoyanchev @从4.0开始
 */
public final class CloseStatus {

	/**
	 * "1000 indicates a normal closure, meaning that the purpose for which the connection
	 * was established has been fulfilled."
	 */
	/**
	 * "1000表示正常关闭，这意味着已建立连接的目的已实现。 
	 * "
	 */
	public static final CloseStatus NORMAL = new CloseStatus(1000);

	/**
	 * "1001 indicates that an endpoint is "going away", such as a server going down or a
	 * browser having navigated away from a page."
	 */
	/**
	 * "1001指示端点正在"离开"，例如服务器关闭或浏览器已离开页面。 
	 * 
	 */
	public static final CloseStatus GOING_AWAY = new CloseStatus(1001);

	/**
	 * "1002 indicates that an endpoint is terminating the connection due to a protocol
	 * error."
	 */
	/**
	 * "1002指示端点由于协议错误而正在终止连接。 
	 * "
	 */
	public static final CloseStatus PROTOCOL_ERROR  = new CloseStatus(1002);

	/**
	 * "1003 indicates that an endpoint is terminating the connection because it has
	 * received a type of data it cannot accept (e.g., an endpoint that understands only
	 * text data MAY send this if it receives a binary message)."
	 */
	/**
	 * "1003指示端点正在终止连接，因为它已接收到它不能接受的数据类型（例如，仅理解文本数据的端点可以在接收到二进制消息时发送此数据）。 
	 * "
	 */
	public static final CloseStatus NOT_ACCEPTABLE = new CloseStatus(1003);

	// 10004: Reserved.
	// The specific meaning might be defined in the future.

	/**
	 * "1005 is a reserved value and MUST NOT be set as a status code in a Close control
	 * frame by an endpoint. It is designated for use in applications expecting a status
	 * code to indicate that no status code was actually present."
	 */
	/**
	 * "1005是保留值，端点不得在Close控制帧中将其设置为状态代码。 
	 * 它指定用于期望状态代码指示实际上不存在状态代码的应用程序。 
	 * "
	 */
	public static final CloseStatus NO_STATUS_CODE = new CloseStatus(1005);

	/**
	 * "1006 is a reserved value and MUST NOT be set as a status code in a Close control
	 * frame by an endpoint. It is designated for use in applications expecting a status
	 * code to indicate that the connection was closed abnormally, e.g., without sending
	 * or receiving a Close control frame."
	 */
	/**
	 * "1006是保留值，端点不得在"关闭"控制帧中将其设置为状态代码。 
	 * 它指定用于期望状态代码指示连接异常关闭的应用程序，例如未发送或接收。 
	 * 关闭控制框。 
	 * "
	 */
	public static final CloseStatus NO_CLOSE_FRAME = new CloseStatus(1006);

	/**
	 * "1007 indicates that an endpoint is terminating the connection because it has
	 * received data within a message that was not consistent with the type of the message
	 * (e.g., non-UTF-8 [RFC3629] data within a text message)."
	 */
	/**
	 * "1007指示端点正在终止连接，因为它已接收到消息中与消息类型不一致的数据（例如，文本消息中的非UTF-8 [RFC3629]数据）。 
	 * "
	 */
	public static final CloseStatus BAD_DATA = new CloseStatus(1007);

	/**
	 * "1008 indicates that an endpoint is terminating the connection because it has
	 * received a message that violates its policy. This is a generic status code that can
	 * be returned when there is no other more suitable status code (e.g., 1003 or 1009)
	 * or if there is a need to hide specific details about the policy."
	 */
	/**
	 * "1008指示端点正在终止连接，因为它收到了违反其策略的消息。 
	 * 这是通用状态代码，当没有其他更合适的状态代码（例如1003或1009）或存在需要隐藏有关该政策的具体细节。 
	 * "
	 */
	public static final CloseStatus POLICY_VIOLATION = new CloseStatus(1008);

	/**
	 * "1009 indicates that an endpoint is terminating the connection because it has
	 * received a message that is too big for it to process."
	 */
	/**
	 * "1009指示端点正在终止连接，因为它收到的消息太大而无法处理。 
	 * "
	 */
	public static final CloseStatus TOO_BIG_TO_PROCESS = new CloseStatus(1009);

	/**
	 * "1010 indicates that an endpoint (client) is terminating the connection because it
	 * has expected the server to negotiate one or more extension, but the server didn't
	 * return them in the response message of the WebSocket handshake. The list of
	 * extensions that are needed SHOULD appear in the /reason/ part of the Close frame.
	 * Note that this status code is not used by the server, because it can fail the
	 * WebSocket handshake instead."
	 */
	/**
	 * "1010指示端点（客户端）正在终止连接，因为它已期望服务器协商一个或多个扩展，但是服务器未在WebSocket握手的响应消息中返回它们。 
	 * 所需的扩展列表应该出现在"关闭"框架的/ reason /部分。 
	 * 请注意，服务器不会使用此状态代码，因为它可能会使WebSocket握手失败。 
	 * 
	 */
	public static final CloseStatus REQUIRED_EXTENSION = new CloseStatus(1010);

	/**
	 * "1011 indicates that a server is terminating the connection because it encountered
	 * an unexpected condition that prevented it from fulfilling the request."
	 */
	/**
	 * "1011表示服务器正在终止连接，因为它遇到了无法满足请求的意外状况。 
	 * "
	 */
	public static final CloseStatus SERVER_ERROR = new CloseStatus(1011);

	/**
	 * "1012 indicates that the service is restarted. A client may reconnect, and if it
	 * chooses to do, should reconnect using a randomized delay of 5 - 30s."
	 */
	/**
	 * "1012表示服务已重新启动。 
	 * 客户端可以重新连接，并且如果选择这样做，则应该使用5到30秒的随机延迟来重新连接。 
	 * "
	 */
	public static final CloseStatus SERVICE_RESTARTED = new CloseStatus(1012);

	/**
	 * "1013 indicates that the service is experiencing overload. A client should only
	 * connect to a different IP (when there are multiple for the target) or reconnect to
	 * the same IP upon user action."
	 */
	/**
	 * "1013表示服务正在过载。 
	 * 客户端应仅连接到不同的IP（当目标有多个IP时），或根据用户的操作重新连接到相同的IP。 
	 * "
	 */
	public static final CloseStatus SERVICE_OVERLOAD = new CloseStatus(1013);

	/**
	 * "1015 is a reserved value and MUST NOT be set as a status code in a Close control
	 * frame by an endpoint. It is designated for use in applications expecting a status
	 * code to indicate that the connection was closed due to a failure to perform a TLS
	 * handshake (e.g., the server certificate can't be verified)."
	 */
	/**
	 * "1015是保留值，绝不能由端点在"关闭"控制帧中设置为状态代码。 
	 * 它指定用于期望状态代码指示由于执行TLS失败而关闭连接的应用程序握手（例如，无法验证服务器证书）。 
	 * "
	 */
	public static final CloseStatus TLS_HANDSHAKE_FAILURE = new CloseStatus(1015);

	/**
	 * A status code for use within the framework the indicate a session has
	 * become unreliable (e.g. timed out while sending a message) and extra
	 * care should be exercised, e.g. avoid sending any further data to the
	 * client that may be done during normal shutdown.
	 * @since 4.0.3
	 */
	/**
	 * 在框架内使用的状态代码表示会话变得不可靠（例如，在发送消息时超时），应格外小心，例如避免在正常关闭期间将任何其他数据发送到客户端。 
	 *  @4.0.3起
	 */
	public static final CloseStatus SESSION_NOT_RELIABLE = new CloseStatus(4500);


	private final int code;

	@Nullable
	private final String reason;


	/**
	 * Create a new {@link CloseStatus} instance.
	 * @param code the status code
	 */
	/**
	 * 创建一个新的{@link  CloseStatus}实例。 
	 *  
	 * @param 编码状态码
	 */
	public CloseStatus(int code) {
		this(code, null);
	}

	/**
	 * Create a new {@link CloseStatus} instance.
	 * @param code the status code
	 * @param reason the reason
	 */
	/**
	 * 创建一个新的{@link  CloseStatus}实例。 
	 *  
	 * @param 编码状态码
	 * @param 原因原因
	 */
	public CloseStatus(int code, @Nullable String reason) {
		Assert.isTrue((code >= 1000 && code < 5000), "Invalid status code");
		this.code = code;
		this.reason = reason;
	}


	/**
	 * Return the status code.
	 */
	/**
	 * 返回状态码。 
	 * 
	 */
	public int getCode() {
		return this.code;
	}

	/**
	 * Return the reason, or {@code null} if none.
	 */
	/**
	 * 返回原因，如果没有，则返回{@code  null}。 
	 * 
	 */
	@Nullable
	public String getReason() {
		return this.reason;
	}

	/**
	 * Create a new {@link CloseStatus} from this one with the specified reason.
	 * @param reason the reason
	 * @return a new {@link CloseStatus} instance
	 */
	/**
	 * 使用指定的原因，从此创建一个新的{@link  CloseStatus}。 
	 *  
	 * @param 原因
	 * @return 一个新的{@link  CloseStatus}实例的原因
	 */
	public CloseStatus withReason(String reason) {
		Assert.hasText(reason, "Reason must not be empty");
		return new CloseStatus(this.code, reason);
	}


	public boolean equalsCode(CloseStatus other) {
		return (this.code == other.code);
	}

	@Override
	public boolean equals(@Nullable Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof CloseStatus)) {
			return false;
		}
		CloseStatus otherStatus = (CloseStatus) other;
		return (this.code == otherStatus.code && ObjectUtils.nullSafeEquals(this.reason, otherStatus.reason));
	}

	@Override
	public int hashCode() {
		return this.code * 29 + ObjectUtils.nullSafeHashCode(this.reason);
	}

	@Override
	public String toString() {
		return "CloseStatus[code=" + this.code + ", reason=" + this.reason + "]";
	}

}
