/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.socket.sockjs.support;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.InvalidMediaTypeException;
import org.springframework.http.MediaType;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.DigestUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.sockjs.SockJsException;
import org.springframework.web.socket.sockjs.SockJsService;
import org.springframework.web.util.WebUtils;

/**
 * An abstract base class for {@link SockJsService} implementations that provides SockJS
 * path resolution and handling of static SockJS requests (e.g. "/info", "/iframe.html",
 * etc). Sub-classes must handle session URLs (i.e. transport-specific requests).
 *
 * By default, only same origin requests are allowed. Use {@link #setAllowedOrigins}
 * to specify a list of allowed origins (a list containing "*" will allow all origins).
 *
 * @author Rossen Stoyanchev
 * @author Sebastien Deleuze
 * @since 4.0
 */
/**
 * {@link  SockJsService}实现的抽象基类，提供SockJS路径解析和静态SockJS请求的处理（例如"/info"、"/iframe.html"等）。 
 * 子类必须处理会话网址（即特定于传输的请求）。 
 * 默认情况下，仅允许相同的原始请求。 
 * 使用{@link  #setAllowedOrigins}指定允许的来源列表（包含""的列表将允许所有来源）。 
 *  @author  Rossen Stoyanchev @author 塞巴斯蒂安·德勒兹@始于4.0
 */
public abstract class AbstractSockJsService implements SockJsService, CorsConfigurationSource {

	private static final String XFRAME_OPTIONS_HEADER = "X-Frame-Options";

	private static final long ONE_YEAR = TimeUnit.DAYS.toSeconds(365);


	private static final Random random = new Random();

	protected final Log logger = LogFactory.getLog(getClass());

	private final TaskScheduler taskScheduler;

	private String name = "SockJSService@" + ObjectUtils.getIdentityHexString(this);

	private String clientLibraryUrl = "https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js";

	private int streamBytesLimit = 128 * 1024;

	private boolean sessionCookieNeeded = true;

	private long heartbeatTime = TimeUnit.SECONDS.toMillis(25);

	private long disconnectDelay = TimeUnit.SECONDS.toMillis(5);

	private int httpMessageCacheSize = 100;

	private boolean webSocketEnabled = true;

	private boolean suppressCors = false;

	protected final Set<String> allowedOrigins = new LinkedHashSet<>();

	private final SockJsRequestHandler infoHandler = new InfoHandler();

	private final SockJsRequestHandler iframeHandler = new IframeHandler();


	public AbstractSockJsService(TaskScheduler scheduler) {
		Assert.notNull(scheduler, "TaskScheduler must not be null");
		this.taskScheduler = scheduler;
	}


	/**
	 * A scheduler instance to use for scheduling heart-beat messages.
	 */
	/**
	 * 用于调度心跳消息的调度程序实例。 
	 * 
	 */
	public TaskScheduler getTaskScheduler() {
		return this.taskScheduler;
	}

	/**
	 * Set a unique name for this service (mainly for logging purposes).
	 */
	/**
	 * 为此服务设置一个唯一的名称（主要用于记录目的）。 
	 * 
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Return the unique name associated with this service.
	 */
	/**
	 * 返回与此服务关联的唯一名称。 
	 * 
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Transports with no native cross-domain communication (e.g. "eventsource",
	 * "htmlfile") must get a simple page from the "foreign" domain in an invisible
	 * iframe so that code in the iframe can run from  a domain local to the SockJS
	 * server. Since the iframe needs to load the SockJS javascript client library,
	 * this property allows specifying where to load it from.
	 * <p>By default this is set to point to
	 * "https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js".
	 * However, it can also be set to point to a URL served by the application.
	 * <p>Note that it's possible to specify a relative URL in which case the URL
	 * must be relative to the iframe URL. For example assuming a SockJS endpoint
	 * mapped to "/sockjs", and resulting iframe URL "/sockjs/iframe.html", then the
	 * the relative URL must start with "../../" to traverse up to the location
	 * above the SockJS mapping. In case of a prefix-based Servlet mapping one more
	 * traversal may be needed.
	 */
	/**
	 * 没有本地跨域通信的传输（例如"eventsource"，"htmlfile"）必须从不可见的iframe中的"外部"域中获取一个简单页面，以便iframe中的代码可以从SockJS服务器本地的域中运行。 
	 * 由于iframe需要加载SockJS javascript客户端库，因此此属性允许指定从何处加载它。 
	 *  <p>默认情况下，它设置为指向"https://cdn.jsdelivr.net/sockjs/1.0.0/sockjs.min.js"。 
	 * 但是，也可以将其设置为指向应用程序提供的URL。 
	 *  <p>请注意，可以指定相对网址，在这种情况下，该网址必须相对于iframe网址。 
	 * 例如，假设SockJS端点映射到"/ sockjs"，并且生成的iframe URL为"/sockjs/iframe.html"，则相对URL必须以"../../"开头，以遍历到SockJS映射。 
	 * 在基于前缀的Servlet映射的情况下，可能需要再遍历一次。 
	 * 
	 */
	public void setSockJsClientLibraryUrl(String clientLibraryUrl) {
		this.clientLibraryUrl = clientLibraryUrl;
	}

	/**
	 * Return he URL to the SockJS JavaScript client library.
	 */
	/**
	 * 将URL返回到SockJS JavaScript客户端库。 
	 * 
	 */
	public String getSockJsClientLibraryUrl() {
		return this.clientLibraryUrl;
	}

	/**
	 * Streaming transports save responses on the client side and don't free
	 * memory used by delivered messages. Such transports need to recycle the
	 * connection once in a while. This property sets a minimum number of bytes
	 * that can be sent over a single HTTP streaming request before it will be
	 * closed. After that client will open a new request. Setting this value to
	 * one effectively disables streaming and will make streaming transports to
	 * behave like polling transports.
	 * <p>The default value is 128K (i.e. 128 * 1024).
	 */
	/**
	 * 流传输将响应保存在客户端，并且不会释放已传递邮件所使用的内存。 
	 * 这样的传输需要不时地回收连接。 
	 * 此属性设置在关闭HTTP之前可以通过单个HTTP流请求发送的最小字节数。 
	 * 之后，客户端将打开一个新请求。 
	 * 将此值设置为1会有效禁用流传输，并使流传输的行为类似于轮询传输。 
	 *  <p>默认值为128K（即1281024）。 
	 * 
	 */
	public void setStreamBytesLimit(int streamBytesLimit) {
		this.streamBytesLimit = streamBytesLimit;
	}

	/**
	 * Return the minimum number of bytes that can be sent over a single HTTP
	 * streaming request before it will be closed.
	 */
	/**
	 * 返回关闭单个HTTP流请求之前可以发送的最小字节数。 
	 * 
	 */
	public int getStreamBytesLimit() {
		return this.streamBytesLimit;
	}

	/**
	 * The SockJS protocol requires a server to respond to an initial "/info" request from
	 * clients with a "cookie_needed" boolean property that indicates whether the use of a
	 * JSESSIONID cookie is required for the application to function correctly, e.g. for
	 * load balancing or in Java Servlet containers for the use of an HTTP session.
	 * <p>This is especially important for IE 8,9 that support XDomainRequest -- a modified
	 * AJAX/XHR -- that can do requests across domains but does not send any cookies. In
	 * those cases, the SockJS client prefers the "iframe-htmlfile" transport over
	 * "xdr-streaming" in order to be able to send cookies.
	 * <p>The SockJS protocol also expects a SockJS service to echo back the JSESSIONID
	 * cookie when this property is set to true. However, when running in a Servlet
	 * container this is not necessary since the container takes care of it.
	 * <p>The default value is "true" to maximize the chance for applications to work
	 * correctly in IE 8,9 with support for cookies (and the JSESSIONID cookie in
	 * particular). However, an application can choose to set this to "false" if
	 * the use of cookies (and HTTP session) is not required.
	 */
	/**
	 * SockJS协议要求服务器使用"cookie_needed"布尔属性响应来自客户端的初始"/ info"请求，该布尔属性指示是否需要使用JSESSIONID cookie才能使应用正常运行，例如用于负载平衡或在Java Servlet容器中用于HTTP会话。 
	 *  <p>这对于支持XDomainRequest（经过修改的AJAX / XHR）的IE 8,9尤其重要，它可以跨域执行请求，但不发送任何cookie。 
	 * 在那些情况下，SockJS客户端更喜欢"iframe-htmlfile"传输而不是"xdr-streaming"传输，以便能够发送cookie。 
	 *  <p>当此属性设置为true时，SockJS协议还希望SockJS服务回显JSESSIONID cookie。 
	 * 但是，当在Servlet容器中运行时，这不是必需的，因为容器会处理它。 
	 *  <p>默认值为"true"，以最大程度地提高应用程序在IE 8,9中正常运行并支持cookie（特别是JSESSIONID cookie）的机会。 
	 * 但是，如果不需要使用cookie（和HTTP会话），则应用程序可以选择将其设置为"false"。 
	 * 
	 */
	public void setSessionCookieNeeded(boolean sessionCookieNeeded) {
		this.sessionCookieNeeded = sessionCookieNeeded;
	}

	/**
	 * Return whether the JSESSIONID cookie is required for the application to function.
	 */
	/**
	 * 返回应用程序运行是否需要JSESSIONID cookie。 
	 * 
	 */
	public boolean isSessionCookieNeeded() {
		return this.sessionCookieNeeded;
	}

	/**
	 * Specify the amount of time in milliseconds when the server has not sent
	 * any messages and after which the server should send a heartbeat frame
	 * to the client in order to keep the connection from breaking.
	 * <p>The default value is 25,000 (25 seconds).
	 */
	/**
	 * 指定服务器未发送任何消息时的时间量（以毫秒为单位），之后服务器应将心跳帧发送给客户端，以防止连接断开。 
	 *  <p>默认值为25,000（25秒）。 
	 * 
	 */
	public void setHeartbeatTime(long heartbeatTime) {
		this.heartbeatTime = heartbeatTime;
	}

	/**
	 * Return the amount of time in milliseconds when the server has not sent
	 * any messages.
	 */
	/**
	 * 返回服务器未发送任何消息时的时间（以毫秒为单位）。 
	 * 
	 */
	public long getHeartbeatTime() {
		return this.heartbeatTime;
	}

	/**
	 * The amount of time in milliseconds before a client is considered
	 * disconnected after not having a receiving connection, i.e. an active
	 * connection over which the server can send data to the client.
	 * <p>The default value is 5000.
	 */
	/**
	 * 在没有接收连接（即活动连接，服务器可以通过该连接将数据发送到客户端）之后，客户端被认为断开连接之前的时间（以毫秒为单位）。 
	 *  <p>默认值为5000。 
	 * 
	 */
	public void setDisconnectDelay(long disconnectDelay) {
		this.disconnectDelay = disconnectDelay;
	}

	/**
	 * Return the amount of time in milliseconds before a client is considered disconnected.
	 */
	/**
	 * 返回客户端被视为断开连接之前的时间（以毫秒为单位）。 
	 * 
	 */
	public long getDisconnectDelay() {
		return this.disconnectDelay;
	}

	/**
	 * The number of server-to-client messages that a session can cache while waiting
	 * for the next HTTP polling request from the client. All HTTP transports use this
	 * property since even streaming transports recycle HTTP requests periodically.
	 * <p>The amount of time between HTTP requests should be relatively brief and will
	 * not exceed the allows disconnect delay (see {@link #setDisconnectDelay(long)});
	 * 5 seconds by default.
	 * <p>The default size is 100.
	 */
	/**
	 * 会话在等待来自客户端的下一个HTTP轮询请求时可以缓存的服务器到客户端消息的数量。 
	 * 所有HTTP传输都使用此属性，因为即使流传输也定期回收HTTP请求。 
	 *  <p> HTTP请求之间的时间间隔应该相对较短，并且不会超过允许的断开延迟（请参阅{@link  #setDisconnectDelay（long）}）； 
	 * 默认为5秒。 
	 *  <p>默认大小为100。 
	 * 
	 */
	public void setHttpMessageCacheSize(int httpMessageCacheSize) {
		this.httpMessageCacheSize = httpMessageCacheSize;
	}

	/**
	 * Return the size of the HTTP message cache.
	 */
	/**
	 * 返回HTTP消息缓存的大小。 
	 * 
	 */
	public int getHttpMessageCacheSize() {
		return this.httpMessageCacheSize;
	}

	/**
	 * Some load balancers do not support WebSocket. This option can be used to
	 * disable the WebSocket transport on the server side.
	 * <p>The default value is "true".
	 */
	/**
	 * 某些负载平衡器不支持WebSocket。 
	 * 此选项可用于在服务器端禁用WebSocket传输。 
	 *  <p>默认值为"true"。 
	 * 
	 */
	public void setWebSocketEnabled(boolean webSocketEnabled) {
		this.webSocketEnabled = webSocketEnabled;
	}

	/**
	 * Return whether WebSocket transport is enabled.
	 */
	/**
	 * 返回是否启用WebSocket传输。 
	 * 
	 */
	public boolean isWebSocketEnabled() {
		return this.webSocketEnabled;
	}

	/**
	 * This option can be used to disable automatic addition of CORS headers for
	 * SockJS requests.
	 * <p>The default value is "false".
	 * @since 4.1.2
	 */
	/**
	 * 此选项可用于为SockJS请求禁用自动添加CORS标头。 
	 *  <p>默认值为"false"。 
	 *  @从4.1.2开始
	 */
	public void setSuppressCors(boolean suppressCors) {
		this.suppressCors = suppressCors;
	}

	/**
	 * Return if automatic addition of CORS headers has been disabled.
	 * @since 4.1.2
	 * @see #setSuppressCors
	 */
	/**
	 * 如果已禁用自动添加CORS标头，则返回。 
	 *  @始于4.1.2 
	 * @see  #setSuppressCors
	 */
	public boolean shouldSuppressCors() {
		return this.suppressCors;
	}

	/**
	 * Configure allowed {@code Origin} header values. This check is mostly
	 * designed for browsers. There is nothing preventing other types of client
	 * to modify the {@code Origin} header value.
	 * <p>When SockJS is enabled and origins are restricted, transport types
	 * that do not allow to check request origin (Iframe based transports)
	 * are disabled. As a consequence, IE 6 to 9 are not supported when origins
	 * are restricted.
	 * <p>Each provided allowed origin must have a scheme, and optionally a port
	 * (e.g. "https://example.org", "https://example.org:9090"). An allowed origin
	 * string may also be "*" in which case all origins are allowed.
	 * @since 4.1.2
	 * @see <a href="https://tools.ietf.org/html/rfc6454">RFC 6454: The Web Origin Concept</a>
	 * @see <a href="https://github.com/sockjs/sockjs-client#supported-transports-by-browser-html-served-from-http-or-https">SockJS supported transports by browser</a>
	 */
	/**
	 * 配置允许的{@code  Origin}头值。 
	 * 此检查主要是针对浏览器设计的。 
	 * 没有阻止其他类型的客户端修改{@code  Origin}标头值的措施。 
	 *  <p>启用SockJS并限制来源时，将禁用不允许检查请求来源的传输类型（基于Iframe的传输）。 
	 * 因此，在限制来源时不支持IE 6至9。 
	 *  <p>每个提供的允许来源必须有一个方案，以及一个可选的端口（例如"https://example.org"，"https://example.org:9090"）。 
	 * 允许的来源字符串也可以是""，在这种情况下，所有来源都被允许。 
	 *  @since 4.1.2 
	 * @see  <a href="https://tools.ietf.org/html/rfc6454"> RFC 6454：Web起源概念</a> 
	 * @see  <a href ="https ：//github.com/sockjs/sockjs-client#supported-transports-by-browser-html-served-from-http-or-https"> SockJS支持的浏览器传输</a>
	 */
	public void setAllowedOrigins(Collection<String> allowedOrigins) {
		Assert.notNull(allowedOrigins, "Allowed origins Collection must not be null");
		this.allowedOrigins.clear();
		this.allowedOrigins.addAll(allowedOrigins);
	}

	/**
	 * Return configure allowed {@code Origin} header values.
	 * @since 4.1.2
	 * @see #setAllowedOrigins
	 */
	/**
	 * 返回配置允许的{@code  Origin}头值。 
	 *  @始于4.1.2 
	 * @see  #setAllowedOrigins
	 */
	public Collection<String> getAllowedOrigins() {
		return Collections.unmodifiableSet(this.allowedOrigins);
	}


	/**
	 * This method determines the SockJS path and handles SockJS static URLs.
	 * Session URLs and raw WebSocket requests are delegated to abstract methods.
	 */
	/**
	 * 此方法确定SockJS路径并处理SockJS静态URL。 
	 * 会话URL和原始WebSocket请求都委托给抽象方法。 
	 * 
	 */
	@Override
	public final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,
			@Nullable String sockJsPath, WebSocketHandler wsHandler) throws SockJsException {

		if (sockJsPath == null) {
			if (logger.isWarnEnabled()) {
				logger.warn("Expected SockJS path. Failing request: " + request.getURI());
			}
			response.setStatusCode(HttpStatus.NOT_FOUND);
			return;
		}

		try {
			request.getHeaders();
		}
		catch (InvalidMediaTypeException ex) {
			// As per SockJS protocol content-type can be ignored (it's always json)
		}

		String requestInfo = (logger.isDebugEnabled() ? request.getMethod() + " " + request.getURI() : null);

		try {
			if (sockJsPath.isEmpty() || sockJsPath.equals("/")) {
				if (requestInfo != null) {
					logger.debug("Processing transport request: " + requestInfo);
				}
				response.getHeaders().setContentType(new MediaType("text", "plain", StandardCharsets.UTF_8));
				response.getBody().write("Welcome to SockJS!\n".getBytes(StandardCharsets.UTF_8));
			}

			else if (sockJsPath.equals("/info")) {
				if (requestInfo != null) {
					logger.debug("Processing transport request: " + requestInfo);
				}
				this.infoHandler.handle(request, response);
			}

			else if (sockJsPath.matches("/iframe[0-9-.a-z_]*.html")) {
				if (!this.allowedOrigins.isEmpty() && !this.allowedOrigins.contains("*")) {
					if (requestInfo != null) {
						logger.debug("Iframe support is disabled when an origin check is required. " +
								"Ignoring transport request: " + requestInfo);
					}
					response.setStatusCode(HttpStatus.NOT_FOUND);
					return;
				}
				if (this.allowedOrigins.isEmpty()) {
					response.getHeaders().add(XFRAME_OPTIONS_HEADER, "SAMEORIGIN");
				}
				if (requestInfo != null) {
					logger.debug("Processing transport request: " + requestInfo);
				}
				this.iframeHandler.handle(request, response);
			}

			else if (sockJsPath.equals("/websocket")) {
				if (isWebSocketEnabled()) {
					if (requestInfo != null) {
						logger.debug("Processing transport request: " + requestInfo);
					}
					handleRawWebSocketRequest(request, response, wsHandler);
				}
				else if (requestInfo != null) {
					logger.debug("WebSocket disabled. Ignoring transport request: " + requestInfo);
				}
			}

			else {
				String[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), "/");
				if (pathSegments.length != 3) {
					if (logger.isWarnEnabled()) {
						logger.warn("Invalid SockJS path '" + sockJsPath + "' - required to have 3 path segments");
					}
					if (requestInfo != null) {
						logger.debug("Ignoring transport request: " + requestInfo);
					}
					response.setStatusCode(HttpStatus.NOT_FOUND);
					return;
				}

				String serverId = pathSegments[0];
				String sessionId = pathSegments[1];
				String transport = pathSegments[2];

				if (!isWebSocketEnabled() && transport.equals("websocket")) {
					if (requestInfo != null) {
						logger.debug("WebSocket disabled. Ignoring transport request: " + requestInfo);
					}
					response.setStatusCode(HttpStatus.NOT_FOUND);
					return;
				}
				else if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {
					if (requestInfo != null) {
						logger.debug("Ignoring transport request: " + requestInfo);
					}
					response.setStatusCode(HttpStatus.NOT_FOUND);
					return;
				}

				if (requestInfo != null) {
					logger.debug("Processing transport request: " + requestInfo);
				}
				handleTransportRequest(request, response, wsHandler, sessionId, transport);
			}
			response.close();
		}
		catch (IOException ex) {
			throw new SockJsException("Failed to write to the response", null, ex);
		}
	}

	protected boolean validateRequest(String serverId, String sessionId, String transport) {
		if (!StringUtils.hasText(serverId) || !StringUtils.hasText(sessionId) || !StringUtils.hasText(transport)) {
			logger.warn("No server, session, or transport path segment in SockJS request.");
			return false;
		}

		// Server and session id's must not contain "."
		if (serverId.contains(".") || sessionId.contains(".")) {
			logger.warn("Either server or session contains a \".\" which is not allowed by SockJS protocol.");
			return false;
		}

		return true;
	}

	/**
	 * Ensure the path does not contain a file extension, either in the filename
	 * (e.g. "/jsonp.bat") or possibly after path parameters ("/jsonp;Setup.bat")
	 * which could be used for RFD exploits.
	 * <p>Since the last part of the path is expected to be a transport type, the
	 * presence of an extension would not work. All we need to do is check if
	 * there are any path parameters, which would have been removed from the
	 * SockJS path during request mapping, and if found reject the request.
	 */
	/**
	 * 确保该路径在文件名（例如"/jsonp.bat"）中或可能在可用于RFD攻击的路径参数（"/jsonp;Setup.bat"）之后均不包含文件扩展名。 
	 *  <p>由于路径的最后部分应该是传输类型，所以扩展名的存在将不起作用。 
	 * 我们需要做的就是检查是否有任何路径参数，这些参数在请求映射期间已从SockJS路径中删除，如果找到，则拒绝该请求。 
	 * 
	 */
	private boolean validatePath(ServerHttpRequest request) {
		String path = request.getURI().getPath();
		int index = path.lastIndexOf('/') + 1;
		return (path.indexOf(';', index) == -1);
	}

	protected boolean checkOrigin(ServerHttpRequest request, ServerHttpResponse response, HttpMethod... httpMethods)
			throws IOException {

		if (WebUtils.isSameOrigin(request)) {
			return true;
		}

		if (!WebUtils.isValidOrigin(request, this.allowedOrigins)) {
			if (logger.isWarnEnabled()) {
				logger.warn("Origin header value '" + request.getHeaders().getOrigin() + "' not allowed.");
			}
			response.setStatusCode(HttpStatus.FORBIDDEN);
			return false;
		}

		return true;
	}

	@Override
	@Nullable
	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
		if (!this.suppressCors && (request.getHeader(HttpHeaders.ORIGIN) != null)) {
			CorsConfiguration config = new CorsConfiguration();
			config.setAllowedOrigins(new ArrayList<>(this.allowedOrigins));
			config.addAllowedMethod("*");
			config.setAllowCredentials(true);
			config.setMaxAge(ONE_YEAR);
			config.addAllowedHeader("*");
			return config;
		}
		return null;
	}

	protected void addCacheHeaders(ServerHttpResponse response) {
		response.getHeaders().setCacheControl("public, max-age=" + ONE_YEAR);
		response.getHeaders().setExpires(new Date().getTime() + ONE_YEAR * 1000);
	}

	protected void addNoCacheHeaders(ServerHttpResponse response) {
		response.getHeaders().setCacheControl("no-store, no-cache, must-revalidate, max-age=0");
	}

	protected void sendMethodNotAllowed(ServerHttpResponse response, HttpMethod... httpMethods) {
		logger.warn("Sending Method Not Allowed (405)");
		response.setStatusCode(HttpStatus.METHOD_NOT_ALLOWED);
		response.getHeaders().setAllow(new LinkedHashSet<>(Arrays.asList(httpMethods)));
	}


	/**
	 * Handle request for raw WebSocket communication, i.e. without any SockJS message framing.
	 */
	/**
	 * 处理原始WebSocket通信的请求，即没有任何SockJS消息框架。 
	 * 
	 */
	protected abstract void handleRawWebSocketRequest(ServerHttpRequest request,
			ServerHttpResponse response, WebSocketHandler webSocketHandler) throws IOException;

	/**
	 * Handle a SockJS session URL (i.e. transport-specific request).
	 */
	/**
	 * 处理SockJS会话网址（即特定于传输的请求）。 
	 * 
	 */
	protected abstract void handleTransportRequest(ServerHttpRequest request, ServerHttpResponse response,
			WebSocketHandler webSocketHandler, String sessionId, String transport) throws SockJsException;


	private interface SockJsRequestHandler {

		void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException;
	}


	private class InfoHandler implements SockJsRequestHandler {

		private static final String INFO_CONTENT =
				"{\"entropy\":%s,\"origins\":[\"*:*\"],\"cookie_needed\":%s,\"websocket\":%s}";

		@Override
		public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
			if (request.getMethod() == HttpMethod.GET) {
				addNoCacheHeaders(response);
				if (checkOrigin(request, response)) {
					response.getHeaders().setContentType(new MediaType("application", "json", StandardCharsets.UTF_8));
					String content = String.format(
							INFO_CONTENT, random.nextInt(), isSessionCookieNeeded(), isWebSocketEnabled());
					response.getBody().write(content.getBytes());
				}

			}
			else if (request.getMethod() == HttpMethod.OPTIONS) {
				if (checkOrigin(request, response)) {
					addCacheHeaders(response);
					response.setStatusCode(HttpStatus.NO_CONTENT);
				}
			}
			else {
				sendMethodNotAllowed(response, HttpMethod.GET, HttpMethod.OPTIONS);
			}
		}
	}


	private class IframeHandler implements SockJsRequestHandler {

		private static final String IFRAME_CONTENT =
				"<!DOCTYPE html>\n" +
				"<html>\n" +
				"<head>\n" +
				"  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n" +
				"  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n" +
				"  <script>\n" +
				"    document.domain = document.domain;\n" +
				"    _sockjs_onload = function(){SockJS.bootstrap_iframe();};\n" +
				"  </script>\n" +
				"  <script src=\"%s\"></script>\n" +
				"</head>\n" +
				"<body>\n" +
				"  <h2>Don't panic!</h2>\n" +
				"  <p>This is a SockJS hidden iframe. It's used for cross domain magic.</p>\n" +
				"</body>\n" +
				"</html>";

		@Override
		public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {
			if (request.getMethod() != HttpMethod.GET) {
				sendMethodNotAllowed(response, HttpMethod.GET);
				return;
			}

			String content = String.format(IFRAME_CONTENT, getSockJsClientLibraryUrl());
			byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);
			StringBuilder builder = new StringBuilder("\"0");
			DigestUtils.appendMd5DigestAsHex(contentBytes, builder);
			builder.append('"');
			String etagValue = builder.toString();

			List<String> ifNoneMatch = request.getHeaders().getIfNoneMatch();
			if (!CollectionUtils.isEmpty(ifNoneMatch) && ifNoneMatch.get(0).equals(etagValue)) {
				response.setStatusCode(HttpStatus.NOT_MODIFIED);
				return;
			}

			response.getHeaders().setContentType(new MediaType("text", "html", StandardCharsets.UTF_8));
			response.getHeaders().setContentLength(contentBytes.length);

			// No cache in order to check every time if IFrame are authorized
			addNoCacheHeaders(response);
			response.getHeaders().setETag(etagValue);
			response.getBody().write(contentBytes);
		}
	}

}
