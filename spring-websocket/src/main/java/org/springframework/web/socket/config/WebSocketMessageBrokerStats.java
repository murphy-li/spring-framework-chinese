/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.web.socket.config;

import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.core.task.TaskExecutor;
import org.springframework.lang.Nullable;
import org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
import org.springframework.web.socket.messaging.StompSubProtocolHandler;
import org.springframework.web.socket.messaging.SubProtocolHandler;
import org.springframework.web.socket.messaging.SubProtocolWebSocketHandler;

/**
 * A central class for aggregating information about internal state and counters
 * from key infrastructure components of the setup that comes with
 * {@code @EnableWebSocketMessageBroker} for Java config and
 * {@code <websocket:message-broker>} for XML.
 *
 * <p>By default aggregated information is logged every 30 minutes at INFO level.
 * The frequency of logging can be changed via {@link #setLoggingPeriod(long)}.
 *
 * <p>This class is declared as a Spring bean by the above configuration with the
 * name "webSocketMessageBrokerStats" and can be easily exported to JMX, e.g. with
 * the {@link org.springframework.jmx.export.MBeanExporter MBeanExporter}.
 *
 * @author Rossen Stoyanchev
 * @since 4.1
 */
/**
 * 中心类，用于从Java config的{@code  @EnableWebSocketMessageBroker}和XML的{@code  <websocket：message-broker>}附带的安装程序的关键基础结构组件中收集有关内部状态和计数器的信息。 
 *  <p>默认情况下，每30分钟在INFO级别记录一次汇总信息。 
 * 可以通过{@link  #setLoggingPeriod（long）}更改日志记录的频率。 
 *  <p>上述配置通过名称"webSocketMessageBrokerStats"将该类声明为Spring Bean，可以轻松导出到JMX，例如与{@link  org.springframework.jmx.export.MBeanExporter MBeanExporter}。 
 *  @author  Rossen Stoyanchev @从4.1开始
 */
public class WebSocketMessageBrokerStats {

	private static final Log logger = LogFactory.getLog(WebSocketMessageBrokerStats.class);


	@Nullable
	private SubProtocolWebSocketHandler webSocketHandler;

	@Nullable
	private StompSubProtocolHandler stompSubProtocolHandler;

	@Nullable
	private StompBrokerRelayMessageHandler stompBrokerRelay;

	@Nullable
	private TaskExecutor inboundChannelExecutor;

	@Nullable
	private TaskExecutor outboundChannelExecutor;

	@Nullable
	private TaskScheduler sockJsTaskScheduler;

	@Nullable
	private ScheduledFuture<?> loggingTask;

	private long loggingPeriod = TimeUnit.MINUTES.toMillis(30);


	public void setSubProtocolWebSocketHandler(SubProtocolWebSocketHandler webSocketHandler) {
		this.webSocketHandler = webSocketHandler;
		this.stompSubProtocolHandler = initStompSubProtocolHandler();
	}

	@Nullable
	private StompSubProtocolHandler initStompSubProtocolHandler() {
		if (this.webSocketHandler == null) {
			return null;
		}
		for (SubProtocolHandler handler : this.webSocketHandler.getProtocolHandlers()) {
			if (handler instanceof StompSubProtocolHandler) {
				return (StompSubProtocolHandler) handler;
			}
		}
		SubProtocolHandler defaultHandler = this.webSocketHandler.getDefaultProtocolHandler();
		if (defaultHandler != null && defaultHandler instanceof StompSubProtocolHandler) {
			return (StompSubProtocolHandler) defaultHandler;
		}
		return null;
	}

	public void setStompBrokerRelay(StompBrokerRelayMessageHandler stompBrokerRelay) {
		this.stompBrokerRelay = stompBrokerRelay;
	}

	public void setInboundChannelExecutor(TaskExecutor inboundChannelExecutor) {
		this.inboundChannelExecutor = inboundChannelExecutor;
	}

	public void setOutboundChannelExecutor(TaskExecutor outboundChannelExecutor) {
		this.outboundChannelExecutor = outboundChannelExecutor;
	}

	public void setSockJsTaskScheduler(TaskScheduler sockJsTaskScheduler) {
		this.sockJsTaskScheduler = sockJsTaskScheduler;
		this.loggingTask = initLoggingTask(TimeUnit.MINUTES.toMillis(1));
	}

	@Nullable
	private ScheduledFuture<?> initLoggingTask(long initialDelay) {
		if (this.sockJsTaskScheduler != null && this.loggingPeriod > 0 && logger.isInfoEnabled()) {
			return this.sockJsTaskScheduler.scheduleWithFixedDelay(
					() -> logger.info(WebSocketMessageBrokerStats.this.toString()),
					Instant.now().plusMillis(initialDelay), Duration.ofMillis(this.loggingPeriod));
		}
		return null;
	}

	/**
	 * Set the frequency for logging information at INFO level in milliseconds.
	 * If set 0 or less than 0, the logging task is cancelled.
	 * <p>By default this property is set to 30 minutes (30 * 60 * 1000).
	 */
	/**
	 * 在INFO级别上设置记录信息的频率（以毫秒为单位）。 
	 * 如果设置为0或小于0，则取消日志记录任务。 
	 *  <p>默认情况下，此属性设置为30分钟（30 60 1000）。 
	 * 
	 */
	public void setLoggingPeriod(long period) {
		if (this.loggingTask != null) {
			this.loggingTask.cancel(true);
		}
		this.loggingPeriod = period;
		this.loggingTask = initLoggingTask(0);
	}

	/**
	 * Return the configured logging period frequency in milliseconds.
	 */
	/**
	 * 返回配置的日志记录周期频率（以毫秒为单位）。 
	 * 
	 */
	public long getLoggingPeriod() {
		return this.loggingPeriod;
	}

	/**
	 * Get stats about WebSocket sessions.
	 */
	/**
	 * 获取有关WebSocket会话的统计信息。 
	 * 
	 */
	public String getWebSocketSessionStatsInfo() {
		return (this.webSocketHandler != null ? this.webSocketHandler.getStatsInfo() : "null");
	}

	/**
	 * Get stats about STOMP-related WebSocket message processing.
	 */
	/**
	 * 获取有关STOMP相关的WebSocket消息处理的统计信息。 
	 * 
	 */
	public String getStompSubProtocolStatsInfo() {
		return (this.stompSubProtocolHandler != null ? this.stompSubProtocolHandler.getStatsInfo() : "null");
	}

	/**
	 * Get stats about STOMP broker relay (when using a full-featured STOMP broker).
	 */
	/**
	 * 获取有关STOMP代理中继的统计信息（使用完整功能的STOMP代理时）。 
	 * 
	 */
	public String getStompBrokerRelayStatsInfo() {
		return (this.stompBrokerRelay != null ? this.stompBrokerRelay.getStatsInfo() : "null");
	}

	/**
	 * Get stats about the executor processing incoming messages from WebSocket clients.
	 */
	/**
	 * 获取有关执行者处理来自WebSocket客户端的传入消息的统计信息。 
	 * 
	 */
	public String getClientInboundExecutorStatsInfo() {
		return (this.inboundChannelExecutor != null ?
				getExecutorStatsInfo(this.inboundChannelExecutor) : "null");
	}

	/**
	 * Get stats about the executor processing outgoing messages to WebSocket clients.
	 */
	/**
	 * 获取有关执行程序处理到WebSocket客户端的传出消息的统计信息。 
	 * 
	 */
	public String getClientOutboundExecutorStatsInfo() {
		return (this.outboundChannelExecutor != null ?
				getExecutorStatsInfo(this.outboundChannelExecutor) : "null");
	}

	/**
	 * Get stats about the SockJS task scheduler.
	 */
	/**
	 * 获取有关SockJS任务计划程序的统计信息。 
	 * 
	 */
	public String getSockJsTaskSchedulerStatsInfo() {
		if (this.sockJsTaskScheduler == null) {
			return "null";
		}
		if (this.sockJsTaskScheduler instanceof ThreadPoolTaskScheduler) {
			return getExecutorStatsInfo(((ThreadPoolTaskScheduler) this.sockJsTaskScheduler)
					.getScheduledThreadPoolExecutor());
		}
		else {
			return "unknown";
		}
	}

	private String getExecutorStatsInfo(Executor executor) {
		executor = executor instanceof ThreadPoolTaskExecutor ?
				((ThreadPoolTaskExecutor) executor).getThreadPoolExecutor() : executor;
		String str = executor.toString();
		return str.substring(str.indexOf("pool"), str.length() - 1);
	}

	@Override
	public String toString() {
		return "WebSocketSession[" + getWebSocketSessionStatsInfo() + "]" +
				", stompSubProtocol[" + getStompSubProtocolStatsInfo() + "]" +
				", stompBrokerRelay[" + getStompBrokerRelayStatsInfo() + "]" +
				", inboundChannel[" + getClientInboundExecutorStatsInfo() + "]" +
				", outboundChannel[" + getClientOutboundExecutorStatsInfo() + "]" +
				", sockJsScheduler[" + getSockJsTaskSchedulerStatsInfo() + "]";
	}

}
