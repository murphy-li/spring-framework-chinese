/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.messaging.handler.annotation.MessageMapping;

/**
 * Annotation that marks a method to be the target of a JMS message listener on the
 * specified {@link #destination}. The {@link #containerFactory} identifies the
 * {@link org.springframework.jms.config.JmsListenerContainerFactory} to use to build
 * the JMS listener container. If not set, a <em>default</em> container factory is
 * assumed to be available with a bean name of {@code jmsListenerContainerFactory}
 * unless an explicit default has been provided through configuration.
 *
 * <p><b>Consider setting up a custom
 * {@link org.springframework.jms.config.DefaultJmsListenerContainerFactory} bean.</b>
 * For production purposes, you'll typically fine-tune timeouts and recovery settings.
 * Most importantly, the default 'AUTO_ACKNOWLEDGE' mode does not provide reliability
 * guarantees, so make sure to use transacted sessions in case of reliability needs.
 *
 * <p>Processing of {@code @JmsListener} annotations is performed by registering a
 * {@link JmsListenerAnnotationBeanPostProcessor}. This can be done manually or,
 * more conveniently, through the {@code <jms:annotation-driven/>} element or
 * {@link EnableJms @EnableJms} annotation.
 *
 * <p>Annotated JMS listener methods are allowed to have flexible signatures similar
 * to what {@link MessageMapping} provides:
 * <ul>
 * <li>{@link javax.jms.Session} to get access to the JMS session</li>
 * <li>{@link javax.jms.Message} or one of its subclasses to get access to the raw JMS message</li>
 * <li>{@link org.springframework.messaging.Message} to use Spring's messaging abstraction counterpart</li>
 * <li>{@link org.springframework.messaging.handler.annotation.Payload @Payload}-annotated method
 * arguments, including support for validation</li>
 * <li>{@link org.springframework.messaging.handler.annotation.Header @Header}-annotated method
 * arguments to extract specific header values, including standard JMS headers defined by
 * {@link org.springframework.jms.support.JmsHeaders}</li>
 * <li>{@link org.springframework.messaging.handler.annotation.Headers @Headers}-annotated
 * method argument that must also be assignable to {@link java.util.Map} for obtaining
 * access to all headers</li>
 * <li>{@link org.springframework.messaging.MessageHeaders} arguments for obtaining
 * access to all headers</li>
 * <li>{@link org.springframework.messaging.support.MessageHeaderAccessor} or
 * {@link org.springframework.jms.support.JmsMessageHeaderAccessor} for convenient
 * access to all method arguments</li>
 * </ul>
 *
 * <p>Annotated methods may have a non-{@code void} return type. When they do,
 * the result of the method invocation is sent as a JMS reply to the destination
 * defined by the {@code JMSReplyTO} header of the incoming message. If this header
 * is not set, a default destination can be provided by adding
 * {@link org.springframework.messaging.handler.annotation.SendTo @SendTo} to the
 * method declaration.
 *
 * <p>This annotation may be used as a <em>meta-annotation</em> to create custom
 * <em>composed annotations</em> with attribute overrides.
 *
 * @author Stephane Nicoll
 * @since 4.1
 * @see EnableJms
 * @see JmsListenerAnnotationBeanPostProcessor
 * @see JmsListeners
 */
/**
 * 注释，该方法将方法标记为指定的{@link  #destination}上的JMS消息侦听器的目标。 
 *  {@link  #containerFactory}标识用于构建JMS侦听器容器的{@link  org.springframework.jms.config.JmsListenerContainerFactory}。 
 * 如果未设置，则假定<em> default </ em>容器工厂可用，且其bean名称为{@code  jmsListenerContainerFactory}，除非已通过配置提供了明确的默认值。 
 *  <p> <b>考虑设置自定义的{@link  org.springframework.jms.config.DefaultJmsListenerContainerFactory} bean。 
 * </ b>出于生产目的，通常会微调超时和恢复设置。 
 * 最重要的是，默认的"AUTO_ACKNOWLEDGE"模式不提供可靠性保证，因此请确保在需要可靠性的情况下使用事务处理会话。 
 *  <p>通过注册{@link  JmsListenerAnnotationBeanPostProcessor}来执行{@code  @JmsListener}注解的处理。 
 * 这可以手动完成，也可以通过{@code  <jms：annotation-driven />}元素或{@link  EnableJms @EnableJms}注释更方便地完成。 
 *  <p>允许带注释的JMS侦听器方法具有类似于{@link  MessageMapping}提供的签名的灵活签名：<ul> <li> {<@link> javax.jms.Session}以访问JMS会话< / li> <li> {<@link> javax.jms.Message}或其子类之一来访问原始JMS消息</ li> <li> {<@link> org.springframework.messaging.Message}使用Spring的消息传递抽象副本</ li> <li> {<@link> org.springframework.messaging.handler.annotation.Payload @Payload}注释的方法参数，包括对验证的支持</ li> <li> {@link  org.springframework.messaging.handler.annotation.Header @Header}注释的方法参数，以提取特定的标头值，包括由{@link  org.springframework.jms.support.JmsHeaders}定义的标准JMS标头。 
 *  li> <li> {<@link> org.springframework.messaging.handler.annotation.Headers @Headers}注释的方法参数，该参数还必须可分配给{@link  java.util.Map}以获取对所有对象的访问权限标头</ li> <li> { @link  org.springframework.messaging.MessageHeaders}参数以获得对所有标头的访问权限</ li> <li> {<@link> org.springframework.messaging.support.MessageHeaderAccessor}或{@link  org.springframework .jms.support.JmsMessageHeaderAccessor}，可方便地访问所有方法参数</ li> </ ul> <p>带注释的方法可能具有非{@code  void}返回类型。 
 * 完成后，方法调用的结果将作为JMS答复发送到由传入消息的{@code  JMSReplyTO}头定义的目标。 
 * 如果未设置此标头，则可以通过将{@link  org.springframework.messaging.handler.annotation.SendTo @SendTo}添加到方法声明中来提供默认目标。 
 *  <p>此注释可用作<em>元注释</ em>，以创建具有属性覆盖的自定义<em>组成的注释</ em>。 
 *  @author  Stephane Nicoll @since 4.1起
 * @see  EnableJms 
 * @see  JmsListenerAnnotationBeanPostProcessor 
 * @see  JmsListeners
 */
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(JmsListeners.class)
@MessageMapping
public @interface JmsListener {

	/**
	 * The unique identifier of the container managing this endpoint.
	 * <p>If none is specified, an auto-generated one is provided.
	 * @see org.springframework.jms.config.JmsListenerEndpointRegistry#getListenerContainer(String)
	 */
	/**
	 * 管理此端点的容器的唯一标识符。 
	 *  <p>如果未指定，则提供自动生成的一个。 
	 *  
	 * @see  org.springframework.jms.config.JmsListenerEndpointRegistry＃getListenerContainer（String）
	 */
	String id() default "";

	/**
	 * The bean name of the {@link org.springframework.jms.config.JmsListenerContainerFactory}
	 * to use to create the message listener container responsible for serving this endpoint.
	 * <p>If not specified, the default container factory is used, if any.
	 */
	/**
	 * {@link  org.springframework.jms.config.JmsListenerContainerFactory}的bean名称，用于创建负责为该端点提供服务的消息侦听器容器。 
	 *  <p>如果未指定，则使用默认容器工厂（如果有）。 
	 * 
	 */
	String containerFactory() default "";

	/**
	 * The destination name for this listener, resolved through the container-wide
	 * {@link org.springframework.jms.support.destination.DestinationResolver} strategy.
	 */
	/**
	 * 通过容器范围内的{@link  org.springframework.jms.support.destination.DestinationResolver}策略解析的此侦听器的目标名称。 
	 * 
	 */
	String destination();

	/**
	 * The name for the durable subscription, if any.
	 */
	/**
	 * 持久订阅的名称（如果有）。 
	 * 
	 */
	String subscription() default "";

	/**
	 * The JMS message selector expression, if any.
	 * <p>See the JMS specification for a detailed definition of selector expressions.
	 */
	/**
	 * JMS消息选择器表达式（如果有）。 
	 *  <p>有关选择器表达式的详细定义，请参见JMS规范。 
	 * 
	 */
	String selector() default "";

	/**
	 * The concurrency limits for the listener, if any. Overrides the value defined
	 * by the container factory used to create the listener container.
	 * <p>The concurrency limits can be a "lower-upper" String &mdash; for example,
	 * "5-10" &mdash; or a simple upper limit String &mdash; for example, "10", in
	 * which case the lower limit will be 1.
	 * <p>Note that the underlying container may or may not support all features.
	 * For instance, it may not be able to scale, in which case only the upper limit
	 * is used.
	 */
	/**
	 * 侦听器的并发限制（如果有）。 
	 * 重写由容器工厂定义的用于创建侦听器容器的值。 
	 *  <p>并发限制可以是"下-上"字符串（例如"5-10"），也可以是简单的上限字符串（例如"10"），在这种情况下，下限为1。 
	 * 请注意，底层容器可能支持也可能不支持所有功能。 
	 * 例如，它可能无法缩放，在这种情况下，仅使用上限。 
	 * 
	 */
	String concurrency() default "";

}
