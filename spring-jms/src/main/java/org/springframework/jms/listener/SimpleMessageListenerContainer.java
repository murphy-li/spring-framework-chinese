/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.listener;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Executor;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.Session;

import org.springframework.jms.support.JmsUtils;
import org.springframework.lang.Nullable;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.Assert;

/**
 * Message listener container that uses the plain JMS client API's
 * {@code MessageConsumer.setMessageListener()} method to
 * create concurrent MessageConsumers for the specified listeners.
 *
 * <p>This is the simplest form of a message listener container.
 * It creates a fixed number of JMS Sessions to invoke the listener,
 * not allowing for dynamic adaptation to runtime demands. Its main
 * advantage is its low level of complexity and the minimum requirements
 * on the JMS provider: Not even the ServerSessionPool facility is required.
 *
 * <p>See the {@link AbstractMessageListenerContainer} javadoc for details
 * on acknowledge modes and transaction options. Note that this container
 * exposes standard JMS behavior for the default "AUTO_ACKNOWLEDGE" mode:
 * that is, automatic message acknowledgment after listener execution,
 * with no redelivery in case of a user exception thrown but potential
 * redelivery in case of the JVM dying during listener execution.
 *
 * <p>For a different style of MessageListener handling, through looped
 * {@code MessageConsumer.receive()} calls that also allow for
 * transactional reception of messages (registering them with XA transactions),
 * see {@link DefaultMessageListenerContainer}.
 *
 * @author Juergen Hoeller
 * @since 2.0
 * @see javax.jms.MessageConsumer#setMessageListener
 * @see DefaultMessageListenerContainer
 * @see org.springframework.jms.listener.endpoint.JmsMessageEndpointManager
 */
/**
 * 消息侦听器容器，该容器使用普通的JMS客户端API的{@code  MessageConsumer.setMessageListener（）}方法为指定的侦听器创建并发MessageConsumers。 
 *  <p>这是消息侦听器容器的最简单形式。 
 * 它创建了固定数量的JMS会话来调用侦听器，不允许动态适应运行时需求。 
 * 它的主要优点是其较低的复杂度和对JMS提供程序的最低要求：甚至不需要ServerSessionPool工具。 
 *  <p>有关确认模式和事务选项的详细信息，请参见{@link  AbstractMessageListenerContainer} javadoc。 
 * 请注意，此容器针对默认的"AUTO_ACKNOWLEDGE"模式公开了标准的JMS行为：即，在侦听器执行后自动进行消息确认，如果引发用户异常，则不进行重新传递，但如果在侦听器执行期间JVM死亡，则可能进行重新传递。 
 *  <p>对于不同类型的MessageListener处理，请通过循环的{@code  MessageConsumer.receive（）}调用（该调用还允许以事务方式接收消息）（在XA事务中注册它们），请参阅{@link  DefaultMessageListenerContainer}。 
 *  @author  Juergen Hoeller @since 2.0起
 * @see  javax.jms.MessageConsumer＃setMessageListener 
 * @see  DefaultMessageListenerContainer 
 * @see  org.springframework.jms.listener.endpoint.JmsMessageEndpointManager
 */
public class SimpleMessageListenerContainer extends AbstractMessageListenerContainer implements ExceptionListener {

	private boolean connectLazily = false;

	private boolean recoverOnException = true;

	private int concurrentConsumers = 1;

	@Nullable
	private Executor taskExecutor;

	@Nullable
	private Set<Session> sessions;

	@Nullable
	private Set<MessageConsumer> consumers;

	private final Object consumersMonitor = new Object();


	/**
	 * Specify whether to connect lazily, i.e. whether to establish the JMS Connection
	 * and the corresponding Sessions and MessageConsumers as late as possible -
	 * in the start phase of this container.
	 * <p>Default is "false": connecting early, i.e. during the bean initialization phase.
	 * Set this flag to "true" in order to switch to lazy connecting if your target broker
	 * is likely to not have started up yet and you prefer to not even try a connection.
	 * @see #start()
	 * @see #initialize()
	 */
	/**
	 * 指定是否延迟连接，即是否在此容器的启动阶段中尽可能晚地建立JMS连接以及相应的Sessions和MessageConsumers。 
	 *  <p>默认为"false"：提早连接，即在bean初始化阶段。 
	 * 如果目标代理可能尚未启动，并且您甚至不想尝试连接，则将此标志设置为"true"，以切换到延迟连接。 
	 *  
	 * @see  #start（）
	 * @see  #initialize（）
	 */
	public void setConnectLazily(boolean connectLazily) {
		this.connectLazily = connectLazily;
	}

	/**
	 * Specify whether to explicitly recover the shared JMS Connection and the
	 * associated Sessions and MessageConsumers whenever a JMSException is reported.
	 * <p>Default is "true": refreshing the shared connection and re-initializing the
	 * consumers whenever the connection propagates an exception to its listener.
	 * Set this flag to "false" in order to rely on automatic recovery within the
	 * provider, holding on to the existing connection and consumer handles.
	 * @since 5.1.8
	 * @see #onException(JMSException)
	 * @see Connection#setExceptionListener
	 */
	/**
	 * 指定在报告JMSException时是否显式恢复共享的JMS连接以及关联的Session和MessageConsumers。 
	 *  <p>默认值为"true"：每当连接将异常传播到其侦听器时，刷新共享连接并重新初始化使用者。 
	 * 将此标志设置为"false"，以便依靠提供者内部的自动恢复，并保持现有连接和使用者句柄。 
	 *  @since 5.1.8 
	 * @see  #onException（JMSException）
	 * @see 连接#setExceptionListener
	 */
	public void setRecoverOnException(boolean recoverOnException) {
		this.recoverOnException = recoverOnException;
	}

	/**
	 * Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple
	 * upper limit String, e.g. "10".
	 * <p>This listener container will always hold on to the maximum number of
	 * consumers {@link #setConcurrentConsumers} since it is unable to scale.
	 * <p>This property is primarily supported for configuration compatibility with
	 * {@link DefaultMessageListenerContainer}. For this local listener container,
	 * generally use {@link #setConcurrentConsumers} instead.
	 */
	/**
	 * 通过"下-上"字符串指定并发限制，例如"5-10"，或简单的上限字符串，例如"10"。 
	 *  <p>此监听器容器将始终保持最大数量的使用者{@link  #setConcurrentConsumers}，因为它无法扩展。 
	 *  <p>主要支持此属性，以与{@link  DefaultMessageListenerContainer}进行配置兼容。 
	 * 对于此本地侦听器容器，通常使用{@link  #setConcurrentConsumers}代替。 
	 * 
	 */
	@Override
	public void setConcurrency(String concurrency) {
		try {
			int separatorIndex = concurrency.indexOf('-');
			if (separatorIndex != -1) {
				setConcurrentConsumers(Integer.parseInt(concurrency.substring(separatorIndex + 1, concurrency.length())));
			}
			else {
				setConcurrentConsumers(Integer.parseInt(concurrency));
			}
		}
		catch (NumberFormatException ex) {
			throw new IllegalArgumentException("Invalid concurrency value [" + concurrency + "]: only " +
					"single maximum integer (e.g. \"5\") and minimum-maximum combo (e.g. \"3-5\") supported. " +
					"Note that SimpleMessageListenerContainer will effectively ignore the minimum value and " +
					"always keep a fixed number of consumers according to the maximum value.");
		}
	}

	/**
	 * Specify the number of concurrent consumers to create. Default is 1.
	 * <p>Raising the number of concurrent consumers is recommendable in order
	 * to scale the consumption of messages coming in from a queue. However,
	 * note that any ordering guarantees are lost once multiple consumers are
	 * registered. In general, stick with 1 consumer for low-volume queues.
	 * <p><b>Do not raise the number of concurrent consumers for a topic.</b>
	 * This would lead to concurrent consumption of the same message,
	 * which is hardly ever desirable.
	 */
	/**
	 * 指定要创建的并发使用者数。 
	 * 默认值为1。 
	 * <p>建议增加并发使用者的数量，以扩展从队列传入的消息的使用。 
	 * 但是，请注意，一旦注册了多个使用者，任何订购保证都将丢失。 
	 * 通常，对于少量队列，请坚持使用1个使用者。 
	 *  <p> <b>请勿增加某个主题的并发使用者数量。 
	 * </ b>这将导致并发使用同一条消息，这几乎是不希望的。 
	 * 
	 */
	public void setConcurrentConsumers(int concurrentConsumers) {
		Assert.isTrue(concurrentConsumers > 0, "'concurrentConsumers' value must be at least 1 (one)");
		this.concurrentConsumers = concurrentConsumers;
	}

	/**
	 * Set the Spring TaskExecutor to use for executing the listener once
	 * a message has been received by the provider.
	 * <p>Default is none, that is, to run in the JMS provider's own receive thread,
	 * blocking the provider's receive endpoint while executing the listener.
	 * <p>Specify a TaskExecutor for executing the listener in a different thread,
	 * rather than blocking the JMS provider, usually integrating with an existing
	 * thread pool. This allows to keep the number of concurrent consumers low (1)
	 * while still processing messages concurrently (decoupled from receiving!).
	 * <p><b>NOTE: Specifying a TaskExecutor for listener execution affects
	 * acknowledgement semantics.</b> Messages will then always get acknowledged
	 * before listener execution, with the underlying Session immediately reused
	 * for receiving the next message. Using this in combination with a transacted
	 * session or with client acknowledgement will lead to unspecified results!
	 * <p><b>NOTE: Concurrent listener execution via a TaskExecutor will lead
	 * to concurrent processing of messages that have been received by the same
	 * underlying Session.</b> As a consequence, it is not recommended to use
	 * this setting with a {@link SessionAwareMessageListener}, at least not
	 * if the latter performs actual work on the given Session. A standard
	 * {@link javax.jms.MessageListener} will work fine, in general.
	 * @see #setConcurrentConsumers
	 * @see org.springframework.core.task.SimpleAsyncTaskExecutor
	 * @see org.springframework.scheduling.commonj.WorkManagerTaskExecutor
	 */
	/**
	 * 设置Spring TaskExecutor以在提供者收到消息后用于执行侦听器。 
	 *  <p>默认为none，即在JMS提供程序自己的接收线程中运行，在执行侦听器时阻止提供程序的接收端点。 
	 *  <p>指定一个TaskExecutor在不同的线程中执行侦听器，而不是阻塞JMS提供程序，通常与现有的线程池集成。 
	 * 这样可以使并发使用者的数量保持较低（1），同时仍可以并发处理消息（与接收脱钩！ 
	 * ）。 
	 *  <p> <b>注意：指定用于侦听器执行的TaskExecutor会影响确认语义。 
	 * </ b>然后，将始终在侦听器执行之前确认消息，并且基本Session会立即重用于接收下一条消息。 
	 * 将此与交易会话或客户确认结合使用将导致不确定的结果！ 
	 *  <p> <b>注意：通过TaskExecutor并发执行侦听器将导致并发处理同一基础会话已接收到的消息。 
	 * </ b>因此，不建议将此设置与{ @link  SessionAwareMessageListener}，至少如果后者在给定的Session上执行实际工作则至少不会这样。 
	 * 通常，标准的{@link  javax.jms.MessageListener}可以正常工作。 
	 *  
	 * @see  #setConcurrentConsumers 
	 * @see  org.springframework.core.task.SimpleAsyncTaskExecutor 
	 * @see  org.springframework.scheduling.commonj.WorkManagerTaskExecutor
	 */
	public void setTaskExecutor(Executor taskExecutor) {
		this.taskExecutor = taskExecutor;
	}

	@Override
	protected void validateConfiguration() {
		super.validateConfiguration();
		if (isSubscriptionDurable() && this.concurrentConsumers != 1) {
			throw new IllegalArgumentException("Only 1 concurrent consumer supported for durable subscription");
		}
	}


	//-------------------------------------------------------------------------
	// Implementation of AbstractMessageListenerContainer's template methods
	//-------------------------------------------------------------------------

	/**
	 * Always use a shared JMS Connection.
	 */
	/**
	 * 始终使用共享的JMS连接。 
	 * 
	 */
	@Override
	protected final boolean sharedConnectionEnabled() {
		return true;
	}

	/**
	 * Creates the specified number of concurrent consumers,
	 * in the form of a JMS Session plus associated MessageConsumer.
	 * @see #createListenerConsumer
	 */
	/**
	 * 以JMS会话和关联的MessageConsumer的形式创建指定数量的并发使用者。 
	 *  
	 * @see  #createListenerConsumer
	 */
	@Override
	protected void doInitialize() throws JMSException {
		if (!this.connectLazily) {
			try {
				establishSharedConnection();
			}
			catch (JMSException ex) {
				logger.debug("Could not connect on initialization - registering message consumers lazily", ex);
				return;
			}
			initializeConsumers();
		}
	}

	/**
	 * Re-initializes this container's JMS message consumers,
	 * if not initialized already.
	 */
	/**
	 * 如果尚未初始化，则重新初始化此容器的JMS消息使用者。 
	 * 
	 */
	@Override
	protected void doStart() throws JMSException {
		super.doStart();
		initializeConsumers();
	}

	/**
	 * Registers this listener container as JMS ExceptionListener on the shared connection.
	 */
	/**
	 * 在共享连接上将此侦听器容器注册为JMS ExceptionListener。 
	 * 
	 */
	@Override
	protected void prepareSharedConnection(Connection connection) throws JMSException {
		super.prepareSharedConnection(connection);
		connection.setExceptionListener(this);
	}

	/**
	 * JMS ExceptionListener implementation, invoked by the JMS provider in
	 * case of connection failures. Re-initializes this listener container's
	 * shared connection and its sessions and consumers, if necessary.
	 * @param ex the reported connection exception
	 * @see #setRecoverOnException
	 * @see #refreshSharedConnection()
	 * @see #initializeConsumers()
	 */
	/**
	 * JMS ExceptionListener实现，在连接失败的情况下由JMS提供程序调用。 
	 * 如有必要，重新初始化此侦听器容器的共享连接及其会话和使用者。 
	 *  
	 * @param 例如报告的连接异常
	 * @see  #setRecoverOnException 
	 * @see  #refreshSharedConnection（）
	 * @see  #initializeConsumers（）
	 */
	@Override
	public void onException(JMSException ex) {
		// First invoke the user-specific ExceptionListener, if any.
		invokeExceptionListener(ex);

		// Now try to recover the shared Connection and all consumers...
		if (this.recoverOnException) {
			if (logger.isDebugEnabled()) {
				logger.debug("Trying to recover from JMS Connection exception: " + ex);
			}
			try {
				synchronized (this.consumersMonitor) {
					this.sessions = null;
					this.consumers = null;
				}
				refreshSharedConnection();
				initializeConsumers();
				logger.debug("Successfully refreshed JMS Connection");
			}
			catch (JMSException recoverEx) {
				logger.debug("Failed to recover JMS Connection", recoverEx);
				logger.error("Encountered non-recoverable JMSException", ex);
			}
		}
	}

	/**
	 * Initialize the JMS Sessions and MessageConsumers for this container.
	 * @throws JMSException in case of setup failure
	 */
	/**
	 * 初始化此容器的JMS会话和MessageConsumers。 
	 *  
	 * @throws 如果安装失败，则JMSException
	 */
	protected void initializeConsumers() throws JMSException {
		// Register Sessions and MessageConsumers.
		synchronized (this.consumersMonitor) {
			if (this.consumers == null) {
				this.sessions = new HashSet<>(this.concurrentConsumers);
				this.consumers = new HashSet<>(this.concurrentConsumers);
				Connection con = getSharedConnection();
				for (int i = 0; i < this.concurrentConsumers; i++) {
					Session session = createSession(con);
					MessageConsumer consumer = createListenerConsumer(session);
					this.sessions.add(session);
					this.consumers.add(consumer);
				}
			}
		}
	}

	/**
	 * Create a MessageConsumer for the given JMS Session,
	 * registering a MessageListener for the specified listener.
	 * @param session the JMS Session to work on
	 * @return the MessageConsumer
	 * @throws JMSException if thrown by JMS methods
	 * @see #executeListener
	 */
	/**
	 * 为给定的JMS会话创建一个MessageConsumer，为指定的侦听器注册一个MessageListener。 
	 *  
	 * @param 会话要在
	 * @return  MessageConsumer 
	 * @throws  JMSException上工作的JMS会话，如果被JMS方法抛出
	 * @see  #executeListener
	 */
	protected MessageConsumer createListenerConsumer(final Session session) throws JMSException {
		Destination destination = getDestination();
		if (destination == null) {
			String destinationName = getDestinationName();
			Assert.state(destinationName != null, "No destination set");
			destination = resolveDestinationName(session, destinationName);
		}
		MessageConsumer consumer = createConsumer(session, destination);

		if (this.taskExecutor != null) {
			consumer.setMessageListener(message -> this.taskExecutor.execute(() -> processMessage(message, session)));
		}
		else {
			consumer.setMessageListener(message -> processMessage(message, session));
		}

		return consumer;
	}

	/**
	 * Process a message received from the provider.
	 * <p>Executes the listener, exposing the current JMS Session as
	 * thread-bound resource (if "exposeListenerSession" is "true").
	 * @param message the received JMS Message
	 * @param session the JMS Session to operate on
	 * @see #executeListener
	 * @see #setExposeListenerSession
	 */
	/**
	 * 处理从提供者收到的消息。 
	 *  <p>执行侦听器，将当前JMS会话公开为线程绑定资源（如果"exposeListenerSession"为"true"）。 
	 *  
	 * @param 消息接收到的JMS消息
	 * @param 会话JMS会话要在
	 * @see  #executeListener 
	 * @see  #setExposeListenerSession上运行
	 */
	protected void processMessage(Message message, Session session) {
		ConnectionFactory connectionFactory = getConnectionFactory();
		boolean exposeResource = (connectionFactory != null && isExposeListenerSession());
		if (exposeResource) {
			TransactionSynchronizationManager.bindResource(
					connectionFactory, new LocallyExposedJmsResourceHolder(session));
		}
		try {
			executeListener(session, message);
		}
		finally {
			if (exposeResource) {
				TransactionSynchronizationManager.unbindResource(getConnectionFactory());
			}
		}
	}

	/**
	 * Destroy the registered JMS Sessions and associated MessageConsumers.
	 */
	/**
	 * 销毁已注册的JMS会话和关联的MessageConsumers。 
	 * 
	 */
	@Override
	protected void doShutdown() throws JMSException {
		synchronized (this.consumersMonitor) {
			if (this.consumers != null) {
				logger.debug("Closing JMS MessageConsumers");
				for (MessageConsumer consumer : this.consumers) {
					JmsUtils.closeMessageConsumer(consumer);
				}
				if (this.sessions != null) {
					logger.debug("Closing JMS Sessions");
					for (Session session : this.sessions) {
						JmsUtils.closeSession(session);
					}
				}
			}
		}
	}

}
