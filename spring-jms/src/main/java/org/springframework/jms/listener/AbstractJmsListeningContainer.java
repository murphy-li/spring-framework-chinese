/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.listener;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import javax.jms.Connection;
import javax.jms.JMSException;

import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.context.SmartLifecycle;
import org.springframework.jms.JmsException;
import org.springframework.jms.connection.ConnectionFactoryUtils;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.destination.JmsDestinationAccessor;
import org.springframework.lang.Nullable;
import org.springframework.util.ClassUtils;

/**
 * Common base class for all containers which need to implement listening
 * based on a JMS Connection (either shared or freshly obtained for each attempt).
 * Inherits basic Connection and Session configuration handling from the
 * {@link org.springframework.jms.support.JmsAccessor} base class.
 *
 * <p>This class provides basic lifecycle management, in particular management
 * of a shared JMS Connection. Subclasses are supposed to plug into this
 * lifecycle, implementing the {@link #sharedConnectionEnabled()} as well
 * as the {@link #doInitialize()} and {@link #doShutdown()} template methods.
 *
 * <p>This base class does not assume any specific listener programming model
 * or listener invoker mechanism. It just provides the general runtime
 * lifecycle management needed for any kind of JMS-based listening mechanism
 * that operates on a JMS Connection/Session.
 *
 * <p>For a concrete listener programming model, check out the
 * {@link AbstractMessageListenerContainer} subclass. For a concrete listener
 * invoker mechanism, check out the {@link DefaultMessageListenerContainer} class.
 *
 * @author Juergen Hoeller
 * @since 2.0.3
 * @see #sharedConnectionEnabled()
 * @see #doInitialize()
 * @see #doShutdown()
 */
/**
 * 需要基于JMS连接实现监听的所有容器的通用基类（每次尝试共享或新鲜获得）。 
 * 从{@link  org.springframework.jms.support.JmsAccessor}基类继承基本的Connection和Session配置处理。 
 *  <p>此类提供基本的生命周期管理，尤其是共享JMS Connection的管理。 
 * 子类应该插入此生命周期，实现{@link  #sharedConnectionEnabled（）}以及{@link  #doInitialize（）}和{@link  #doShutdown（）}模板方法。 
 *  <p>此基类不假定任何特定的侦听器编程模型或侦听器调用程序机制。 
 * 它只是提供了在JMS连接/会话上运行的任何一种基于JMS的侦听机制所需的常规运行时生命周期管理。 
 *  <p>对于具体的侦听器编程模型，请检查{@link  AbstractMessageListenerContainer}子类。 
 * 有关具体的侦听器调用程序机制，请检查{@link  DefaultMessageListenerContainer}类。 
 *  @author  Juergen Hoeller @since 2.0.3 
 * @see  #sharedConnectionEnabled（）
 * @see  #doInitialize（）
 * @see  #doShutdown（）
 */
public abstract class AbstractJmsListeningContainer extends JmsDestinationAccessor
		implements BeanNameAware, DisposableBean, SmartLifecycle {

	@Nullable
	private String clientId;

	private boolean autoStartup = true;

	private int phase = DEFAULT_PHASE;

	@Nullable
	private String beanName;

	@Nullable
	private Connection sharedConnection;

	private boolean sharedConnectionStarted = false;

	protected final Object sharedConnectionMonitor = new Object();

	private boolean active = false;

	private volatile boolean running = false;

	private final List<Object> pausedTasks = new LinkedList<>();

	protected final Object lifecycleMonitor = new Object();


	/**
	 * Specify the JMS client ID for a shared Connection created and used
	 * by this container.
	 * <p>Note that client IDs need to be unique among all active Connections
	 * of the underlying JMS provider. Furthermore, a client ID can only be
	 * assigned if the original ConnectionFactory hasn't already assigned one.
	 * @see javax.jms.Connection#setClientID
	 * @see #setConnectionFactory
	 */
	/**
	 * 为该容器创建和使用的共享连接指定JMS客户端ID。 
	 *  <p>请注意，底层JMS提供程序的所有活动Connections中的客户机ID必须唯一。 
	 * 此外，仅当原始ConnectionFactory尚未分配客户机ID时，才可以分配客户机ID。 
	 *  
	 * @see  javax.jms.Connection＃setClientID 
	 * @see  #setConnectionFactory
	 */
	public void setClientId(@Nullable String clientId) {
		this.clientId = clientId;
	}

	/**
	 * Return the JMS client ID for the shared Connection created and used
	 * by this container, if any.
	 */
	/**
	 * 返回此容器创建和使用的共享连接的JMS客户端ID（如果有）。 
	 * 
	 */
	@Nullable
	public String getClientId() {
		return this.clientId;
	}

	/**
	 * Set whether to automatically start the container after initialization.
	 * <p>Default is "true"; set this to "false" to allow for manual startup
	 * through the {@link #start()} method.
	 */
	/**
	 * 设置是否在初始化后自动启动容器。 
	 *  <p>默认为"true"； 
	 * 将此设置为"false"以允许通过{@link  #start（）}方法手动启动。 
	 * 
	 */
	public void setAutoStartup(boolean autoStartup) {
		this.autoStartup = autoStartup;
	}

	@Override
	public boolean isAutoStartup() {
		return this.autoStartup;
	}

	/**
	 * Specify the phase in which this container should be started and
	 * stopped. The startup order proceeds from lowest to highest, and
	 * the shutdown order is the reverse of that. By default this value
	 * is Integer.MAX_VALUE meaning that this container starts as late
	 * as possible and stops as soon as possible.
	 */
	/**
	 * 指定启动和停止此容器的阶段。 
	 * 启动顺序从最低到最高，而关闭顺序则相反。 
	 * 默认情况下，此值为Integer.MAX_VALUE，表示此容器尽可能早地启动，并尽快停止。 
	 * 
	 */
	public void setPhase(int phase) {
		this.phase = phase;
	}

	/**
	 * Return the phase in which this container will be started and stopped.
	 */
	/**
	 * 返回此容器将被启动和停止的阶段。 
	 * 
	 */
	@Override
	public int getPhase() {
		return this.phase;
	}

	@Override
	public void setBeanName(@Nullable String beanName) {
		this.beanName = beanName;
	}

	/**
	 * Return the bean name that this listener container has been assigned
	 * in its containing bean factory, if any.
	 */
	/**
	 * 返回此侦听器容器在其包含的bean工厂中已分配的bean名称（如果有）。 
	 * 
	 */
	@Nullable
	protected final String getBeanName() {
		return this.beanName;
	}


	/**
	 * Delegates to {@link #validateConfiguration()} and {@link #initialize()}.
	 */
	/**
	 * 委托给{@link  #validateConfiguration（）}和{@link  #initialize（）}。 
	 * 
	 */
	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();
		validateConfiguration();
		initialize();
	}

	/**
	 * Validate the configuration of this container.
	 * <p>The default implementation is empty. To be overridden in subclasses.
	 */
	/**
	 * 验证此容器的配置。 
	 *  <p>默认实现为空。 
	 * 在子类中被覆盖。 
	 * 
	 */
	protected void validateConfiguration() {
	}

	/**
	 * Calls {@link #shutdown()} when the BeanFactory destroys the container instance.
	 * @see #shutdown()
	 */
	/**
	 * BeanFactory销毁容器实例时，调用{@link  #shutdown（）}。 
	 *  
	 * @see  #shutdown（）
	 */
	@Override
	public void destroy() {
		shutdown();
	}


	//-------------------------------------------------------------------------
	// Lifecycle methods for starting and stopping the container
	//-------------------------------------------------------------------------

	/**
	 * Initialize this container.
	 * <p>Creates a JMS Connection, starts the {@link javax.jms.Connection}
	 * (if {@link #setAutoStartup(boolean) "autoStartup"} hasn't been turned off),
	 * and calls {@link #doInitialize()}.
	 * @throws org.springframework.jms.JmsException if startup failed
	 */
	/**
	 * 初始化此容器。 
	 *  <p>创建JMS连接，启动{@link  javax.jms.Connection}（如果尚未关闭{@link  #setAutoStartup（boolean）"autoStartup"}），并调用{<@链接> #doInitialize（）}。 
	 *  
	 * @throws  org.springframework.jms.JmsException如果启动失败
	 */
	public void initialize() throws JmsException {
		try {
			synchronized (this.lifecycleMonitor) {
				this.active = true;
				this.lifecycleMonitor.notifyAll();
			}
			doInitialize();
		}
		catch (JMSException ex) {
			synchronized (this.sharedConnectionMonitor) {
				ConnectionFactoryUtils.releaseConnection(this.sharedConnection, getConnectionFactory(), this.autoStartup);
				this.sharedConnection = null;
			}
			throw convertJmsAccessException(ex);
		}
	}

	/**
	 * Stop the shared Connection, call {@link #doShutdown()},
	 * and close this container.
	 * @throws JmsException if shutdown failed
	 */
	/**
	 * 停止共享的连接，调用{@link  #doShutdown（）}，然后关闭此容器。 
	 *  
	 * @throws  JmsException如果关机失败
	 */
	public void shutdown() throws JmsException {
		logger.debug("Shutting down JMS listener container");
		boolean wasRunning;
		synchronized (this.lifecycleMonitor) {
			wasRunning = this.running;
			this.running = false;
			this.active = false;
			this.pausedTasks.clear();
			this.lifecycleMonitor.notifyAll();
		}

		// Stop shared Connection early, if necessary.
		if (wasRunning && sharedConnectionEnabled()) {
			try {
				stopSharedConnection();
			}
			catch (Throwable ex) {
				logger.debug("Could not stop JMS Connection on shutdown", ex);
			}
		}

		// Shut down the invokers.
		try {
			doShutdown();
		}
		catch (JMSException ex) {
			throw convertJmsAccessException(ex);
		}
		finally {
			if (sharedConnectionEnabled()) {
				synchronized (this.sharedConnectionMonitor) {
					ConnectionFactoryUtils.releaseConnection(this.sharedConnection, getConnectionFactory(), false);
					this.sharedConnection = null;
				}
			}
		}
	}

	/**
	 * Return whether this container is currently active,
	 * that is, whether it has been set up but not shut down yet.
	 */
	/**
	 * 返回此容器当前是否处于活动状态，即是否已设置但尚未关闭。 
	 * 
	 */
	public final boolean isActive() {
		synchronized (this.lifecycleMonitor) {
			return this.active;
		}
	}

	/**
	 * Start this container.
	 * @throws JmsException if starting failed
	 * @see #doStart
	 */
	/**
	 * 启动此容器。 
	 *  
	 * @throws 如果启动失败，则JmsException 
	 * @see  #doStart
	 */
	@Override
	public void start() throws JmsException {
		try {
			doStart();
		}
		catch (JMSException ex) {
			throw convertJmsAccessException(ex);
		}
	}

	/**
	 * Start the shared Connection, if any, and notify all invoker tasks.
	 * @throws JMSException if thrown by JMS API methods
	 * @see #startSharedConnection
	 */
	/**
	 * 启动共享的Connection（如果有），并通知所有调用者任务。 
	 *  
	 * @throws  JMSException（如果由JMS API方法抛出）
	 * @see  #startSharedConnection
	 */
	protected void doStart() throws JMSException {
		// Lazily establish a shared Connection, if necessary.
		if (sharedConnectionEnabled()) {
			establishSharedConnection();
		}

		// Reschedule paused tasks, if any.
		synchronized (this.lifecycleMonitor) {
			this.running = true;
			this.lifecycleMonitor.notifyAll();
			resumePausedTasks();
		}

		// Start the shared Connection, if any.
		if (sharedConnectionEnabled()) {
			startSharedConnection();
		}
	}

	/**
	 * Stop this container.
	 * @throws JmsException if stopping failed
	 * @see #doStop
	 */
	/**
	 * 停止此容器。 
	 *  
	 * @throws 如果停止失败，则JmsException 
	 * @see  #doStop
	 */
	@Override
	public void stop() throws JmsException {
		try {
			doStop();
		}
		catch (JMSException ex) {
			throw convertJmsAccessException(ex);
		}
	}

	/**
	 * Notify all invoker tasks and stop the shared Connection, if any.
	 * @throws JMSException if thrown by JMS API methods
	 * @see #stopSharedConnection
	 */
	/**
	 * 通知所有调用者任务，并停止共享的Connection（如果有）。 
	 *  
	 * @throws  JMSException（如果由JMS API方法抛出）
	 * @see  #stopSharedConnection
	 */
	protected void doStop() throws JMSException {
		synchronized (this.lifecycleMonitor) {
			this.running = false;
			this.lifecycleMonitor.notifyAll();
		}

		if (sharedConnectionEnabled()) {
			stopSharedConnection();
		}
	}

	/**
	 * Determine whether this container is currently running,
	 * that is, whether it has been started and not stopped yet.
	 * @see #start()
	 * @see #stop()
	 * @see #runningAllowed()
	 */
	/**
	 * 确定此容器当前是否正在运行，即是否已启动并且尚未停止。 
	 *  
	 * @see  #start（）
	 * @see  #stop（）
	 * @see  #runningAllowed（）
	 */
	@Override
	public final boolean isRunning() {
		return (this.running && runningAllowed());
	}

	/**
	 * Check whether this container's listeners are generally allowed to run.
	 * <p>This implementation always returns {@code true}; the default 'running'
	 * state is purely determined by {@link #start()} / {@link #stop()}.
	 * <p>Subclasses may override this method to check against temporary
	 * conditions that prevent listeners from actually running. In other words,
	 * they may apply further restrictions to the 'running' state, returning
	 * {@code false} if such a restriction prevents listeners from running.
	 */
	/**
	 * 检查是否通常允许运行此容器的侦听器。 
	 *  <p>此实现始终返回{@code  true};默认的"运行"状态完全由{@link  #start（）} / {@link  #stop（）}确定。 
	 *  <p>子类可以重写此方法，以检查阻止侦听器实际运行的临时条件。 
	 * 换句话说，他们可以将其他限制应用于"运行"状态，如果这种限制阻止侦听器运行，则返回{@code  false}。 
	 * 
	 */
	protected boolean runningAllowed() {
		return true;
	}


	//-------------------------------------------------------------------------
	// Management of a shared JMS Connection
	//-------------------------------------------------------------------------

	/**
	 * Establish a shared Connection for this container.
	 * <p>The default implementation delegates to {@link #createSharedConnection()},
	 * which does one immediate attempt and throws an exception if it fails.
	 * Can be overridden to have a recovery process in place, retrying
	 * until a Connection can be successfully established.
	 * @throws JMSException if thrown by JMS API methods
	 */
	/**
	 * 为此容器建立一个共享的连接。 
	 *  <p>默认的实现委托给{@link  #createSharedConnection（）}，它立即进行一次尝试，如果失败则抛出异常。 
	 * 可以被覆盖以具有适当的恢复过程，然后重试直到可以成功建立连接为止。 
	 *  
	 * @throws  JMSException，如果由JMS API方法抛出
	 */
	protected void establishSharedConnection() throws JMSException {
		synchronized (this.sharedConnectionMonitor) {
			if (this.sharedConnection == null) {
				this.sharedConnection = createSharedConnection();
				logger.debug("Established shared JMS Connection");
			}
		}
	}

	/**
	 * Refresh the shared Connection that this container holds.
	 * <p>Called on startup and also after an infrastructure exception
	 * that occurred during invoker setup and/or execution.
	 * @throws JMSException if thrown by JMS API methods
	 */
	/**
	 * 刷新此容器保存的共享连接。 
	 *  <p>在启动时以及在调用程序设置和/或执行期间发生的基础结构异常之后调用。 
	 *  
	 * @throws  JMSException，如果由JMS API方法抛出
	 */
	protected final void refreshSharedConnection() throws JMSException {
		synchronized (this.sharedConnectionMonitor) {
			ConnectionFactoryUtils.releaseConnection(
					this.sharedConnection, getConnectionFactory(), this.sharedConnectionStarted);
			this.sharedConnection = null;
			this.sharedConnection = createSharedConnection();
			if (this.sharedConnectionStarted) {
				this.sharedConnection.start();
			}
		}
	}

	/**
	 * Create a shared Connection for this container.
	 * <p>The default implementation creates a standard Connection
	 * and prepares it through {@link #prepareSharedConnection}.
	 * @return the prepared Connection
	 * @throws JMSException if the creation failed
	 */
	/**
	 * 为此容器创建一个共享的连接。 
	 *  <p>默认实现创建一个标准连接，并通过{@link  #prepareSharedConnection}进行准备。 
	 * 如果创建失败，请
	 * @return 准备好的Connection 
	 * @throws  JMSException
	 */
	protected Connection createSharedConnection() throws JMSException {
		Connection con = createConnection();
		try {
			prepareSharedConnection(con);
			return con;
		}
		catch (JMSException ex) {
			JmsUtils.closeConnection(con);
			throw ex;
		}
	}

	/**
	 * Prepare the given Connection, which is about to be registered
	 * as shared Connection for this container.
	 * <p>The default implementation sets the specified client id, if any.
	 * Subclasses can override this to apply further settings.
	 * @param connection the Connection to prepare
	 * @throws JMSException if the preparation efforts failed
	 * @see #getClientId()
	 */
	/**
	 * 准备给定的Connection，它将为此容器注册为共享Connection。 
	 *  <p>默认实现会设置指定的客户端ID（如果有）。 
	 * 子类可以覆盖此设置以应用更多设置。 
	 *  
	 * @param 连接如果准备工作失败，则Connection准备
	 * @throws  JMSException 
	 * @see  #getClientId（）
	 */
	protected void prepareSharedConnection(Connection connection) throws JMSException {
		String clientId = getClientId();
		if (clientId != null) {
			connection.setClientID(clientId);
		}
	}

	/**
	 * Start the shared Connection.
	 * @throws JMSException if thrown by JMS API methods
	 * @see javax.jms.Connection#start()
	 */
	/**
	 * 启动共享的连接。 
	 *  
	 * @throws  JMSException（如果由JMS API方法抛出）
	 * @see  javax.jms.Connection＃start（）
	 */
	protected void startSharedConnection() throws JMSException {
		synchronized (this.sharedConnectionMonitor) {
			this.sharedConnectionStarted = true;
			if (this.sharedConnection != null) {
				try {
					this.sharedConnection.start();
				}
				catch (javax.jms.IllegalStateException ex) {
					logger.debug("Ignoring Connection start exception - assuming already started: " + ex);
				}
			}
		}
	}

	/**
	 * Stop the shared Connection.
	 * @throws JMSException if thrown by JMS API methods
	 * @see javax.jms.Connection#start()
	 */
	/**
	 * 停止共享的连接。 
	 *  
	 * @throws  JMSException（如果由JMS API方法抛出）
	 * @see  javax.jms.Connection＃start（）
	 */
	protected void stopSharedConnection() throws JMSException {
		synchronized (this.sharedConnectionMonitor) {
			this.sharedConnectionStarted = false;
			if (this.sharedConnection != null) {
				try {
					this.sharedConnection.stop();
				}
				catch (javax.jms.IllegalStateException ex) {
					logger.debug("Ignoring Connection stop exception - assuming already stopped: " + ex);
				}
			}
		}
	}

	/**
	 * Return the shared JMS Connection maintained by this container.
	 * Available after initialization.
	 * @return the shared Connection (never {@code null})
	 * @throws IllegalStateException if this container does not maintain a
	 * shared Connection, or if the Connection hasn't been initialized yet
	 * @see #sharedConnectionEnabled()
	 */
	/**
	 * 返回此容器维护的共享JMS连接。 
	 * 初始化后可用。 
	 *  
	 * @return 共享的Connection（永远{<@@code> null}）
	 * @throws 如果此容器未维护共享的Connection，或者尚未初始化Connection，则抛出IllegalStateException 
	 * @see  #sharedConnectionEnabled（）
	 */
	protected final Connection getSharedConnection() {
		if (!sharedConnectionEnabled()) {
			throw new IllegalStateException(
					"This listener container does not maintain a shared Connection");
		}
		synchronized (this.sharedConnectionMonitor) {
			if (this.sharedConnection == null) {
				throw new SharedConnectionNotInitializedException(
						"This listener container's shared Connection has not been initialized yet");
			}
			return this.sharedConnection;
		}
	}


	//-------------------------------------------------------------------------
	// Management of paused tasks
	//-------------------------------------------------------------------------

	/**
	 * Take the given task object and reschedule it, either immediately if
	 * this container is currently running, or later once this container
	 * has been restarted.
	 * <p>If this container has already been shut down, the task will not
	 * get rescheduled at all.
	 * @param task the task object to reschedule
	 * @return whether the task has been rescheduled
	 * (either immediately or for a restart of this container)
	 * @see #doRescheduleTask
	 */
	/**
	 * 采取给定的任务对象并重新安排它的时间，如果此容器当前正在运行，则立即重新安排，或者稍后重新启动此容器后，重新安排其时间。 
	 *  <p>如果此容器已被关闭，则该任务将完全不会重新安排。 
	 *  
	 * @param 任务重新计划任务对象
	 * @return 是否已重新计划任务（立即重新计划或重新启动此容器）
	 * @see  #doRescheduleTask
	 */
	protected final boolean rescheduleTaskIfNecessary(Object task) {
		if (this.running) {
			try {
				doRescheduleTask(task);
			}
			catch (RuntimeException ex) {
				logRejectedTask(task, ex);
				this.pausedTasks.add(task);
			}
			return true;
		}
		else if (this.active) {
			this.pausedTasks.add(task);
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * Try to resume all paused tasks.
	 * Tasks for which rescheduling failed simply remain in paused mode.
	 */
	/**
	 * 尝试恢复所有暂停的任务。 
	 * 重新计划失败的任务仅保留在暂停模式下。 
	 * 
	 */
	protected void resumePausedTasks() {
		synchronized (this.lifecycleMonitor) {
			if (!this.pausedTasks.isEmpty()) {
				for (Iterator<?> it = this.pausedTasks.iterator(); it.hasNext();) {
					Object task = it.next();
					try {
						doRescheduleTask(task);
						it.remove();
						if (logger.isDebugEnabled()) {
							logger.debug("Resumed paused task: " + task);
						}
					}
					catch (RuntimeException ex) {
						logRejectedTask(task, ex);
						// Keep the task in paused mode...
					}
				}
			}
		}
	}

	/**
	 * Determine the number of currently paused tasks, if any.
	 */
	/**
	 * 确定当前暂停的任务数（如果有）。 
	 * 
	 */
	public int getPausedTaskCount() {
		synchronized (this.lifecycleMonitor) {
			return this.pausedTasks.size();
		}
	}

	/**
	 * Reschedule the given task object immediately.
	 * <p>To be implemented by subclasses if they ever call
	 * {@code rescheduleTaskIfNecessary}.
	 * This implementation throws an UnsupportedOperationException.
	 * @param task the task object to reschedule
	 * @see #rescheduleTaskIfNecessary
	 */
	/**
	 * 立即重新计划给定的任务对象。 
	 *  <p>如果子类调用{@code  rescheduleTaskIfNecessary}，则由子类实现。 
	 * 此实现引发UnsupportedOperationException。 
	 *  
	 * @param 任务任务对象要重新计划
	 * @see  #rescheduleTaskIfNecessary
	 */
	protected void doRescheduleTask(Object task) {
		throw new UnsupportedOperationException(
				ClassUtils.getShortName(getClass()) + " does not support rescheduling of tasks");
	}

	/**
	 * Log a task that has been rejected by {@link #doRescheduleTask}.
	 * <p>The default implementation simply logs a corresponding message
	 * at debug level.
	 * @param task the rejected task object
	 * @param ex the exception thrown from {@link #doRescheduleTask}
	 */
	/**
	 * 记录已被{@link  #doRescheduleTask}拒绝的任务。 
	 *  <p>默认实现只是在调试级别记录相应的消息。 
	 *  
	 * @param 任务被拒绝的任务对象
	 * @param ，除了从{@link  #doRescheduleTask}引发的异常
	 */
	protected void logRejectedTask(Object task, RuntimeException ex) {
		if (logger.isDebugEnabled()) {
			logger.debug("Listener container task [" + task + "] has been rejected and paused: " + ex);
		}
	}


	//-------------------------------------------------------------------------
	// Template methods to be implemented by subclasses
	//-------------------------------------------------------------------------

	/**
	 * Return whether a shared JMS Connection should be maintained
	 * by this container base class.
	 * @see #getSharedConnection()
	 */
	/**
	 * 返回此容器基类是否应维护共享的JMS连接。 
	 *  
	 * @see  #getSharedConnection（）
	 */
	protected abstract boolean sharedConnectionEnabled();

	/**
	 * Register any invokers within this container.
	 * <p>Subclasses need to implement this method for their specific
	 * invoker management process.
	 * <p>A shared JMS Connection, if any, will already have been
	 * started at this point.
	 * @throws JMSException if registration failed
	 * @see #getSharedConnection()
	 */
	/**
	 * 在此容器中注册所有调用程序。 
	 *  <p>子类需要为其特定的调用程序管理过程实现此方法。 
	 *  <p>此时将已经启动共享的JMS连接（如果有）。 
	 *  
	 * @throws 如果注册失败，则JMSException 
	 * @see  #getSharedConnection（）
	 */
	protected abstract void doInitialize() throws JMSException;

	/**
	 * Close the registered invokers.
	 * <p>Subclasses need to implement this method for their specific
	 * invoker management process.
	 * <p>A shared JMS Connection, if any, will automatically be closed
	 * <i>afterwards</i>.
	 * @throws JMSException if shutdown failed
	 * @see #shutdown()
	 */
	/**
	 * 关闭注册的调用者。 
	 *  <p>子类需要为其特定的调用程序管理过程实现此方法。 
	 *  <p>共享的JMS连接（如果有）将在<i>之后自动关闭</ i>。 
	 *  
	 * @throws 如果关机失败，则JMSException 
	 * @see  #shutdown（）
	 */
	protected abstract void doShutdown() throws JMSException;


	/**
	 * Exception that indicates that the initial setup of this container's
	 * shared JMS Connection failed. This is indicating to invokers that they need
	 * to establish the shared Connection themselves on first access.
	 */
	/**
	 * 异常，指示此容器的共享JMS连接的初始设置失败。 
	 * 这向调用者表明，他们需要在首次访问时自己建立共享的Connection。 
	 * 
	 */
	@SuppressWarnings("serial")
	public static class SharedConnectionNotInitializedException extends RuntimeException {

		/**
		 * Create a new SharedConnectionNotInitializedException.
		 * @param msg the detail message
		 */
		/**
		 * 创建一个新的SharedConnectionNotInitializedException。 
		 *  
		 * @param  msg详细信息
		 */
		protected SharedConnectionNotInitializedException(String msg) {
			super(msg);
		}
	}

}
