/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.listener;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.Session;

import org.springframework.jms.connection.ConnectionFactoryUtils;
import org.springframework.jms.connection.JmsResourceHolder;
import org.springframework.jms.connection.SingleConnectionFactory;
import org.springframework.jms.support.JmsUtils;
import org.springframework.lang.Nullable;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.ResourceTransactionManager;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionSynchronizationUtils;
import org.springframework.util.Assert;

/**
 * Base class for listener container implementations which are based on polling.
 * Provides support for listener handling based on {@link javax.jms.MessageConsumer},
 * optionally participating in externally managed transactions.
 *
 * <p>This listener container variant is built for repeated polling attempts,
 * each invoking the {@link #receiveAndExecute} method. The MessageConsumer used
 * may be reobtained fo reach attempt or cached in between attempts; this is up
 * to the concrete implementation. The receive timeout for each attempt can be
 * configured through the {@link #setReceiveTimeout "receiveTimeout"} property.
 *
 * <p>The underlying mechanism is based on standard JMS MessageConsumer handling,
 * which is perfectly compatible with both native JMS and JMS in a Java EE environment.
 * Neither the JMS {@code MessageConsumer.setMessageListener} facility  nor the JMS
 * ServerSessionPool facility is required. A further advantage of this approach is
 * full control over the listening process, allowing for custom scaling and throttling
 * and of concurrent message processing (which is up to concrete subclasses).
 *
 * <p>Message reception and listener execution can automatically be wrapped
 * in transactions through passing a Spring
 * {@link org.springframework.transaction.PlatformTransactionManager} into the
 * {@link #setTransactionManager "transactionManager"} property. This will usually
 * be a {@link org.springframework.transaction.jta.JtaTransactionManager} in a
 * Java EE environment, in combination with a JTA-aware JMS ConnectionFactory
 * obtained from JNDI (check your application server's documentation).
 *
 * <p>This base class does not assume any specific mechanism for asynchronous
 * execution of polling invokers. Check out {@link DefaultMessageListenerContainer}
 * for a concrete implementation which is based on Spring's
 * {@link org.springframework.core.task.TaskExecutor} abstraction,
 * including dynamic scaling of concurrent consumers and automatic self recovery.
 *
 * @author Juergen Hoeller
 * @since 2.0.3
 * @see #createListenerConsumer
 * @see #receiveAndExecute
 * @see #setTransactionManager
 */
/**
 * 基于轮询的侦听器容器实现的基类。 
 * 提供基于{@link  javax.jms.MessageConsumer}的侦听器处理的支持，可以选择参与外部管理的事务。 
 *  <p>此侦听器容器变体是为重复轮询尝试而构建的，每次尝试都调用{@link  #receiveAndExecute}方法。 
 * 可以在到达尝试后重新获得使用的MessageConsumer或在两次尝试之间将其缓存； 
 * 这取决于具体的实现。 
 * 可以通过{@link  #setReceiveTimeout"receiveTimeout"}属性配置每次尝试的接收超时。 
 *  <p>基础机制基于标准的JMS MessageConsumer处理，该处理与Java EE环境中的本机JMS和JMS完全兼容。 
 * 既不需要JMS {@code  MessageConsumer.setMessageListener}工具，也不需要JMS ServerSessionPool工具。 
 * 这种方法的另一个优点是可以完全控制侦听过程，允许自定义缩放和限制以及并发消息处理（取决于具体的子类）。 
 * 通过将Spring {@link  org.springframework.transaction.PlatformTransactionManager}传递到{@link  #setTransactionManager"transactionManager"}属性中，可以自动将消息接收和侦听器执行包装在事务中。 
 * 在Java EE环境中，它通常是{@link  org.springframework.transaction.jta.JtaTransactionManager}，与从JNDI获得的支持JTA的JMS ConnectionFactory结合使用（请参阅应用程序服务器的文档）。 
 *  <p>此基类不采用任何特定的机制来异步执行轮询调用程序。 
 * 请查看{@link  DefaultMessageListenerContainer}以获得基于Spring的{@link  org.springframework.core.task.TaskExecutor}抽象的具体实现，包括动态缩放并发使用者和自动自我恢复。 
 *  @author  Juergen Hoeller @since 2.0.3 
 * @see  #createListenerConsumer 
 * @see  #receiveAndExecute 
 * @see  #setTransactionManager
 */
public abstract class AbstractPollingMessageListenerContainer extends AbstractMessageListenerContainer {

	/**
	 * The default receive timeout: 1000 ms = 1 second.
	 */
	/**
	 * 默认的接收超时：1000 ms = 1秒。 
	 * 
	 */
	public static final long DEFAULT_RECEIVE_TIMEOUT = 1000;


	private final MessageListenerContainerResourceFactory transactionalResourceFactory =
			new MessageListenerContainerResourceFactory();

	private boolean sessionTransactedCalled = false;

	@Nullable
	private PlatformTransactionManager transactionManager;

	private DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();

	private long receiveTimeout = DEFAULT_RECEIVE_TIMEOUT;


	@Override
	public void setSessionTransacted(boolean sessionTransacted) {
		super.setSessionTransacted(sessionTransacted);
		this.sessionTransactedCalled = true;
	}

	/**
	 * Specify the Spring {@link org.springframework.transaction.PlatformTransactionManager}
	 * to use for transactional wrapping of message reception plus listener execution.
	 * <p>Default is none, not performing any transactional wrapping.
	 * If specified, this will usually be a Spring
	 * {@link org.springframework.transaction.jta.JtaTransactionManager} or one
	 * of its subclasses, in combination with a JTA-aware ConnectionFactory that
	 * this message listener container obtains its Connections from.
	 * <p><b>Note: Consider the use of local JMS transactions instead.</b>
	 * Simply switch the {@link #setSessionTransacted "sessionTransacted"} flag
	 * to "true" in order to use a locally transacted JMS Session for the entire
	 * receive processing, including any Session operations performed by a
	 * {@link SessionAwareMessageListener} (e.g. sending a response message). This
	 * allows for fully synchronized Spring transactions based on local JMS
	 * transactions, similar to what
	 * {@link org.springframework.jms.connection.JmsTransactionManager} provides. Check
	 * {@link AbstractMessageListenerContainer}'s javadoc for
	 * a discussion of transaction choices and message redelivery scenarios.
	 * @see #setSessionTransacted(boolean)
	 * @see org.springframework.transaction.jta.JtaTransactionManager
	 * @see org.springframework.jms.connection.JmsTransactionManager
	 */
	/**
	 * 指定Spring {@link  org.springframework.transaction.PlatformTransactionManager}以用于消息接收和侦听器执行的事务包装。 
	 *  <p>默认为无，不执行任何事务包装。 
	 * 如果指定，则通常是Spring {@link  org.springframework.transaction.jta.JtaTransactionManager}或其子类之一，再加上JTA感知的ConnectionFactory，此消息侦听器容器可从中获取其Connections。 
	 *  <p> <b>注意：请考虑使用本地JMS事务。 
	 * </ b>只需将{@link  #setSessionTransacted"sessionTransacted"}标志设置为"true"，即可将本地事务处理的JMS会话用于整个接收过程，包括{{@link> SessionAwareMessageListener}执行的任何Session操作（例如，发送响应消息）。 
	 * 这允许基于本地JMS事务的完全同步的Spring事务，类似于{@link  org.springframework.jms.connection.JmsTransactionManager}提供的事务。 
	 * 查看{@link  AbstractMessageListenerContainer}的javadoc，以获取有关事务选择和消息重新交付场景的讨论。 
	 *  
	 * @see  #setSessionTransacted（boolean）
	 * @see  org.springframework.transaction.jta.JtaTransactionManager 
	 * @see  org.springframework.jms.connection.JmsTransactionManager
	 */
	public void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {
		this.transactionManager = transactionManager;
	}

	/**
	 * Return the Spring PlatformTransactionManager to use for transactional
	 * wrapping of message reception plus listener execution.
	 */
	/**
	 * 返回Spring PlatformTransactionManager以用于消息接收和侦听器执行的事务包装。 
	 * 
	 */
	@Nullable
	protected final PlatformTransactionManager getTransactionManager() {
		return this.transactionManager;
	}

	/**
	 * Specify the transaction name to use for transactional wrapping.
	 * Default is the bean name of this listener container, if any.
	 * @see org.springframework.transaction.TransactionDefinition#getName()
	 */
	/**
	 * 指定用于事务包装的事务名称。 
	 * 默认值为此侦听器容器的Bean名称（如果有）。 
	 *  
	 * @see  org.springframework.transaction.TransactionDefinition＃getName（）
	 */
	public void setTransactionName(String transactionName) {
		this.transactionDefinition.setName(transactionName);
	}

	/**
	 * Specify the transaction timeout to use for transactional wrapping, in <b>seconds</b>.
	 * Default is none, using the transaction manager's default timeout.
	 * @see org.springframework.transaction.TransactionDefinition#getTimeout()
	 * @see #setReceiveTimeout
	 */
	/**
	 * 指定用于事务包装的事务超时，以<b>秒</ b>为单位。 
	 * 默认值为无，使用事务管理器的默认超时。 
	 *  
	 * @see  org.springframework.transaction.TransactionDefinition＃getTimeout（）
	 * @see  #setReceiveTimeout
	 */
	public void setTransactionTimeout(int transactionTimeout) {
		this.transactionDefinition.setTimeout(transactionTimeout);
	}

	/**
	 * Set the timeout to use for receive calls, in <b>milliseconds</b>.
	 * The default is 1000 ms, that is, 1 second.
	 * <p><b>NOTE:</b> This value needs to be smaller than the transaction
	 * timeout used by the transaction manager (in the appropriate unit,
	 * of course). 0 indicates no timeout at all; however, this is only
	 * feasible if not running within a transaction manager and generally
	 * discouraged since such a listener container cannot cleanly shut down.
	 * A negative value such as -1 indicates a no-wait receive operation.
	 * @see #receiveFromConsumer(MessageConsumer, long)
	 * @see javax.jms.MessageConsumer#receive(long)
	 * @see javax.jms.MessageConsumer#receiveNoWait()
	 * @see javax.jms.MessageConsumer#receive()
	 * @see #setTransactionTimeout
	 */
	/**
	 * 设置用于接听电话的超时时间，以<b>毫秒</ b>为单位。 
	 * 缺省值为1000毫秒，即1秒。 
	 *  <p> <b>注意：</ b>该值必须小于事务管理器使用的事务超时（当然，以适当的单位为单位）。 
	 *  0表示完全没有超时； 
	 * 但是，只有在不运行在事务管理器中并且通常不鼓励这样做的情况下，这才是可行的，因为这样的侦听器容器无法彻底关闭。 
	 * 负数（例如-1）表示无等待接收操作。 
	 *  
	 * @see  #receiveFromConsumer（MessageConsumer，长）
	 * @see  javax.jms.MessageConsumer＃receive（长）
	 * @see  javax.jms.MessageConsumer＃receiveNoWait（）
	 * @see  javax.jms.MessageConsumer＃receive（ ）
	 * @see  #setTransactionTimeout
	 */
	public void setReceiveTimeout(long receiveTimeout) {
		this.receiveTimeout = receiveTimeout;
	}

	/**
	 * Return the receive timeout (ms) configured for this listener container.
	 * @since 4.2
	 */
	/**
	 * 返回为此侦听器容器配置的接收超时（毫秒）。 
	 *  @4.2起
	 */
	protected long getReceiveTimeout() {
		return this.receiveTimeout;
	}


	@Override
	public void initialize() {
		// Set sessionTransacted=true in case of a non-JTA transaction manager.
		if (!this.sessionTransactedCalled &&
				this.transactionManager instanceof ResourceTransactionManager &&
				!TransactionSynchronizationUtils.sameResourceFactory(
						(ResourceTransactionManager) this.transactionManager, obtainConnectionFactory())) {
			super.setSessionTransacted(true);
		}

		// Use bean name as default transaction name.
		if (this.transactionDefinition.getName() == null) {
			String beanName = getBeanName();
			if (beanName != null) {
				this.transactionDefinition.setName(beanName);
			}
		}

		// Proceed with superclass initialization.
		super.initialize();
	}


	/**
	 * Create a MessageConsumer for the given JMS Session,
	 * registering a MessageListener for the specified listener.
	 * @param session the JMS Session to work on
	 * @return the MessageConsumer
	 * @throws javax.jms.JMSException if thrown by JMS methods
	 * @see #receiveAndExecute
	 */
	/**
	 * 为给定的JMS会话创建一个MessageConsumer，为指定的侦听器注册一个MessageListener。 
	 *  
	 * @param 会话要在
	 * @return  MessageConsumer 
	 * @throws  javax.jms.JMSException上工作的JMS会话，如果被JMS方法抛出
	 * @see  #receiveAndExecute
	 */
	protected MessageConsumer createListenerConsumer(Session session) throws JMSException {
		Destination destination = getDestination();
		if (destination == null) {
			String destinationName = getDestinationName();
			Assert.state(destinationName != null, "No destination set");
			destination = resolveDestinationName(session, destinationName);
		}
		return createConsumer(session, destination);
	}

	/**
	 * Execute the listener for a message received from the given consumer,
	 * wrapping the entire operation in an external transaction if demanded.
	 * @param session the JMS Session to work on
	 * @param consumer the MessageConsumer to work on
	 * @return whether a message has been received
	 * @throws JMSException if thrown by JMS methods
	 * @see #doReceiveAndExecute
	 */
	/**
	 * 对从给定使用者接收到的消息执行侦听器，如果需要，将整个操作包装在外部事务中。 
	 *  
	 * @param 会话要在
	 * @param 上使用的JMS会话使用者要在
	 * @return 上使用的MessageConsumer进行操作<
	 * @returns>是否已被JMS方法抛出的JMSException 
	 * @see  #doReceiveAndExecute
	 */
	protected boolean receiveAndExecute(
			Object invoker, @Nullable Session session, @Nullable MessageConsumer consumer)
			throws JMSException {

		if (this.transactionManager != null) {
			// Execute receive within transaction.
			TransactionStatus status = this.transactionManager.getTransaction(this.transactionDefinition);
			boolean messageReceived;
			try {
				messageReceived = doReceiveAndExecute(invoker, session, consumer, status);
			}
			catch (JMSException | RuntimeException | Error ex) {
				rollbackOnException(this.transactionManager, status, ex);
				throw ex;
			}
			this.transactionManager.commit(status);
			return messageReceived;
		}

		else {
			// Execute receive outside of transaction.
			return doReceiveAndExecute(invoker, session, consumer, null);
		}
	}

	/**
	 * Actually execute the listener for a message received from the given consumer,
	 * fetching all requires resources and invoking the listener.
	 * @param session the JMS Session to work on
	 * @param consumer the MessageConsumer to work on
	 * @param status the TransactionStatus (may be {@code null})
	 * @return whether a message has been received
	 * @throws JMSException if thrown by JMS methods
	 * @see #doExecuteListener(javax.jms.Session, javax.jms.Message)
	 */
	/**
	 * 实际上是为从给定使用者接收到的消息执行侦听器，获取所有消息都需要资源并调用侦听器。 
	 *  
	 * @param 会话JMS会话要在
	 * @param 消费者上工作，而MessageConsumer则要在
	 * @param 状态下工作，TransactionStatus（可能为{@code  null}）
	 * @return 是否已收到消息
	 * @throws 如果由JMS方法抛出，则抛出JMSException 
	 * @see  #doExecuteListener（javax.jms.Session，javax.jms.Message）
	 */
	protected boolean doReceiveAndExecute(Object invoker, @Nullable Session session,
			@Nullable MessageConsumer consumer, @Nullable TransactionStatus status) throws JMSException {

		Connection conToClose = null;
		Session sessionToClose = null;
		MessageConsumer consumerToClose = null;
		try {
			Session sessionToUse = session;
			boolean transactional = false;
			if (sessionToUse == null) {
				sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(
						obtainConnectionFactory(), this.transactionalResourceFactory, true);
				transactional = (sessionToUse != null);
			}
			if (sessionToUse == null) {
				Connection conToUse;
				if (sharedConnectionEnabled()) {
					conToUse = getSharedConnection();
				}
				else {
					conToUse = createConnection();
					conToClose = conToUse;
					conToUse.start();
				}
				sessionToUse = createSession(conToUse);
				sessionToClose = sessionToUse;
			}
			MessageConsumer consumerToUse = consumer;
			if (consumerToUse == null) {
				consumerToUse = createListenerConsumer(sessionToUse);
				consumerToClose = consumerToUse;
			}
			Message message = receiveMessage(consumerToUse);
			if (message != null) {
				if (logger.isDebugEnabled()) {
					logger.debug("Received message of type [" + message.getClass() + "] from consumer [" +
							consumerToUse + "] of " + (transactional ? "transactional " : "") + "session [" +
							sessionToUse + "]");
				}
				messageReceived(invoker, sessionToUse);
				boolean exposeResource = (!transactional && isExposeListenerSession() &&
						!TransactionSynchronizationManager.hasResource(obtainConnectionFactory()));
				if (exposeResource) {
					TransactionSynchronizationManager.bindResource(
							obtainConnectionFactory(), new LocallyExposedJmsResourceHolder(sessionToUse));
				}
				try {
					doExecuteListener(sessionToUse, message);
				}
				catch (Throwable ex) {
					if (status != null) {
						if (logger.isDebugEnabled()) {
							logger.debug("Rolling back transaction because of listener exception thrown: " + ex);
						}
						status.setRollbackOnly();
					}
					handleListenerException(ex);
					// Rethrow JMSException to indicate an infrastructure problem
					// that may have to trigger recovery...
					if (ex instanceof JMSException) {
						throw (JMSException) ex;
					}
				}
				finally {
					if (exposeResource) {
						TransactionSynchronizationManager.unbindResource(obtainConnectionFactory());
					}
				}
				// Indicate that a message has been received.
				return true;
			}
			else {
				if (logger.isTraceEnabled()) {
					logger.trace("Consumer [" + consumerToUse + "] of " + (transactional ? "transactional " : "") +
							"session [" + sessionToUse + "] did not receive a message");
				}
				noMessageReceived(invoker, sessionToUse);
				// Nevertheless call commit, in order to reset the transaction timeout (if any).
				if (shouldCommitAfterNoMessageReceived(sessionToUse)) {
					commitIfNecessary(sessionToUse, null);
				}
				// Indicate that no message has been received.
				return false;
			}
		}
		finally {
			JmsUtils.closeMessageConsumer(consumerToClose);
			JmsUtils.closeSession(sessionToClose);
			ConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), true);
		}
	}

	/**
	 * This implementation checks whether the Session is externally synchronized.
	 * In this case, the Session is not locally transacted, despite the listener
	 * container's "sessionTransacted" flag being set to "true".
	 * @see org.springframework.jms.connection.JmsResourceHolder
	 */
	/**
	 * 此实现检查Session是否在外部同步。 
	 * 在这种情况下，即使将侦听器容器的"sessionTransacted"标志设置为"true"，也不会在本地进行Session事务处理。 
	 *  
	 * @see  org.springframework.jms.connection.JmsResourceHolder
	 */
	@Override
	protected boolean isSessionLocallyTransacted(Session session) {
		if (!super.isSessionLocallyTransacted(session)) {
			return false;
		}
		JmsResourceHolder resourceHolder =
				(JmsResourceHolder) TransactionSynchronizationManager.getResource(obtainConnectionFactory());
		return (resourceHolder == null || resourceHolder instanceof LocallyExposedJmsResourceHolder ||
				!resourceHolder.containsSession(session));
	}

	/**
	 * Determine whether to trigger a commit after no message has been received.
	 * This is a good idea on any modern-day JMS provider.
	 * @param session the current JMS Session which received no message
	 * @return whether to call {@link #commitIfNecessary} on the given Session
	 */
	/**
	 * 确定在未收到任何消息后是否触发提交。 
	 * 这对任何现代JMS提供程序都是一个好主意。 
	 *  
	 * @param 会话当前未收到消息的JMS会话
	 * @return 是否在给定会话上调用{@link  #commitIfNecessary}
	 */
	protected boolean shouldCommitAfterNoMessageReceived(Session session) {
		return true;
	}

	/**
	 * Perform a rollback, handling rollback exceptions properly.
	 * @param status object representing the transaction
	 * @param ex the thrown listener exception or error
	 */
	/**
	 * 执行回滚，正确处理回滚异常。 
	 * 表示事务
	 * @param 的
	 * @param 状态对象，例如抛出的侦听器异常或错误
	 */
	private void rollbackOnException(PlatformTransactionManager manager, TransactionStatus status, Throwable ex) {
		logger.debug("Initiating transaction rollback on listener exception", ex);
		try {
			manager.rollback(status);
		}
		catch (RuntimeException ex2) {
			logger.error("Listener exception overridden by rollback exception", ex);
			throw ex2;
		}
		catch (Error err) {
			logger.error("Listener exception overridden by rollback error", ex);
			throw err;
		}
	}

	/**
	 * Receive a message from the given consumer.
	 * @param consumer the MessageConsumer to use
	 * @return the Message, or {@code null} if none
	 * @throws JMSException if thrown by JMS methods
	 */
	/**
	 * 接收来自给定消费者的消息。 
	 *  
	 * @param 消费MessageConsumer以使用
	 * @return 消息，如果没有，则{@code  null} 
	 * @throws  JMSException（如果由JMS方法抛出）
	 */
	@Nullable
	protected Message receiveMessage(MessageConsumer consumer) throws JMSException {
		return receiveFromConsumer(consumer, getReceiveTimeout());
	}

	/**
	 * Template method that gets called right when a new message has been received,
	 * before attempting to process it. Allows subclasses to react to the event
	 * of an actual incoming message, for example adapting their consumer count.
	 * @param invoker the invoker object (passed through)
	 * @param session the receiving JMS Session
	 */
	/**
	 * 收到新消息后立即尝试调用的模板方法，然后尝试对其进行处理。 
	 * 允许子类对实际传入消息的事件做出反应，例如调整其使用者数量。 
	 *  
	 * @param 调用者调用者对象（通过）
	 * @param 会话接收JMS会话
	 */
	protected void messageReceived(Object invoker, Session session) {
	}

	/**
	 * Template method that gets called when <i>no</i> message has been received,
	 * before returning to the receive loop again. Allows subclasses to react to
	 * the event of no incoming message, for example marking the invoker as idle.
	 * @param invoker the invoker object (passed through)
	 * @param session the receiving JMS Session
	 */
	/**
	 * 在没有收到<i> no </ i>消息时调用的模板方法，然后再次返回到接收循环。 
	 * 允许子类对没有传入消息的事件做出反应，例如将调用者标记为空闲。 
	 *  
	 * @param 调用者调用者对象（通过）
	 * @param 会话接收JMS会话
	 */
	protected void noMessageReceived(Object invoker, Session session) {
	}

	/**
	 * Fetch an appropriate Connection from the given JmsResourceHolder.
	 * <p>This implementation accepts any JMS 1.1 Connection.
	 * @param holder the JmsResourceHolder
	 * @return an appropriate Connection fetched from the holder,
	 * or {@code null} if none found
	 */
	/**
	 * 从给定的JmsResourceHolder中获取适当的Connection。 
	 *  <p>此实现接受任何JMS 1.1连接。 
	 *  
	 * @param 持有人JmsResourceHolder 
	 * @return 从持有人获取的适当连接； 
	 * 如果找不到，则为{@code  null}
	 */
	@Nullable
	protected Connection getConnection(JmsResourceHolder holder) {
		return holder.getConnection();
	}

	/**
	 * Fetch an appropriate Session from the given JmsResourceHolder.
	 * <p>This implementation accepts any JMS 1.1 Session.
	 * @param holder the JmsResourceHolder
	 * @return an appropriate Session fetched from the holder,
	 * or {@code null} if none found
	 */
	/**
	 * 从给定的JmsResourceHolder中获取适当的会话。 
	 *  <p>此实现接受任何JMS 1.1会话。 
	 *  
	 * @param 持有人JmsResourceHolder 
	 * @return 从持有人获取的适当会话，如果找不到，则为{@code  null}
	 */
	@Nullable
	protected Session getSession(JmsResourceHolder holder) {
		return holder.getSession();
	}


	/**
	 * ResourceFactory implementation that delegates to this listener container's protected callback methods.
	 */
	/**
	 * 委派给此侦听器容器的受保护回调方法的ResourceFactory实现。 
	 * 
	 */
	private class MessageListenerContainerResourceFactory implements ConnectionFactoryUtils.ResourceFactory {

		@Override
		@Nullable
		public Connection getConnection(JmsResourceHolder holder) {
			return AbstractPollingMessageListenerContainer.this.getConnection(holder);
		}

		@Override
		@Nullable
		public Session getSession(JmsResourceHolder holder) {
			return AbstractPollingMessageListenerContainer.this.getSession(holder);
		}

		@Override
		public Connection createConnection() throws JMSException {
			if (AbstractPollingMessageListenerContainer.this.sharedConnectionEnabled()) {
				Connection sharedCon = AbstractPollingMessageListenerContainer.this.getSharedConnection();
				return new SingleConnectionFactory(sharedCon).createConnection();
			}
			else {
				return AbstractPollingMessageListenerContainer.this.createConnection();
			}
		}

		@Override
		public Session createSession(Connection con) throws JMSException {
			return AbstractPollingMessageListenerContainer.this.createSession(con);
		}

		@Override
		public boolean isSynchedLocalTransactionAllowed() {
			return AbstractPollingMessageListenerContainer.this.isSessionTransacted();
		}
	}

}
