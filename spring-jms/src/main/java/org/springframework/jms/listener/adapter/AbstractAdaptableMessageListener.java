/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2018的原始作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.listener.adapter;

import javax.jms.BytesMessage;
import javax.jms.Destination;
import javax.jms.InvalidDestinationException;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.MessageProducer;
import javax.jms.Session;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.jms.listener.SessionAwareMessageListener;
import org.springframework.jms.support.JmsHeaderMapper;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.QosSettings;
import org.springframework.jms.support.SimpleJmsHeaderMapper;
import org.springframework.jms.support.converter.MessageConversionException;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessagingMessageConverter;
import org.springframework.jms.support.converter.SimpleMessageConverter;
import org.springframework.jms.support.converter.SmartMessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.jms.support.destination.DynamicDestinationResolver;
import org.springframework.lang.Nullable;
import org.springframework.messaging.MessageHeaders;
import org.springframework.util.Assert;

/**
 * An abstract JMS {@link MessageListener} adapter providing the necessary
 * infrastructure to extract the payload of a JMS {@link Message}.
 *
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 4.1
 * @see MessageListener
 * @see SessionAwareMessageListener
 */
/**
 * 抽象的JMS {@link  MessageListener}适配器，提供了提取JMS {@link  Message}的有效负载所必需的基础结构。 
 *  @author  Juergen Hoeller @author  Stephane Nicoll @始于4.1 
 * @see  MessageListener 
 * @see  SessionAwareMessageListener
 */
public abstract class AbstractAdaptableMessageListener
		implements MessageListener, SessionAwareMessageListener<Message> {

	/** Logger available to subclasses. */
	/**
	 * 记录器可用于子类。 
	 * 
	 */
	protected final Log logger = LogFactory.getLog(getClass());

	@Nullable
	private Object defaultResponseDestination;

	private DestinationResolver destinationResolver = new DynamicDestinationResolver();

	@Nullable
	private MessageConverter messageConverter = new SimpleMessageConverter();

	private final MessagingMessageConverterAdapter messagingMessageConverter = new MessagingMessageConverterAdapter();

	@Nullable
	private QosSettings responseQosSettings;


	/**
	 * Set the default destination to send response messages to. This will be applied
	 * in case of a request message that does not carry a "JMSReplyTo" field.
	 * <p>Response destinations are only relevant for listener methods that return
	 * result objects, which will be wrapped in a response message and sent to a
	 * response destination.
	 * <p>Alternatively, specify a "defaultResponseQueueName" or "defaultResponseTopicName",
	 * to be dynamically resolved via the DestinationResolver.
	 * @see #setDefaultResponseQueueName(String)
	 * @see #setDefaultResponseTopicName(String)
	 * @see #getResponseDestination
	 */
	/**
	 * 设置发送响应消息的默认目的地。 
	 * 如果请求消息中不包含"JMSReplyTo"字段，则将应用此方法。 
	 *  <p>响应目标仅与返回结果对象的侦听器方法相关，该结果对象将包装在响应消息中并发送到响应目标。 
	 *  <p>或者，指定要通过DestinationResolver动态解析的"defaultResponseQueueName"或"defaultResponseTopicName"。 
	 *  
	 * @see  #setDefaultResponseQueueName（String）
	 * @see  #setDefaultResponseTopicName（String）
	 * @see  #getResponseDestination
	 */
	public void setDefaultResponseDestination(Destination destination) {
		this.defaultResponseDestination = destination;
	}

	/**
	 * Set the name of the default response queue to send response messages to.
	 * This will be applied in case of a request message that does not carry a
	 * "JMSReplyTo" field.
	 * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".
	 * @see #setDestinationResolver
	 * @see #setDefaultResponseDestination(javax.jms.Destination)
	 */
	/**
	 * 设置要将响应消息发送到的默认响应队列的名称。 
	 * 如果请求消息中不包含"JMSReplyTo"字段，则将应用此方法。 
	 *  <p>或者，将JMS目标对象指定为"defaultResponseDestination"。 
	 *  
	 * @see  #setDestinationResolver 
	 * @see  #setDefaultResponseDestination（javax.jms.Destination）
	 */
	public void setDefaultResponseQueueName(String destinationName) {
		this.defaultResponseDestination = new DestinationNameHolder(destinationName, false);
	}

	/**
	 * Set the name of the default response topic to send response messages to.
	 * This will be applied in case of a request message that does not carry a
	 * "JMSReplyTo" field.
	 * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".
	 * @see #setDestinationResolver
	 * @see #setDefaultResponseDestination(javax.jms.Destination)
	 */
	/**
	 * 设置要将响应消息发送到的默认响应主题的名称。 
	 * 如果请求消息中不包含"JMSReplyTo"字段，则将应用此方法。 
	 *  <p>或者，将JMS目标对象指定为"defaultResponseDestination"。 
	 *  
	 * @see  #setDestinationResolver 
	 * @see  #setDefaultResponseDestination（javax.jms.Destination）
	 */
	public void setDefaultResponseTopicName(String destinationName) {
		this.defaultResponseDestination = new DestinationNameHolder(destinationName, true);
	}

	/**
	 * Set the DestinationResolver that should be used to resolve response
	 * destination names for this adapter.
	 * <p>The default resolver is a DynamicDestinationResolver. Specify a
	 * JndiDestinationResolver for resolving destination names as JNDI locations.
	 * @see org.springframework.jms.support.destination.DynamicDestinationResolver
	 * @see org.springframework.jms.support.destination.JndiDestinationResolver
	 */
	/**
	 * 设置用于解析此适配器的响应目标名称的DestinationResolver。 
	 *  <p>默认解析器是DynamicDestinationResolver。 
	 * 指定一个JndiDestinationResolver以便将目标名称解析为JNDI位置。 
	 *  
	 * @see  org.springframework.jms.support.destination.DynamicDestinationResolver 
	 * @see  org.springframework.jms.support.destination.JndiDestinationResolver
	 */
	public void setDestinationResolver(DestinationResolver destinationResolver) {
		Assert.notNull(destinationResolver, "DestinationResolver must not be null");
		this.destinationResolver = destinationResolver;
	}

	/**
	 * Return the DestinationResolver for this adapter.
	 */
	/**
	 * 返回此适配器的DestinationResolver。 
	 * 
	 */
	protected DestinationResolver getDestinationResolver() {
		return this.destinationResolver;
	}

	/**
	 * Set the converter that will convert incoming JMS messages to
	 * listener method arguments, and objects returned from listener
	 * methods back to JMS messages.
	 * <p>The default converter is a {@link SimpleMessageConverter}, which is able
	 * to handle {@link javax.jms.BytesMessage BytesMessages},
	 * {@link javax.jms.TextMessage TextMessages} and
	 * {@link javax.jms.ObjectMessage ObjectMessages}.
	 */
	/**
	 * 设置转换器，以将传入的JMS消息转换为侦听器方法参数，并将从侦听器方法返回的对象转换回JMS消息。 
	 *  <p>默认转换器是{@link  SimpleMessageConverter}，它能够处理{@link  javax.jms.BytesMessage BytesMessages}，{<@link> javax.jms.TextMessage TextMessages}和{<@链接> javax.jms.ObjectMessage ObjectMessages}。 
	 * 
	 */
	public void setMessageConverter(@Nullable MessageConverter messageConverter) {
		this.messageConverter = messageConverter;
	}

	/**
	 * Return the converter that will convert incoming JMS messages to
	 * listener method arguments, and objects returned from listener
	 * methods back to JMS messages.
	 */
	/**
	 * 返回将输入的JMS消息转换为侦听器方法参数的转换器，并将从侦听器方法返回的对象转换回JMS消息。 
	 * 
	 */
	@Nullable
	protected MessageConverter getMessageConverter() {
		return this.messageConverter;
	}

	/**
	 * Set the {@link JmsHeaderMapper} implementation to use to map the standard
	 * JMS headers. By default, a {@link SimpleJmsHeaderMapper} is used.
	 * @see SimpleJmsHeaderMapper
	 */
	/**
	 * 设置{@link  JmsHeaderMapper}实现以用于映射标准JMS标头。 
	 * 默认情况下，使用{@link  SimpleJmsHeaderMapper}。 
	 *  
	 * @see  SimpleJmsHeaderMapper
	 */
	public void setHeaderMapper(JmsHeaderMapper headerMapper) {
		Assert.notNull(headerMapper, "HeaderMapper must not be null");
		this.messagingMessageConverter.setHeaderMapper(headerMapper);
	}

	/**
	 * Return the {@link MessagingMessageConverter} for this listener,
	 * being able to convert {@link org.springframework.messaging.Message}.
	 */
	/**
	 * 返回此侦听器的{@link  MessagingMessageConverter}，可以转换{@link  org.springframework.messaging.Message}。 
	 * 
	 */
	protected final MessagingMessageConverter getMessagingMessageConverter() {
		return this.messagingMessageConverter;
	}

	/**
	 * Set the {@link QosSettings} to use when sending a response. Can be set to
	 * {@code null} to indicate that the broker's defaults should be used.
	 * @param responseQosSettings the QoS settings to use when sending a response or
	 * {@code null} to use the default values.
	 * @since 5.0
	 */
	/**
	 * 设置{@link  QosSettings}以在发送响应时使用。 
	 * 可以设置为{@code  null}以指示应该使用代理的默认值。 
	 *  
	 * @param  responseQos设置发送响应时使用的QoS设置，或{@code  null}使用默认值。 
	 *  @5.0起
	 */
	public void setResponseQosSettings(@Nullable QosSettings responseQosSettings) {
		this.responseQosSettings = responseQosSettings;
	}

	/**
	 * Return the {@link QosSettings} to use when sending a response,
	 * or {@code null} if the defaults should be used.
	 * @since 5.0
	 */
	/**
	 * 返回{@link  QosSettings}以在发送响应时使用； 
	 * 如果应使用默认值，则返回{@code  null}。 
	 *  @5.0起
	 */
	@Nullable
	protected QosSettings getResponseQosSettings() {
		return this.responseQosSettings;
	}


	/**
	 * Standard JMS {@link MessageListener} entry point.
	 * <p>Delegates the message to the target listener method, with appropriate
	 * conversion of the message argument. In case of an exception, the
	 * {@link #handleListenerException(Throwable)} method will be invoked.
	 * <p><b>Note:</b> Does not support sending response messages based on
	 * result objects returned from listener methods. Use the
	 * {@link SessionAwareMessageListener} entry point (typically through a Spring
	 * message listener container) for handling result objects as well.
	 * @param message the incoming JMS message
	 * @see #handleListenerException
	 * @see #onMessage(javax.jms.Message, javax.jms.Session)
	 */
	/**
	 * 标准JMS {@link  MessageListener}入口点。 
	 *  <p>将消息委托给目标侦听器方法，并适当地转换message参数。 
	 * 如果发生异常，将调用{@link  #handleListenerException（Throwable）}方法。 
	 *  <p> <b>注意：</ b>不支持基于从侦听器方法返回的结果对象发送响应消息。 
	 * 也可以使用{@link  SessionAwareMessageListener}入口点（通常通过Spring消息侦听器容器）来处理结果对象。 
	 *  
	 * @param 消息传入的JMS消息
	 * @see  #handleListenerException 
	 * @see  #onMessage（javax.jms.Message，javax.jms.Session）
	 */
	@Override
	public void onMessage(Message message) {
		try {
			onMessage(message, null);
		}
		catch (Throwable ex) {
			handleListenerException(ex);
		}
	}

	@Override
	public abstract void onMessage(Message message, @Nullable Session session) throws JMSException;

	/**
	 * Handle the given exception that arose during listener execution.
	 * The default implementation logs the exception at error level.
	 * <p>This method only applies when used as standard JMS {@link MessageListener}.
	 * In case of the Spring {@link SessionAwareMessageListener} mechanism,
	 * exceptions get handled by the caller instead.
	 * @param ex the exception to handle
	 * @see #onMessage(javax.jms.Message)
	 */
	/**
	 * 处理在侦听器执行期间出现的给定异常。 
	 * 默认实现将异常记录在错误级别。 
	 *  <p>仅当用作标准JMS {@link  MessageListener}时，此方法才适用。 
	 * 对于Spring {@link  SessionAwareMessageListener}机制，异常将由调用方处理。 
	 *  
	 * @param 异常处理
	 * @see  #onMessage（javax.jms.Message）
	 */
	protected void handleListenerException(Throwable ex) {
		logger.error("Listener execution failed", ex);
	}


	/**
	 * Extract the message body from the given JMS message.
	 * @param message the JMS {@code Message}
	 * @return the content of the message, to be passed into the listener method
	 * as an argument
	 * @throws MessageConversionException if the message could not be extracted
	 */
	/**
	 * 从给定的JMS消息中提取消息正文。 
	 *  
	 * @param 消息JMS {@code 消息} 
	 * @return 消息的内容，如果不能提取消息，则将其作为参数传递给侦听器方法
	 * @throws  MessageConversionException
	 */
	protected Object extractMessage(Message message)  {
		try {
			MessageConverter converter = getMessageConverter();
			if (converter != null) {
				return converter.fromMessage(message);
			}
			return message;
		}
		catch (JMSException ex) {
			throw new MessageConversionException("Could not convert JMS message", ex);
		}
	}

	/**
	 * Handle the given result object returned from the listener method,
	 * sending a response message back.
	 * @param result the result object to handle (never {@code null})
	 * @param request the original request message
	 * @param session the JMS Session to operate on (may be {@code null})
	 * @throws ReplyFailureException if the response message could not be sent
	 * @see #buildMessage
	 * @see #postProcessResponse
	 * @see #getResponseDestination
	 * @see #sendResponse
	 */
	/**
	 * 处理从侦听器方法返回的给定结果对象，并发送回响应消息。 
	 *  
	 * @param 结果结果对象要处理（永远不{@code  null}）
	 * @param 请求原始请求消息
	 * @param 会话，JMS会话将在此会话上进行操作（可能为{@code  null} ）
	 * @throws  ReplyFailureException如果无法发送响应消息
	 * @see  #buildMessage 
	 * @see  #postProcessResponse 
	 * @see  #getResponseDestination 
	 * @see  #sendResponse
	 */
	protected void handleResult(Object result, Message request, @Nullable Session session) {
		if (session != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Listener method returned result [" + result +
						"] - generating response message for it");
			}
			try {
				Message response = buildMessage(session, result);
				postProcessResponse(request, response);
				Destination destination = getResponseDestination(request, response, session, result);
				sendResponse(session, destination, response);
			}
			catch (Exception ex) {
				throw new ReplyFailureException("Failed to send reply with payload [" + result + "]", ex);
			}
		}

		else {
			// No JMS Session available
			if (logger.isWarnEnabled()) {
				logger.warn("Listener method returned result [" + result +
						"]: not generating response message for it because of no JMS Session given");
			}
		}
	}

	/**
	 * Build a JMS message to be sent as response based on the given result object.
	 * @param session the JMS Session to operate on
	 * @param result the content of the message, as returned from the listener method
	 * @return the JMS {@code Message} (never {@code null})
	 * @throws JMSException if thrown by JMS API methods
	 * @see #setMessageConverter
	 */
	/**
	 * 根据给定的结果对象构建一个JMS消息作为响应发送。 
	 *  
	 * @param 会话要在
	 * @param 上进行操作的JMS会话会产生消息的内容，该内容是从侦听器方法
	 * @return  JMS {@code 消息}返回的（永远不会{@code  null} ）
	 * @throws  JMSException，如果由JMS API方法抛出
	 * @see  #setMessageConverter
	 */
	protected Message buildMessage(Session session, Object result) throws JMSException {
		Object content = preProcessResponse(result instanceof JmsResponse
				? ((JmsResponse<?>) result).getResponse() : result);

		MessageConverter converter = getMessageConverter();
		if (converter != null) {
			if (content instanceof org.springframework.messaging.Message) {
				return this.messagingMessageConverter.toMessage(content, session);
			}
			else {
				return converter.toMessage(content, session);
			}
		}

		if (!(content instanceof Message)) {
			throw new MessageConversionException(
					"No MessageConverter specified - cannot handle message [" + content + "]");
		}
		return (Message) content;
	}

	/**
	 * Pre-process the given result before it is converted to a {@link Message}.
	 * @param result the result of the invocation
	 * @return the payload response to handle, either the {@code result} argument
	 * or any other object (for instance wrapping the result).
	 * @since 4.3
	 */
	/**
	 * 在将给定结果转换为{@link 消息}之前对其进行预处理。 
	 *  
	 * @param 会导致调用的结果
	 * @return 要处理的有效负载响应，可以是{@code  result}参数，也可以是任何其他对象（例如，包装结果）。 
	 *  @4.3起
	 */
	protected Object preProcessResponse(Object result) {
		return result;
	}

	/**
	 * Post-process the given response message before it will be sent.
	 * <p>The default implementation sets the response's correlation id
	 * to the request message's correlation id, if any; otherwise to the
	 * request message id.
	 * @param request the original incoming JMS message
	 * @param response the outgoing JMS message about to be sent
	 * @throws JMSException if thrown by JMS API methods
	 * @see javax.jms.Message#setJMSCorrelationID
	 */
	/**
	 * 在发送给定响应消息之前，对其进行后处理。 
	 *  <p>默认实现将响应的相关ID设置为请求消息的相关ID（如果有）； 
	 * 否则为请求消息ID。 
	 *  
	 * @param 请求原始传入的JMS消息
	 * @param 响应即将发送的传出JMS消息
	 * @throws  JMSException（如果由JMS API方法抛出）
	 * @see  javax.jms.Message＃setJMSCorrelationID
	 */
	protected void postProcessResponse(Message request, Message response) throws JMSException {
		String correlation = request.getJMSCorrelationID();
		if (correlation == null) {
			correlation = request.getJMSMessageID();
		}
		response.setJMSCorrelationID(correlation);
	}

	private Destination getResponseDestination(Message request, Message response, Session session, Object result)
			throws JMSException {

		if (result instanceof JmsResponse) {
			JmsResponse<?> jmsResponse = (JmsResponse<?>) result;
			Destination destination = jmsResponse.resolveDestination(getDestinationResolver(), session);
			if (destination != null) {
				return destination;
			}
		}
		return getResponseDestination(request, response, session);
	}

	/**
	 * Determine a response destination for the given message.
	 * <p>The default implementation first checks the JMS Reply-To
	 * {@link Destination} of the supplied request; if that is not {@code null}
	 * it is returned; if it is {@code null}, then the configured
	 * {@link #resolveDefaultResponseDestination default response destination}
	 * is returned; if this too is {@code null}, then an
	 * {@link javax.jms.InvalidDestinationException} is thrown.
	 * @param request the original incoming JMS message
	 * @param response the outgoing JMS message about to be sent
	 * @param session the JMS Session to operate on
	 * @return the response destination (never {@code null})
	 * @throws JMSException if thrown by JMS API methods
	 * @throws javax.jms.InvalidDestinationException if no {@link Destination} can be determined
	 * @see #setDefaultResponseDestination
	 * @see javax.jms.Message#getJMSReplyTo()
	 */
	/**
	 * 确定给定消息的响应目的地。 
	 *  <p>默认实现首先检查提供的请求的JMS回复{@link  Destination}； 
	 * 如果不是{@code  null}，则返回它； 
	 * 如果它是{@code  null}，则返回配置的{@link  #resolveDefaultResponseDestination默认响应目的地}； 
	 * 如果这也是{@code  null}，则抛出{@link  javax.jms.InvalidDestinationException}。 
	 *  
	 * @param 请求原始传入的JMS消息
	 * @param 响应即将发送的传出JMS消息
	 * @param 会话JMS会话在
	 * @return 上运行，响应目的地（永远{<@@code> null} ）
	 * @throws 如果由JMS API方法抛出，则为JMSException 
	 * @throws  javax.jms.InvalidDestinationException如果无法确定{@link  Destination}，则为
	 * @see  #setDefaultResponseDestination 
	 * @see  javax.jms.Message＃getJMSReplyTo （）
	 */
	protected Destination getResponseDestination(Message request, Message response, Session session)
			throws JMSException {

		Destination replyTo = request.getJMSReplyTo();
		if (replyTo == null) {
			replyTo = resolveDefaultResponseDestination(session);
			if (replyTo == null) {
				throw new InvalidDestinationException("Cannot determine response destination: " +
						"Request message does not contain reply-to destination, and no default response destination set.");
			}
		}
		return replyTo;
	}

	/**
	 * Resolve the default response destination into a JMS {@link Destination}, using this
	 * accessor's {@link DestinationResolver} in case of a destination name.
	 * @return the located {@link Destination}
	 * @throws javax.jms.JMSException if resolution failed
	 * @see #setDefaultResponseDestination
	 * @see #setDefaultResponseQueueName
	 * @see #setDefaultResponseTopicName
	 * @see #setDestinationResolver
	 */
	/**
	 * 如果使用目的地名称，则使用此访问者的{@link  DestinationResolver}将默认响应目的地解析为JMS {@link  Destination}。 
	 *  
	 * @return 定位的{@link 目标} 
	 * @throws  javax.jms.JMSException如果解析失败
	 * @see  #setDefaultResponseDestination 
	 * @see  #setDefaultResponseQueueName 
	 * @see  #setDefaultResponseTopicName 
	 * @see  #setDestinationResolver
	 */
	@Nullable
	protected Destination resolveDefaultResponseDestination(Session session) throws JMSException {
		if (this.defaultResponseDestination instanceof Destination) {
			return (Destination) this.defaultResponseDestination;
		}
		if (this.defaultResponseDestination instanceof DestinationNameHolder) {
			DestinationNameHolder nameHolder = (DestinationNameHolder) this.defaultResponseDestination;
			return getDestinationResolver().resolveDestinationName(session, nameHolder.name, nameHolder.isTopic);
		}
		return null;
	}

	/**
	 * Send the given response message to the given destination.
	 * @param response the JMS message to send
	 * @param destination the JMS destination to send to
	 * @param session the JMS session to operate on
	 * @throws JMSException if thrown by JMS API methods
	 * @see #postProcessProducer
	 * @see javax.jms.Session#createProducer
	 * @see javax.jms.MessageProducer#send
	 */
	/**
	 * 将给定的响应消息发送到给定的目的地。 
	 *  
	 * @param 响应JMS消息以发送
	 * @param 目标JMS目的地发送给
	 * @param 会话JMS会话在
	 * @throws 上运行JMS异常（如果由JMS API方法抛出）
	 * @see  #postProcessProducer 
	 * @see  javax.jms.Session＃createProducer 
	 * @see  javax.jms.MessageProducer＃send
	 */
	protected void sendResponse(Session session, Destination destination, Message response) throws JMSException {
		MessageProducer producer = session.createProducer(destination);
		try {
			postProcessProducer(producer, response);
			QosSettings settings = getResponseQosSettings();
			if (settings != null) {
				producer.send(response, settings.getDeliveryMode(), settings.getPriority(),
						settings.getTimeToLive());
			}
			else {
				producer.send(response);
			}
		}
		finally {
			JmsUtils.closeMessageProducer(producer);
		}
	}

	/**
	 * Post-process the given message producer before using it to send the response.
	 * <p>The default implementation is empty.
	 * @param producer the JMS message producer that will be used to send the message
	 * @param response the outgoing JMS message about to be sent
	 * @throws JMSException if thrown by JMS API methods
	 */
	/**
	 * 在使用给定消息生成器发送响应之前，对其进行后处理。 
	 *  <p>默认实现为空。 
	 *  
	 * @param 生产者将用于发送消息的JMS消息生产者
	 * @param 响应即将发送的外发JMS消息
	 * @throws  JMSException（如果由JMS API方法抛出）
	 */
	protected void postProcessProducer(MessageProducer producer, Message response) throws JMSException {
	}


	/**
	 * A {@link MessagingMessageConverter} that lazily invoke payload extraction and
	 * delegate it to {@link #extractMessage(javax.jms.Message)} in order to enforce
	 * backward compatibility.
	 */
	/**
	 * 一个{@link  MessagingMessageConverter}，它懒惰地调用有效负载提取并将其委托给{@link  #extractMessage（javax.jms.Message）}，以实现向后兼容。 
	 * 
	 */
	private class MessagingMessageConverterAdapter extends MessagingMessageConverter {

		@SuppressWarnings("unchecked")
		@Override
		public Object fromMessage(javax.jms.Message message) throws JMSException, MessageConversionException {
			return new LazyResolutionMessage(message);
		}

		@Override
		protected Object extractPayload(Message message) throws JMSException {
			Object payload = extractMessage(message);
			if (message instanceof BytesMessage) {
				try {
					// In case the BytesMessage is going to be received as a user argument:
					// reset it, otherwise it would appear empty to such processing code...
					((BytesMessage) message).reset();
				}
				catch (JMSException ex) {
					// Continue since the BytesMessage typically won't be used any further.
					logger.debug("Failed to reset BytesMessage after payload extraction", ex);
				}
			}
			return payload;
		}

		@Override
		protected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint)
				throws JMSException {

			MessageConverter converter = getMessageConverter();
			if (converter == null) {
				throw new IllegalStateException("No message converter, cannot handle '" + payload + "'");
			}
			if (converter instanceof SmartMessageConverter) {
				return ((SmartMessageConverter) converter).toMessage(payload, session, conversionHint);

			}
			return converter.toMessage(payload, session);
		}


		protected class LazyResolutionMessage implements org.springframework.messaging.Message<Object> {

			private final javax.jms.Message message;

			@Nullable
			private Object payload;

			@Nullable
			private MessageHeaders headers;

			public LazyResolutionMessage(javax.jms.Message message) {
				this.message = message;
			}

			@Override
			public Object getPayload() {
				if (this.payload == null) {
					try {
						this.payload = unwrapPayload();
					}
					catch (JMSException ex) {
						throw new MessageConversionException(
								"Failed to extract payload from [" + this.message + "]", ex);
					}
				}
				return this.payload;
			}

			/**
			 * Extract the payload of the current message. Since we deferred the resolution
			 * of the payload, a custom converter may still return a full message for it. In
			 * this case, its payload is returned.
			 * @return the payload of the message
			 */
			/**
			 * 提取当前消息的有效负载。 
			 * 由于我们推迟了有效负载的分辨率，因此自定义转换器可能仍会为其返回完整的消息。 
			 * 在这种情况下，将返回其有效载荷。 
			 *  
			 * @return 消息的有效负载
			 */
			@SuppressWarnings("rawtypes")
			private Object unwrapPayload() throws JMSException {
				Object payload = extractPayload(this.message);
				if (payload instanceof org.springframework.messaging.Message) {
					return ((org.springframework.messaging.Message) payload).getPayload();
				}
				return payload;
			}

			@Override
			public MessageHeaders getHeaders() {
				if (this.headers == null) {
					this.headers = extractHeaders(this.message);
				}
				return this.headers;
			}
		}
	}


	/**
	 * Internal class combining a destination name
	 * and its target destination type (queue or topic).
	 */
	/**
	 * 组合了目标名称及其目标目的地类型（队列或主题）的内部类。 
	 * 
	 */
	private static class DestinationNameHolder {

		public final String name;

		public final boolean isTopic;

		public DestinationNameHolder(String name, boolean isTopic) {
			this.name = name;
			this.isTopic = isTopic;
		}
	}

}
