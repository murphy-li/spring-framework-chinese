/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.listener;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Executor;

import javax.jms.Connection;
import javax.jms.JMSException;
import javax.jms.MessageConsumer;
import javax.jms.Session;

import org.springframework.core.Constants;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.JmsException;
import org.springframework.jms.support.JmsUtils;
import org.springframework.jms.support.destination.CachingDestinationResolver;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.SchedulingAwareRunnable;
import org.springframework.scheduling.SchedulingTaskExecutor;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.backoff.BackOff;
import org.springframework.util.backoff.BackOffExecution;
import org.springframework.util.backoff.FixedBackOff;

/**
 * Message listener container variant that uses plain JMS client APIs, specifically
 * a loop of {@code MessageConsumer.receive()} calls that also allow for
 * transactional reception of messages (registering them with XA transactions).
 * Designed to work in a native JMS environment as well as in a Java EE environment,
 * with only minimal differences in configuration.
 *
 * <p>This is a simple but nevertheless powerful form of message listener container.
 * On startup, it obtains a fixed number of JMS Sessions to invoke the listener,
 * and optionally allows for dynamic adaptation at runtime (up to a maximum number).
 * Like {@link SimpleMessageListenerContainer}, its main advantage is its low level
 * of runtime complexity, in particular the minimal requirements on the JMS provider:
 * not even the JMS {@code ServerSessionPool} facility is required. Beyond that, it is
 * fully self-recovering in case the broker is temporarily unavailable, and allows
 * for stops/restarts as well as runtime changes to its configuration.
 *
 * <p>Actual {@code MessageListener} execution happens in asynchronous work units which are
 * created through Spring's {@link org.springframework.core.task.TaskExecutor TaskExecutor}
 * abstraction. By default, the specified number of invoker tasks will be created
 * on startup, according to the {@link #setConcurrentConsumers "concurrentConsumers"}
 * setting. Specify an alternative {@code TaskExecutor} to integrate with an existing
 * thread pool facility (such as a Java EE server's), for example using a
 * {@link org.springframework.scheduling.commonj.WorkManagerTaskExecutor CommonJ WorkManager}.
 * With a native JMS setup, each of those listener threads is going to use a
 * cached JMS {@code Session} and {@code MessageConsumer} (only refreshed in case
 * of failure), using the JMS provider's resources as efficiently as possible.
 *
 * <p>Message reception and listener execution can automatically be wrapped
 * in transactions by passing a Spring
 * {@link org.springframework.transaction.PlatformTransactionManager} into the
 * {@link #setTransactionManager "transactionManager"} property. This will usually
 * be a {@link org.springframework.transaction.jta.JtaTransactionManager} in a
 * Java EE environment, in combination with a JTA-aware JMS {@code ConnectionFactory}
 * obtained from JNDI (check your Java EE server's documentation). Note that this
 * listener container will automatically reobtain all JMS handles for each transaction
 * in case an external transaction manager is specified, for compatibility with
 * all Java EE servers (in particular JBoss). This non-caching behavior can be
 * overridden through the {@link #setCacheLevel "cacheLevel"} /
 * {@link #setCacheLevelName "cacheLevelName"} property, enforcing caching of
 * the {@code Connection} (or also {@code Session} and {@code MessageConsumer})
 * even if an external transaction manager is involved.
 *
 * <p>Dynamic scaling of the number of concurrent invokers can be activated
 * by specifying a {@link #setMaxConcurrentConsumers "maxConcurrentConsumers"}
 * value that is higher than the {@link #setConcurrentConsumers "concurrentConsumers"}
 * value. Since the latter's default is 1, you can also simply specify a
 * "maxConcurrentConsumers" of e.g. 5, which will lead to dynamic scaling up to
 * 5 concurrent consumers in case of increasing message load, as well as dynamic
 * shrinking back to the standard number of consumers once the load decreases.
 * Consider adapting the {@link #setIdleTaskExecutionLimit "idleTaskExecutionLimit"}
 * setting to control the lifespan of each new task, to avoid frequent scaling up
 * and down, in particular if the {@code ConnectionFactory} does not pool JMS
 * {@code Sessions} and/or the {@code TaskExecutor} does not pool threads (check
 * your configuration!). Note that dynamic scaling only really makes sense for a
 * queue in the first place; for a topic, you will typically stick with the default
 * number of 1 consumer, otherwise you'd receive the same message multiple times on
 * the same node.
 *
 * <p><b>Note: Don't use Spring's {@link org.springframework.jms.connection.CachingConnectionFactory}
 * in combination with dynamic scaling.</b> Ideally, don't use it with a message
 * listener container at all, since it is generally preferable to let the
 * listener container itself handle appropriate caching within its lifecycle.
 * Also, stopping and restarting a listener container will only work with an
 * independent, locally cached Connection - not with an externally cached one.
 *
 * <p><b>It is strongly recommended to either set {@link #setSessionTransacted
 * "sessionTransacted"} to "true" or specify an external {@link #setTransactionManager
 * "transactionManager"}.</b> See the {@link AbstractMessageListenerContainer}
 * javadoc for details on acknowledge modes and native transaction options, as
 * well as the {@link AbstractPollingMessageListenerContainer} javadoc for details
 * on configuring an external transaction manager. Note that for the default
 * "AUTO_ACKNOWLEDGE" mode, this container applies automatic message acknowledgment
 * before listener execution, with no redelivery in case of an exception.
 *
 * @author Juergen Hoeller
 * @since 2.0
 * @see #setTransactionManager
 * @see #setCacheLevel
 * @see javax.jms.MessageConsumer#receive(long)
 * @see SimpleMessageListenerContainer
 * @see org.springframework.jms.listener.endpoint.JmsMessageEndpointManager
 */
/**
 * 使用普通JMS客户端API的消息侦听器容器变体，特别是{<< @code >> MessageConsumer.receive（）}调用的循环，该循环还允许事务性地接收消息（在XA事务中注册它们）。 
 * 设计用于在本机JMS环境和Java EE环境中工作，并且配置差异很小。 
 *  <p>这是消息侦听器容器的一种简单但功能强大的形式。 
 * 在启动时，它获得固定数量的JMS会话来调用侦听器，并可选地允许在运行时进行动态适配（最大数量）。 
 * 像{<< @link >> SimpleMessageListenerContainer}一样，它的主要优点是运行时复杂度低，尤其是对JMS提供程序的最低要求：甚至都不需要JMS {<< @code >> ServerSessionPool}工具。 
 * 除此之外，如果代理暂时不可用，它可以完全自我恢复，并允许停止/重新启动以及对其配置进行运行时更改。 
 *  <p>实际的{<< @code >> MessageListener}执行在异步工作单元中进行，该异步工作单元是通过Spring的{<< @link >> org.springframework.core.task.TaskExecutor TaskExecutor}抽象创建的。 
 * 默认情况下，将根据{<< @link >> #setConcurrentConsumers"concurrentConsumers"}设置在启动时创建指定数量的调用程序任务。 
 * 指定替代的{<< @code >> TaskExecutor}以与现有线程池工具（例如Java EE服务器）集成，例如使用{<< @link >> org.springframework.scheduling.commonj.WorkManagerTaskExecutor CommonJ WorkManager}。 
 * 通过本机JMS设置，这些侦听器线程中的每一个都将使用JMS提供程序的JMS提供程序的缓存JMS {<< @code >> Session}和{<< @code >> MessageConsumer}（仅在失败的情况下刷新）。 
 * 资源尽可能地高效。 
 *  <p>通过将Spring {<< @link >> org.springframework.transaction.PlatformTransactionManager}传递到{<< @link >> #setTransactionManager"transactionManager"}属性中，可以自动将消息接收和侦听器执行包装在事务中。 
 * 这通常是Java EE环境中的{<< @link >> org.springframework.transaction.jta.JtaTransactionManager}，以及从JNDI获得的支持JTA的JMS {<< @code >> ConnectionFactory}（请参阅您的Java EE服务器的文档）。 
 * 请注意，在指定外部事务管理器的情况下，此侦听器容器将自动为每个事务重新获取所有JMS句柄，以与所有Java EE服务器（特别是JBoss）兼容。 
 * 可以通过{<< @link >> #setCacheLevel"cacheLevel"} / {<< @link >> #setCacheLevelName"cacheLevelName"}属性覆盖此非缓存行为，从而强制{<< @code >>即使涉及外部事务管理器，也可以使用Connection}（或{<< @code >>会话}和{<< @code >> MessageConsumer}）。 
 *  <p>可以通过指定比{<< @link >> #setConcurrentConsumers"concurrentConsumers"}值高的{<< @link >> #setMaxConcurrentConsumers"maxConcurrentConsumers"}值来激活并发调用者数量的动态缩放。 
 *  。 
 * 由于后者的默认值为1，因此您也可以简单地指定"maxConcurrentConsumers"，例如5，这将导致在消息负载增加的情况下最多可动态扩展至5个并发使用者，并且一旦负载减少，就会动态缩小到标准数目的使用者。 
 * 考虑调整{<< @link >> #setIdleTaskExecutionLimit"idleTaskExecutionLimit"}设置以控制每个新任务的生命周期，以避免频繁地放大和缩小，尤其是在{<< @code >> ConnectionFactory}未合并时JMS {<< @code >>会话}和/或{<< @code >> TaskExecutor}不合并线程（请检查配置！ 
 * ）。 
 * 请注意，动态缩放首先只对队列有意义。 
 * 对于一个主题，您通常会坚持使用1个使用者的默认数量，否则，您将在同一节点上多次收到同一条消息。 
 *  <p> <b>注意：请勿将Spring的{<< @link >> org.springframework.jms.connection.CachingConnectionFactory}与动态缩放结合使用。 
 * </ b>理想情况下，请勿将其与消息一起使用根本没有监听器容器，因为通常最好让监听器容器本身在其生命周期内处理适当的缓存。 
 * 另外，停止和重新启动侦听器容器仅适用于独立的本地缓存的Connection，而不适用于外部缓存的Connection。 
 *  <p> <b>强烈建议将{<< @link >> #setSessionTransacted"sessionTransacted"}设置为"true"，或指定外部{<< @link >> #setTransactionManager"transactionManager"}。 
 * </ p b>有关确认模式和本机事务选项的详细信息，请参见{<< @link >> AbstractMessageListenerContainer} Javadoc； 
 * 有关配置外部事务管理器的详细信息，请参见{<< @link >> AbstractPollingMessageListenerContainer} Javadoc。 
 * 
 */
/**
 * 请注意，对于默认的"AUTO_ACKNOWLEDGE"模式，此容器在侦听器执行之前应用自动消息确认，在发生异常的情况下不会重新发送。 
 *  << @author >> Juergen Hoeller @始于2.0 << 
 * @see >> #setTransactionManager << 
 * @see >> #setCacheLevel << 
 * @see >> javax.jms.MessageConsumer＃receive（long）<< 
 * @see >> SimpleMessageListenerContainer << 
 * @see >> org.springframework.jms.listener.endpoint.JmsMessageEndpointManager
 */
public class DefaultMessageListenerContainer extends AbstractPollingMessageListenerContainer {

	/**
	 * Default thread name prefix: "DefaultMessageListenerContainer-".
	 */
	/**
	 * 默认线程名称前缀："DefaultMessageListenerContainer-"。 
	 * 
	 */
	public static final String DEFAULT_THREAD_NAME_PREFIX =
			ClassUtils.getShortName(DefaultMessageListenerContainer.class) + "-";

	/**
	 * The default recovery interval: 5000 ms = 5 seconds.
	 */
	/**
	 * 默认恢复间隔：5000 ms = 5秒。 
	 * 
	 */
	public static final long DEFAULT_RECOVERY_INTERVAL = 5000;


	/**
	 * Constant that indicates to cache no JMS resources at all.
	 * @see #setCacheLevel
	 */
	/**
	 * 指示根本不缓存任何JMS资源的常量。 
	 *  
	 * @see  #setCacheLevel
	 */
	public static final int CACHE_NONE = 0;

	/**
	 * Constant that indicates to cache a shared JMS {@code Connection} for each
	 * listener thread.
	 * @see #setCacheLevel
	 */
	/**
	 * 指示为每个侦听器线程缓存共享的JMS {@code  Connection}的常量。 
	 *  
	 * @see  #setCacheLevel
	 */
	public static final int CACHE_CONNECTION = 1;

	/**
	 * Constant that indicates to cache a shared JMS {@code Connection} and a JMS
	 * {@code Session} for each listener thread.
	 * @see #setCacheLevel
	 */
	/**
	 * 指示为每个侦听器线程缓存共享的JMS {@code  Connection}和JMS {@code  Session}的常数。 
	 *  
	 * @see  #setCacheLevel
	 */
	public static final int CACHE_SESSION = 2;

	/**
	 * Constant that indicates to cache a shared JMS {@code Connection}, a JMS
	 * {@code Session}, and a JMS MessageConsumer for each listener thread.
	 * @see #setCacheLevel
	 */
	/**
	 * 指示为每个侦听器线程缓存共享的JMS {@code  Connection}，JMS {@code  Session}和JMS MessageConsumer的常数。 
	 *  
	 * @see  #setCacheLevel
	 */
	public static final int CACHE_CONSUMER = 3;

	/**
	 * Constant that indicates automatic choice of an appropriate caching level
	 * (depending on the transaction management strategy).
	 * @see #setCacheLevel
	 */
	/**
	 * 指示自动选择适当的缓存级别的常数（取决于事务管理策略）。 
	 *  
	 * @see  #setCacheLevel
	 */
	public static final int CACHE_AUTO = 4;


	private static final Constants constants = new Constants(DefaultMessageListenerContainer.class);


	@Nullable
	private Executor taskExecutor;

	private BackOff backOff = new FixedBackOff(DEFAULT_RECOVERY_INTERVAL, Long.MAX_VALUE);

	private int cacheLevel = CACHE_AUTO;

	private int concurrentConsumers = 1;

	private int maxConcurrentConsumers = 1;

	private int maxMessagesPerTask = Integer.MIN_VALUE;

	private int idleConsumerLimit = 1;

	private int idleTaskExecutionLimit = 1;

	private final Set<AsyncMessageListenerInvoker> scheduledInvokers = new HashSet<>();

	private int activeInvokerCount = 0;

	private int registeredWithDestination = 0;

	private volatile boolean recovering = false;

	private volatile boolean interrupted = false;

	@Nullable
	private Runnable stopCallback;

	private Object currentRecoveryMarker = new Object();

	private final Object recoveryMonitor = new Object();


	/**
	 * Set the Spring {@code TaskExecutor} to use for running the listener threads.
	 * <p>Default is a {@link org.springframework.core.task.SimpleAsyncTaskExecutor},
	 * starting up a number of new threads, according to the specified number
	 * of concurrent consumers.
	 * <p>Specify an alternative {@code TaskExecutor} for integration with an existing
	 * thread pool. Note that this really only adds value if the threads are
	 * managed in a specific fashion, for example within a Java EE environment.
	 * A plain thread pool does not add much value, as this listener container
	 * will occupy a number of threads for its entire lifetime.
	 * @see #setConcurrentConsumers
	 * @see org.springframework.core.task.SimpleAsyncTaskExecutor
	 * @see org.springframework.scheduling.commonj.WorkManagerTaskExecutor
	 */
	/**
	 * 将Spring {@code  TaskExecutor}设置为用于运行侦听器线程。 
	 *  <p>默认值为{@link  org.springframework.core.task.SimpleAsyncTaskExecutor}，根据指定的并发使用者数，启动多个新线程。 
	 *  <p>指定备用{{@@code> TaskExecutor}与现有线程池集成。 
	 * 请注意，这仅在以特定方式（例如在Java EE环境中）管理线程时才真正增加价值。 
	 * 普通线程池不会增加太多价值，因为此侦听器容器将在整个生命周期中占用大量线程。 
	 *  
	 * @see  #setConcurrentConsumers 
	 * @see  org.springframework.core.task.SimpleAsyncTaskExecutor 
	 * @see  org.springframework.scheduling.commonj.WorkManagerTaskExecutor
	 */
	public void setTaskExecutor(Executor taskExecutor) {
		this.taskExecutor = taskExecutor;
	}

	/**
	 * Specify the {@link BackOff} instance to use to compute the interval
	 * between recovery attempts. If the {@link BackOffExecution} implementation
	 * returns {@link BackOffExecution#STOP}, this listener container will not further
	 * attempt to recover.
	 * <p>The {@link #setRecoveryInterval(long) recovery interval} is ignored
	 * when this property is set.
	 * @since 4.1
	 */
	/**
	 * 指定{@link  BackOff}实例以计算两次恢复尝试之间的间隔。 
	 * 如果{@link  BackOffExecution}实现返回{@link  BackOffExecution＃STOP}，则此侦听器容器将不再尝试恢复。 
	 *  <p>设置此属性时，将忽略{@link  #setRecoveryInterval（long）恢复间隔}。 
	 *  @始于4.1
	 */
	public void setBackOff(BackOff backOff) {
		this.backOff = backOff;
	}

	/**
	 * Specify the interval between recovery attempts, in <b>milliseconds</b>.
	 * The default is 5000 ms, that is, 5 seconds. This is a convenience method
	 * to create a {@link FixedBackOff} with the specified interval.
	 * <p>For more recovery options, consider specifying a {@link BackOff}
	 * instance instead.
	 * @see #setBackOff(BackOff)
	 * @see #handleListenerSetupFailure
	 */
	/**
	 * 指定两次恢复尝试之间的间隔，以<b>毫秒</ b>为单位。 
	 * 缺省值为5000毫秒，即5秒。 
	 * 这是一种使用指定间隔创建{@link  FixedBackOff}的便捷方法。 
	 *  <p>有关更多恢复选项，请考虑指定一个{@link  BackOff}实例。 
	 *  
	 * @see  #setBackOff（BackOff）
	 * @see  #handleListenerSetupFailure
	 */
	public void setRecoveryInterval(long recoveryInterval) {
		this.backOff = new FixedBackOff(recoveryInterval, Long.MAX_VALUE);
	}

	/**
	 * Specify the level of caching that this listener container is allowed to apply,
	 * in the form of the name of the corresponding constant: e.g. "CACHE_CONNECTION".
	 * @see #setCacheLevel
	 */
	/**
	 * 以相应常量名称的形式指定允许该侦听器容器应用的缓存级别： "CACHE_CONNECTION"。 
	 *  
	 * @see  #setCacheLevel
	 */
	public void setCacheLevelName(String constantName) throws IllegalArgumentException {
		if (!constantName.startsWith("CACHE_")) {
			throw new IllegalArgumentException("Only cache constants allowed");
		}
		setCacheLevel(constants.asNumber(constantName).intValue());
	}

	/**
	 * Specify the level of caching that this listener container is allowed to apply.
	 * <p>Default is {@link #CACHE_NONE} if an external transaction manager has been specified
	 * (to reobtain all resources freshly within the scope of the external transaction),
	 * and {@link #CACHE_CONSUMER} otherwise (operating with local JMS resources).
	 * <p>Some Java EE servers only register their JMS resources with an ongoing XA
	 * transaction in case of a freshly obtained JMS {@code Connection} and {@code Session},
	 * which is why this listener container by default does not cache any of those.
	 * However, depending on the rules of your server with respect to the caching
	 * of transactional resources, consider switching this setting to at least
	 * {@link #CACHE_CONNECTION} or {@link #CACHE_SESSION} even in conjunction with an
	 * external transaction manager.
	 * @see #CACHE_NONE
	 * @see #CACHE_CONNECTION
	 * @see #CACHE_SESSION
	 * @see #CACHE_CONSUMER
	 * @see #setCacheLevelName
	 * @see #setTransactionManager
	 */
	/**
	 * 指定允许应用此侦听器容器的缓存级别。 
	 *  <p>如果已指定外部事务管理器（以重新获取外部事务范围内的所有资源），则默认为{@link  #CACHE_NONE}，否则为{@link  #CACHE_CONSUMER}（与本地操作JMS资源）。 
	 *  <p>某些Java EE服务器仅在新获得的JMS {@code  Connection}和{@code  Session}的情况下，才通过正在进行的XA事务注册其JMS资源，这就是为什么此侦听器容器默认不添加的原因缓存其中任何一个。 
	 * 但是，根据服务器有关事务资源缓存的规则，即使与外部事务管理器一起使用，也要考虑将此设置至少切换到{@link  #CACHE_CONNECTION}或{@link  #CACHE_SESSION} 。 
	 *  
	 * @see  #CACHE_NONE 
	 * @see  #CACHE_CONNECTION 
	 * @see  #CACHE_SESSION 
	 * @see  #CACHE_CONSUMER 
	 * @see  #setCacheLevelName 
	 * @see  #setTransactionManager
	 */
	public void setCacheLevel(int cacheLevel) {
		this.cacheLevel = cacheLevel;
	}

	/**
	 * Return the level of caching that this listener container is allowed to apply.
	 */
	/**
	 * 返回允许该侦听器容器应用的缓存级别。 
	 * 
	 */
	public int getCacheLevel() {
		return this.cacheLevel;
	}


	/**
	 * Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple
	 * upper limit String, e.g. "10" (the lower limit will be 1 in this case).
	 * <p>This listener container will always hold on to the minimum number of consumers
	 * ({@link #setConcurrentConsumers}) and will slowly scale up to the maximum number
	 * of consumers {@link #setMaxConcurrentConsumers} in case of increasing load.
	 */
	/**
	 * 通过"下-上"字符串指定并发限制，例如"5-10"，或简单的上限字符串，例如"10"（在这种情况下，下限将为1）。 
	 *  <p>此侦听器容器将始终保持最少数量的使用者（{@link  #setConcurrentConsumers}），并在负载增加的情况下缓慢扩展至最大数量的使用者{@link  #setMaxConcurrentConsumers} 。 
	 * 
	 */
	@Override
	public void setConcurrency(String concurrency) {
		try {
			int separatorIndex = concurrency.indexOf('-');
			if (separatorIndex != -1) {
				setConcurrentConsumers(Integer.parseInt(concurrency.substring(0, separatorIndex)));
				setMaxConcurrentConsumers(Integer.parseInt(concurrency.substring(separatorIndex + 1, concurrency.length())));
			}
			else {
				setConcurrentConsumers(1);
				setMaxConcurrentConsumers(Integer.parseInt(concurrency));
			}
		}
		catch (NumberFormatException ex) {
			throw new IllegalArgumentException("Invalid concurrency value [" + concurrency + "]: only " +
					"single maximum integer (e.g. \"5\") and minimum-maximum combo (e.g. \"3-5\") supported.");
		}
	}

	/**
	 * Specify the number of concurrent consumers to create. Default is 1.
	 * <p>Specifying a higher value for this setting will increase the standard
	 * level of scheduled concurrent consumers at runtime: This is effectively
	 * the minimum number of concurrent consumers which will be scheduled
	 * at any given time. This is a static setting; for dynamic scaling,
	 * consider specifying the "maxConcurrentConsumers" setting instead.
	 * <p>Raising the number of concurrent consumers is recommendable in order
	 * to scale the consumption of messages coming in from a queue. However,
	 * note that any ordering guarantees are lost once multiple consumers are
	 * registered. In general, stick with 1 consumer for low-volume queues.
	 * <p><b>Do not raise the number of concurrent consumers for a topic,
	 * unless vendor-specific setup measures clearly allow for it.</b>
	 * With regular setup, this would lead to concurrent consumption
	 * of the same message, which is hardly ever desirable.
	 * <p><b>This setting can be modified at runtime, for example through JMX.</b>
	 * @see #setMaxConcurrentConsumers
	 */
	/**
	 * 指定要创建的并发使用者数。 
	 * 默认值为1。 
	 * <p>为此设置指定更高的值将增加运行时调度的并发使用者的标准级别：这实际上是在任何给定时间调度的最小并发使用者数。 
	 * 这是静态设置； 
	 * 对于动态缩放，请考虑改为指定"maxConcurrentConsumers"设置。 
	 *  <p>建议增加并发使用者的数量，以扩展从队列传入的消息的使用量。 
	 * 但是，请注意，一旦注册了多个使用者，任何订购保证都将丢失。 
	 * 通常，对于少量队列，请坚持使用1个使用者。 
	 *  <p> <b>除非特定于供应商的设置措施明确允许，否则请勿增加某个主题的并发使用者数量。 
	 * </ b>使用常规设置，这将导致并发使用同一条消息，即几乎没有希望。 
	 *  <p> <b>可以在运行时修改此设置，例如通过JMX。 
	 * </ b> 
	 * @see  #setMaxConcurrentConsumers
	 */
	public void setConcurrentConsumers(int concurrentConsumers) {
		Assert.isTrue(concurrentConsumers > 0, "'concurrentConsumers' value must be at least 1 (one)");
		synchronized (this.lifecycleMonitor) {
			this.concurrentConsumers = concurrentConsumers;
			if (this.maxConcurrentConsumers < concurrentConsumers) {
				this.maxConcurrentConsumers = concurrentConsumers;
			}
		}
	}

	/**
	 * Return the "concurrentConsumer" setting.
	 * <p>This returns the currently configured "concurrentConsumers" value;
	 * the number of currently scheduled/active consumers might differ.
	 * @see #getScheduledConsumerCount()
	 * @see #getActiveConsumerCount()
	 */
	/**
	 * 返回"concurrentConsumer"设置。 
	 *  <p>这将返回当前配置的"concurrentConsumers"值； 
	 * 当前计划/活动的使用者数量可能会有所不同。 
	 *  
	 * @see  #getScheduledConsumerCount（）
	 * @see  #getActiveConsumerCount（）
	 */
	public final int getConcurrentConsumers() {
		synchronized (this.lifecycleMonitor) {
			return this.concurrentConsumers;
		}
	}

	/**
	 * Specify the maximum number of concurrent consumers to create. Default is 1.
	 * <p>If this setting is higher than "concurrentConsumers", the listener container
	 * will dynamically schedule new consumers at runtime, provided that enough
	 * incoming messages are encountered. Once the load goes down again, the number of
	 * consumers will be reduced to the standard level ("concurrentConsumers") again.
	 * <p>Raising the number of concurrent consumers is recommendable in order
	 * to scale the consumption of messages coming in from a queue. However,
	 * note that any ordering guarantees are lost once multiple consumers are
	 * registered. In general, stick with 1 consumer for low-volume queues.
	 * <p><b>Do not raise the number of concurrent consumers for a topic,
	 * unless vendor-specific setup measures clearly allow for it.</b>
	 * With regular setup, this would lead to concurrent consumption
	 * of the same message, which is hardly ever desirable.
	 * <p><b>This setting can be modified at runtime, for example through JMX.</b>
	 * @see #setConcurrentConsumers
	 */
	/**
	 * 指定要创建的最大并发使用者数。 
	 * 默认值为1。 
	 * <p>如果此设置高于"concurrentConsumers"，则侦听器容器将在运行时动态调度新使用者，前提是遇到足够的传入消息。 
	 * 一旦负载再次下降，使用者的数量将再次减少到标准级别（"concurrentConsumers"）。 
	 *  <p>建议增加并发使用者的数量，以扩展从队列传入的消息的使用量。 
	 * 但是，请注意，一旦注册了多个使用者，任何订购保证都将丢失。 
	 * 通常，对于少量队列，请坚持使用1个使用者。 
	 *  <p> <b>除非特定于供应商的设置措施明确允许，否则请勿增加某个主题的并发使用者数量。 
	 * </ b>使用常规设置，这将导致并发使用同一条消息，即几乎没有希望。 
	 *  <p> <b>可以在运行时修改此设置，例如通过JMX。 
	 * </ b> 
	 * @see  #setConcurrentConsumers
	 */
	public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
		Assert.isTrue(maxConcurrentConsumers > 0, "'maxConcurrentConsumers' value must be at least 1 (one)");
		synchronized (this.lifecycleMonitor) {
			this.maxConcurrentConsumers = Math.max(maxConcurrentConsumers, this.concurrentConsumers);
		}
	}

	/**
	 * Return the "maxConcurrentConsumer" setting.
	 * <p>This returns the currently configured "maxConcurrentConsumers" value;
	 * the number of currently scheduled/active consumers might differ.
	 * @see #getScheduledConsumerCount()
	 * @see #getActiveConsumerCount()
	 */
	/**
	 * 返回"maxConcurrentConsumer"设置。 
	 *  <p>这将返回当前配置的"maxConcurrentConsumers"值； 
	 * 当前计划/活动的使用者数量可能会有所不同。 
	 *  
	 * @see  #getScheduledConsumerCount（）
	 * @see  #getActiveConsumerCount（）
	 */
	public final int getMaxConcurrentConsumers() {
		synchronized (this.lifecycleMonitor) {
			return this.maxConcurrentConsumers;
		}
	}

	/**
	 * Specify the maximum number of messages to process in one task.
	 * More concretely, this limits the number of message reception attempts
	 * per task, which includes receive iterations that did not actually
	 * pick up a message until they hit their timeout (see the
	 * {@link #setReceiveTimeout "receiveTimeout"} property).
	 * <p>Default is unlimited (-1) in case of a standard TaskExecutor,
	 * reusing the original invoker threads until shutdown (at the
	 * expense of limited dynamic scheduling).
	 * <p>In case of a SchedulingTaskExecutor indicating a preference for
	 * short-lived tasks, the default is 10 instead. Specify a number
	 * of 10 to 100 messages to balance between rather long-lived and
	 * rather short-lived tasks here.
	 * <p>Long-lived tasks avoid frequent thread context switches through
	 * sticking with the same thread all the way through, while short-lived
	 * tasks allow thread pools to control the scheduling. Hence, thread
	 * pools will usually prefer short-lived tasks.
	 * <p><b>This setting can be modified at runtime, for example through JMX.</b>
	 * @see #setTaskExecutor
	 * @see #setReceiveTimeout
	 * @see org.springframework.scheduling.SchedulingTaskExecutor#prefersShortLivedTasks()
	 */
	/**
	 * 指定一项任务中要处理的最大消息数。 
	 * 更具体地讲，这限制了每个任务的消息接收尝试次数，其中包括直到它们达到超时才真正接收消息的接收迭代（请参见{@link  #setReceiveTimeout"receiveTimeout"}属性）。 
	 *  <p>对于标准TaskExecutor，默认值为无限制（-1），重用原始调用程序线程直到关机（以有限的动态调度为代价）。 
	 *  <p>如果SchedulingTaskExecutor指示对短期任务的偏好，则默认值为10。 
	 * 在此处指定10到100条消息的数量，以平衡寿命较长和寿命较短​​的任务。 
	 *  <p>寿命长的任务通过始终坚持使用同一线程来避免频繁的线程上下文切换，而寿命短的任务则允许线程池控制调度。 
	 * 因此，线程池通常会选择短期任务。 
	 *  <p> <b>可以在运行时修改此设置，例如通过JMX。 
	 * </ b> 
	 * @see  #setTaskExecutor 
	 * @see  #setReceiveTimeout 
	 * @see  org.springframework.scheduling.SchedulingTaskExecutor＃prefersShortLivedTasks（）
	 */
	public void setMaxMessagesPerTask(int maxMessagesPerTask) {
		Assert.isTrue(maxMessagesPerTask != 0, "'maxMessagesPerTask' must not be 0");
		synchronized (this.lifecycleMonitor) {
			this.maxMessagesPerTask = maxMessagesPerTask;
		}
	}

	/**
	 * Return the maximum number of messages to process in one task.
	 */
	/**
	 * 返回在一个任务中要处理的最大消息数。 
	 * 
	 */
	public final int getMaxMessagesPerTask() {
		synchronized (this.lifecycleMonitor) {
			return this.maxMessagesPerTask;
		}
	}

	/**
	 * Specify the limit for the number of consumers that are allowed to be idle
	 * at any given time.
	 * <p>This limit is used by the {@link #scheduleNewInvokerIfAppropriate} method
	 * to determine if a new invoker should be created. Increasing the limit causes
	 * invokers to be created more aggressively. This can be useful to ramp up the
	 * number of invokers faster.
	 * <p>The default is 1, only scheduling a new invoker (which is likely to
	 * be idle initially) if none of the existing invokers is currently idle.
	 */
	/**
	 * 指定在任何给定时间允许空闲的使用者数量的限制。 
	 *  <p> {<@link> #scheduleNewInvokerIfAppropriate}方法使用此限制来确定是否应创建新的调用程序。 
	 * 增加限制会导致更积极地创建调用程序。 
	 * 这对于加快调用者的数量很有用。 
	 *  <p>默认值为1，如果当前没有任何现有调用程序处于空闲状态，则仅调度新的调用程序（最初可能处于空闲状态）。 
	 * 
	 */
	public void setIdleConsumerLimit(int idleConsumerLimit) {
		Assert.isTrue(idleConsumerLimit > 0, "'idleConsumerLimit' must be 1 or higher");
		synchronized (this.lifecycleMonitor) {
			this.idleConsumerLimit = idleConsumerLimit;
		}
	}

	/**
	 * Return the limit for the number of idle consumers.
	 */
	/**
	 * 返回空闲使用者数量的限制。 
	 * 
	 */
	public final int getIdleConsumerLimit() {
		synchronized (this.lifecycleMonitor) {
			return this.idleConsumerLimit;
		}
	}

	/**
	 * Specify the limit for idle executions of a consumer task, not having
	 * received any message within its execution. If this limit is reached,
	 * the task will shut down and leave receiving to other executing tasks.
	 * <p>The default is 1, closing idle resources early once a task didn't
	 * receive a message. This applies to dynamic scheduling only; see the
	 * {@link #setMaxConcurrentConsumers "maxConcurrentConsumers"} setting.
	 * The minimum number of consumers
	 * (see {@link #setConcurrentConsumers "concurrentConsumers"})
	 * will be kept around until shutdown in any case.
	 * <p>Within each task execution, a number of message reception attempts
	 * (according to the "maxMessagesPerTask" setting) will each wait for an incoming
	 * message (according to the "receiveTimeout" setting). If all of those receive
	 * attempts in a given task return without a message, the task is considered
	 * idle with respect to received messages. Such a task may still be rescheduled;
	 * however, once it reached the specified "idleTaskExecutionLimit", it will
	 * shut down (in case of dynamic scaling).
	 * <p>Raise this limit if you encounter too frequent scaling up and down.
	 * With this limit being higher, an idle consumer will be kept around longer,
	 * avoiding the restart of a consumer once a new load of messages comes in.
	 * Alternatively, specify a higher "maxMessagesPerTask" and/or "receiveTimeout" value,
	 * which will also lead to idle consumers being kept around for a longer time
	 * (while also increasing the average execution time of each scheduled task).
	 * <p><b>This setting can be modified at runtime, for example through JMX.</b>
	 * @see #setMaxMessagesPerTask
	 * @see #setReceiveTimeout
	 */
	/**
	 * 指定使用者任务空闲执行的限制，该任务在执行期间未收到任何消息。 
	 * 如果达到此限制，则任务将关闭，而将接收任务留给其他正在执行的任务。 
	 *  <p>默认值为1，一旦任务未收到消息，则尽早关闭空闲资源。 
	 * 这仅适用于动态调度。 
	 * 请参见{@link  #setMaxConcurrentConsumers"maxConcurrentConsumers"}设置。 
	 * 在任何情况下，直到关闭计算机为止，消费者的最小数量（请参阅{@link  #setConcurrentConsumers"concurrentConsumers"}）。 
	 *  <p>在每次任务执行期间，都会有许多消息接收尝试（根据"maxMessagesPerTask"设置）等待输入的消息（根据"receiveTimeout"设置）。 
	 * 如果给定任务中的所有接收尝试都返回而没有消息，则相对于接收到的消息，该任务被认为是空闲的。 
	 * 此类任务可能仍会重新安排； 
	 * 但是，一旦达到指定的"idleTaskExecutionLimit"，它将关闭（在动态缩放的情况下）。 
	 *  <p>如果您过于频繁地进行缩放，请提高此限制。 
	 * 在此限制较高的情况下，空闲的使用者将保持更长的时间，从而避免在收到新的消息负载后重新启动使用者。 
	 * 或者，指定较高的"maxMessagesPerTask"和/或"receiveTimeout"值，这也将导致使闲置的消费者闲置更长的时间（同时也增加了每个计划任务的平均执行时间）。 
	 *  <p> <b>可以在运行时修改此设置，例如通过JMX。 
	 * </ b> 
	 * @see  #setMaxMessagesPerTask 
	 * @see  #setReceiveTimeout
	 */
	public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
		Assert.isTrue(idleTaskExecutionLimit > 0, "'idleTaskExecutionLimit' must be 1 or higher");
		synchronized (this.lifecycleMonitor) {
			this.idleTaskExecutionLimit = idleTaskExecutionLimit;
		}
	}

	/**
	 * Return the limit for idle executions of a consumer task.
	 */
	/**
	 * 返回使用者任务的空闲执行限制。 
	 * 
	 */
	public final int getIdleTaskExecutionLimit() {
		synchronized (this.lifecycleMonitor) {
			return this.idleTaskExecutionLimit;
		}
	}


	//-------------------------------------------------------------------------
	// Implementation of AbstractMessageListenerContainer's template methods
	//-------------------------------------------------------------------------

	@Override
	public void initialize() {
		// Adapt default cache level.
		if (this.cacheLevel == CACHE_AUTO) {
			this.cacheLevel = (getTransactionManager() != null ? CACHE_NONE : CACHE_CONSUMER);
		}

		// Prepare taskExecutor and maxMessagesPerTask.
		synchronized (this.lifecycleMonitor) {
			if (this.taskExecutor == null) {
				this.taskExecutor = createDefaultTaskExecutor();
			}
			else if (this.taskExecutor instanceof SchedulingTaskExecutor &&
					((SchedulingTaskExecutor) this.taskExecutor).prefersShortLivedTasks() &&
					this.maxMessagesPerTask == Integer.MIN_VALUE) {
				// TaskExecutor indicated a preference for short-lived tasks. According to
				// setMaxMessagesPerTask javadoc, we'll use 10 message per task in this case
				// unless the user specified a custom value.
				this.maxMessagesPerTask = 10;
			}
		}

		// Proceed with actual listener initialization.
		super.initialize();
	}

	/**
	 * Creates the specified number of concurrent consumers,
	 * in the form of a JMS Session plus associated MessageConsumer
	 * running in a separate thread.
	 * @see #scheduleNewInvoker
	 * @see #setTaskExecutor
	 */
	/**
	 * 创建指定数量的并发使用者，形式为JMS会话以及在单独线程中运行的关联MessageConsumer。 
	 *  
	 * @see  #scheduleNewInvoker 
	 * @see  #setTaskExecutor
	 */
	@Override
	protected void doInitialize() throws JMSException {
		synchronized (this.lifecycleMonitor) {
			for (int i = 0; i < this.concurrentConsumers; i++) {
				scheduleNewInvoker();
			}
		}
	}

	/**
	 * Destroy the registered JMS Sessions and associated MessageConsumers.
	 */
	/**
	 * 销毁已注册的JMS会话和关联的MessageConsumers。 
	 * 
	 */
	@Override
	protected void doShutdown() throws JMSException {
		logger.debug("Waiting for shutdown of message listener invokers");
		try {
			synchronized (this.lifecycleMonitor) {
				long receiveTimeout = getReceiveTimeout();
				long waitStartTime = System.currentTimeMillis();
				int waitCount = 0;
				while (this.activeInvokerCount > 0) {
					if (waitCount > 0 && !isAcceptMessagesWhileStopping() &&
							System.currentTimeMillis() - waitStartTime >= receiveTimeout) {
						// Unexpectedly some invokers are still active after the receive timeout period
						// -> interrupt remaining receive attempts since we'd reject the messages anyway
						for (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {
							scheduledInvoker.interruptIfNecessary();
						}
					}
					if (logger.isDebugEnabled()) {
						logger.debug("Still waiting for shutdown of " + this.activeInvokerCount +
								" message listener invokers (iteration " + waitCount + ")");
					}
					// Wait for AsyncMessageListenerInvokers to deactivate themselves...
					if (receiveTimeout > 0) {
						this.lifecycleMonitor.wait(receiveTimeout);
					}
					else {
						this.lifecycleMonitor.wait();
					}
					waitCount++;
				}
				// Clear remaining scheduled invokers, possibly left over as paused tasks
				for (AsyncMessageListenerInvoker scheduledInvoker : this.scheduledInvokers) {
					scheduledInvoker.clearResources();
				}
				this.scheduledInvokers.clear();
			}
		}
		catch (InterruptedException ex) {
			// Re-interrupt current thread, to allow other threads to react.
			Thread.currentThread().interrupt();
		}
	}

	/**
	 * Overridden to reset the stop callback, if any.
	 */
	/**
	 * 重写以重置stop回调（如果有）。 
	 * 
	 */
	@Override
	public void start() throws JmsException {
		synchronized (this.lifecycleMonitor) {
			this.stopCallback = null;
		}
		super.start();
	}

	/**
	 * Stop this listener container, invoking the specific callback
	 * once all listener processing has actually stopped.
	 * <p>Note: Further {@code stop(runnable)} calls (before processing
	 * has actually stopped) will override the specified callback. Only the
	 * latest specified callback will be invoked.
	 * <p>If a subsequent {@link #start()} call restarts the listener container
	 * before it has fully stopped, the callback will not get invoked at all.
	 * @param callback the callback to invoke once listener processing
	 * has fully stopped
	 * @throws JmsException if stopping failed
	 * @see #stop()
	 */
	/**
	 * 停止此侦听器容器，一旦所有侦听器处理实际停止，就调用特定的回调。 
	 *  <p>注意：进一步的{@code  stop（runnable）}调用（在处理实际停止之前）将覆盖指定的回调。 
	 * 仅最新指定的回调将被调用。 
	 *  <p>如果随后的{@link  #start（）}调用在完全停止之前重新启动侦听器容器，则根本不会调用该回调。 
	 *  
	 * @param 回调一旦侦听器处理完全停止，将调用的回调
	 * @throws 如果停止失败，则JmsException 
	 * @see  #stop（）
	 */
	@Override
	public void stop(Runnable callback) throws JmsException {
		synchronized (this.lifecycleMonitor) {
			if (!isRunning() || this.stopCallback != null) {
				// Not started, already stopped, or previous stop attempt in progress
				// -> return immediately, no stop process to control anymore.
				callback.run();
				return;
			}
			this.stopCallback = callback;
		}
		stop();
	}

	/**
	 * Return the number of currently scheduled consumers.
	 * <p>This number will always be between "concurrentConsumers" and
	 * "maxConcurrentConsumers", but might be higher than "activeConsumerCount"
	 * (in case some consumers are scheduled but not executing at the moment).
	 * @see #getConcurrentConsumers()
	 * @see #getMaxConcurrentConsumers()
	 * @see #getActiveConsumerCount()
	 */
	/**
	 * 返回当前计划的使用者数。 
	 *  <p>此数字将始终在"concurrentConsumers"和"maxConcurrentConsumers"之间，但可能高于"activeConsumerCount"（以防某些使用者已安排但目前未执行）。 
	 *  
	 * @see  #getConcurrentConsumers（）
	 * @see  #getMaxConcurrentConsumers（）
	 * @see  #getActiveConsumerCount（）
	 */
	public final int getScheduledConsumerCount() {
		synchronized (this.lifecycleMonitor) {
			return this.scheduledInvokers.size();
		}
	}

	/**
	 * Return the number of currently active consumers.
	 * <p>This number will always be between "concurrentConsumers" and
	 * "maxConcurrentConsumers", but might be lower than "scheduledConsumerCount"
	 * (in case some consumers are scheduled but not executing at the moment).
	 * @see #getConcurrentConsumers()
	 * @see #getMaxConcurrentConsumers()
	 * @see #getActiveConsumerCount()
	 */
	/**
	 * 返回当前活动消费者的数量。 
	 *  <p>此数字将始终在"concurrentConsumers"和"maxConcurrentConsumers"之间，但可能低于"scheduledConsumerCount"（以防某些使用者已安排但目前未执行）。 
	 *  
	 * @see  #getConcurrentConsumers（）
	 * @see  #getMaxConcurrentConsumers（）
	 * @see  #getActiveConsumerCount（）
	 */
	public final int getActiveConsumerCount() {
		synchronized (this.lifecycleMonitor) {
			return this.activeInvokerCount;
		}
	}

	/**
	 * Return whether at least one consumer has entered a fixed registration with the
	 * target destination. This is particularly interesting for the pub-sub case where
	 * it might be important to have an actual consumer registered that is guaranteed
	 * not to miss any messages that are just about to be published.
	 * <p>This method may be polled after a {@link #start()} call, until asynchronous
	 * registration of consumers has happened which is when the method will start returning
	 * {@code true} &ndash; provided that the listener container ever actually establishes
	 * a fixed registration. It will then keep returning {@code true} until shutdown,
	 * since the container will hold on to at least one consumer registration thereafter.
	 * <p>Note that a listener container is not bound to having a fixed registration in
	 * the first place. It may also keep recreating consumers for every invoker execution.
	 * This particularly depends on the {@link #setCacheLevel cache level} setting:
	 * only {@link #CACHE_CONSUMER} will lead to a fixed registration.
	 */
	/**
	 * 返回是否至少有一个消费者已经在目标目的地输入了固定注册。 
	 * 这对于pub-sub情况特别有意思，在这种情况下，重要的是要注册一个真正的使用者，以确保不会错过任何将要发布的消息。 
	 *  <p>此方法可能在{@link  #start（）}调用之后被轮询，直到发生了消费者的异步注册为止，这是该方法将开始返回{@code  true}的时候–前提是侦听器容器实际上建立了固定注册。 
	 * 然后它将继续返回{@code  true}，直到关闭为止，因为此后容器将至少保留一个消费者注册。 
	 *  <p>请注意，侦听器容器并不首先要进行固定注册。 
	 * 它还可能会为每次调用者执行重新创建使用者。 
	 * 这尤其取决于{@link  #setCacheLevel缓存级别}设置：仅{@link  #CACHE_CONSUMER}会导致固定注册。 
	 * 
	 */
	public boolean isRegisteredWithDestination() {
		synchronized (this.lifecycleMonitor) {
			return (this.registeredWithDestination > 0);
		}
	}


	/**
	 * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified.
	 * <p>The default implementation builds a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}
	 * with the specified bean name (or the class name, if no bean name specified) as thread name prefix.
	 * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)
	 */
	/**
	 * 创建一个默认的TaskExecutor。 
	 * 如果未指定显式TaskExecutor则调用。 
	 *  <p>默认实现使用一个指定的bean名称（或类名，如果未指定bean名称）作为线程名称前缀来构建一个{@link  org.springframework.core.task.SimpleAsyncTaskExecutor}。 
	 *  
	 * @see  org.springframework.core.task.SimpleAsyncTaskExecutor＃SimpleAsyncTaskExecutor（String）
	 */
	protected TaskExecutor createDefaultTaskExecutor() {
		String beanName = getBeanName();
		String threadNamePrefix = (beanName != null ? beanName + "-" : DEFAULT_THREAD_NAME_PREFIX);
		return new SimpleAsyncTaskExecutor(threadNamePrefix);
	}

	/**
	 * Schedule a new invoker, increasing the total number of scheduled
	 * invokers for this listener container.
	 */
	/**
	 * 计划一个新的调用程序，从而增加此侦听器容器的预定调用程序总数。 
	 * 
	 */
	private void scheduleNewInvoker() {
		AsyncMessageListenerInvoker invoker = new AsyncMessageListenerInvoker();
		if (rescheduleTaskIfNecessary(invoker)) {
			// This should always be true, since we're only calling this when active.
			this.scheduledInvokers.add(invoker);
		}
	}

	/**
	 * Use a shared JMS Connection depending on the "cacheLevel" setting.
	 * @see #setCacheLevel
	 * @see #CACHE_CONNECTION
	 */
	/**
	 * 根据"cacheLevel"设置使用共享的JMS连接。 
	 *  
	 * @see  #setCacheLevel 
	 * @see  #CACHE_CONNECTION
	 */
	@Override
	protected final boolean sharedConnectionEnabled() {
		return (getCacheLevel() >= CACHE_CONNECTION);
	}

	/**
	 * Re-executes the given task via this listener container's TaskExecutor.
	 * @see #setTaskExecutor
	 */
	/**
	 * 通过此侦听器容器的TaskExecutor重新执行给定的任务。 
	 *  
	 * @see  #setTaskExecutor
	 */
	@Override
	protected void doRescheduleTask(Object task) {
		Assert.state(this.taskExecutor != null, "No TaskExecutor available");
		this.taskExecutor.execute((Runnable) task);
	}

	/**
	 * Tries scheduling a new invoker, since we know messages are coming in...
	 * @see #scheduleNewInvokerIfAppropriate()
	 */
	/**
	 * 尝试安排新的调用程序，因为我们知道消息正在传入... 
	 * @see  #scheduleNewInvokerIfAppropriate（）
	 */
	@Override
	protected void messageReceived(Object invoker, Session session) {
		((AsyncMessageListenerInvoker) invoker).setIdle(false);
		scheduleNewInvokerIfAppropriate();
	}

	/**
	 * Marks the affected invoker as idle.
	 */
	/**
	 * 将受影响的调用方标记为空闲。 
	 * 
	 */
	@Override
	protected void noMessageReceived(Object invoker, Session session) {
		((AsyncMessageListenerInvoker) invoker).setIdle(true);
	}

	/**
	 * Schedule a new invoker, increasing the total number of scheduled
	 * invokers for this listener container, but only if the specified
	 * "maxConcurrentConsumers" limit has not been reached yet, and only
	 * if the specified "idleConsumerLimit" has not been reached either.
	 * <p>Called once a message has been received, in order to scale up while
	 * processing the message in the invoker that originally received it.
	 * @see #setTaskExecutor
	 * @see #getMaxConcurrentConsumers()
	 * @see #getIdleConsumerLimit()
	 */
	/**
	 * 安排一个新的调用程序，增加为此侦听器容器调度的调用程序的总数，但前提是尚未达到指定的"maxConcurrentConsumers"限制，并且仅当达到指定的"idleConsumerLimit"时，才可以。 
	 *  <p>一旦接收到一条消息就调用该消息，以便在最初接收该消息的调用程序中处理该消息时进行扩展。 
	 *  
	 * @see  #setTaskExecutor 
	 * @see  #getMaxConcurrentConsumers（）
	 * @see  #getIdleConsumerLimit（）
	 */
	protected void scheduleNewInvokerIfAppropriate() {
		if (isRunning()) {
			resumePausedTasks();
			synchronized (this.lifecycleMonitor) {
				if (this.scheduledInvokers.size() < this.maxConcurrentConsumers &&
						getIdleInvokerCount() < this.idleConsumerLimit) {
					scheduleNewInvoker();
					if (logger.isDebugEnabled()) {
						logger.debug("Raised scheduled invoker count: " + this.scheduledInvokers.size());
					}
				}
			}
		}
	}

	/**
	 * Determine whether the current invoker should be rescheduled,
	 * given that it might not have received a message in a while.
	 * @param idleTaskExecutionCount the number of idle executions
	 * that this invoker task has already accumulated (in a row)
	 */
	/**
	 * 考虑到当前调用者可能暂时没有收到消息，请确定是否应该重新安排其时间。 
	 *  
	 * @param  idleTaskExecutionCount此调用程序任务已经累积（连续）的空闲执行次数
	 */
	private boolean shouldRescheduleInvoker(int idleTaskExecutionCount) {
		boolean superfluous =
				(idleTaskExecutionCount >= this.idleTaskExecutionLimit && getIdleInvokerCount() > 1);
		return (this.scheduledInvokers.size() <=
				(superfluous ? this.concurrentConsumers : this.maxConcurrentConsumers));
	}

	/**
	 * Determine whether this listener container currently has more
	 * than one idle instance among its scheduled invokers.
	 */
	/**
	 * 确定此侦听器容器当前在其计划的调用程序中是否具有多个空闲实例。 
	 * 
	 */
	private int getIdleInvokerCount() {
		int count = 0;
		for (AsyncMessageListenerInvoker invoker : this.scheduledInvokers) {
			if (invoker.isIdle()) {
				count++;
			}
		}
		return count;
	}


	/**
	 * Overridden to accept a failure in the initial setup - leaving it up to the
	 * asynchronous invokers to establish the shared Connection on first access.
	 * @see #refreshConnectionUntilSuccessful()
	 */
	/**
	 * 重写以接受初始设置中的失败-由异步调用者在首次访问时建立共享连接。 
	 *  
	 * @see  #refreshConnectionUntilSuccessful（）
	 */
	@Override
	protected void establishSharedConnection() {
		try {
			super.establishSharedConnection();
		}
		catch (Exception ex) {
			if (ex instanceof JMSException) {
				invokeExceptionListener((JMSException) ex);
			}
			logger.debug("Could not establish shared JMS Connection - " +
					"leaving it up to asynchronous invokers to establish a Connection as soon as possible", ex);
		}
	}

	/**
	 * This implementations proceeds even after an exception thrown from
	 * {@code Connection.start()}, relying on listeners to perform
	 * appropriate recovery.
	 */
	/**
	 * 即使在{@code  Connection.start（）}抛出异常之后，依赖于侦听器执行适当的恢复，该实现仍将继续进行。 
	 * 
	 */
	@Override
	protected void startSharedConnection() {
		try {
			super.startSharedConnection();
		}
		catch (Exception ex) {
			logger.debug("Connection start failed - relying on listeners to perform recovery", ex);
		}
	}

	/**
	 * This implementations proceeds even after an exception thrown from
	 * {@code Connection.stop()}, relying on listeners to perform
	 * appropriate recovery after a restart.
	 */
	/**
	 * 即使从{@code  Connection.stop（）}抛出异常之后，也要继续执行此实现，它依赖侦听器在重新启动后执行适当的恢复。 
	 * 
	 */
	@Override
	protected void stopSharedConnection() {
		try {
			super.stopSharedConnection();
		}
		catch (Exception ex) {
			logger.debug("Connection stop failed - relying on listeners to perform recovery after restart", ex);
		}
	}

	/**
	 * Handle the given exception that arose during setup of a listener.
	 * Called for every such exception in every concurrent listener.
	 * <p>The default implementation logs the exception at warn level
	 * if not recovered yet, and at debug level if already recovered.
	 * Can be overridden in subclasses.
	 * @param ex the exception to handle
	 * @param alreadyRecovered whether a previously executing listener
	 * already recovered from the present listener setup failure
	 * (this usually indicates a follow-up failure than can be ignored
	 * other than for debug log purposes)
	 * @see #recoverAfterListenerSetupFailure()
	 */
	/**
	 * 处理在设置侦听器时出现的给定异常。 
	 * 在每个并发侦听器中为每个此类异常调用。 
	 *  <p>如果尚未恢复，则默认实现在警告级别记录异常，如果已经恢复，则在调试级别记录异常。 
	 * 可以在子类中覆盖。 
	 *  
	 * @param 用来处理
	 * @param 的异常已恢复以前的执行中的侦听器是否已从当前侦听器设置故障中恢复（这通常表明是后续故障，除了调试日志目的之外，可以忽略）<
	 * @see > #recoverAfterListenerSetupFailure（）
	 */
	protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered) {
		if (ex instanceof JMSException) {
			invokeExceptionListener((JMSException) ex);
		}
		if (ex instanceof SharedConnectionNotInitializedException) {
			if (!alreadyRecovered) {
				logger.debug("JMS message listener invoker needs to establish shared Connection");
			}
		}
		else {
			// Recovery during active operation..
			if (alreadyRecovered) {
				logger.debug("Setup of JMS message listener invoker failed - already recovered by other invoker", ex);
			}
			else {
				StringBuilder msg = new StringBuilder();
				msg.append("Setup of JMS message listener invoker failed for destination '");
				msg.append(getDestinationDescription()).append("' - trying to recover. Cause: ");
				msg.append(ex instanceof JMSException ? JmsUtils.buildExceptionMessage((JMSException) ex) : ex.getMessage());
				if (logger.isDebugEnabled()) {
					logger.warn(msg, ex);
				}
				else {
					logger.warn(msg);
				}
			}
		}
	}

	/**
	 * Recover this listener container after a listener failed to set itself up,
	 * for example re-establishing the underlying Connection.
	 * <p>The default implementation delegates to DefaultMessageListenerContainer's
	 * recovery-capable {@link #refreshConnectionUntilSuccessful()} method, which will
	 * try to re-establish a Connection to the JMS provider both for the shared
	 * and the non-shared Connection case.
	 * @see #refreshConnectionUntilSuccessful()
	 * @see #refreshDestination()
	 */
	/**
	 * 在侦听器无法自行设置（例如，重新建立基础连接）后，请恢复该侦听器容器。 
	 *  <p>默认实现将委托DefaultMessageListenerContainer的具有恢复功能的{@link  #refreshConnectionUntilSuccessful（）}方法，该方法将尝试为共享和非共享Connection案例重新建立与JMS提供程序的连接。 
	 *  
	 * @see  #refreshConnectionUntilSuccessful（）
	 * @see  #refreshDestination（）
	 */
	protected void recoverAfterListenerSetupFailure() {
		this.recovering = true;
		try {
			refreshConnectionUntilSuccessful();
			refreshDestination();
		}
		finally {
			this.recovering = false;
			this.interrupted = false;
		}
	}

	/**
	 * Refresh the underlying Connection, not returning before an attempt has been
	 * successful. Called in case of a shared Connection as well as without shared
	 * Connection, so either needs to operate on the shared Connection or on a
	 * temporary Connection that just gets established for validation purposes.
	 * <p>The default implementation retries until it successfully established a
	 * Connection, for as long as this message listener container is running.
	 * Applies the specified recovery interval between retries.
	 * @see #setRecoveryInterval
	 * @see #start()
	 * @see #stop()
	 */
	/**
	 * 刷新基础连接，在尝试成功之前不返回。 
	 * 在共享连接以及没有共享连接的情况下调用，因此需要在共享连接上运行，也需要在为验证目的而建立的临时连接上运行。 
	 *  <p>在此消息侦听器容器运行期间，默认实现将重试，直到成功建立连接为止。 
	 * 应用两次重试之间的指定恢复间隔。 
	 *  
	 * @see  #setRecoveryInterval 
	 * @see  #start（）
	 * @see  #stop（）
	 */
	protected void refreshConnectionUntilSuccessful() {
		BackOffExecution execution = this.backOff.start();
		while (isRunning()) {
			try {
				if (sharedConnectionEnabled()) {
					refreshSharedConnection();
				}
				else {
					Connection con = createConnection();
					JmsUtils.closeConnection(con);
				}
				logger.debug("Successfully refreshed JMS Connection");
				break;
			}
			catch (Exception ex) {
				if (ex instanceof JMSException) {
					invokeExceptionListener((JMSException) ex);
				}
				StringBuilder msg = new StringBuilder();
				msg.append("Could not refresh JMS Connection for destination '");
				msg.append(getDestinationDescription()).append("' - retrying using ");
				msg.append(execution).append(". Cause: ");
				msg.append(ex instanceof JMSException ? JmsUtils.buildExceptionMessage((JMSException) ex) : ex.getMessage());
				if (logger.isDebugEnabled()) {
					logger.error(msg, ex);
				}
				else {
					logger.error(msg);
				}
			}
			if (!applyBackOffTime(execution)) {
				StringBuilder msg = new StringBuilder();
				msg.append("Stopping container for destination '")
						.append(getDestinationDescription())
						.append("': back-off policy does not allow ").append("for further attempts.");
				logger.error(msg.toString());
				stop();
			}
		}
	}

	/**
	 * Refresh the JMS destination that this listener container operates on.
	 * <p>Called after listener setup failure, assuming that a cached Destination
	 * object might have become invalid (a typical case on WebLogic JMS).
	 * <p>The default implementation removes the destination from a
	 * DestinationResolver's cache, in case of a CachingDestinationResolver.
	 * @see #setDestinationName
	 * @see org.springframework.jms.support.destination.CachingDestinationResolver
	 */
	/**
	 * 刷新此侦听器容器操作的JMS目标。 
	 *  <p>在侦听器设置失败后调用，假定高速缓存的Destination对象可能已变得无效（WebLogic JMS上的典型情况）。 
	 *  <p>在使用CachingDestinationResolver的情况下，默认实现从DestinationResolver的缓存中删除目标。 
	 *  
	 * @see  #setDestinationName 
	 * @see  org.springframework.jms.support.destination.CachingDestinationResolver
	 */
	protected void refreshDestination() {
		String destName = getDestinationName();
		if (destName != null) {
			DestinationResolver destResolver = getDestinationResolver();
			if (destResolver instanceof CachingDestinationResolver) {
				((CachingDestinationResolver) destResolver).removeFromCache(destName);
			}
		}
	}

	/**
	 * Apply the next back-off time using the specified {@link BackOffExecution}.
	 * <p>Return {@code true} if the back-off period has been applied and a new
	 * attempt to recover should be made, {@code false} if no further attempt
	 * should be made.
	 * @since 4.1
	 */
	/**
	 * 使用指定的{@link  BackOffExecution}应用下一个退避时间。 
	 *  <p>如果已应用退避时间段并返回新的恢复尝试，则返回{@code  true}，如果不进行进一步尝试，则返回{@code  false}。 
	 *  @始于4.1
	 */
	protected boolean applyBackOffTime(BackOffExecution execution) {
		if (this.recovering && this.interrupted) {
			// Interrupted right before and still failing... give up.
			return false;
		}
		long interval = execution.nextBackOff();
		if (interval == BackOffExecution.STOP) {
			return false;
		}
		else {
			try {
				synchronized (this.lifecycleMonitor) {
					this.lifecycleMonitor.wait(interval);
				}
			}
			catch (InterruptedException interEx) {
				// Re-interrupt current thread, to allow other threads to react.
				Thread.currentThread().interrupt();
				if (this.recovering) {
					this.interrupted = true;
				}
			}
			return true;
		}
	}

	/**
	 * Return whether this listener container is currently in a recovery attempt.
	 * <p>May be used to detect recovery phases but also the end of a recovery phase,
	 * with {@code isRecovering()} switching to {@code false} after having been found
	 * to return {@code true} before.
	 * @see #recoverAfterListenerSetupFailure()
	 */
	/**
	 * 返回此侦听器容器当前是否正在尝试恢复。 
	 *  <p>可用于检测恢复阶段，但也可用于检测恢复阶段的结束，在发现返回{@code  true之后，{<@code> isRecovering（）}切换为{@code  false} }之前。 
	 *  
	 * @see  #recoverAfterListenerSetupFailure（）
	 */
	public final boolean isRecovering() {
		return this.recovering;
	}


	//-------------------------------------------------------------------------
	// Inner classes used as internal adapters
	//-------------------------------------------------------------------------

	/**
	 * Runnable that performs looped {@code MessageConsumer.receive()} calls.
	 */
	/**
	 * 运行循环{@code  MessageConsumer.receive（）}调用的Runnable。 
	 * 
	 */
	private class AsyncMessageListenerInvoker implements SchedulingAwareRunnable {

		@Nullable
		private Session session;

		@Nullable
		private MessageConsumer consumer;

		@Nullable
		private Object lastRecoveryMarker;

		private boolean lastMessageSucceeded;

		private int idleTaskExecutionCount = 0;

		private volatile boolean idle = true;

		@Nullable
		private volatile Thread currentReceiveThread;

		@Override
		public void run() {
			synchronized (lifecycleMonitor) {
				activeInvokerCount++;
				lifecycleMonitor.notifyAll();
			}
			boolean messageReceived = false;
			try {
				if (maxMessagesPerTask < 0) {
					messageReceived = executeOngoingLoop();
				}
				else {
					int messageCount = 0;
					while (isRunning() && messageCount < maxMessagesPerTask) {
						messageReceived = (invokeListener() || messageReceived);
						messageCount++;
					}
				}
			}
			catch (Throwable ex) {
				clearResources();
				if (!this.lastMessageSucceeded) {
					// We failed more than once in a row or on startup -
					// wait before first recovery attempt.
					waitBeforeRecoveryAttempt();
				}
				this.lastMessageSucceeded = false;
				boolean alreadyRecovered = false;
				synchronized (recoveryMonitor) {
					if (this.lastRecoveryMarker == currentRecoveryMarker) {
						handleListenerSetupFailure(ex, false);
						recoverAfterListenerSetupFailure();
						currentRecoveryMarker = new Object();
					}
					else {
						alreadyRecovered = true;
					}
				}
				if (alreadyRecovered) {
					handleListenerSetupFailure(ex, true);
				}
			}
			finally {
				synchronized (lifecycleMonitor) {
					decreaseActiveInvokerCount();
					lifecycleMonitor.notifyAll();
				}
				if (!messageReceived) {
					this.idleTaskExecutionCount++;
				}
				else {
					this.idleTaskExecutionCount = 0;
				}
				synchronized (lifecycleMonitor) {
					if (!shouldRescheduleInvoker(this.idleTaskExecutionCount) || !rescheduleTaskIfNecessary(this)) {
						// We're shutting down completely.
						scheduledInvokers.remove(this);
						if (logger.isDebugEnabled()) {
							logger.debug("Lowered scheduled invoker count: " + scheduledInvokers.size());
						}
						lifecycleMonitor.notifyAll();
						clearResources();
					}
					else if (isRunning()) {
						int nonPausedConsumers = getScheduledConsumerCount() - getPausedTaskCount();
						if (nonPausedConsumers < 1) {
							logger.error("All scheduled consumers have been paused, probably due to tasks having been rejected. " +
									"Check your thread pool configuration! Manual recovery necessary through a start() call.");
						}
						else if (nonPausedConsumers < getConcurrentConsumers()) {
							logger.warn("Number of scheduled consumers has dropped below concurrentConsumers limit, probably " +
									"due to tasks having been rejected. Check your thread pool configuration! Automatic recovery " +
									"to be triggered by remaining consumers.");
						}
					}
				}
			}
		}

		private boolean executeOngoingLoop() throws JMSException {
			boolean messageReceived = false;
			boolean active = true;
			while (active) {
				synchronized (lifecycleMonitor) {
					boolean interrupted = false;
					boolean wasWaiting = false;
					while ((active = isActive()) && !isRunning()) {
						if (interrupted) {
							throw new IllegalStateException("Thread was interrupted while waiting for " +
									"a restart of the listener container, but container is still stopped");
						}
						if (!wasWaiting) {
							decreaseActiveInvokerCount();
						}
						wasWaiting = true;
						try {
							lifecycleMonitor.wait();
						}
						catch (InterruptedException ex) {
							// Re-interrupt current thread, to allow other threads to react.
							Thread.currentThread().interrupt();
							interrupted = true;
						}
					}
					if (wasWaiting) {
						activeInvokerCount++;
					}
					if (scheduledInvokers.size() > maxConcurrentConsumers) {
						active = false;
					}
				}
				if (active) {
					messageReceived = (invokeListener() || messageReceived);
				}
			}
			return messageReceived;
		}

		private boolean invokeListener() throws JMSException {
			this.currentReceiveThread = Thread.currentThread();
			try {
				initResourcesIfNecessary();
				boolean messageReceived = receiveAndExecute(this, this.session, this.consumer);
				this.lastMessageSucceeded = true;
				return messageReceived;
			}
			finally {
				this.currentReceiveThread = null;
			}
		}

		private void decreaseActiveInvokerCount() {
			activeInvokerCount--;
			if (stopCallback != null && activeInvokerCount == 0) {
				stopCallback.run();
				stopCallback = null;
			}
		}

		private void initResourcesIfNecessary() throws JMSException {
			if (getCacheLevel() <= CACHE_CONNECTION) {
				updateRecoveryMarker();
			}
			else {
				if (this.session == null && getCacheLevel() >= CACHE_SESSION) {
					updateRecoveryMarker();
					this.session = createSession(getSharedConnection());
				}
				if (this.consumer == null && getCacheLevel() >= CACHE_CONSUMER) {
					this.consumer = createListenerConsumer(this.session);
					synchronized (lifecycleMonitor) {
						registeredWithDestination++;
					}
				}
			}
		}

		private void updateRecoveryMarker() {
			synchronized (recoveryMonitor) {
				this.lastRecoveryMarker = currentRecoveryMarker;
			}
		}

		private void interruptIfNecessary() {
			Thread currentReceiveThread = this.currentReceiveThread;
			if (currentReceiveThread != null && !currentReceiveThread.isInterrupted()) {
				currentReceiveThread.interrupt();
			}
		}

		private void clearResources() {
			if (sharedConnectionEnabled()) {
				synchronized (sharedConnectionMonitor) {
					JmsUtils.closeMessageConsumer(this.consumer);
					JmsUtils.closeSession(this.session);
				}
			}
			else {
				JmsUtils.closeMessageConsumer(this.consumer);
				JmsUtils.closeSession(this.session);
			}
			if (this.consumer != null) {
				synchronized (lifecycleMonitor) {
					registeredWithDestination--;
				}
			}
			this.consumer = null;
			this.session = null;
		}

		/**
		 * Apply the back-off time once. In a regular scenario, the back-off is only applied if we
		 * failed to recover with the broker. This additional wait period avoids a burst retry
		 * scenario when the broker is actually up but something else if failing (i.e. listener
		 * specific).
		 */
		/**
		 * 申请退避时间一次。 
		 * 在正常情况下，仅当我们无法通过代理恢复时才应用退避。 
		 * 这个额外的等待时间避免了当代理实际启动时出现突发重试的情况，但是避免了失败时的其他情况（即特定于侦听器）。 
		 * 
		 */
		private void waitBeforeRecoveryAttempt() {
			BackOffExecution execution = DefaultMessageListenerContainer.this.backOff.start();
			applyBackOffTime(execution);
		}

		@Override
		public boolean isLongLived() {
			return (maxMessagesPerTask < 0);
		}

		public void setIdle(boolean idle) {
			this.idle = idle;
		}

		public boolean isIdle() {
			return this.idle;
		}
	}

}
