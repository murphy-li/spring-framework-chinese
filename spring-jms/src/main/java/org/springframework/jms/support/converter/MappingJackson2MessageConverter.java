/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2019的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.jms.support.converter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;

import javax.jms.BytesMessage;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import javax.jms.TextMessage;

import com.fasterxml.jackson.annotation.JsonView;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.core.MethodParameter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;

/**
 * Message converter that uses Jackson 2.x to convert messages to and from JSON.
 * Maps an object to a {@link BytesMessage}, or to a {@link TextMessage} if the
 * {@link #setTargetType targetType} is set to {@link MessageType#TEXT}.
 * Converts from a {@link TextMessage} or {@link BytesMessage} to an object.
 *
 * <p>It customizes Jackson's default properties with the following ones:
 * <ul>
 * <li>{@link MapperFeature#DEFAULT_VIEW_INCLUSION} is disabled</li>
 * <li>{@link DeserializationFeature#FAIL_ON_UNKNOWN_PROPERTIES} is disabled</li>
 * </ul>
 *
 * <p>Compatible with Jackson 2.6 and higher, as of Spring 4.3.
 *
 * @author Mark Pollack
 * @author Dave Syer
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 * @since 3.1.4
 */
/**
 * 使用Jackson 2.x在JSON之间来回转换消息的消息转换器。 
 * 如果将{@link  #setTargetType targetType}设置为{@link  MessageType＃TEXT}，则将对象映射到{@link  BytesMessage}或{{@link> TextMessage}。 
 * 从{@link  TextMessage}或{@link  BytesMessage}转换为对象。 
 *  <p>它使用以下内容自定义Jackson的默认属性：<ul> <li> {<@link> MapperFeature＃DEFAULT_VIEW_INCLUSION}已禁用</ li> <li> {<@link> DeserializationFeature＃FAIL_ON_UNKNOWN_PROPERTIES}已禁用</ </ li> </ ul> <p>从Spring 4.3开始与Jackson 2.6和更高版本兼容。 
 *  @author  Mark Pollack @author  Dave Syer @author  Juergen Hoeller @author  Stephane Nicoll @3.1.4起
 */
public class MappingJackson2MessageConverter implements SmartMessageConverter, BeanClassLoaderAware {

	/**
	 * The default encoding used for writing to text messages: UTF-8.
	 */
	/**
	 * 用于写短信的默认编码为：UTF-8。 
	 * 
	 */
	public static final String DEFAULT_ENCODING = "UTF-8";


	private ObjectMapper objectMapper;

	private MessageType targetType = MessageType.BYTES;

	@Nullable
	private String encoding;

	@Nullable
	private String encodingPropertyName;

	@Nullable
	private String typeIdPropertyName;

	private Map<String, Class<?>> idClassMappings = new HashMap<>();

	private Map<Class<?>, String> classIdMappings = new HashMap<>();

	@Nullable
	private ClassLoader beanClassLoader;


	public MappingJackson2MessageConverter() {
		this.objectMapper = new ObjectMapper();
		this.objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false);
		this.objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
	}

	/**
	 * Specify the {@link ObjectMapper} to use instead of using the default.
	 */
	/**
	 * 指定要使用的{@link  ObjectMapper}而不是使用默认值。 
	 * 
	 */
	public void setObjectMapper(ObjectMapper objectMapper) {
		Assert.notNull(objectMapper, "ObjectMapper must not be null");
		this.objectMapper = objectMapper;
	}

	/**
	 * Specify whether {@link #toMessage(Object, Session)} should marshal to a
	 * {@link BytesMessage} or a {@link TextMessage}.
	 * <p>The default is {@link MessageType#BYTES}, i.e. this converter marshals to
	 * a {@link BytesMessage}. Note that the default version of this converter
	 * supports {@link MessageType#BYTES} and {@link MessageType#TEXT} only.
	 * @see MessageType#BYTES
	 * @see MessageType#TEXT
	 */
	/**
	 * 指定{@link  #toMessage（Object，Session）}应该编组为{@link  BytesMessage}还是{@link  TextMessage}。 
	 *  <p>默认值为{@link  MessageType＃BYTES}，即此转换器将编组为{@link  BytesMessage}。 
	 * 请注意，此转换器的默认版本仅支持{@link  MessageType＃BYTES}和{@link  MessageType＃TEXT}。 
	 *  
	 * @see  MessageType＃BYTES 
	 * @see  MessageType＃TEXT
	 */
	public void setTargetType(MessageType targetType) {
		Assert.notNull(targetType, "MessageType must not be null");
		this.targetType = targetType;
	}

	/**
	 * Specify the encoding to use when converting to and from text-based
	 * message body content. The default encoding will be "UTF-8".
	 * <p>When reading from a a text-based message, an encoding may have been
	 * suggested through a special JMS property which will then be preferred
	 * over the encoding set on this MessageConverter instance.
	 * @see #setEncodingPropertyName
	 */
	/**
	 * 指定在与基于文本的邮件正文内容之间进行转换时要使用的编码。 
	 * 默认编码为"UTF-8"。 
	 *  <p>从基于文本的消息中读取时，可能已经通过特殊的JMS属性建议了编码，该属性将比在此MessageConverter实例上设置的编码优先。 
	 *  
	 * @see  #setEncodingPropertyName
	 */
	public void setEncoding(String encoding) {
		this.encoding = encoding;
	}

	/**
	 * Specify the name of the JMS message property that carries the encoding from
	 * bytes to String and back is BytesMessage is used during the conversion process.
	 * <p>Default is none. Setting this property is optional; if not set, UTF-8 will
	 * be used for decoding any incoming bytes message.
	 * @see #setEncoding
	 */
	/**
	 * 指定JMS消息属性的名称，该属性携带从字节到字符串的编码，然后返回，即在转换过程中使用BytesMessage。 
	 *  <p>默认为无。 
	 * 设置此属性是可选的； 
	 * 如果未设置，则UTF-8将用于解码任何传入的字节消息。 
	 *  
	 * @see  #setEncoding
	 */
	public void setEncodingPropertyName(String encodingPropertyName) {
		this.encodingPropertyName = encodingPropertyName;
	}

	/**
	 * Specify the name of the JMS message property that carries the type id for the
	 * contained object: either a mapped id value or a raw Java class name.
	 * <p>Default is none. <b>NOTE: This property needs to be set in order to allow
	 * for converting from an incoming message to a Java object.</b>
	 * @see #setTypeIdMappings
	 */
	/**
	 * 指定带有所包含对象的类型ID的JMS消息属性的名称：映射ID值或原始Java类名称。 
	 *  <p>默认为无。 
	 *  <b>注意：需要设置此属性，以允许从传入消息转换为Java对象。 
	 * </ b> 
	 * @see  #setTypeIdMappings
	 */
	public void setTypeIdPropertyName(String typeIdPropertyName) {
		this.typeIdPropertyName = typeIdPropertyName;
	}

	/**
	 * Specify mappings from type ids to Java classes, if desired.
	 * This allows for synthetic ids in the type id message property,
	 * instead of transferring Java class names.
	 * <p>Default is no custom mappings, i.e. transferring raw Java class names.
	 * @param typeIdMappings a Map with type id values as keys and Java classes as values
	 */
	/**
	 * 如果需要，请指定从类型ID到Java类的映射。 
	 * 这允许在类型id消息属性中使用合成ID，而不是传输Java类名称。 
	 *  <p>默认为没有自定义映射，即传输原始Java类名称。 
	 *  
	 * @param  typeId映射以类型id值作为键和Java类作为值的Map
	 */
	public void setTypeIdMappings(Map<String, Class<?>> typeIdMappings) {
		this.idClassMappings = new HashMap<>();
		typeIdMappings.forEach((id, clazz) -> {
			this.idClassMappings.put(id, clazz);
			this.classIdMappings.put(clazz, id);
		});
	}

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}


	@Override
	public Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {
		Message message;
		try {
			switch (this.targetType) {
				case TEXT:
					message = mapToTextMessage(object, session, this.objectMapper.writer());
					break;
				case BYTES:
					message = mapToBytesMessage(object, session, this.objectMapper.writer());
					break;
				default:
					message = mapToMessage(object, session, this.objectMapper.writer(), this.targetType);
			}
		}
		catch (IOException ex) {
			throw new MessageConversionException("Could not map JSON object [" + object + "]", ex);
		}
		setTypeIdOnMessage(object, message);
		return message;
	}

	@Override
	public Message toMessage(Object object, Session session, @Nullable Object conversionHint)
			throws JMSException, MessageConversionException {

		return toMessage(object, session, getSerializationView(conversionHint));
	}

	/**
	 * Convert a Java object to a JMS Message using the specified json view
	 * and the supplied session  to create the message object.
	 * @param object the object to convert
	 * @param session the Session to use for creating a JMS Message
	 * @param jsonView the view to use to filter the content
	 * @return the JMS Message
	 * @throws javax.jms.JMSException if thrown by JMS API methods
	 * @throws MessageConversionException in case of conversion failure
	 * @since 4.3
	 */
	/**
	 * 使用指定的json视图和提供的会话将Java对象转换为JMS Message，以创建消息对象。 
	 *  
	 * @param 对象要转换的对象
	 * @param 会话用于创建JMS消息的Session 
	 * @param  jsonView用于过滤内容的视图
	 * @return  JMS消息
	 * @throws  javax.jms .JMSException，如果由JMS API方法
	 * @throws 引发，则在转换失败时出现MessageConversionException @4.3起
	 */
	public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView)
			throws JMSException, MessageConversionException {

		if (jsonView != null) {
			return toMessage(object, session, this.objectMapper.writerWithView(jsonView));
		}
		else {
			return toMessage(object, session, this.objectMapper.writer());
		}
	}

	@Override
	public Object fromMessage(Message message) throws JMSException, MessageConversionException {
		try {
			JavaType targetJavaType = getJavaTypeForMessage(message);
			return convertToObject(message, targetJavaType);
		}
		catch (IOException ex) {
			throw new MessageConversionException("Failed to convert JSON message content", ex);
		}
	}

	protected Message toMessage(Object object, Session session, ObjectWriter objectWriter)
			throws JMSException, MessageConversionException {

		Message message;
		try {
			switch (this.targetType) {
				case TEXT:
					message = mapToTextMessage(object, session, objectWriter);
					break;
				case BYTES:
					message = mapToBytesMessage(object, session, objectWriter);
					break;
				default:
					message = mapToMessage(object, session, objectWriter, this.targetType);
			}
		}
		catch (IOException ex) {
			throw new MessageConversionException("Could not map JSON object [" + object + "]", ex);
		}
		setTypeIdOnMessage(object, message);
		return message;
	}


	/**
	 * Map the given object to a {@link TextMessage}.
	 * @param object the object to be mapped
	 * @param session current JMS session
	 * @param objectWriter the writer to use
	 * @return the resulting message
	 * @throws JMSException if thrown by JMS methods
	 * @throws IOException in case of I/O errors
	 * @since 4.3
	 * @see Session#createBytesMessage
	 */
	/**
	 * 将给定的对象映射到{@link  TextMessage}。 
	 *  
	 * @param 对象要映射的对象
	 * @param 会话当前JMS会话
	 * @param  objectWriter编写器以使用
	 * @return 结果消息
	 * @throws  JMSException（如果被JMS方法抛出） I / O错误的情况（自4.3开始）
	 * @see  Session＃createBytesMessage
	 */
	protected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter)
			throws JMSException, IOException {

		StringWriter writer = new StringWriter();
		objectWriter.writeValue(writer, object);
		return session.createTextMessage(writer.toString());
	}

	/**
	 * Map the given object to a {@link BytesMessage}.
	 * @param object the object to be mapped
	 * @param session current JMS session
	 * @param objectWriter the writer to use
	 * @return the resulting message
	 * @throws JMSException if thrown by JMS methods
	 * @throws IOException in case of I/O errors
	 * @since 4.3
	 * @see Session#createBytesMessage
	 */
	/**
	 * 将给定的对象映射到{@link  BytesMessage}。 
	 *  
	 * @param 对象要映射的对象
	 * @param 会话当前JMS会话
	 * @param  objectWriter编写器以使用
	 * @return 结果消息
	 * @throws  JMSException（如果被JMS方法抛出） I / O错误的情况（自4.3开始）
	 * @see  Session＃createBytesMessage
	 */
	protected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter)
			throws JMSException, IOException {

		ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
		if (this.encoding != null) {
			OutputStreamWriter writer = new OutputStreamWriter(bos, this.encoding);
			objectWriter.writeValue(writer, object);
		}
		else {
			// Jackson usually defaults to UTF-8 but can also go straight to bytes, e.g. for Smile.
			// We use a direct byte array argument for the latter case to work as well.
			objectWriter.writeValue(bos, object);
		}

		BytesMessage message = session.createBytesMessage();
		message.writeBytes(bos.toByteArray());
		if (this.encodingPropertyName != null) {
			message.setStringProperty(this.encodingPropertyName,
					(this.encoding != null ? this.encoding : DEFAULT_ENCODING));
		}
		return message;
	}

	/**
	 * Template method that allows for custom message mapping.
	 * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or
	 * {@link MessageType#BYTES}.
	 * <p>The default implementation throws an {@link IllegalArgumentException}.
	 * @param object the object to marshal
	 * @param session the JMS Session
	 * @param objectWriter the writer to use
	 * @param targetType the target message type (other than TEXT or BYTES)
	 * @return the resulting message
	 * @throws JMSException if thrown by JMS methods
	 * @throws IOException in case of I/O errors
	 */
	/**
	 * 允许自定义消息映射的模板方法。 
	 * 当{@link  #setTargetType}不是{@link  MessageType＃TEXT}或{@link  MessageType＃BYTES}时调用。 
	 *  <p>默认实现会引发一个{@link  IllegalArgumentException}。 
	 *  
	 * @param 对象要编组的对象
	 * @param 会话JMS会话
	 * @param  object编写器以使用
	 * @param  targetType目标消息类型（TEXT或BYTES除外）
	 * @return 结果消息<如果I / O错误，则由JMS方法
	 * @throws  IOException抛出@
	 * @throws> JMSException
	 */
	protected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType)
			throws JMSException, IOException {

		throw new IllegalArgumentException("Unsupported message type [" + targetType +
				"]. MappingJackson2MessageConverter by default only supports TextMessages and BytesMessages.");
	}

	/**
	 * Set a type id for the given payload object on the given JMS Message.
	 * <p>The default implementation consults the configured type id mapping and
	 * sets the resulting value (either a mapped id or the raw Java class name)
	 * into the configured type id message property.
	 * @param object the payload object to set a type id for
	 * @param message the JMS Message on which to set the type id property
	 * @throws JMSException if thrown by JMS methods
	 * @see #getJavaTypeForMessage(javax.jms.Message)
	 * @see #setTypeIdPropertyName(String)
	 * @see #setTypeIdMappings(java.util.Map)
	 */
	/**
	 * 在给定的JMS消息上为给定的有效负载对象设置类型ID。 
	 *  <p>默认实现参考已配置的类型ID映射，并将结果值（已映射的ID或原始Java类名称）设置为已配置的类型ID消息属性。 
	 *  
	 * @param 对象负载对象，用于为
	 * @param 消息设置类型ID的JMS消息，在其上设置类型ID属性
	 * @throws  JMSException，如果被JMS方法抛出
	 * @see  #getJavaTypeForMessage（javax.jms .Message）
	 * @see  #setTypeIdPropertyName（String）
	 * @see  #setTypeIdMappings（java.util.Map）
	 */
	protected void setTypeIdOnMessage(Object object, Message message) throws JMSException {
		if (this.typeIdPropertyName != null) {
			String typeId = this.classIdMappings.get(object.getClass());
			if (typeId == null) {
				typeId = object.getClass().getName();
			}
			message.setStringProperty(this.typeIdPropertyName, typeId);
		}
	}

	/**
	 * Convenience method to dispatch to converters for individual message types.
	 */
	/**
	 * 为单个消息类型调度到转换器的便捷方法。 
	 * 
	 */
	private Object convertToObject(Message message, JavaType targetJavaType) throws JMSException, IOException {
		if (message instanceof TextMessage) {
			return convertFromTextMessage((TextMessage) message, targetJavaType);
		}
		else if (message instanceof BytesMessage) {
			return convertFromBytesMessage((BytesMessage) message, targetJavaType);
		}
		else {
			return convertFromMessage(message, targetJavaType);
		}
	}

	/**
	 * Convert a TextMessage to a Java Object with the specified type.
	 * @param message the input message
	 * @param targetJavaType the target type
	 * @return the message converted to an object
	 * @throws JMSException if thrown by JMS
	 * @throws IOException in case of I/O errors
	 */
	/**
	 * 将TextMessage转换为具有指定类型的Java对象。 
	 *  
	 * @param 消息输入消息
	 * @param  targetJavaType目标类型
	 * @return 消息转换为对象
	 * @throws  JMSException如果被JMS抛出
	 * @throws  IOException如果发生I / O错误
	 */
	protected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType)
			throws JMSException, IOException {

		String body = message.getText();
		return this.objectMapper.readValue(body, targetJavaType);
	}

	/**
	 * Convert a BytesMessage to a Java Object with the specified type.
	 * @param message the input message
	 * @param targetJavaType the target type
	 * @return the message converted to an object
	 * @throws JMSException if thrown by JMS
	 * @throws IOException in case of I/O errors
	 */
	/**
	 * 将BytesMessage转换为具有指定类型的Java对象。 
	 *  
	 * @param 消息输入消息
	 * @param  targetJavaType目标类型
	 * @return 消息转换为对象
	 * @throws  JMSException如果被JMS抛出
	 * @throws  IOException如果发生I / O错误
	 */
	protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType)
			throws JMSException, IOException {

		String encoding = this.encoding;
		if (this.encodingPropertyName != null && message.propertyExists(this.encodingPropertyName)) {
			encoding = message.getStringProperty(this.encodingPropertyName);
		}
		byte[] bytes = new byte[(int) message.getBodyLength()];
		message.readBytes(bytes);
		if (encoding != null) {
			try {
				String body = new String(bytes, encoding);
				return this.objectMapper.readValue(body, targetJavaType);
			}
			catch (UnsupportedEncodingException ex) {
				throw new MessageConversionException("Cannot convert bytes to String", ex);
			}
		}
		else {
			// Jackson internally performs encoding detection, falling back to UTF-8.
			return this.objectMapper.readValue(bytes, targetJavaType);
		}
	}

	/**
	 * Template method that allows for custom message mapping.
	 * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or
	 * {@link MessageType#BYTES}.
	 * <p>The default implementation throws an {@link IllegalArgumentException}.
	 * @param message the input message
	 * @param targetJavaType the target type
	 * @return the message converted to an object
	 * @throws JMSException if thrown by JMS
	 * @throws IOException in case of I/O errors
	 */
	/**
	 * 允许自定义消息映射的模板方法。 
	 * 当{@link  #setTargetType}不是{@link  MessageType＃TEXT}或{@link  MessageType＃BYTES}时调用。 
	 *  <p>默认实现会引发一个{@link  IllegalArgumentException}。 
	 *  
	 * @param 消息输入消息
	 * @param  targetJavaType目标类型
	 * @return 消息转换为对象
	 * @throws  JMSException如果被JMS抛出
	 * @throws  IOException如果发生I / O错误
	 */
	protected Object convertFromMessage(Message message, JavaType targetJavaType)
			throws JMSException, IOException {

		throw new IllegalArgumentException("Unsupported message type [" + message.getClass() +
				"]. MappingJacksonMessageConverter by default only supports TextMessages and BytesMessages.");
	}

	/**
	 * Determine a Jackson JavaType for the given JMS Message,
	 * typically parsing a type id message property.
	 * <p>The default implementation parses the configured type id property name
	 * and consults the configured type id mapping. This can be overridden with
	 * a different strategy, e.g. doing some heuristics based on message origin.
	 * @param message the JMS Message from which to get the type id property
	 * @throws JMSException if thrown by JMS methods
	 * @see #setTypeIdOnMessage(Object, javax.jms.Message)
	 * @see #setTypeIdPropertyName(String)
	 * @see #setTypeIdMappings(java.util.Map)
	 */
	/**
	 * 为给定的JMS消息确定Jackson的JavaType，通常是解析type id message属性。 
	 *  <p>默认实现解析配置的类型ID属性名称，并查询配置的类型ID映射。 
	 * 这可以用其他策略来覆盖，例如根据消息来源进行启发式搜索
	 * @param 消息从中获取类型ID属性的JMS消息
	 * @throws 如果被JMS方法抛出，则JMSException 
	 * @see  #setTypeIdOnMessage（Object，javax.jms.Message）
	 * @see  #setTypeIdPropertyName（String） 
	 * @see  #setTypeIdMappings（java.util.Map）
	 */
	protected JavaType getJavaTypeForMessage(Message message) throws JMSException {
		String typeId = message.getStringProperty(this.typeIdPropertyName);
		if (typeId == null) {
			throw new MessageConversionException(
					"Could not find type id property [" + this.typeIdPropertyName + "] on message [" +
					message.getJMSMessageID() + "] from destination [" + message.getJMSDestination() + "]");
		}
		Class<?> mappedClass = this.idClassMappings.get(typeId);
		if (mappedClass != null) {
			return this.objectMapper.getTypeFactory().constructType(mappedClass);
		}
		try {
			Class<?> typeClass = ClassUtils.forName(typeId, this.beanClassLoader);
			return this.objectMapper.getTypeFactory().constructType(typeClass);
		}
		catch (Throwable ex) {
			throw new MessageConversionException("Failed to resolve type id [" + typeId + "]", ex);
		}
	}

	/**
	 * Determine a Jackson serialization view based on the given conversion hint.
	 * @param conversionHint the conversion hint Object as passed into the
	 * converter for the current conversion attempt
	 * @return the serialization view class, or {@code null} if none
	 */
	/**
	 * 根据给定的转换提示确定Jackson的序列化视图。 
	 *  
	 * @param  conversion提示为当前转换尝试传递到转换器中的转换提示对象
	 * @return 序列化视图类，如果没有，则为{@code  null}
	 */
	@Nullable
	protected Class<?> getSerializationView(@Nullable Object conversionHint) {
		if (conversionHint instanceof MethodParameter) {
			MethodParameter methodParam = (MethodParameter) conversionHint;
			JsonView annotation = methodParam.getParameterAnnotation(JsonView.class);
			if (annotation == null) {
				annotation = methodParam.getMethodAnnotation(JsonView.class);
				if (annotation == null) {
					return null;
				}
			}
			return extractViewClass(annotation, conversionHint);
		}
		else if (conversionHint instanceof JsonView) {
			return extractViewClass((JsonView) conversionHint, conversionHint);
		}
		else if (conversionHint instanceof Class) {
			return (Class<?>) conversionHint;
		}
		else {
			return null;
		}
	}

	private Class<?> extractViewClass(JsonView annotation, Object conversionHint) {
		Class<?>[] classes = annotation.value();
		if (classes.length != 1) {
			throw new IllegalArgumentException(
					"@JsonView only supported for handler methods with exactly 1 class argument: " + conversionHint);
		}
		return classes[0];
	}

}
