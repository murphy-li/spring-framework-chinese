/** Generated by english-annotation-buster, Powered by Google Translate.**/
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 版权所有2002-2017的原始作者或作者。 
 * 根据Apache许可证2.0版（"许可证"）获得许可； 
 * 除非遵守许可，否则不得使用此文件。 
 * 您可以在https://www.apache.org/licenses/LICENSE-2.0上获得许可的副本。 
 * 除非适用法律要求或以书面形式同意，否则根据"许可"分发的软件将按"现状"分发，没有任何明示或暗示的保证或条件。 
 * 有关许可下特定的语言管理权限和限制，请参阅许可。 
 * 
 */

package org.springframework.aop.interceptor;

import java.io.Serializable;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.aop.support.AopUtils;
import org.springframework.lang.Nullable;

/**
 * Base {@code MethodInterceptor} implementation for tracing.
 *
 * <p>By default, log messages are written to the log for the interceptor class,
 * not the class which is being intercepted. Setting the {@code useDynamicLogger}
 * bean property to {@code true} causes all log messages to be written to
 * the {@code Log} for the target class being intercepted.
 *
 * <p>Subclasses must implement the {@code invokeUnderTrace} method, which
 * is invoked by this class ONLY when a particular invocation SHOULD be traced.
 * Subclasses should write to the {@code Log} instance provided.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @since 1.2
 * @see #setUseDynamicLogger
 * @see #invokeUnderTrace(org.aopalliance.intercept.MethodInvocation, org.apache.commons.logging.Log)
 */
/**
 * 用于跟踪的基础{@code  MethodInterceptor}实现。 
 *  <p>默认情况下，日志消息被写入拦截器类的日志，而不是被拦截的类。 
 * 将{@code  useDynamicLogger} bean属性设置为{@code  true}会导致将所有日志消息写入要拦截的目标类的{@code  Log}。 
 *  <p>子类必须实现{@code  invokeUnderTrace}方法，该方法仅在应跟踪特定的调用时才由此类调用。 
 * 子类应写入提供的{@code  Log}实例。 
 *  @author 罗布·哈罗普（Rob Harrop）@author 于尔根·霍勒（Juergen Hoeller）@自1.2起
 */
@SuppressWarnings("serial")
public abstract class AbstractTraceInterceptor implements MethodInterceptor, Serializable {

	/**
	 * The default {@code Log} instance used to write trace messages.
	 * This instance is mapped to the implementing {@code Class}.
	 */
	/**
	 * 用于写入跟踪消息的默认{@code  Log}实例。 
	 * 该实例映射到实现中的{@code  Class}。 
	 * 
	 */
	@Nullable
	protected transient Log defaultLogger = LogFactory.getLog(getClass());

	/**
	 * Indicates whether or not proxy class names should be hidden when using dynamic loggers.
	 * @see #setUseDynamicLogger
	 */
	/**
	 * 指示在使用动态记录器时是否应隐藏代理类名称。 
	 *  
	 * @see  #setUseDynamicLogger
	 */
	private boolean hideProxyClassNames = false;

	/**
	 * Indicates whether to pass an exception to the logger.
	 * @see #writeToLog(Log, String, Throwable)
	 */
	/**
	 * 指示是否将异常传递给记录器。 
	 *  
	 * @see  #writeToLog（日志，字符串，可抛出）
	 */
	private boolean logExceptionStackTrace = true;


	/**
	 * Set whether to use a dynamic logger or a static logger.
	 * Default is a static logger for this trace interceptor.
	 * <p>Used to determine which {@code Log} instance should be used to write
	 * log messages for a particular method invocation: a dynamic one for the
	 * {@code Class} getting called, or a static one for the {@code Class}
	 * of the trace interceptor.
	 * <p><b>NOTE:</b> Specify either this property or "loggerName", not both.
	 * @see #getLoggerForInvocation(org.aopalliance.intercept.MethodInvocation)
	 */
	/**
	 * 设置使用动态记录器还是静态记录器。 
	 * 默认值为此跟踪拦截器的静态记录器。 
	 *  <p>用于确定应使用哪个{@code  Log}实例来为特定方法调用编写日志消息：被调用的{@code  Class}是动态的，或者是{跟踪拦截器的@code 类}。 
	 *  <p> <b>注意：</ b>请同时指定此属性或"loggerName"。 
	 *  
	 * @see  #getLoggerForInvocation（org.aopalliance.intercept.MethodInvocation）
	 */
	public void setUseDynamicLogger(boolean useDynamicLogger) {
		// Release default logger if it is not being used.
		this.defaultLogger = (useDynamicLogger ? null : LogFactory.getLog(getClass()));
	}

	/**
	 * Set the name of the logger to use. The name will be passed to the
	 * underlying logger implementation through Commons Logging, getting
	 * interpreted as log category according to the logger's configuration.
	 * <p>This can be specified to not log into the category of a class
	 * (whether this interceptor's class or the class getting called)
	 * but rather into a specific named category.
	 * <p><b>NOTE:</b> Specify either this property or "useDynamicLogger", not both.
	 * @see org.apache.commons.logging.LogFactory#getLog(String)
	 * @see java.util.logging.Logger#getLogger(String)
	 */
	/**
	 * 设置要使用的记录器的名称。 
	 * 该名称将通过Commons Logging传递给基础记录器实现，根据记录器的配置将其解释为日志类别。 
	 *  <p>可以将其指定为不登录到类的类别（无论是该拦截器的类还是被调用的类），而是登录到特定的命名类别。 
	 *  <p> <b>注意：</ b>请同时指定此属性或"useDynamicLogger"。 
	 *  
	 * @see  org.apache.commons.logging.LogFactory＃getLog（String）
	 * @see  java.util.logging.Logger＃getLogger（String）
	 */
	public void setLoggerName(String loggerName) {
		this.defaultLogger = LogFactory.getLog(loggerName);
	}

	/**
	 * Set to "true" to have {@link #setUseDynamicLogger dynamic loggers} hide
	 * proxy class names wherever possible. Default is "false".
	 */
	/**
	 * 设置为"true"以使{@link  #setUseDynamicLogger动态记录器}尽可能隐藏代理类名称。 
	 * 默认值为"false"。 
	 * 
	 */
	public void setHideProxyClassNames(boolean hideProxyClassNames) {
		this.hideProxyClassNames = hideProxyClassNames;
	}

	/**
	 * Set whether to pass an exception to the logger, suggesting inclusion
	 * of its stack trace into the log. Default is "true"; set this to "false"
	 * in order to reduce the log output to just the trace message (which may
	 * include the exception class name and exception message, if applicable).
	 * @since 4.3.10
	 */
	/**
	 * 设置是否将异常传递给记录器，建议将其堆栈跟踪包括在日志中。 
	 * 默认值为"true"； 
	 * 将其设置为"false"，以便将日志输出减少为仅跟踪消息（如果适用，可能包括异常类名称和异常消息）。 
	 *  @自4.3.10起
	 */
	public void setLogExceptionStackTrace(boolean logExceptionStackTrace) {
		this.logExceptionStackTrace = logExceptionStackTrace;
	}


	/**
	 * Determines whether or not logging is enabled for the particular {@code MethodInvocation}.
	 * If not, the method invocation proceeds as normal, otherwise the method invocation is passed
	 * to the {@code invokeUnderTrace} method for handling.
	 * @see #invokeUnderTrace(org.aopalliance.intercept.MethodInvocation, org.apache.commons.logging.Log)
	 */
	/**
	 * 确定是否为特定的{@code  MethodInvocation}启用日志记录。 
	 * 如果不是，则方法调用照常进行，否则将方法调用传递给{@code  invokeUnderTrace}方法进行处理。 
	 *  
	 * @see  #invokeUnderTrace（org.aopalliance.intercept.MethodInvocation，org.apache.commons.logging.Log）
	 */
	@Override
	@Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {
		Log logger = getLoggerForInvocation(invocation);
		if (isInterceptorEnabled(invocation, logger)) {
			return invokeUnderTrace(invocation, logger);
		}
		else {
			return invocation.proceed();
		}
	}

	/**
	 * Return the appropriate {@code Log} instance to use for the given
	 * {@code MethodInvocation}. If the {@code useDynamicLogger} flag
	 * is set, the {@code Log} instance will be for the target class of the
	 * {@code MethodInvocation}, otherwise the {@code Log} will be the
	 * default static logger.
	 * @param invocation the {@code MethodInvocation} being traced
	 * @return the {@code Log} instance to use
	 * @see #setUseDynamicLogger
	 */
	/**
	 * 返回适当的{@code  Log}实例，以用于给定的{@code  MethodInvocation}。 
	 * 如果设置了{@code  useDynamicLogger}标志，则{@code  Log}实例将用于{@code  MethodInvocation}的目标类，否则{{@@code> Log}将是默认静态记录器。 
	 *  
	 * @param 调用跟踪的{@code  MethodInvocation} 
	 * @return  {@code  Log}实例以使用
	 * @see  #setUseDynamicLogger
	 */
	protected Log getLoggerForInvocation(MethodInvocation invocation) {
		if (this.defaultLogger != null) {
			return this.defaultLogger;
		}
		else {
			Object target = invocation.getThis();
			return LogFactory.getLog(getClassForLogging(target));
		}
	}

	/**
	 * Determine the class to use for logging purposes.
	 * @param target the target object to introspect
	 * @return the target class for the given object
	 * @see #setHideProxyClassNames
	 */
	/**
	 * 确定用于记录目的的类。 
	 *  
	 * @param 以目标对象为内省
	 * @return 给定对象的目标类
	 * @see  #setHideProxyClassNames
	 */
	protected Class<?> getClassForLogging(Object target) {
		return (this.hideProxyClassNames ? AopUtils.getTargetClass(target) : target.getClass());
	}

	/**
	 * Determine whether the interceptor should kick in, that is,
	 * whether the {@code invokeUnderTrace} method should be called.
	 * <p>Default behavior is to check whether the given {@code Log}
	 * instance is enabled. Subclasses can override this to apply the
	 * interceptor in other cases as well.
	 * @param invocation the {@code MethodInvocation} being traced
	 * @param logger the {@code Log} instance to check
	 * @see #invokeUnderTrace
	 * @see #isLogEnabled
	 */
	/**
	 * 确定拦截器是否应该启动，即是否应调用{@code  invokeUnderTrace}方法。 
	 *  <p>默认行为是检查给定的{@code  Log}实例是否已启用。 
	 * 子类也可以重写此方法以在其他情况下应用拦截器。 
	 *  
	 * @param 调用{@code  MethodInvocation}被跟踪
	 * @param 记录器{@code  Log}实例以检查
	 * @see  #invokeUnderTrace 
	 * @see  #isLogEnabled
	 */
	protected boolean isInterceptorEnabled(MethodInvocation invocation, Log logger) {
		return isLogEnabled(logger);
	}

	/**
	 * Determine whether the given {@link Log} instance is enabled.
	 * <p>Default is {@code true} when the "trace" level is enabled.
	 * Subclasses can override this to change the level under which 'tracing' occurs.
	 * @param logger the {@code Log} instance to check
	 */
	/**
	 * 确定是否启用了给定的{@link  Log}实例。 
	 *  <p>启用"跟踪"级别时，默认值为{@code  true}。 
	 * 子类可以覆盖此设置，以更改发生"跟踪"的级别。 
	 *  
	 * @param 记录{@code  Log}实例以进行检查
	 */
	protected boolean isLogEnabled(Log logger) {
		return logger.isTraceEnabled();
	}

	/**
	 * Write the supplied trace message to the supplied {@code Log} instance.
	 * <p>To be called by {@link #invokeUnderTrace} for enter/exit messages.
	 * <p>Delegates to {@link #writeToLog(Log, String, Throwable)} as the
	 * ultimate delegate that controls the underlying logger invocation.
	 * @since 4.3.10
	 * @see #writeToLog(Log, String, Throwable)
	 */
	/**
	 * 将提供的跟踪消息写入提供的{@code  Log}实例。 
	 *  <p>由{@link  #invokeUnderTrace}调用以输入/退出消息。 
	 *  <p>作为控制基础记录器调用的最终委托，委托给{@link  #writeToLog（Log，String，Throwable）}。 
	 *  @since 4.3.10 
	 * @see  #writeToLog（日志，字符串，可抛出）
	 */
	protected void writeToLog(Log logger, String message) {
		writeToLog(logger, message, null);
	}

	/**
	 * Write the supplied trace message and {@link Throwable} to the
	 * supplied {@code Log} instance.
	 * <p>To be called by {@link #invokeUnderTrace} for enter/exit outcomes,
	 * potentially including an exception. Note that an exception's stack trace
	 * won't get logged when {@link #setLogExceptionStackTrace} is "false".
	 * <p>By default messages are written at {@code TRACE} level. Subclasses
	 * can override this method to control which level the message is written
	 * at, typically also overriding {@link #isLogEnabled} accordingly.
	 * @since 4.3.10
	 * @see #setLogExceptionStackTrace
	 * @see #isLogEnabled
	 */
	/**
	 * 将提供的跟踪消息和{@link  Throwable}写入提供的{@code  Log}实例。 
	 *  <p>由{@link  #invokeUnderTrace}调用以获取进入/退出结果，可能包括异常。 
	 * 请注意，当{@link  #setLogExceptionStackTrace}为"false"时，不会记录异常的堆栈跟踪。 
	 *  <p>默认情况下，消息以{@code  TRACE}级别编写。 
	 * 子类可以重写此方法来控制消息的编写级别，通常还相应地重写{@link  #isLogEnabled}。 
	 *  @since 4.3.10 
	 * @see  #setLogExceptionStackTrace 
	 * @see  #isLogEnabled
	 */
	protected void writeToLog(Log logger, String message, @Nullable Throwable ex) {
		if (ex != null && this.logExceptionStackTrace) {
			logger.trace(message, ex);
		}
		else {
			logger.trace(message);
		}
	}


	/**
	 * Subclasses must override this method to perform any tracing around the
	 * supplied {@code MethodInvocation}. Subclasses are responsible for
	 * ensuring that the {@code MethodInvocation} actually executes by
	 * calling {@code MethodInvocation.proceed()}.
	 * <p>By default, the passed-in {@code Log} instance will have log level
	 * "trace" enabled. Subclasses do not have to check for this again, unless
	 * they overwrite the {@code isInterceptorEnabled} method to modify
	 * the default behavior, and may delegate to {@code writeToLog} for actual
	 * messages to be written.
	 * @param logger the {@code Log} to write trace messages to
	 * @return the result of the call to {@code MethodInvocation.proceed()}
	 * @throws Throwable if the call to {@code MethodInvocation.proceed()}
	 * encountered any errors
	 * @see #isLogEnabled
	 * @see #writeToLog(Log, String)
	 * @see #writeToLog(Log, String, Throwable)
	 */
	/**
	 * 子类必须重写此方法，以对提供的{@code  MethodInvocation}进行任何跟踪。 
	 * 子类负责通过调用{@code  MethodInvocation.proceed（）}确保{@code  MethodInvocation}实际执行。 
	 *  <p>默认情况下，传入的{@code  Log}实例将启用日志级别的"跟踪"。 
	 * 子类不必再次进行检查，除非它们覆盖{@code  isInterceptorEnabled}方法以修改默认行为，并且可以委托{{@code> writeToLog}来写入实际消息。 
	 *  
	 * @param 记录{@code 日志}，以将跟踪消息写入对
	 * @return 的调用结果
	 * @return  MethodInvocation.proceed（）} 
	 * @throws 如果对{@code  MethodInvocation.proceed（）}遇到任何错误
	 * @see  #isLogEnabled 
	 * @see  #writeToLog（Log，String）
	 * @see  #writeToLog（Log，String，Throwable）
	 */
	@Nullable
	protected abstract Object invokeUnderTrace(MethodInvocation invocation, Log logger) throws Throwable;

}
